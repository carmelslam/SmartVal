<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>× ×™×§×•×œ â€“ ×¢×•×–×¨×ª ×“×™×’×™×˜×œ×™×ª</title>
  <script type="module" src="./webhook.js"></script>
  <script type="module" src="./helper.js"></script>

  <link rel="icon" type="image/webp" href="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp">
  <link rel="shortcut icon" href="https://carmelcayouf.com/wp-content/uploads/2025/04/logo-yaron.webp">
  <link rel="apple-touch-icon" href="https://carmelcayouf.com/wp-content/uploads/2025/04/logo-yaron.webp">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }
    .container {
      max-width: 480px;
      background: #fff;
      padding: 35px;
      border-radius: 18px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.12);
      text-align: center;
      position: relative;
      width: 90%;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
    }
    .logo img {
      width: 120px;
      margin-bottom: 15px;
    }
    .title { 
      font-size: 26px; 
      font-weight: 700; 
      margin-bottom: 8px; 
      color: #2d3748;
      letter-spacing: -0.5px;
    }
    .subtitle { 
      font-size: 16px; 
      color: #718096; 
      margin-bottom: 8px; 
      font-weight: 500;
    }
    h2 {
      font-size: 22px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 25px;
      font-weight: 600;
      letter-spacing: -0.3px;
    }
    input {
      width: 100%;
      padding: 14px 16px;
      font-size: 15px;
      margin-bottom: 18px;
      border-radius: 14px;
      border: 1.5px solid #e2e8f0;
      box-sizing: border-box;
      transition: all 0.3s ease;
      background: #f7fafc;
      color: #2d3748;
      font-weight: 500;
    }
    
    input:focus {
      outline: none;
      border-color: #667eea;
      background: #fff;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      transform: translateY(-1px);
    }

    /* Modern input container with integrated microphone */
    .input-container {
      position: relative;
      margin-bottom: 20px;
    }
    
    .input-with-mic {
      width: 100%;
      padding: 16px 50px 16px 18px;
      font-size: 15px;
      border-radius: 18px;
      border: 1.5px solid #e2e8f0;
      box-sizing: border-box;
      transition: all 0.3s ease;
      background: #f7fafc;
      resize: none;
      min-height: 90px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #2d3748;
      font-weight: 500;
      line-height: 1.5;
    }
    
    .input-with-mic:focus {
      outline: none;
      border-color: #667eea;
      background: #fff;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.08);
      transform: translateY(-2px);
    }
    
    .mic-button {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 34px;
      height: 34px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 15px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 12px rgba(30, 58, 138, 0.3);
    }
    
    .mic-button:hover {
      transform: translateY(-50%) scale(1.1);
      box-shadow: 0 4px 12px rgba(30, 58, 138, 0.4);
    }
    
    .mic-button:active {
      transform: translateY(-50%) scale(0.95);
    }
    
    .mic-button.recording {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3); }
      50% { box-shadow: 0 4px 16px rgba(255, 107, 107, 0.6); }
      100% { box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3); }
    }
    
    /* Modern button container */
    .button-container {
      display: flex;
      gap: 12px;
      margin-top: 28px;
      justify-content: center;
    }
    
    .btn-modern {
      padding: 12px 24px;
      font-size: 15px;
      font-weight: 600;
      border: none;
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      min-width: 130px;
      letter-spacing: -0.2px;
    }
    
    .btn-send {
      background: linear-gradient(135deg, #16a34a 0%, #22c55e 100%);
      color: white;
      box-shadow: 0 6px 20px rgba(34, 197, 94, 0.3);
    }
    
    .btn-send:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(34, 197, 94, 0.4);
    }
    
    .btn-send:active {
      transform: translateY(-1px);
    }
    
    .btn-clear {
      background: rgba(255, 255, 255, 0.9);
      color: #4a5568;
      border: 1.5px solid #e2e8f0;
      backdrop-filter: blur(10px);
    }
    
    .btn-clear:hover {
      background: rgba(255, 255, 255, 1);
      border-color: #cbd5e0;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    
    .btn-secondary {
      background: #64748b;
      color: white;
      border: 1.5px solid #64748b;
    }
    
    .btn-secondary:hover {
      background: #475569;
      border-color: #475569;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(71, 85, 105, 0.3);
    }
    .floating-response {
      position: fixed;
      bottom: 30px;
      right: 30px;
      max-width: 380px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(102, 126, 234, 0.2);
      padding: 20px;
      border-radius: 18px;
      box-shadow: 0 12px 40px rgba(102, 126, 234, 0.15);
      font-size: 15px;
      color: #2d3748;
      z-index: 1000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      animation: slideInUp 0.3s ease-out;
    }

    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @media (max-width: 480px) {
      .floating-response {
        right: 20px;
        left: 20px;
        max-width: none;
        bottom: 20px;
      }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="logo">
    <img src="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp" alt="Logo">
  </div>
  <div class="title">×™×¨×•×Ÿ ×›×™×•×£ ×©×××•×ª - ×¤×•×¨×˜×œ</div>
  <div class="subtitle">×©×××™ ×¨×›×‘ ×•×”×¢×¨×›×ª × ×–×§×™ ×¨×›×•×©</div>
  <h2>ğŸ‘©â€ğŸ’¼ × ×™×§×•×œ â€“ ×¢×•×–×¨×ª ×“×™×’×™×˜×œ×™×ª</h2>
  <form id="assistantForm">
    <input type="text" id="plateInput" name="plate" placeholder="××¡×¤×¨ ×¨×›×‘ (××•×¤×¦×™×•× ×œ×™)">
    
    <!-- Modern input container with integrated microphone -->
    <div class="input-container">
      <textarea id="freeQuery" name="query" class="input-with-mic" placeholder="××” ×ª×¨×¦×” ×œ×“×¢×ª ××• ×œ×‘×§×©? ××¤×©×¨ ×œ×›×ª×•×‘ ××• ×œ×”×§×™×© ×¢×œ ×”××™×§×¨×•×¤×•×Ÿ ×œ×“×‘×¨..."></textarea>
      <button type="button" id="micBtn" class="mic-button" title="×œ×—×¥ ×›×“×™ ×œ×”×§×œ×™×˜ ×§×•×œ">
        ğŸ¤
      </button>
    </div>
    
    <!-- Modern button container -->
    <div class="button-container">
      <button type="button" class="btn-modern btn-clear" onclick="clearForm()">
        ğŸ—‘ï¸ × ×§×”
      </button>
      <button type="submit" id="sendBtn" class="btn-modern btn-send">
        <span>ğŸ“¤</span>
        ×©×œ×— ×©××œ×”
      </button>
      <button type="button" class="btn-modern btn-secondary" onclick="window.location.href='selection.html'">
        â†©ï¸ ×—×–×•×¨ ×œ×‘×—×™×¨×”
      </button>
    </div>
  </form>
</div>
<div id="agentResponse" class="floating-response" style="display:none;"></div>
<script>
  window.addEventListener('DOMContentLoaded', () => {
    // Enhanced authentication audit
    const userAuthToken = sessionStorage.getItem('auth');
    const loginTime = sessionStorage.getItem('loginTime');
    const password = sessionStorage.getItem('password');
    const plate = sessionStorage.getItem('plate');
    
    console.group("ğŸ” Nicole Authentication Audit");
    console.log("ğŸ“Š Authentication State:", {
      auth_token: userAuthToken ? userAuthToken.substring(0, 20) + '...' : 'MISSING',
      auth_length: userAuthToken?.length || 0,
      login_time: loginTime,
      password_exists: !!password,
      password_type: password ? typeof password : 'undefined',
      plate_preloaded: plate || 'NONE',
      session_keys: Object.keys(sessionStorage).sort(),
      timestamp: new Date().toISOString()
    });
    
    // Check authentication validity
    const isValidAuth = userAuthToken && loginTime;
    console.log("ğŸ« Auth Validation:", {
      has_auth_token: !!userAuthToken,
      has_login_time: !!loginTime,
      is_valid: isValidAuth,
      login_age_minutes: loginTime ? Math.round((Date.now() - new Date(loginTime).getTime()) / 60000) : 'N/A'
    });
    
    // Check for auth conflicts or issues
    const authIssues = [];
    if (!userAuthToken) authIssues.push('Missing auth token');
    if (!loginTime) authIssues.push('Missing login time');
    if (!password && !userAuthToken) authIssues.push('No password fallback');
    
    if (authIssues.length > 0) {
      console.warn("âš ï¸ Authentication Issues:", authIssues);
    }
    
    if (!isValidAuth) {
      console.error("âŒ Authentication failed, redirecting to login");
      console.log("ğŸ”„ Redirect reason:", authIssues.join(', '));
      alert("×”×’×™×©×” ×—×¡×•××” - ×× × ×”×ª×—×‘×¨ ×“×¨×š ×“×£ ×”×‘×™×ª");
      window.location.href = 'index.html';
      return;
    }
    
    console.log("âœ… Authentication verified successfully");
    console.groupEnd();
    
    // Pre-populate plate if available
    if (plate) {
      document.getElementById('plateInput').value = plate;
      console.log("ğŸš— Pre-populated plate number:", plate);
    }
    
    // Store auth audit in session for debugging
    sessionStorage.setItem('nicole_auth_audit', JSON.stringify({
      timestamp: new Date().toISOString(),
      auth_valid: true,
      auth_method: password ? 'password' : 'auth_token',
      login_age_minutes: Math.round((Date.now() - new Date(loginTime).getTime()) / 60000)
    }));
    
    // Initialize modern UI functionality
    initializeModernUI();
  });

  // Helper function to detect browser info
  function getBrowserInfo() {
    const ua = navigator.userAgent;
    if (ua.includes('Chrome')) return 'Chrome';
    if (ua.includes('Firefox')) return 'Firefox';
    if (ua.includes('Safari') && !ua.includes('Chrome')) return 'Safari';
    if (ua.includes('Edge')) return 'Edge';
    if (ua.includes('Opera')) return 'Opera';
    return 'Unknown';
  }

  function clearForm() {
    document.getElementById('plateInput').value = '';
    document.getElementById('freeQuery').value = '';
    document.getElementById('freeQuery').focus();
  }

  function initializeModernUI() {
    const micBtn = document.getElementById('micBtn');
    const textarea = document.getElementById('freeQuery');
    const sendBtn = document.getElementById('sendBtn');
    
    // Enhanced microphone button functionality
    let isRecording = false;
    let recordingTimeout;
    let inactivityTimeout;
    let wasVoiceInput = false; // Track if last input was from voice
    const MAX_RECORDING_TIME = 60000; // 60 seconds max recording
    const INACTIVITY_TIMEOUT = 15000; // 15 seconds of silence
    
    micBtn.addEventListener('click', function() {
      if (micBtn.disabled) return;
      
      if (!isRecording) {
        startRecording();
      } else {
        stopRecording();
      }
    });
    
    // Initialize speech recognition
    let recognition;
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      const SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.lang = 'he-IL';
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;
      recognition.continuous = false;

      recognition.addEventListener('result', (event) => {
        const transcript = event.results[0][0].transcript;
        textarea.value = transcript;
        
        // Mark that this input came from voice
        wasVoiceInput = true;
        
        // Reset inactivity timeout when speech is detected
        if (inactivityTimeout) {
          clearTimeout(inactivityTimeout);
          inactivityTimeout = null;
        }
        
        stopRecording();
        console.log('ğŸ¤ Speech recognized:', transcript);
      });

      recognition.addEventListener('error', (event) => {
        const errorDetails = {
          error_type: event.error,
          timestamp: new Date().toISOString(),
          user_agent: navigator.userAgent,
          browser: getBrowserInfo(),
          mic_permissions: 'unknown'
        };
        
        console.group('ğŸš¨ Microphone Error Analysis');
        console.error('ğŸ¤ Speech recognition error:', event.error);
        console.log('ğŸ“Š Error Details:', errorDetails);
        
        stopRecording();
        
        let errorMessage = '×©×’×™××” ×‘×–×™×”×•×™ ×§×•×œ';
        let troubleshooting = '';
        let severity = 'medium';
        
        switch(event.error) {
          case 'no-speech':
            errorMessage = '×œ× ×–×•×”×” ×“×™×‘×•×¨. ×× × × ×¡×” ×©×•×‘ ×•×“×‘×¨ ×‘×§×•×œ ×‘×¨×•×¨.';
            troubleshooting = '×‘×“×•×§ ×©×”××™×§×¨×•×¤×•×Ÿ ×¢×•×‘×“ ×•×©××™×Ÿ ×¨×¢×© ×¡×‘×™×‘×”';
            severity = 'low';
            break;
          case 'audio-capture':
            errorMessage = '×œ× × ×™×ª×Ÿ ×œ×’×©×ª ×œ××™×§×¨×•×¤×•×Ÿ. ×× × ×‘×“×•×§ ××ª ×”×”×¨×©××•×ª ×•×”×—×™×‘×•×¨.';
            troubleshooting = '1. ×‘×“×•×§ ×©×”××™×§×¨×•×¤×•×Ÿ ××—×•×‘×¨\n2. ××©×¨ ×”×¨×©××•×ª ×œ××™×§×¨×•×¤×•×Ÿ\n3. ×¡×’×•×¨ ×™×™×©×•××™× ××—×¨×™× ×©×¢×©×•×™×™× ×œ×”×©×ª××© ×‘××™×§×¨×•×¤×•×Ÿ';
            severity = 'high';
            break;
          case 'not-allowed':
            errorMessage = '×’×™×©×” ×œ××™×§×¨×•×¤×•×Ÿ × ×“×—×ª×”. ×× × ××©×¨ ×”×¨×©××” ×‘×”×’×“×¨×•×ª ×”×“×¤×“×¤×Ÿ.';
            troubleshooting = '×œ×—×¥ ×¢×œ ×¡××œ ×”××™×§×¨×•×¤×•×Ÿ ×‘×©×•×¨×ª ×”×›×ª×•×‘×ª ×•××©×¨ ×”×¨×©××”';
            severity = 'high';
            break;
          case 'network':
            errorMessage = '×©×’×™××ª ×¨×©×ª. ×× × ×‘×“×•×§ ××ª ×”×—×™×‘×•×¨ ×œ××™× ×˜×¨× ×˜.';
            troubleshooting = '×‘×“×•×§ ×—×™×‘×•×¨ ×”××™× ×˜×¨× ×˜ ×•× ×¡×” ×©×•×‘';
            severity = 'medium';
            break;
          case 'aborted':
            errorMessage = '×–×™×”×•×™ ×”×§×•×œ ×”×•×¤×¡×§.';
            troubleshooting = '×–×•×”×™ ×©×’×™××” ×–×× ×™×ª, × ×™×ª×Ÿ ×œ× ×¡×•×ª ×©×•×‘';
            severity = 'low';
            break;
          case 'service-not-allowed':
            errorMessage = '×©×™×¨×•×ª ×–×™×”×•×™ ×§×•×œ ×œ× ×–××™×Ÿ.';
            troubleshooting = '×”×©×™×¨×•×ª ×¢×©×•×™ ×œ×”×™×•×ª ×—×¡×•× ××• ×œ× ×–××™×Ÿ ×‘××–×•×¨ ×©×œ×š';
            severity = 'high';
            break;
          default:
            errorMessage = `×©×’×™××” ×‘×–×™×”×•×™ ×§×•×œ: ${event.error}`;
            troubleshooting = '×©×’×™××” ×œ× ××–×•×”×”, × ×¡×” ×œ×¨×¢× ×Ÿ ××ª ×”×“×£';
            severity = 'medium';
        }
        
        // Log detailed error for debugging
        console.log('ğŸ› ï¸ Error Analysis:', {
          error_code: event.error,
          message: errorMessage,
          troubleshooting: troubleshooting,
          severity: severity,
          browser_support: !!window.webkitSpeechRecognition || !!window.SpeechRecognition,
          permissions_api: !!navigator.permissions
        });
        
        // Save error to session for pattern analysis
        const micErrors = JSON.parse(sessionStorage.getItem('nicole_mic_errors') || '[]');
        micErrors.push({
          ...errorDetails,
          message: errorMessage,
          severity: severity,
          troubleshooting: troubleshooting
        });
        // Keep only last 20 errors
        if (micErrors.length > 20) micErrors.shift();
        sessionStorage.setItem('nicole_mic_errors', JSON.stringify(micErrors));
        
        console.groupEnd();
        
        // Show user-friendly error with troubleshooting
        const fullMessage = `${errorMessage}\n\n×¤×ª×¨×•×Ÿ ××•×¦×¢:\n${troubleshooting}`;
        alert(fullMessage);
        
        // If it's a critical error, disable mic button temporarily
        if (severity === 'high') {
          micBtn.style.opacity = '0.5';
          micBtn.disabled = true;
          setTimeout(() => {
            micBtn.style.opacity = '1';
            micBtn.disabled = false;
          }, 10000); // Re-enable after 10 seconds
        }
      });

      recognition.addEventListener('end', () => {
        stopRecording();
      });
      
      // Cleanup function for page unload
      window.addEventListener('beforeunload', () => {
        if (isRecording) {
          stopRecording();
        }
        if (recordingTimeout) clearTimeout(recordingTimeout);
        if (inactivityTimeout) clearTimeout(inactivityTimeout);
      });
      
      // Cleanup function for visibility changes (tab switches)
      document.addEventListener('visibilitychange', () => {
        if (document.hidden && isRecording) {
          console.log('ğŸ¤ Tab hidden while recording, stopping...');
          stopRecording();
        }
      });
    } else {
      // Speech recognition not supported
      micBtn.style.opacity = '0.5';
      micBtn.style.cursor = 'not-allowed';
      micBtn.title = '×–×™×”×•×™ ×§×•×œ ×œ× × ×ª××š ×‘×“×¤×“×¤×Ÿ ×–×”';
      micBtn.disabled = true;
    }
    
    async function startRecording() {
      if (!recognition) {
        alert('×–×™×”×•×™ ×§×•×œ ×œ× × ×ª××š ×‘×“×¤×“×¤×Ÿ ×–×”');
        return;
      }

      // Check microphone permissions
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream.getTracks().forEach(track => track.stop()); // Stop the stream immediately
      } catch (error) {
        console.error('ğŸ¤ Microphone permission error:', error);
        if (error.name === 'NotAllowedError') {
          alert('× ×“×¨×©×ª ×”×¨×©××” ×œ××™×§×¨×•×¤×•×Ÿ ×›×“×™ ×œ×”×©×ª××© ×‘×–×™×”×•×™ ×§×•×œ. ×× × ××©×¨ ××ª ×”×”×¨×©××” ×•× ×¡×” ×©×•×‘.');
        } else if (error.name === 'NotFoundError') {
          alert('×œ× × ××¦× ××™×§×¨×•×¤×•×Ÿ. ×× × ×—×‘×¨ ××™×§×¨×•×¤×•×Ÿ ×•× ×¡×” ×©×•×‘.');
        } else {
          alert('×©×’×™××” ×‘×’×™×©×” ×œ××™×§×¨×•×¤×•×Ÿ: ' + error.message);
        }
        return;
      }

      isRecording = true;
      micBtn.classList.add('recording');
      micBtn.innerHTML = 'â¹ï¸';
      micBtn.title = '×œ×—×¥ ×›×“×™ ×œ×”×¤×¡×™×§ ×”×§×œ×˜×”';
      
      // Add visual feedback to textarea
      textarea.style.borderColor = '#ff6b6b';
      textarea.placeholder = 'ğŸ¤ ××§×œ×™×˜... ×“×‘×¨ ×¢×›×©×™×• ××• ×œ×—×¥ ×©×•×‘ ×›×“×™ ×œ×”×¤×¡×™×§';
      
      // Set maximum recording timeout
      recordingTimeout = setTimeout(() => {
        console.log('ğŸ¤ Maximum recording time reached, stopping...');
        stopRecording();
        alert('×”×§×œ×˜×” ×”×•×¤×¡×§×” ×œ××—×¨ ×“×§×”. ×× × × ×¡×” ×©×•×‘.');
      }, MAX_RECORDING_TIME);
      
      // Set inactivity timeout
      inactivityTimeout = setTimeout(() => {
        console.log('ğŸ¤ No speech detected for 15 seconds, stopping...');
        stopRecording();
        // Don't show alert for inactivity timeout - it's normal
      }, INACTIVITY_TIMEOUT);
      
      try {
        recognition.start();
        console.log('ğŸ¤ Speech recognition started with timeouts:', {
          max_time: MAX_RECORDING_TIME,
          inactivity_timeout: INACTIVITY_TIMEOUT
        });
      } catch (error) {
        console.error('ğŸ¤ Failed to start recognition:', error);
        if (error.message.includes('already started')) {
          // Recognition already running, stop and restart
          recognition.stop();
          setTimeout(() => {
            recognition.start();
          }, 100);
        } else {
          stopRecording();
          alert('×©×’×™××” ×‘×”×¤×¢×œ×ª ×–×™×”×•×™ ×§×•×œ: ' + error.message);
        }
      }
    }
    
    function stopRecording() {
      isRecording = false;
      micBtn.classList.remove('recording');
      micBtn.innerHTML = 'ğŸ¤';
      micBtn.title = '×œ×—×¥ ×›×“×™ ×œ×”×§×œ×™×˜ ×§×•×œ';
      
      // Clear all timeouts
      if (recordingTimeout) {
        clearTimeout(recordingTimeout);
        recordingTimeout = null;
      }
      if (inactivityTimeout) {
        clearTimeout(inactivityTimeout);
        inactivityTimeout = null;
      }
      
      // Reset textarea styling
      textarea.style.borderColor = '#e2e8f0';
      textarea.placeholder = '××” ×ª×¨×¦×” ×œ×“×¢×ª ××• ×œ×‘×§×©? ××¤×©×¨ ×œ×›×ª×•×‘ ××• ×œ×”×§×™×© ×¢×œ ×”××™×§×¨×•×¤×•×Ÿ ×œ×“×‘×¨...';
      
      if (recognition) {
        try {
          recognition.stop();
        } catch (error) {
          console.log('Recognition already stopped');
        }
      }
      
      console.log('ğŸ¤ Recording stopped with timeout cleanup...');
    }
    
    // Form submission handler
    const form = document.getElementById('assistantForm');
    form.addEventListener('submit', async function(e) {
      e.preventDefault();
      
      const query = textarea.value.trim();
      const plate = document.getElementById('plateInput').value.trim();
      
      // Check if this was voice input (will be reset after processing)
      const currentWasVoiceInput = wasVoiceInput;
      
      // Enhanced validation: require at least one field (plate OR query)
      if (!query && !plate) {
        alert('×× × ××œ× ×œ×¤×—×•×ª ×©×“×” ××—×“:\nâ€¢ ××¡×¤×¨ ×¨×›×‘, ××•\nâ€¢ ×©××œ×”/×‘×§×©×”');
        
        // Focus on the first empty field
        if (!plate) {
          document.getElementById('plateInput').focus();
          document.getElementById('plateInput').style.animation = 'shake 0.5s';
          setTimeout(() => { document.getElementById('plateInput').style.animation = ''; }, 500);
        } else {
          textarea.focus();
          textarea.style.animation = 'shake 0.5s';
          setTimeout(() => { textarea.style.animation = ''; }, 500);
        }
        
        console.log('âŒ Validation failed: Both fields empty', { plate, query });
        return;
      }
      
      // If only plate is provided, create a default query
      let finalQuery = query;
      if (!query && plate) {
        finalQuery = `××” ×”××™×“×¢ ×”×–××™×Ÿ ×¢×‘×•×¨ ×¨×›×‘ ××¡×¤×¨ ${plate}?`;
        console.log('ğŸ”„ Auto-generated query for plate-only request:', finalQuery);
      }
      
      console.log('âœ… Validation passed:', { 
        plate: plate || 'NONE', 
        query: finalQuery,
        validation_type: query && plate ? 'BOTH' : query ? 'QUERY_ONLY' : 'PLATE_ONLY'
      });
      
      // Add loading state
      sendBtn.innerHTML = '<span>â³</span> ×©×•×œ×—...';
      sendBtn.disabled = true;
      
      try {
        // Store user query in conversation context
        storeConversationContext(finalQuery, 'user');
        
        await submitQuery(plate, finalQuery, currentWasVoiceInput);
        
        // Reset voice input flag after successful submission
        wasVoiceInput = false;
      } catch (error) {
        console.error('Submit error:', error);
        alert('×©×’×™××” ×‘×©×œ×™×—×ª ×”×©××œ×”: ' + error.message);
      } finally {
        // Reset button state
        sendBtn.innerHTML = '<span>ğŸ“¤</span> ×©×œ×— ×©××œ×”';
        sendBtn.disabled = false;
      }
    });

    // Submit query to webhook and handle response
    async function submitQuery(plate, query, wasVoiceInput = false, isReply = false) {
      // Generate unique trace ID for this request
      const traceId = 'nicole_' + Date.now() + '_' + Math.random().toString(36).substring(2, 8);
      
      // Get conversation context for continuous dialogue
      const conversationContext = getConversationContext();
      const hasContext = conversationContext.length > 0;
      
      const payload = { 
        plate: plate, 
        free_query: query, 
        source: 'assistant-ui',
        password: sessionStorage.getItem('password') || sessionStorage.getItem('auth'),
        trace_id: traceId,
        timestamp: new Date().toISOString(),
        user_agent: navigator.userAgent,
        page_url: window.location.href,
        // Conversation context
        is_reply: isReply,
        conversation_context: hasContext ? conversationContext : null,
        conversation_id: hasContext ? JSON.parse(sessionStorage.getItem('nicole_conversation') || '{}').conversation_id : null,
        voice_input: wasVoiceInput
      };

      // Enhanced logging for debugging
      console.group(`ğŸ” Nicole Query Debug [${traceId}]`);
      console.log('ğŸ“¤ Outgoing Payload:', JSON.stringify(payload, null, 2));
      console.log('ğŸ”— Webhook URL:', WEBHOOKS?.SEARCH_MODULE || 'URL_NOT_LOADED');
      console.log('ğŸ”‘ Auth Data:', {
        password_exists: !!sessionStorage.getItem('password'),
        auth_exists: !!sessionStorage.getItem('auth'),
        auth_type: sessionStorage.getItem('password') ? 'password' : 'auth'
      });
      console.log('ğŸŒ Environment Info:', {
        user_agent: navigator.userAgent,
        language: navigator.language,
        platform: navigator.platform,
        encoding: document.characterSet || document.charset,
        page_encoding: document.inputEncoding,
        url: window.location.href,
        timestamp: new Date().toISOString()
      });

      try {
        // Import webhook from webhook.js module
        const { WEBHOOKS } = await import('./webhook.js');
        const webhookUrl = WEBHOOKS.SEARCH_MODULE;
        
        console.log('ğŸŒ Sending request to:', webhookUrl);
        const startTime = performance.now();
        
        const response = await fetch(webhookUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        // Read as text first, then try to parse as JSON
        const rawResponse = await response.text();
        const endTime = performance.now();
        const requestDuration = Math.round(endTime - startTime);
        
        // Store debug information for analysis
        const debugEntry = {
          trace_id: traceId,
          timestamp: new Date().toISOString(),
          request_duration_ms: requestDuration,
          response_status: response.status,
          response_headers: Object.fromEntries(response.headers.entries()),
          response_size: rawResponse.length,
          query: query,
          plate: plate || 'NONE'
        };
        
        // Enhanced logging for debugging JSON issues
        console.log('ğŸ“¥ Raw Response Details:', {
          length: rawResponse.length,
          first_200_chars: rawResponse.substring(0, 200),
          last_100_chars: rawResponse.substring(Math.max(0, rawResponse.length - 100)),
          char_codes: rawResponse.substring(0, 30).split('').map(c => c.charCodeAt(0)),
          is_empty: rawResponse.trim() === '',
          starts_with_brace: rawResponse.trim().startsWith('{'),
          ends_with_brace: rawResponse.trim().endsWith('}'),
          brace_count: (rawResponse.match(/\{/g) || []).length,
          closing_brace_count: (rawResponse.match(/\}/g) || []).length,
          has_text_field: rawResponse.includes('"text"'),
          has_audioContent_field: rawResponse.includes('"audioContent"')
        });
        
        // Log the exact raw response for manual inspection
        console.log('ğŸ” FULL RAW RESPONSE:', rawResponse);
        
        try {
          // Clean the response text to handle potential encoding issues
          let cleanResponse = rawResponse.trim();
          
          // Remove potential BOM (Byte Order Mark) if present
          if (cleanResponse.charCodeAt(0) === 0xFEFF) {
            cleanResponse = cleanResponse.substring(1);
            console.log('ğŸ§¹ Removed BOM from response');
          }
          
          // Check if JSON is complete and fix common issues
          if (!cleanResponse.endsWith('}') && cleanResponse.includes('{')) {
            console.log('âš ï¸ JSON appears incomplete, attempting to fix...');
            
            // Count braces to see if we need to close
            const openBraces = (cleanResponse.match(/\{/g) || []).length;
            const closeBraces = (cleanResponse.match(/\}/g) || []).length;
            
            if (openBraces > closeBraces) {
              // Add missing closing braces
              const missingBraces = openBraces - closeBraces;
              cleanResponse += '}'.repeat(missingBraces);
              console.log(`ğŸ”§ Added ${missingBraces} missing closing brace(s)`);
            }
            
            // Fix trailing commas that might cause issues
            cleanResponse = cleanResponse.replace(/,(\s*[}\]])/g, '$1');
          }
          
          // Try to parse as JSON (new format with audio)
          const responseData = JSON.parse(cleanResponse);
          
          console.log('âœ… JSON Parse Success:', {
            response_type: typeof responseData,
            has_text: !!responseData.text,
            has_audio: !!responseData.audio,
            has_message: !!responseData.message,
            has_response: !!responseData.response,
            all_keys: Object.keys(responseData)
          });
          
          // Determine the text content from various possible fields
          let textContent = responseData.text || 
                           responseData.message || 
                           responseData.response || 
                           responseData.content ||
                           responseData.answer ||
                           responseData.reply ||
                           JSON.stringify(responseData, null, 2);
          
          // Handle audio content if present
          let audioContent = responseData.audio || 
                            responseData.audioContent || 
                            responseData.audio_content ||
                            null;
          
          if (!textContent || textContent.trim() === '') {
            console.warn('âš ï¸ No readable text content found in response');
            textContent = '×ª×’×•×‘×” ×”×ª×§×‘×œ×” ××š ×œ×œ× ×ª×•×›×Ÿ ×˜×§×¡×˜';
          }
          
          // Show debug info only in development
          const isDebugMode = window.location.hostname === 'localhost' || window.location.search.includes('debug=true');
          let debugInfo = '';
          
          if (isDebugMode) {
            debugInfo = `
              <div style="background: #f0f0f0; padding: 10px; margin: 10px 0; font-size: 12px; border-radius: 5px;">
                <strong>ğŸ” DEBUG INFO:</strong><br>
                <strong>Response Keys:</strong> ${Object.keys(responseData).join(', ')}<br>
                <strong>Text Source:</strong> ${responseData.text ? 'text' : responseData.message ? 'message' : responseData.response ? 'response' : 'fallback'}<br>
                <strong>Audio Field:</strong> ${responseData.audio ? 'Present' : 'Missing'}
              </div>
            `;
          }
          
          displayResponse(debugInfo + textContent, audioContent);
          
          // Store success in debug entry
          debugEntry.parsing_success = true;
          debugEntry.response_structure = Object.keys(responseData);
          debugEntry.text_source = responseData.text ? 'text' : responseData.message ? 'message' : responseData.response ? 'response' : responseData.answer ? 'answer' : 'fallback';
          debugEntry.has_hebrew = /[\u0590-\u05FF]/.test(textContent);
          debugEntry.final_text_length = textContent.length;
          debugEntry.has_audio = !!audioContent;
          debugEntry.audio_source = responseData.audioContent ? 'audioContent' : responseData.audio ? 'audio' : null;
          
        } catch (jsonError) {
          console.error('âŒ JSON Parse Error Details:', {
            error_name: jsonError.name,
            error_message: jsonError.message,
            raw_response_preview: rawResponse.substring(0, 300),
            response_length: rawResponse.length,
            first_char_code: rawResponse.charCodeAt(0),
            last_char_code: rawResponse.charCodeAt(rawResponse.length - 1)
          });
          
          // Try to extract meaningful content even if JSON parsing fails
          let fallbackContent = rawResponse;
          let extractedSuccessfully = false;
          
          // Multiple extraction strategies
          if (rawResponse.includes('{') && rawResponse.includes('}')) {
            
            // Strategy 1: Extract the largest valid JSON block
            const firstBrace = rawResponse.indexOf('{');
            const lastBrace = rawResponse.lastIndexOf('}');
            if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
              const possibleJson = rawResponse.substring(firstBrace, lastBrace + 1);
              try {
                const extractedData = JSON.parse(possibleJson);
                const extractedText = extractedData.text || extractedData.message || extractedData.response || extractedData.answer;
                const extractedAudio = extractedData.audio || extractedData.audioContent;
                if (extractedText) {
                  console.log('âœ… Successfully extracted content using Strategy 1');
                  displayResponse(extractedText, extractedAudio);
                  
                  // Update debug entry for successful extraction
                  debugEntry.parsing_success = true;
                  debugEntry.extraction_method = 'strategy_1_basic';
                  debugEntry.has_hebrew = /[\u0590-\u05FF]/.test(extractedText);
                  extractedSuccessfully = true;
                }
              } catch (secondError) {
                console.log('ğŸ”„ Strategy 1 failed, trying Strategy 2...');
              }
            }
            
            // Strategy 2: Try to fix common JSON issues and re-parse
            if (!extractedSuccessfully) {
              try {
                let fixedJson = rawResponse.substring(firstBrace, lastBrace + 1);
                
                // Fix common issues
                fixedJson = fixedJson.replace(/,(\s*[}\]])/g, '$1'); // Remove trailing commas
                fixedJson = fixedJson.replace(/([{,]\s*)(\w+):/g, '$1"$2":'); // Add quotes to keys
                fixedJson = fixedJson.replace(/:\s*([^",{\[\]}\s][^",}\]]*[^",}\]\s])\s*([,}])/g, ': "$1"$2'); // Quote unquoted values
                
                const extractedData = JSON.parse(fixedJson);
                const extractedText = extractedData.text || extractedData.message || extractedData.response || extractedData.answer;
                const extractedAudio = extractedData.audio || extractedData.audioContent;
                if (extractedText) {
                  console.log('âœ… Successfully extracted content using Strategy 2');
                  displayResponse(extractedText, extractedAudio);
                  
                  debugEntry.parsing_success = true;
                  debugEntry.extraction_method = 'strategy_2_fixed';
                  debugEntry.has_hebrew = /[\u0590-\u05FF]/.test(extractedText);
                  extractedSuccessfully = true;
                }
              } catch (thirdError) {
                console.log('ğŸ”„ Strategy 2 also failed, trying Strategy 3...');
              }
            }
            
            // Strategy 3: Use regex to extract text field value
            if (!extractedSuccessfully) {
              const textMatch = rawResponse.match(/"text"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/);
              if (textMatch) {
                const extractedText = textMatch[1].replace(/\\"/g, '"').replace(/\\n/g, '\n');
                console.log('âœ… Successfully extracted text using Strategy 3 (regex)');
                displayResponse(extractedText, null);
                
                debugEntry.parsing_success = true;
                debugEntry.extraction_method = 'strategy_3_regex';
                debugEntry.has_hebrew = /[\u0590-\u05FF]/.test(extractedText);
                extractedSuccessfully = true;
              }
            }
          }
          
          // Final fallback if no extraction strategy worked
          if (!extractedSuccessfully) {
            if (fallbackContent.length > 0) {
              displayResponse(`×©×’×™××” ×‘×¤×¢× ×•×— ×”×ª×’×•×‘×”, ××š ×”×ª×•×›×Ÿ ×”×ª×§×‘×œ:\n\n${fallbackContent}`);
            } else {
              displayResponse('×©×’×™××” ×‘×§×‘×œ×ª ×ª×’×•×‘×” ××”×©×¨×ª. ×× × × ×¡×” ×©×•×‘.');
            }
            
            // Store failure in debug entry
            debugEntry.parsing_success = false;
            debugEntry.error_type = 'json_parse_failed';
            debugEntry.error_message = jsonError.message;
            debugEntry.extraction_method = 'none';
            debugEntry.has_hebrew = /[\u0590-\u05FF]/.test(fallbackContent);
            debugEntry.fallback_used = fallbackContent.length > 0;
          }
        }
        
        // Store debug entry in session for analysis
        const debugHistory = JSON.parse(sessionStorage.getItem('nicole_debug_history') || '[]');
        debugHistory.push(debugEntry);
        // Keep only last 50 entries
        if (debugHistory.length > 50) debugHistory.shift();
        sessionStorage.setItem('nicole_debug_history', JSON.stringify(debugHistory));
        
        console.log(`âœ… Request completed [${traceId}]:`, {
          duration: requestDuration + 'ms',
          success: debugEntry.parsing_success,
          has_hebrew: debugEntry.has_hebrew
        });
        console.groupEnd();

      } catch (err) {
        console.error('âŒ Request failed:', err);
        console.groupEnd();
        displayResponse('×©×’×™××” ×‘×©×œ×™×—×ª ×”×‘×§×©×”. × ×¡×” ×©×•×‘.');
      }
    }

    // Display response in floating box with manual TTS controls
    function displayResponse(text, audio = null) {
      const responseBox = document.getElementById('agentResponse');
      responseBox.style.display = 'block';
      
      // Clean and format the text content for display
      let displayText = text;
      let textForTTS = text;
      
      // Handle different content types
      if (typeof text === 'object') {
        console.log('ğŸ“ Received object response, converting to readable format');
        displayText = JSON.stringify(text, null, 2);
        textForTTS = Object.values(text).join(' ');
      } else if (typeof text === 'string') {
        // Clean the text for better display
        displayText = text.trim();
        textForTTS = text.replace(/[\n\r]+/g, ' ').trim();
        
        // If text looks like JSON that wasn't parsed, try to format it
        if (displayText.startsWith('{') && displayText.endsWith('}')) {
          try {
            const parsed = JSON.parse(displayText);
            const readable = parsed.text || parsed.message || parsed.response || JSON.stringify(parsed, null, 2);
            displayText = readable;
            textForTTS = readable.replace(/[\n\r]+/g, ' ').trim();
            console.log('ğŸ”„ Reformatted JSON string for better display');
          } catch (e) {
            console.log('ğŸ“ Text looks like JSON but failed to parse, displaying as-is');
          }
        }
        
        // Convert markdown-like formatting to HTML for better display
        displayText = displayText
          .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
          .replace(/\*(.*?)\*/g, '<em>$1</em>')
          .replace(/\n/g, '<br>');
      }
      
      // Escape text for TTS button to prevent XSS
      const escapedTextForTTS = textForTTS.replace(/'/g, "\\'").replace(/"/g, '\\"');
      
      responseBox.innerHTML = `
        <div style="margin-bottom: 10px; font-weight: bold; color: #667eea;">
          ğŸ‘©â€ğŸ’¼ ×ª×©×•×‘×ª × ×™×§×•×œ:
        </div>
        <div style="line-height: 1.5; margin-bottom: 10px; white-space: pre-wrap;">
          ${displayText}
        </div>
        
        <!-- Response Controls -->
        <div style="display: flex; gap: 8px; margin-bottom: 8px; align-items: center; flex-wrap: wrap;">
          <button onclick="showReplyBox()" style="
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
          ">
            ğŸ’¬ ×”×©×‘ ×¢×œ ×”×ª×©×•×‘×”
          </button>
          
          <button onclick="manualSpeakResponse('${escapedTextForTTS}', this)" style="
            background: #22c55e;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
          ">
            ğŸ”Š ×”×©××¢ ×ª×©×•×‘×”
          </button>
          
          <button onclick="testTTSDebug()" style="
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
          ">
            ğŸ”§ ×‘×“×•×§ TTS
          </button>
          
          <div id="ttsStatus" style="font-size: 11px; color: #666;"></div>
        </div>
        
        <!-- Reply Box (initially hidden) -->
        <div id="replyBox" style="display: none; margin-top: 12px; padding: 12px; background: rgba(102, 126, 234, 0.05); border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.2);">
          <div style="margin-bottom: 8px; font-weight: 600; color: #667eea; font-size: 13px;">
            ğŸ’¬ ×”××©×š ×”×©×™×—×”:
          </div>
          <textarea id="replyInput" placeholder="×›×ª×•×‘ ××ª ×”×©××œ×” ××• ×”×ª×’×•×‘×” ×©×œ×š..." style="
            width: 100%;
            min-height: 60px;
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 13px;
            font-family: inherit;
            resize: vertical;
            box-sizing: border-box;
          "></textarea>
          <div style="display: flex; gap: 6px; margin-top: 8px; justify-content: flex-end;">
            <button onclick="cancelReply()" style="
              background: #f3f4f6;
              color: #6b7280;
              border: none;
              border-radius: 4px;
              padding: 4px 8px;
              cursor: pointer;
              font-size: 11px;
            ">
              ×‘×™×˜×•×œ
            </button>
            <button onclick="sendReply()" style="
              background: #667eea;
              color: white;
              border: none;
              border-radius: 4px;
              padding: 4px 12px;
              cursor: pointer;
              font-size: 11px;
              font-weight: 600;
            ">
              ×©×œ×— ×ª×’×•×‘×”
            </button>
          </div>
        </div>
        
        <button onclick="this.parentElement.style.display='none'" style="
          position: absolute; 
          top: 8px; 
          left: 8px; 
          background: #f0f0f0; 
          border: none; 
          border-radius: 50%; 
          width: 24px; 
          height: 24px; 
          cursor: pointer;
          font-size: 12px;
        ">âœ•</button>
      `;

      // Handle audio playback
      if (audio) {
        let audioElement;
        
        // Handle different audio formats
        if (typeof audio === 'string') {
          if (audio.startsWith('data:audio') || audio.startsWith('http')) {
            audioElement = new Audio(audio);
          } else {
            // Assume it's base64 audio content
            audioElement = new Audio('data:audio/mp3;base64,' + audio);
          }
        } else if (audio instanceof Blob) {
          const audioUrl = URL.createObjectURL(audio);
          audioElement = new Audio(audioUrl);
        }
        
        if (audioElement) {
          try {
            audioElement.play();
            console.log('ğŸ”Š Auto-playing audio response');
          } catch (e) {
            console.warn("ğŸ”‡ Autoplay blocked. User must click play.");
            window.pendingTTSAudio = audioElement;
          }
        }
      }
      
      // Log response handling success
      console.log('âœ… Response displayed successfully:', {
        text_length: displayText.length,
        has_audio: !!audio,
        text_type: typeof text
      });
      
      // Store this response in conversation context
      storeConversationContext(displayText, 'assistant');
    }
    
    // Manual TTS trigger for testing
    window.manualSpeakResponse = async function(text, buttonElement) {
      const statusDiv = document.getElementById('ttsStatus');
      const originalButtonText = buttonElement.innerHTML;
      
      try {
        buttonElement.innerHTML = 'â³ ××›×™×Ÿ ×§×•×œ...';
        buttonElement.disabled = true;
        
        if (statusDiv) statusDiv.textContent = '×‘×•×“×§ ×”×¨×©××•×ª ×“×¤×“×¤×Ÿ...';
        
        // Check if we have pending TTS audio from autoplay block
        if (window.pendingTTSAudio) {
          console.log('ğŸ”Š Playing pending TTS audio...');
          await window.pendingTTSAudio.play();
          window.pendingTTSAudio = null; // Clear after use
          if (statusDiv) statusDiv.textContent = 'âœ… ×”×•×©××¢ ××”×–×™×›×¨×•×Ÿ';
        } else {
          // Generate new TTS
          await speakResponse(text);
          if (statusDiv) statusDiv.textContent = 'âœ… ×”×•×©××¢ ×‘×”×¦×œ×—×”';
        }
        
      } catch (error) {
        console.error('Manual TTS Error:', error);
        if (statusDiv) statusDiv.textContent = `âŒ ×©×’×™××”: ${error.message}`;
      } finally {
        buttonElement.innerHTML = originalButtonText;
        buttonElement.disabled = false;
        
        // Clear status after 3 seconds
        setTimeout(() => {
          if (statusDiv) statusDiv.textContent = '';
        }, 3000);
      }
    };
    
    // TTS debugging function
    window.testTTSDebug = async function() {
      const statusDiv = document.getElementById('ttsStatus');
      
      console.group('ğŸ”§ TTS Debug Test');
      
      try {
        statusDiv.textContent = '×‘×•×“×§ TTS...';
        
        // Test 1: Check API availability
        console.log('ğŸ” Testing Google TTS API availability...');
        const testResponse = await fetch('https://texttospeech.googleapis.com/v1/voices?key=AIzaSyCYMIbBVJsGfOv1pbELD41-Lxe7OwsHd1o');
        
        console.log('ğŸ“¡ API Response Status:', testResponse.status);
        console.log('ğŸ“¡ API Response Headers:', Object.fromEntries(testResponse.headers.entries()));
        
        if (!testResponse.ok) {
          const errorText = await testResponse.text();
          console.error('âŒ API Error Details:', errorText);
          throw new Error(`API Error: ${testResponse.status} ${testResponse.statusText} - ${errorText}`);
        }
        
        const voicesData = await testResponse.json();
        console.log('âœ… Google TTS API is accessible, voices available:', voicesData.voices?.length || 0);
        
        // Test 2: Check browser audio support
        console.log('ğŸ” Testing browser audio support...');
        const testAudio = new Audio();
        const canPlayMp3 = testAudio.canPlayType('audio/mpeg');
        console.log('Audio MP3 support:', canPlayMp3);
        
        // Test 3: Try simple TTS
        console.log('ğŸ” Testing simple TTS...');
        await speakResponse('×‘×“×™×§×”');
        
        statusDiv.textContent = 'âœ… TTS ×¢×•×‘×“ ×ª×§×™×Ÿ';
        console.log('âœ… All TTS tests passed');
        
      } catch (error) {
        console.error('âŒ TTS Debug failed:', error);
        statusDiv.textContent = `âŒ ${error.message}`;
        
        // Additional debug info
        console.log('ğŸ” Debug Info:');
        console.log('- User Agent:', navigator.userAgent);
        console.log('- Browser supports Audio:', !!window.Audio);
        console.log('- HTTPS:', window.location.protocol === 'https:');
      } finally {
        console.groupEnd();
        
        // Clear status after 5 seconds
        setTimeout(() => {
          if (statusDiv) statusDiv.textContent = '';
        }, 5000);
      }
    };
    

    // Enhanced Text-to-Speech functionality using Google Cloud TTS
    async function speakResponse(text) {
      if (!text) {
        console.log('ğŸ”Š No text provided for TTS');
        return;
      }
      
      // Clean text for TTS - remove markdown, special characters, etc.
      let cleanText = text
        .replace(/\*\*/g, '') // Remove ** markdown
        .replace(/\*/g, '') // Remove * markdown
        .replace(/_{2,}/g, '') // Remove __ markdown
        .replace(/`{1,3}/g, '') // Remove code blocks
        .replace(/#{1,6}\s*/g, '') // Remove headings
        .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // Replace links with text
        .replace(/\s+/g, ' ') // Normalize spaces
        .trim();
      
      // Limit text length for TTS (Google TTS has limits)
      const maxLength = 5000;
      const textForTTS = cleanText.length > maxLength ? cleanText.substring(0, maxLength) + '...' : cleanText;
      
      const apiKey = 'AIzaSyCYMIbBVJsGfOv1pbELD41-Lxe7OwsHd1o';
      const voice = 'he-IL-Wavenet-A'; // Female Hebrew voice
      
      console.log('ğŸ”Š Starting TTS for text length:', textForTTS.length);

      try {
        console.log('ğŸ”— Calling Google TTS API...');
        const response = await fetch(`https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            input: { text: textForTTS },
            voice: { 
              languageCode: 'he-IL', 
              name: voice,
              ssmlGender: 'FEMALE'
            },
            audioConfig: { 
              audioEncoding: 'MP3',
              speakingRate: 1.0,
              pitch: 0.0,
              volumeGainDb: 0.0
            }
          })
        });

        console.log('ğŸ“¡ TTS API Response:', {
          status: response.status,
          statusText: response.statusText,
          headers: Object.fromEntries(response.headers.entries())
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error('âŒ TTS API Error Details:', errorText);
          
          // Try to parse error for more specific info
          try {
            const errorData = JSON.parse(errorText);
            console.error('âŒ Parsed API Error:', errorData);
            throw new Error(`TTS API error: ${response.status} - ${errorData.error?.message || errorText}`);
          } catch {
            throw new Error(`TTS API error: ${response.status} ${response.statusText} - ${errorText}`);
          }
        }

        const data = await response.json();
        
        if (data.audioContent) {
          const audio = new Audio('data:audio/mp3;base64,' + data.audioContent);
          
          // Add audio event listeners for better feedback
          audio.addEventListener('loadstart', () => {
            console.log('ğŸ”Š TTS audio loading...');
          });
          
          audio.addEventListener('canplay', () => {
            console.log('ğŸ”Š TTS audio ready to play');
          });
          
          audio.addEventListener('play', () => {
            console.log('ğŸ”Š Nicole is speaking...');
            // Add visual indicator that Nicole is speaking
            updateNicoleSpeakingStatus(true);
          });
          
          audio.addEventListener('ended', () => {
            console.log('ğŸ”Š Nicole finished speaking');
            updateNicoleSpeakingStatus(false);
          });
          
          audio.addEventListener('error', (e) => {
            console.error('ğŸ”Š Audio playback error:', e);
            updateNicoleSpeakingStatus(false);
          });
          
          // Handle browser autoplay restrictions
          try {
            // Try to play immediately
            await audio.play();
            console.log('âœ… TTS played successfully (auto)');
            
          } catch (autoplayError) {
            console.warn('ğŸ”‡ Browser blocked autoplay:', autoplayError.name);
            
            if (autoplayError.name === 'NotAllowedError') {
              // Browser blocked autoplay - show user notification
              console.log('ğŸ’¡ TTS requires user interaction due to browser autoplay policy');
              
              // Show visual notification that speech is ready but needs user click
              const responseBox = document.getElementById('agentResponse');
              if (responseBox) {
                const autoplayNotice = document.createElement('div');
                autoplayNotice.innerHTML = `
                  <div style="
                    background: rgba(249, 168, 37, 0.1);
                    border: 1px solid #f9a825;
                    color: #f57c00;
                    padding: 8px 12px;
                    border-radius: 8px;
                    margin-top: 8px;
                    font-size: 12px;
                    text-align: center;
                  ">
                    ğŸ”Š ×”×ª×©×•×‘×” ××•×›× ×” ×œ×”×©××¢×” - ×œ×—×¥ ×¢×œ ×›×¤×ª×•×¨ "×”×©××¢ ×ª×©×•×‘×”"
                  </div>
                `;
                responseBox.appendChild(autoplayNotice);
                
                // Store audio for manual playback
                window.pendingTTSAudio = audio;
              }
            } else {
              // Other playback error
              throw autoplayError;
            }
          }
          
        } else {
          console.warn('ğŸ”Š No audio content received from TTS API');
        }
      } catch (error) {
        console.error('ğŸ”Š Google TTS Error:', error);
        
        // Don't use automatic fallback - let user choose manually
        console.log('ğŸ’¡ TTS failed. User can use manual TTS buttons if needed.');
        
        // Provide detailed error feedback for debugging
        if (error.message.includes('network') || error.message.includes('fetch')) {
          console.log('ğŸ”Š TTS failed due to network issue');
        } else if (error.message.includes('quota') || error.message.includes('limit')) {
          console.log('ğŸ”Š TTS failed due to API quota limits');
        } else if (error.message.includes('403') || error.message.includes('401')) {
          console.log('ğŸ”Š TTS failed due to API authentication/authorization');
        }
        
        // Throw error so manual TTS can handle it appropriately
        throw error;
      }
    }
    
    
    // Helper function to show Nicole speaking status
    function updateNicoleSpeakingStatus(isSpeaking) {
      const responseBox = document.getElementById('agentResponse');
      if (responseBox && responseBox.style.display !== 'none') {
        const statusDiv = responseBox.querySelector('.nicole-speaking-status');
        
        if (isSpeaking) {
          if (!statusDiv) {
            const speakingIndicator = document.createElement('div');
            speakingIndicator.className = 'nicole-speaking-status';
            speakingIndicator.innerHTML = 'ğŸ”Š × ×™×§×•×œ ××“×‘×¨×ª...';
            speakingIndicator.style.cssText = `
              position: absolute;
              bottom: 8px;
              right: 8px;
              background: rgba(102, 126, 234, 0.1);
              color: #667eea;
              padding: 4px 8px;
              border-radius: 12px;
              font-size: 12px;
              font-weight: 500;
              animation: pulse 1.5s infinite;
            `;
            responseBox.appendChild(speakingIndicator);
          }
        } else {
          if (statusDiv) {
            statusDiv.remove();
          }
        }
      }
    }

    // Save conversation to helper for later reference
    function saveToHelper(question, answer) {
      try {
        const stored = sessionStorage.getItem("helper") || sessionStorage.getItem("expertise");
        if (!stored) return;

        const helper = JSON.parse(stored);
        if (!helper.assistant_history) helper.assistant_history = [];

        helper.assistant_history.push({
          question,
          answer,
          timestamp: new Date().toISOString()
        });

        sessionStorage.setItem("helper", JSON.stringify(helper));
        sessionStorage.setItem("expertise", JSON.stringify(helper));
        console.log('ğŸ’¾ Conversation saved to helper');
      } catch (error) {
        console.error('ğŸ’¾ Save to helper failed:', error);
      }
    }
    
    // Auto-resize textarea
    textarea.addEventListener('input', function() {
      this.style.height = 'auto';
      this.style.height = Math.min(this.scrollHeight, 200) + 'px';
    });
    
    // Enhanced focus states
    textarea.addEventListener('focus', function() {
      this.parentElement.style.transform = 'scale(1.02)';
    });
    
    textarea.addEventListener('blur', function() {
      this.parentElement.style.transform = 'scale(1)';
    });
    
    // Add global debug function for easy console access
    window.nicoleDebug = {
      getHistory: () => {
        const history = JSON.parse(sessionStorage.getItem('nicole_debug_history') || '[]');
        console.table(history);
        return history;
      },
      clearHistory: () => {
        sessionStorage.removeItem('nicole_debug_history');
        console.log('ğŸ§¹ Nicole debug history cleared');
      },
      getLastRequest: () => {
        const history = JSON.parse(sessionStorage.getItem('nicole_debug_history') || '[]');
        return history[history.length - 1] || null;
      },
      exportHistory: () => {
        const history = JSON.parse(sessionStorage.getItem('nicole_debug_history') || '[]');
        const blob = new Blob([JSON.stringify(history, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `nicole_debug_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        console.log('ğŸ’¾ Debug history exported');
      },
      getMicErrors: () => {
        const errors = JSON.parse(sessionStorage.getItem('nicole_mic_errors') || '[]');
        console.table(errors);
        return errors;
      },
      clearMicErrors: () => {
        sessionStorage.removeItem('nicole_mic_errors');
        console.log('ğŸ§¹ Microphone error history cleared');
      },
      getErrorPatterns: () => {
        const errors = JSON.parse(sessionStorage.getItem('nicole_mic_errors') || '[]');
        const patterns = {};
        errors.forEach(error => {
          patterns[error.error_type] = (patterns[error.error_type] || 0) + 1;
        });
        console.log('ğŸ“Š Error Patterns:', patterns);
        return patterns;
      },
      testMicrophone: async () => {
        console.log('ğŸ¤ Testing microphone permissions...');
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          console.log('âœ… Microphone access granted');
          stream.getTracks().forEach(track => track.stop());
          return { success: true, message: 'Microphone working' };
        } catch (error) {
          console.error('âŒ Microphone test failed:', error);
          return { success: false, error: error.message };
        }
      },
      // New debugging tools for JSON and encoding issues
      analyzeText: (text) => {
        console.group('ğŸ” Text Analysis');
        console.log('ğŸ“ Text Info:', {
          length: text.length,
          type: typeof text,
          first_10_chars: text.substring(0, 10),
          last_10_chars: text.substring(text.length - 10),
          char_codes: text.substring(0, 20).split('').map(c => ({ char: c, code: c.charCodeAt(0) })),
          has_bom: text.charCodeAt(0) === 0xFEFF,
          has_hebrew: /[\u0590-\u05FF]/.test(text),
          has_arabic: /[\u0600-\u06FF]/.test(text),
          line_breaks: text.match(/\r?\n/g)?.length || 0,
          is_json_like: text.trim().startsWith('{') && text.trim().endsWith('}')
        });
        
        if (text.trim().startsWith('{')) {
          try {
            const parsed = JSON.parse(text);
            console.log('âœ… Valid JSON:', parsed);
          } catch (e) {
            console.error('âŒ JSON Parse Error:', e.message);
            console.log('ğŸ”§ JSON Syntax Check:', {
              balanced_braces: (text.match(/\{/g)?.length || 0) === (text.match(/\}/g)?.length || 0),
              balanced_brackets: (text.match(/\[/g)?.length || 0) === (text.match(/\]/g)?.length || 0),
              has_quotes: /["']/.test(text),
              has_commas: /,/.test(text)
            });
          }
        }
        console.groupEnd();
        return text;
      },
      testEncoding: () => {
        const testStrings = [
          '×©×œ×•× ×¢×•×œ×', // Hebrew
          'Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…', // Arabic
          'Hello World', // English
          '{"text": "×‘×“×™×§×”"}' // JSON with Hebrew
        ];
        
        console.group('ğŸŒ Character Encoding Test');
        testStrings.forEach((str, index) => {
          console.log(`Test ${index + 1}:`, {
            original: str,
            encoded: encodeURIComponent(str),
            base64: btoa(unescape(encodeURIComponent(str))),
            char_codes: str.split('').map(c => c.charCodeAt(0)),
            json_stringify: JSON.stringify(str),
            roundtrip_test: decodeURIComponent(encodeURIComponent(str)) === str
          });
        });
        console.groupEnd();
      },
      simulateResponse: (responseText) => {
        console.group('ğŸ§ª Simulate Response Processing');
        console.log('Input:', responseText);
        
        try {
          // Simulate the same processing as the real code
          let cleanResponse = responseText.trim();
          
          if (cleanResponse.charCodeAt(0) === 0xFEFF) {
            cleanResponse = cleanResponse.substring(1);
            console.log('ğŸ§¹ Removed BOM');
          }
          
          const responseData = JSON.parse(cleanResponse);
          const textContent = responseData.text || responseData.message || responseData.response || responseData.content;
          
          console.log('âœ… Simulation Success:', {
            parsed_data: responseData,
            extracted_text: textContent,
            would_display: textContent || 'fallback content'
          });
          
        } catch (error) {
          console.error('âŒ Simulation Failed:', error.message);
          console.log('ğŸ”„ Would attempt extraction fallback...');
          
          if (responseText.includes('{') && responseText.includes('}')) {
            const firstBrace = responseText.indexOf('{');
            const lastBrace = responseText.lastIndexOf('}');
            if (firstBrace !== -1 && lastBrace !== -1) {
              const extracted = responseText.substring(firstBrace, lastBrace + 1);
              console.log('ğŸ”§ Extracted JSON:', extracted);
              try {
                const extractedData = JSON.parse(extracted);
                console.log('âœ… Extraction Success:', extractedData);
              } catch (e2) {
                console.error('âŒ Extraction also failed:', e2.message);
              }
            }
          }
        }
        console.groupEnd();
      },
      // Conversation context debugging
      getConversation: () => {
        const context = JSON.parse(sessionStorage.getItem('nicole_conversation') || '{}');
        console.group('ğŸ’¬ Conversation Context');
        console.log('Conversation ID:', context.conversation_id);
        console.log('Started:', context.started_at);
        console.log('Messages:', context.messages?.length || 0);
        console.log('Current Plate:', context.current_plate);
        if (context.messages && context.messages.length > 0) {
          console.table(context.messages.map(msg => ({
            role: msg.role,
            content: msg.content.substring(0, 50) + (msg.content.length > 50 ? '...' : ''),
            timestamp: msg.timestamp
          })));
        }
        console.groupEnd();
        return context;
      },
      clearConversation: () => {
        sessionStorage.removeItem('nicole_conversation');
        console.log('ğŸ§¹ Conversation context cleared');
        initializeConversationContext();
      }
    };
    
    console.log('ğŸ”§ Nicole Debug Tools Available:');
    console.log('  - nicoleDebug.getHistory() - View all request/response history');
    console.log('  - nicoleDebug.getLastRequest() - Get the most recent request');
    console.log('  - nicoleDebug.clearHistory() - Clear debug history');
    console.log('  - nicoleDebug.exportHistory() - Export history as JSON file');
    console.log('  - nicoleDebug.getMicErrors() - View microphone error history');
    console.log('  - nicoleDebug.getErrorPatterns() - Analyze error frequency');
    console.log('  - nicoleDebug.testMicrophone() - Test mic permissions');
    console.log('  - nicoleDebug.clearMicErrors() - Clear mic error history');
    console.log('  - nicoleDebug.analyzeText(text) - Analyze text and encoding');
    console.log('  - nicoleDebug.testEncoding() - Test character encoding support');
    console.log('  - nicoleDebug.simulateResponse(text) - Simulate response processing');
    console.log('  - nicoleDebug.getConversation() - View conversation context');
    console.log('  - nicoleDebug.clearConversation() - Clear conversation context');
    
    // Initialize conversation context
    initializeConversationContext();
  }
  
  // Conversation Context Management
  function initializeConversationContext() {
    if (!sessionStorage.getItem('nicole_conversation')) {
      const initialContext = {
        conversation_id: 'conv_' + Date.now() + '_' + Math.random().toString(36).substring(2, 8),
        started_at: new Date().toISOString(),
        messages: [],
        current_plate: sessionStorage.getItem('plate') || null
      };
      sessionStorage.setItem('nicole_conversation', JSON.stringify(initialContext));
      console.log('ğŸ”„ New conversation context initialized:', initialContext.conversation_id);
    }
  }
  
  function storeConversationContext(message, role = 'user') {
    try {
      const context = JSON.parse(sessionStorage.getItem('nicole_conversation') || '{}');
      if (!context.messages) context.messages = [];
      
      const messageEntry = {
        role: role, // 'user' or 'assistant'
        content: message,
        timestamp: new Date().toISOString(),
        message_id: 'msg_' + Date.now() + '_' + Math.random().toString(36).substring(2, 6)
      };
      
      context.messages.push(messageEntry);
      context.last_activity = new Date().toISOString();
      
      // Keep only last 20 messages for context (10 exchanges)
      if (context.messages.length > 20) {
        context.messages = context.messages.slice(-20);
      }
      
      sessionStorage.setItem('nicole_conversation', JSON.stringify(context));
      console.log(`ğŸ’¬ Stored ${role} message in conversation context`);
      
    } catch (error) {
      console.error('âŒ Failed to store conversation context:', error);
    }
  }
  
  function getConversationContext() {
    try {
      const context = JSON.parse(sessionStorage.getItem('nicole_conversation') || '{}');
      return context.messages || [];
    } catch (error) {
      console.error('âŒ Failed to get conversation context:', error);
      return [];
    }
  }
  
  // Reply Functions
  window.showReplyBox = function() {
    const replyBox = document.getElementById('replyBox');
    const replyInput = document.getElementById('replyInput');
    
    if (replyBox && replyInput) {
      replyBox.style.display = 'block';
      replyInput.focus();
      
      // Scroll the reply box into view
      setTimeout(() => {
        replyBox.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }, 100);
    }
  };
  
  window.cancelReply = function() {
    const replyBox = document.getElementById('replyBox');
    const replyInput = document.getElementById('replyInput');
    
    if (replyBox && replyInput) {
      replyBox.style.display = 'none';
      replyInput.value = '';
    }
  };
  
  window.sendReply = async function() {
    const replyInput = document.getElementById('replyInput');
    const replyText = replyInput?.value?.trim();
    
    if (!replyText) {
      alert('×× × ×›×ª×•×‘ ×ª×’×•×‘×” ××• ×©××œ×”');
      return;
    }
    
    // Hide reply box and clear input
    cancelReply();
    
    // Get current plate from main form or session
    const currentPlate = document.getElementById('plateInput')?.value?.trim() || 
                        sessionStorage.getItem('plate') || '';
    
    // Store user message in context
    storeConversationContext(replyText, 'user');
    
    // Show loading state
    const responseBox = document.getElementById('agentResponse');
    if (responseBox) {
      const loadingDiv = document.createElement('div');
      loadingDiv.id = 'replyLoading';
      loadingDiv.innerHTML = `
        <div style="
          background: rgba(102, 126, 234, 0.1);
          border: 1px solid rgba(102, 126, 234, 0.3);
          padding: 12px;
          border-radius: 8px;
          margin-top: 12px;
          text-align: center;
          color: #667eea;
          font-size: 13px;
        ">
          <div style="display: inline-flex; align-items: center; gap: 8px;">
            <div style="width: 16px; height: 16px; border: 2px solid #667eea; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
            ×©×•×œ×— ×ª×’×•×‘×”...
          </div>
        </div>
      `;
      responseBox.appendChild(loadingDiv);
    }
    
    try {
      // Send reply with conversation context
      await submitQuery(currentPlate, replyText, false, true);
      
    } catch (error) {
      console.error('Reply error:', error);
      alert('×©×’×™××” ×‘×©×œ×™×—×ª ×”×ª×’×•×‘×”: ' + error.message);
    } finally {
      // Remove loading indicator
      const loadingDiv = document.getElementById('replyLoading');
      if (loadingDiv) {
        loadingDiv.remove();
      }
    }
  };
</script>

<style>
  /* Add shake animation for validation feedback */
  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
  }
  
  /* Enhance container animations */
  .input-container {
    transition: transform 0.2s ease;
  }
  
  /* Loading button state */
  .btn-send:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    transform: none !important;
  }
  
  /* Spinner animation for loading states */
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  /* Reply box styling enhancements */
  #replyBox {
    transition: all 0.3s ease;
  }
  
  #replyInput:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
  }
</style>
</body>
</html>
