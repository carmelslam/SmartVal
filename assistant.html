<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>× ×™×§×•×œ â€“ ×¢×•×–×¨×ª ×“×™×’×™×˜×œ×™×ª</title>
  <script type="module" src="./webhook.js"></script>
  <script type="module" src="./helper.js"></script>

  <link rel="icon" type="image/webp" href="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp">
  <link rel="shortcut icon" href="https://carmelcayouf.com/wp-content/uploads/2025/04/logo-yaron.webp">
  <link rel="apple-touch-icon" href="https://carmelcayouf.com/wp-content/uploads/2025/04/logo-yaron.webp">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }
    .container {
      max-width: 480px;
      background: #fff;
      padding: 35px;
      border-radius: 18px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.12);
      text-align: center;
      position: relative;
      width: 90%;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
    }
    .logo img {
      width: 120px;
      margin-bottom: 15px;
    }
    .title { 
      font-size: 26px; 
      font-weight: 700; 
      margin-bottom: 8px; 
      color: #2d3748;
      letter-spacing: -0.5px;
    }
    .subtitle { 
      font-size: 16px; 
      color: #718096; 
      margin-bottom: 8px; 
      font-weight: 500;
    }
    h2 {
      font-size: 22px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 25px;
      font-weight: 600;
      letter-spacing: -0.3px;
    }
    input {
      width: 100%;
      padding: 14px 16px;
      font-size: 15px;
      margin-bottom: 18px;
      border-radius: 14px;
      border: 1.5px solid #e2e8f0;
      box-sizing: border-box;
      transition: all 0.3s ease;
      background: #f7fafc;
      color: #2d3748;
      font-weight: 500;
    }
    
    input:focus {
      outline: none;
      border-color: #667eea;
      background: #fff;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      transform: translateY(-1px);
    }

    /* Modern input container with integrated microphone */
    .input-container {
      position: relative;
      margin-bottom: 20px;
    }
    
    .input-with-mic {
      width: 100%;
      padding: 16px 50px 16px 18px;
      font-size: 15px;
      border-radius: 18px;
      border: 1.5px solid #e2e8f0;
      box-sizing: border-box;
      transition: all 0.3s ease;
      background: #f7fafc;
      resize: none;
      min-height: 90px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #2d3748;
      font-weight: 500;
      line-height: 1.5;
    }
    
    .input-with-mic:focus {
      outline: none;
      border-color: #667eea;
      background: #fff;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.08);
      transform: translateY(-2px);
    }
    
    .mic-button {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 34px;
      height: 34px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 15px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 12px rgba(30, 58, 138, 0.3);
    }
    
    .mic-button:hover {
      transform: translateY(-50%) scale(1.1);
      box-shadow: 0 4px 12px rgba(30, 58, 138, 0.4);
    }
    
    .mic-button:active {
      transform: translateY(-50%) scale(0.95);
    }
    
    .mic-button.recording {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3); }
      50% { box-shadow: 0 4px 16px rgba(255, 107, 107, 0.6); }
      100% { box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3); }
    }
    
    /* Modern button container */
    .button-container {
      display: flex;
      gap: 12px;
      margin-top: 28px;
      justify-content: center;
    }
    
    .btn-modern {
      padding: 12px 24px;
      font-size: 15px;
      font-weight: 600;
      border: none;
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      min-width: 130px;
      letter-spacing: -0.2px;
    }
    
    .btn-send {
      background: linear-gradient(135deg, #16a34a 0%, #22c55e 100%);
      color: white;
      box-shadow: 0 6px 20px rgba(34, 197, 94, 0.3);
    }
    
    .btn-send:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(34, 197, 94, 0.4);
    }
    
    .btn-send:active {
      transform: translateY(-1px);
    }
    
    .btn-clear {
      background: rgba(255, 255, 255, 0.9);
      color: #4a5568;
      border: 1.5px solid #e2e8f0;
      backdrop-filter: blur(10px);
    }
    
    .btn-clear:hover {
      background: rgba(255, 255, 255, 1);
      border-color: #cbd5e0;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    
    .btn-secondary {
      background: #64748b;
      color: white;
      border: 1.5px solid #64748b;
    }
    
    .btn-secondary:hover {
      background: #475569;
      border-color: #475569;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(71, 85, 105, 0.3);
    }
    .floating-response {
      position: fixed;
      bottom: 30px;
      right: 30px;
      max-width: 380px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(102, 126, 234, 0.2);
      padding: 20px;
      border-radius: 18px;
      box-shadow: 0 12px 40px rgba(102, 126, 234, 0.15);
      font-size: 15px;
      color: #2d3748;
      z-index: 1000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      animation: slideInUp 0.3s ease-out;
    }

    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @media (max-width: 480px) {
      .floating-response {
        right: 20px;
        left: 20px;
        max-width: none;
        bottom: 20px;
      }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="logo">
    <img src="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp" alt="Logo">
  </div>
  <div class="title">×™×¨×•×Ÿ ×›×™×•×£ ×©×××•×ª - ×¤×•×¨×˜×œ</div>
  <div class="subtitle">×©×××™ ×¨×›×‘ ×•×”×¢×¨×›×ª × ×–×§×™ ×¨×›×•×©</div>
  <h2>ğŸ‘©â€ğŸ’¼ × ×™×§×•×œ â€“ ×¢×•×–×¨×ª ×“×™×’×™×˜×œ×™×ª</h2>
  <form id="assistantForm">
    <input type="text" id="plateInput" name="plate" placeholder="××¡×¤×¨ ×¨×›×‘ (××•×¤×¦×™×•× ×œ×™)">
    
    <!-- Modern input container with integrated microphone -->
    <div class="input-container">
      <textarea id="freeQuery" name="query" class="input-with-mic" placeholder="××” ×ª×¨×¦×” ×œ×“×¢×ª ××• ×œ×‘×§×©? ××¤×©×¨ ×œ×›×ª×•×‘ ××• ×œ×”×§×™×© ×¢×œ ×”××™×§×¨×•×¤×•×Ÿ ×œ×“×‘×¨..."></textarea>
      <button type="button" id="micBtn" class="mic-button" title="×œ×—×¥ ×›×“×™ ×œ×”×§×œ×™×˜ ×§×•×œ">
        ğŸ¤
      </button>
    </div>
    
    <!-- Modern button container -->
    <div class="button-container">
      <button type="button" class="btn-modern btn-clear" onclick="clearForm()">
        ğŸ—‘ï¸ × ×§×”
      </button>
      <button type="submit" id="sendBtn" class="btn-modern btn-send">
        <span>ğŸ“¤</span>
        ×©×œ×— ×©××œ×”
      </button>
      <button type="button" class="btn-modern btn-secondary" onclick="window.location.href='selection.html'">
        â†©ï¸ ×—×–×•×¨ ×œ×‘×—×™×¨×”
      </button>
    </div>
  </form>
</div>
<div id="agentResponse" class="floating-response" style="display:none;"></div>
<script>
  // Global TTS audio control
  window.currentTTSAudio = null;
  window.isTTSPlaying = false;

  window.addEventListener('DOMContentLoaded', () => {
    // Enhanced authentication audit
    const userAuthToken = sessionStorage.getItem('auth');
    const loginTime = sessionStorage.getItem('loginTime');
    const password = sessionStorage.getItem('password');
    const plate = sessionStorage.getItem('plate');
    
    console.group("ğŸ” Nicole Authentication Audit");
    console.log("ğŸ“Š Authentication State:", {
      auth_token: userAuthToken ? userAuthToken.substring(0, 20) + '...' : 'MISSING',
      auth_length: userAuthToken?.length || 0,
      login_time: loginTime,
      password_exists: !!password,
      password_type: password ? typeof password : 'undefined',
      plate_preloaded: plate || 'NONE',
      session_keys: Object.keys(sessionStorage).sort(),
      timestamp: new Date().toISOString()
    });
    
    // Check authentication validity
    const isValidAuth = userAuthToken && loginTime;
    console.log("ğŸ« Auth Validation:", {
      has_auth_token: !!userAuthToken,
      has_login_time: !!loginTime,
      is_valid: isValidAuth,
      login_age_minutes: loginTime ? Math.round((Date.now() - new Date(loginTime).getTime()) / 60000) : 'N/A'
    });
    
    // Check for auth conflicts or issues
    const authIssues = [];
    if (!userAuthToken) authIssues.push('Missing auth token');
    if (!loginTime) authIssues.push('Missing login time');
    if (!password && !userAuthToken) authIssues.push('No password fallback');
    
    if (authIssues.length > 0) {
      console.warn("âš ï¸ Authentication Issues:", authIssues);
    }
    
    if (!isValidAuth) {
      console.error("âŒ Authentication failed, redirecting to login");
      console.log("ğŸ”„ Redirect reason:", authIssues.join(', '));
      alert("×”×’×™×©×” ×—×¡×•××” - ×× × ×”×ª×—×‘×¨ ×“×¨×š ×“×£ ×”×‘×™×ª");
      window.location.href = 'index.html';
      return;
    }
    
    console.log("âœ… Authentication verified successfully");
    console.groupEnd();
    
    // Pre-populate plate if available
    if (plate) {
      document.getElementById('plateInput').value = plate;
      console.log("ğŸš— Pre-populated plate number:", plate);
    }
    
    // Store auth audit in session for debugging
    sessionStorage.setItem('nicole_auth_audit', JSON.stringify({
      timestamp: new Date().toISOString(),
      auth_valid: true,
      auth_method: password ? 'password' : 'auth_token',
      login_age_minutes: Math.round((Date.now() - new Date(loginTime).getTime()) / 60000)
    }));
    
    // Initialize modern UI functionality
    initializeModernUI();
  });

  // Helper function to detect browser info
  function getBrowserInfo() {
    const ua = navigator.userAgent;
    if (ua.includes('Chrome')) return 'Chrome';
    if (ua.includes('Firefox')) return 'Firefox';
    if (ua.includes('Safari') && !ua.includes('Chrome')) return 'Safari';
    if (ua.includes('Edge')) return 'Edge';
    if (ua.includes('Opera')) return 'Opera';
    return 'Unknown';
  }

  function clearForm() {
    document.getElementById('plateInput').value = '';
    document.getElementById('freeQuery').value = '';
    document.getElementById('freeQuery').focus();
  }

  function initializeModernUI() {
    const micBtn = document.getElementById('micBtn');
    const textarea = document.getElementById('freeQuery');
    const sendBtn = document.getElementById('sendBtn');
    
    // Enhanced microphone button functionality
    let isRecording = false;
    let recordingTimeout;
    let inactivityTimeout;
    let wasVoiceInput = false; // Track if last input was from voice
    const MAX_RECORDING_TIME = 60000; // 60 seconds max recording
    const INACTIVITY_TIMEOUT = 15000; // 15 seconds of silence
    
    micBtn.addEventListener('click', function() {
      if (micBtn.disabled) return;
      
      if (!isRecording) {
        startRecording();
      } else {
        stopRecording();
      }
    });
    
    // Initialize speech recognition
    let recognition;
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      const SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.lang = 'he-IL';
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;
      recognition.continuous = false;

      recognition.addEventListener('result', (event) => {
        const transcript = event.results[0][0].transcript;
        textarea.value = transcript;
        
        // Mark that this input came from voice
        wasVoiceInput = true;
        
        // Reset inactivity timeout when speech is detected
        if (inactivityTimeout) {
          clearTimeout(inactivityTimeout);
          inactivityTimeout = null;
        }
        
        stopRecording();
        console.log('ğŸ¤ Speech recognized:', transcript);
      });

      recognition.addEventListener('error', (event) => {
        const errorDetails = {
          error_type: event.error,
          timestamp: new Date().toISOString(),
          user_agent: navigator.userAgent,
          browser: getBrowserInfo(),
          mic_permissions: 'unknown'
        };
        
        console.group('ğŸš¨ Microphone Error Analysis');
        console.error('ğŸ¤ Speech recognition error:', event.error);
        console.log('ğŸ“Š Error Details:', errorDetails);
        
        stopRecording();
        
        let errorMessage = '×©×’×™××” ×‘×–×™×”×•×™ ×§×•×œ';
        let troubleshooting = '';
        let severity = 'medium';
        
        switch(event.error) {
          case 'no-speech':
            errorMessage = '×œ× ×–×•×”×” ×“×™×‘×•×¨. ×× × × ×¡×” ×©×•×‘ ×•×“×‘×¨ ×‘×§×•×œ ×‘×¨×•×¨.';
            troubleshooting = '×‘×“×•×§ ×©×”××™×§×¨×•×¤×•×Ÿ ×¢×•×‘×“ ×•×©××™×Ÿ ×¨×¢×© ×¡×‘×™×‘×”';
            severity = 'low';
            break;
          case 'audio-capture':
            errorMessage = '×œ× × ×™×ª×Ÿ ×œ×’×©×ª ×œ××™×§×¨×•×¤×•×Ÿ. ×× × ×‘×“×•×§ ××ª ×”×”×¨×©××•×ª ×•×”×—×™×‘×•×¨.';
            troubleshooting = '1. ×‘×“×•×§ ×©×”××™×§×¨×•×¤×•×Ÿ ××—×•×‘×¨\n2. ××©×¨ ×”×¨×©××•×ª ×œ××™×§×¨×•×¤×•×Ÿ\n3. ×¡×’×•×¨ ×™×™×©×•××™× ××—×¨×™× ×©×¢×©×•×™×™× ×œ×”×©×ª××© ×‘××™×§×¨×•×¤×•×Ÿ';
            severity = 'high';
            break;
          case 'not-allowed':
            errorMessage = '×’×™×©×” ×œ××™×§×¨×•×¤×•×Ÿ × ×“×—×ª×”. ×× × ××©×¨ ×”×¨×©××” ×‘×”×’×“×¨×•×ª ×”×“×¤×“×¤×Ÿ.';
            troubleshooting = '×œ×—×¥ ×¢×œ ×¡××œ ×”××™×§×¨×•×¤×•×Ÿ ×‘×©×•×¨×ª ×”×›×ª×•×‘×ª ×•××©×¨ ×”×¨×©××”';
            severity = 'high';
            break;
          case 'network':
            errorMessage = '×©×’×™××ª ×¨×©×ª. ×× × ×‘×“×•×§ ××ª ×”×—×™×‘×•×¨ ×œ××™× ×˜×¨× ×˜.';
            troubleshooting = '×‘×“×•×§ ×—×™×‘×•×¨ ×”××™× ×˜×¨× ×˜ ×•× ×¡×” ×©×•×‘';
            severity = 'medium';
            break;
          case 'aborted':
            errorMessage = '×–×™×”×•×™ ×”×§×•×œ ×”×•×¤×¡×§.';
            troubleshooting = '×–×•×”×™ ×©×’×™××” ×–×× ×™×ª, × ×™×ª×Ÿ ×œ× ×¡×•×ª ×©×•×‘';
            severity = 'low';
            break;
          case 'service-not-allowed':
            errorMessage = '×©×™×¨×•×ª ×–×™×”×•×™ ×§×•×œ ×œ× ×–××™×Ÿ.';
            troubleshooting = '×”×©×™×¨×•×ª ×¢×©×•×™ ×œ×”×™×•×ª ×—×¡×•× ××• ×œ× ×–××™×Ÿ ×‘××–×•×¨ ×©×œ×š';
            severity = 'high';
            break;
          default:
            errorMessage = `×©×’×™××” ×‘×–×™×”×•×™ ×§×•×œ: ${event.error}`;
            troubleshooting = '×©×’×™××” ×œ× ××–×•×”×”, × ×¡×” ×œ×¨×¢× ×Ÿ ××ª ×”×“×£';
            severity = 'medium';
        }
        
        // Log detailed error for debugging
        console.log('ğŸ› ï¸ Error Analysis:', {
          error_code: event.error,
          message: errorMessage,
          troubleshooting: troubleshooting,
          severity: severity,
          browser_support: !!window.webkitSpeechRecognition || !!window.SpeechRecognition,
          permissions_api: !!navigator.permissions
        });
        
        // Save error to session for pattern analysis
        const micErrors = JSON.parse(sessionStorage.getItem('nicole_mic_errors') || '[]');
        micErrors.push({
          ...errorDetails,
          message: errorMessage,
          severity: severity,
          troubleshooting: troubleshooting
        });
        // Keep only last 20 errors
        if (micErrors.length > 20) micErrors.shift();
        sessionStorage.setItem('nicole_mic_errors', JSON.stringify(micErrors));
        
        console.groupEnd();
        
        // Show user-friendly error with troubleshooting
        const fullMessage = `${errorMessage}\n\n×¤×ª×¨×•×Ÿ ××•×¦×¢:\n${troubleshooting}`;
        alert(fullMessage);
        
        // If it's a critical error, disable mic button temporarily
        if (severity === 'high') {
          micBtn.style.opacity = '0.5';
          micBtn.disabled = true;
          setTimeout(() => {
            micBtn.style.opacity = '1';
            micBtn.disabled = false;
          }, 10000); // Re-enable after 10 seconds
        }
      });

      recognition.addEventListener('end', () => {
        stopRecording();
      });
      
      // Cleanup function for page unload
      window.addEventListener('beforeunload', () => {
        if (isRecording) {
          stopRecording();
        }
        if (recordingTimeout) clearTimeout(recordingTimeout);
        if (inactivityTimeout) clearTimeout(inactivityTimeout);
      });
      
      // Cleanup function for visibility changes (tab switches)
      document.addEventListener('visibilitychange', () => {
        if (document.hidden && isRecording) {
          console.log('ğŸ¤ Tab hidden while recording, stopping...');
          stopRecording();
        }
      });
    } else {
      // Speech recognition not supported
      micBtn.style.opacity = '0.5';
      micBtn.style.cursor = 'not-allowed';
      micBtn.title = '×–×™×”×•×™ ×§×•×œ ×œ× × ×ª××š ×‘×“×¤×“×¤×Ÿ ×–×”';
      micBtn.disabled = true;
    }
    
    async function startRecording() {
      if (!recognition) {
        alert('×–×™×”×•×™ ×§×•×œ ×œ× × ×ª××š ×‘×“×¤×“×¤×Ÿ ×–×”');
        return;
      }

      // Check microphone permissions
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream.getTracks().forEach(track => track.stop()); // Stop the stream immediately
      } catch (error) {
        console.error('ğŸ¤ Microphone permission error:', error);
        if (error.name === 'NotAllowedError') {
          alert('× ×“×¨×©×ª ×”×¨×©××” ×œ××™×§×¨×•×¤×•×Ÿ ×›×“×™ ×œ×”×©×ª××© ×‘×–×™×”×•×™ ×§×•×œ. ×× × ××©×¨ ××ª ×”×”×¨×©××” ×•× ×¡×” ×©×•×‘.');
        } else if (error.name === 'NotFoundError') {
          alert('×œ× × ××¦× ××™×§×¨×•×¤×•×Ÿ. ×× × ×—×‘×¨ ××™×§×¨×•×¤×•×Ÿ ×•× ×¡×” ×©×•×‘.');
        } else {
          alert('×©×’×™××” ×‘×’×™×©×” ×œ××™×§×¨×•×¤×•×Ÿ: ' + error.message);
        }
        return;
      }

      isRecording = true;
      micBtn.classList.add('recording');
      micBtn.innerHTML = 'â¹ï¸';
      micBtn.title = '×œ×—×¥ ×›×“×™ ×œ×”×¤×¡×™×§ ×”×§×œ×˜×”';
      
      // Add visual feedback to textarea
      textarea.style.borderColor = '#ff6b6b';
      textarea.placeholder = 'ğŸ¤ ××§×œ×™×˜... ×“×‘×¨ ×¢×›×©×™×• ××• ×œ×—×¥ ×©×•×‘ ×›×“×™ ×œ×”×¤×¡×™×§';
      
      // Set maximum recording timeout
      recordingTimeout = setTimeout(() => {
        console.log('ğŸ¤ Maximum recording time reached, stopping...');
        stopRecording();
        alert('×”×§×œ×˜×” ×”×•×¤×¡×§×” ×œ××—×¨ ×“×§×”. ×× × × ×¡×” ×©×•×‘.');
      }, MAX_RECORDING_TIME);
      
      // Set inactivity timeout
      inactivityTimeout = setTimeout(() => {
        console.log('ğŸ¤ No speech detected for 15 seconds, stopping...');
        stopRecording();
        // Don't show alert for inactivity timeout - it's normal
      }, INACTIVITY_TIMEOUT);
      
      try {
        recognition.start();
        console.log('ğŸ¤ Speech recognition started with timeouts:', {
          max_time: MAX_RECORDING_TIME,
          inactivity_timeout: INACTIVITY_TIMEOUT
        });
      } catch (error) {
        console.error('ğŸ¤ Failed to start recognition:', error);
        if (error.message.includes('already started')) {
          // Recognition already running, stop and restart
          recognition.stop();
          setTimeout(() => {
            recognition.start();
          }, 100);
        } else {
          stopRecording();
          alert('×©×’×™××” ×‘×”×¤×¢×œ×ª ×–×™×”×•×™ ×§×•×œ: ' + error.message);
        }
      }
    }
    
    function stopRecording() {
      isRecording = false;
      micBtn.classList.remove('recording');
      micBtn.innerHTML = 'ğŸ¤';
      micBtn.title = '×œ×—×¥ ×›×“×™ ×œ×”×§×œ×™×˜ ×§×•×œ';
      
      // Clear all timeouts
      if (recordingTimeout) {
        clearTimeout(recordingTimeout);
        recordingTimeout = null;
      }
      if (inactivityTimeout) {
        clearTimeout(inactivityTimeout);
        inactivityTimeout = null;
      }
      
      // Reset textarea styling
      textarea.style.borderColor = '#e2e8f0';
      textarea.placeholder = '××” ×ª×¨×¦×” ×œ×“×¢×ª ××• ×œ×‘×§×©? ××¤×©×¨ ×œ×›×ª×•×‘ ××• ×œ×”×§×™×© ×¢×œ ×”××™×§×¨×•×¤×•×Ÿ ×œ×“×‘×¨...';
      
      if (recognition) {
        try {
          recognition.stop();
        } catch (error) {
          console.log('Recognition already stopped');
        }
      }
      
      console.log('ğŸ¤ Recording stopped with timeout cleanup...');
    }
    
    // Form submission handler
    const form = document.getElementById('assistantForm');
    form.addEventListener('submit', async function(e) {
      e.preventDefault();
      
      const query = textarea.value.trim();
      const plate = document.getElementById('plateInput').value.trim();
      
      // Check if this was voice input (will be reset after processing)
      const currentWasVoiceInput = wasVoiceInput;
      
      // Enhanced validation: require at least one field (plate OR query)
      if (!query && !plate) {
        alert('×× × ××œ× ×œ×¤×—×•×ª ×©×“×” ××—×“:\nâ€¢ ××¡×¤×¨ ×¨×›×‘, ××•\nâ€¢ ×©××œ×”/×‘×§×©×”');
        
        // Focus on the first empty field
        if (!plate) {
          document.getElementById('plateInput').focus();
          document.getElementById('plateInput').style.animation = 'shake 0.5s';
          setTimeout(() => { document.getElementById('plateInput').style.animation = ''; }, 500);
        } else {
          textarea.focus();
          textarea.style.animation = 'shake 0.5s';
          setTimeout(() => { textarea.style.animation = ''; }, 500);
        }
        
        console.log('âŒ Validation failed: Both fields empty', { plate, query });
        return;
      }
      
      // If only plate is provided, create a default query
      let finalQuery = query;
      if (!query && plate) {
        finalQuery = `××” ×”××™×“×¢ ×”×–××™×Ÿ ×¢×‘×•×¨ ×¨×›×‘ ××¡×¤×¨ ${plate}?`;
        console.log('ğŸ”„ Auto-generated query for plate-only request:', finalQuery);
      }
      
      console.log('âœ… Validation passed:', { 
        plate: plate || 'NONE', 
        query: finalQuery,
        validation_type: query && plate ? 'BOTH' : query ? 'QUERY_ONLY' : 'PLATE_ONLY'
      });
      
      // Add loading state
      sendBtn.innerHTML = '<span>â³</span> ×©×•×œ×—...';
      sendBtn.disabled = true;
      
      try {
        // Store user query in conversation context
        storeConversationContext(finalQuery, 'user');
        
        await submitQuery(plate, finalQuery, currentWasVoiceInput);
        
        // Reset voice input flag after successful submission
        wasVoiceInput = false;
      } catch (error) {
        console.error('Submit error:', error);
        alert('×©×’×™××” ×‘×©×œ×™×—×ª ×”×©××œ×”: ' + error.message);
      } finally {
        // Reset button state
        sendBtn.innerHTML = '<span>ğŸ“¤</span> ×©×œ×— ×©××œ×”';
        sendBtn.disabled = false;
      }
    });

    // Function to detect and complete truncated JSON responses
    function completeIncompleteJson(jsonString) {
      try {
        console.log('ğŸ” Checking for truncated JSON...');
        
        const trimmed = jsonString.trim();
        
        // Quick check: if it starts with { but doesn't end with }, it might be truncated
        if (trimmed.startsWith('{') && !trimmed.endsWith('}')) {
          console.log('âš ï¸ JSON appears to be truncated');
          
          // Look for the last complete field before truncation
          let completed = trimmed;
          
          // If the JSON ends abruptly in the middle of a string, close the string
          const lastQuoteIndex = completed.lastIndexOf('"');
          const lastOpenQuoteIndex = completed.lastIndexOf('"', lastQuoteIndex - 1);
          
          // Count quotes to see if we're in the middle of a string
          const quoteCount = (completed.match(/"/g) || []).length;
          if (quoteCount % 2 !== 0) {
            // Odd number of quotes means we're in the middle of a string
            console.log('ğŸ”§ Completing truncated string...');
            completed += '"';
          }
          
          // Add closing brace
          if (!completed.endsWith('}')) {
            completed += '}';
            console.log('ğŸ”§ Added closing brace to complete JSON');
          }
          
          // Verify the completion makes sense
          try {
            JSON.parse(completed);
            console.log('âœ… Successfully completed truncated JSON');
            return completed;
          } catch (testError) {
            console.log('âš ï¸ Completion attempt failed, trying more aggressive completion...');
            
            // More aggressive approach: find the last valid comma and close from there
            const lastCommaIndex = trimmed.lastIndexOf(',');
            const lastColonIndex = trimmed.lastIndexOf(':');
            
            if (lastColonIndex > lastCommaIndex) {
              // We're in the middle of a value, try to close it properly
              let aggressiveComplete = trimmed;
              
              // If it looks like we're in a string value, close the string
              const afterColon = trimmed.substring(lastColonIndex + 1).trim();
              if (afterColon.startsWith('"') && !afterColon.endsWith('"')) {
                aggressiveComplete += '"';
              }
              
              aggressiveComplete += '}';
              
              try {
                JSON.parse(aggressiveComplete);
                console.log('âœ… Aggressive completion succeeded');
                return aggressiveComplete;
              } catch (aggressiveError) {
                console.log('âŒ Aggressive completion also failed');
              }
            }
          }
        }
        
        return jsonString;
        
      } catch (error) {
        console.error('âŒ JSON completion failed:', error);
        return jsonString;
      }
    }

    // Function to sanitize JSON strings by properly escaping control characters
    function sanitizeJsonString(jsonString) {
      try {
        console.log('ğŸ§¼ Sanitizing JSON string for control characters...');
        
        let sanitized = '';
        let inString = false;
        let escapeNext = false;
        let stringChar = null; // Track if we're in " or ' quotes
        let fixes = 0;
        
        for (let i = 0; i < jsonString.length; i++) {
          const char = jsonString[i];
          const charCode = char.charCodeAt(0);
          
          if (escapeNext) {
            // Previous character was escape, so this character is literal
            sanitized += char;
            escapeNext = false;
            continue;
          }
          
          if (char === '\\') {
            sanitized += char;
            escapeNext = true;
            continue;
          }
          
          if (!inString) {
            // We're outside a string
            if (char === '"' || char === "'") {
              inString = true;
              stringChar = char;
            }
            sanitized += char;
          } else {
            // We're inside a string
            if (char === stringChar) {
              // End of string
              inString = false;
              stringChar = null;
              sanitized += char;
            } else if (charCode >= 0x00 && charCode <= 0x1F && char !== '\t' && char !== '\n' && char !== '\r') {
              // Control character that needs unicode escaping
              sanitized += '\\u' + ('0000' + charCode.toString(16)).slice(-4);
              fixes++;
            } else if (char === '\n') {
              sanitized += '\\n';
              fixes++;
            } else if (char === '\r') {
              sanitized += '\\r';
              fixes++;
            } else if (char === '\t') {
              sanitized += '\\t';
              fixes++;
            } else if (char === '\b') {
              sanitized += '\\b';
              fixes++;
            } else if (char === '\f') {
              sanitized += '\\f';
              fixes++;
            } else {
              // Regular character
              sanitized += char;
            }
          }
        }
        
        if (fixes > 0) {
          console.log(`âœ… JSON sanitization completed - fixed ${fixes} control characters`);
        } else {
          console.log('â„¹ï¸ No control characters found to fix');
        }
        
        return sanitized;
        
      } catch (error) {
        console.error('âŒ JSON sanitization failed:', error);
        return jsonString; // Return original if sanitization fails
      }
    }

    // Submit query to webhook and handle response
    window.submitQuery = async function submitQuery(plate, query, wasVoiceInput = false, isReply = false) {
      // Generate unique trace ID for this request
      const traceId = 'nicole_' + Date.now() + '_' + Math.random().toString(36).substring(2, 8);
      
      // Get conversation context for continuous dialogue
      const conversationContext = getConversationContext();
      const hasContext = conversationContext.length > 0;
      
      const payload = { 
        plate: plate, 
        free_query: query, 
        source: 'assistant-ui',
        password: sessionStorage.getItem('password') || sessionStorage.getItem('auth'),
        trace_id: traceId,
        timestamp: new Date().toISOString(),
        user_agent: navigator.userAgent,
        page_url: window.location.href,
        // Conversation context
        is_reply: isReply,
        conversation_context: hasContext ? conversationContext : null,
        conversation_id: hasContext ? JSON.parse(sessionStorage.getItem('nicole_conversation') || '{}').conversation_id : null,
        voice_input: wasVoiceInput
      };

      // Enhanced logging for debugging
      console.group(`ğŸ” Nicole Query Debug [${traceId}]`);
      console.log('ğŸ“¤ Outgoing Payload:', JSON.stringify(payload, null, 2));
      console.log('ğŸ”— Webhook URL:', WEBHOOKS?.SEARCH_MODULE || 'URL_NOT_LOADED');
      console.log('ğŸ”‘ Auth Data:', {
        password_exists: !!sessionStorage.getItem('password'),
        auth_exists: !!sessionStorage.getItem('auth'),
        auth_type: sessionStorage.getItem('password') ? 'password' : 'auth'
      });
      console.log('ğŸŒ Environment Info:', {
        user_agent: navigator.userAgent,
        language: navigator.language,
        platform: navigator.platform,
        encoding: document.characterSet || document.charset,
        page_encoding: document.inputEncoding,
        url: window.location.href,
        timestamp: new Date().toISOString()
      });

      try {
        // Import webhook from webhook.js module
        const { WEBHOOKS } = await import('./webhook.js');
        const webhookUrl = WEBHOOKS.SEARCH_MODULE;
        
        console.log('ğŸŒ Sending request to:', webhookUrl);
        const startTime = performance.now();
        
        const response = await fetch(webhookUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        // Read as text first, then try to parse as JSON
        const rawResponse = await response.text();
        const endTime = performance.now();
        const requestDuration = Math.round(endTime - startTime);
        
        // Store debug information for analysis
        const debugEntry = {
          trace_id: traceId,
          timestamp: new Date().toISOString(),
          request_duration_ms: requestDuration,
          response_status: response.status,
          response_headers: Object.fromEntries(response.headers.entries()),
          response_size: rawResponse.length,
          query: query,
          plate: plate || 'NONE'
        };
        
        // Enhanced logging for debugging JSON issues
        console.log('ğŸ“¥ Raw Response Details:', {
          length: rawResponse.length,
          first_200_chars: rawResponse.substring(0, 200),
          last_100_chars: rawResponse.substring(Math.max(0, rawResponse.length - 100)),
          char_codes: rawResponse.substring(0, 30).split('').map(c => c.charCodeAt(0)),
          is_empty: rawResponse.trim() === '',
          starts_with_brace: rawResponse.trim().startsWith('{'),
          ends_with_brace: rawResponse.trim().endsWith('}'),
          brace_count: (rawResponse.match(/\{/g) || []).length,
          closing_brace_count: (rawResponse.match(/\}/g) || []).length,
          has_text_field: rawResponse.includes('"text"'),
          has_audioContent_field: rawResponse.includes('"audioContent"')
        });
        
        // Log the exact raw response for manual inspection
        console.log('ğŸ” FULL RAW RESPONSE:', rawResponse);
        
        try {
          // Clean the response text to handle potential encoding issues
          let cleanResponse = rawResponse.trim();
          
          // Remove potential BOM (Byte Order Mark) if present
          if (cleanResponse.charCodeAt(0) === 0xFEFF) {
            cleanResponse = cleanResponse.substring(1);
            console.log('ğŸ§¹ Removed BOM from response');
          }
          
          // Fix control characters in JSON strings that cause parsing errors
          cleanResponse = sanitizeJsonString(cleanResponse);
          
          // Check for truncated JSON and attempt to complete it
          cleanResponse = completeIncompleteJson(cleanResponse);
          
          // Check if JSON is complete and fix common issues
          if (!cleanResponse.endsWith('}') && cleanResponse.includes('{')) {
            console.log('âš ï¸ JSON appears incomplete, attempting to fix...');
            
            // Count braces to see if we need to close
            const openBraces = (cleanResponse.match(/\{/g) || []).length;
            const closeBraces = (cleanResponse.match(/\}/g) || []).length;
            
            if (openBraces > closeBraces) {
              // Add missing closing braces
              const missingBraces = openBraces - closeBraces;
              cleanResponse += '}'.repeat(missingBraces);
              console.log(`ğŸ”§ Added ${missingBraces} missing closing brace(s)`);
            }
            
            // Fix trailing commas that might cause issues
            cleanResponse = cleanResponse.replace(/,(\s*[}\]])/g, '$1');
          }
          
          // Try to parse as JSON (new format with audio)
          const responseData = JSON.parse(cleanResponse);
          
          console.log('âœ… JSON Parse Success:', {
            response_type: typeof responseData,
            has_text: !!responseData.text,
            has_audio: !!responseData.audio,
            has_message: !!responseData.message,
            has_response: !!responseData.response,
            all_keys: Object.keys(responseData)
          });
          
          // Determine the text content from various possible fields
          let textContent = responseData.text || 
                           responseData.message || 
                           responseData.response || 
                           responseData.content ||
                           responseData.answer ||
                           responseData.reply ||
                           JSON.stringify(responseData, null, 2);
          
          // Handle audio content if present
          let audioContent = responseData.audio || 
                            responseData.audioContent || 
                            responseData.audio_content ||
                            null;
          
          if (!textContent || textContent.trim() === '') {
            console.warn('âš ï¸ No readable text content found in response');
            textContent = '×ª×’×•×‘×” ×”×ª×§×‘×œ×” ××š ×œ×œ× ×ª×•×›×Ÿ ×˜×§×¡×˜';
          }
          
          // Show debug info only in development
          const isDebugMode = window.location.hostname === 'localhost' || window.location.search.includes('debug=true');
          let debugInfo = '';
          
          if (isDebugMode) {
            debugInfo = `
              <div style="background: #f0f0f0; padding: 10px; margin: 10px 0; font-size: 12px; border-radius: 5px;">
                <strong>ğŸ” DEBUG INFO:</strong><br>
                <strong>Response Keys:</strong> ${Object.keys(responseData).join(', ')}<br>
                <strong>Text Source:</strong> ${responseData.text ? 'text' : responseData.message ? 'message' : responseData.response ? 'response' : 'fallback'}<br>
                <strong>Audio Field:</strong> ${responseData.audio ? 'Present' : 'Missing'}
              </div>
            `;
          }
          
          displayResponse(debugInfo + textContent, audioContent);
          
          // Store success in debug entry
          debugEntry.parsing_success = true;
          debugEntry.response_structure = Object.keys(responseData);
          debugEntry.text_source = responseData.text ? 'text' : responseData.message ? 'message' : responseData.response ? 'response' : responseData.answer ? 'answer' : 'fallback';
          debugEntry.has_hebrew = /[\u0590-\u05FF]/.test(textContent);
          debugEntry.final_text_length = textContent.length;
          debugEntry.has_audio = !!audioContent;
          debugEntry.audio_source = responseData.audioContent ? 'audioContent' : responseData.audio ? 'audio' : null;
          
        } catch (jsonError) {
          console.error('âŒ JSON Parse Error Details:', {
            error_name: jsonError.name,
            error_message: jsonError.message,
            raw_response_preview: rawResponse.substring(0, 300),
            response_length: rawResponse.length,
            first_char_code: rawResponse.charCodeAt(0),
            last_char_code: rawResponse.charCodeAt(rawResponse.length - 1)
          });
          
          // Try to extract meaningful content even if JSON parsing fails
          let fallbackContent = rawResponse;
          let extractedSuccessfully = false;
          
          // Multiple extraction strategies
          if (rawResponse.includes('{') && rawResponse.includes('}')) {
            
            // Strategy 1: Extract the largest valid JSON block
            const firstBrace = rawResponse.indexOf('{');
            const lastBrace = rawResponse.lastIndexOf('}');
            if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
              let possibleJson = rawResponse.substring(firstBrace, lastBrace + 1);
              possibleJson = completeIncompleteJson(possibleJson); // Complete truncated JSON
              possibleJson = sanitizeJsonString(possibleJson); // Sanitize before parsing
              try {
                const extractedData = JSON.parse(possibleJson);
                const extractedText = extractedData.text || extractedData.message || extractedData.response || extractedData.answer;
                const extractedAudio = extractedData.audio || extractedData.audioContent;
                if (extractedText) {
                  console.log('âœ… Successfully extracted content using Strategy 1');
                  displayResponse(extractedText, extractedAudio);
                  
                  // Update debug entry for successful extraction
                  debugEntry.parsing_success = true;
                  debugEntry.extraction_method = 'strategy_1_basic';
                  debugEntry.has_hebrew = /[\u0590-\u05FF]/.test(extractedText);
                  extractedSuccessfully = true;
                }
              } catch (secondError) {
                console.log('ğŸ”„ Strategy 1 failed, trying Strategy 2...');
              }
            }
            
            // Strategy 2: Try to fix common JSON issues and re-parse
            if (!extractedSuccessfully) {
              try {
                let fixedJson = rawResponse.substring(firstBrace, lastBrace + 1);
                
                // Complete truncated JSON first
                fixedJson = completeIncompleteJson(fixedJson);
                // Sanitize control characters
                fixedJson = sanitizeJsonString(fixedJson);
                
                // Fix common issues
                fixedJson = fixedJson.replace(/,(\s*[}\]])/g, '$1'); // Remove trailing commas
                fixedJson = fixedJson.replace(/([{,]\s*)(\w+):/g, '$1"$2":'); // Add quotes to keys
                fixedJson = fixedJson.replace(/:\s*([^",{\[\]}\s][^",}\]]*[^",}\]\s])\s*([,}])/g, ': "$1"$2'); // Quote unquoted values
                
                const extractedData = JSON.parse(fixedJson);
                const extractedText = extractedData.text || extractedData.message || extractedData.response || extractedData.answer;
                const extractedAudio = extractedData.audio || extractedData.audioContent;
                if (extractedText) {
                  console.log('âœ… Successfully extracted content using Strategy 2');
                  displayResponse(extractedText, extractedAudio);
                  
                  debugEntry.parsing_success = true;
                  debugEntry.extraction_method = 'strategy_2_fixed';
                  debugEntry.has_hebrew = /[\u0590-\u05FF]/.test(extractedText);
                  extractedSuccessfully = true;
                }
              } catch (thirdError) {
                console.log('ğŸ”„ Strategy 2 also failed, trying Strategy 3...');
              }
            }
            
            // Strategy 3: Use regex to extract text field value
            if (!extractedSuccessfully) {
              const textMatch = rawResponse.match(/"text"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/);
              if (textMatch) {
                const extractedText = textMatch[1].replace(/\\"/g, '"').replace(/\\n/g, '\n');
                console.log('âœ… Successfully extracted text using Strategy 3 (regex)');
                displayResponse(extractedText, null);
                
                debugEntry.parsing_success = true;
                debugEntry.extraction_method = 'strategy_3_regex';
                debugEntry.has_hebrew = /[\u0590-\u05FF]/.test(extractedText);
                extractedSuccessfully = true;
              }
            }
          }
          
          // Final fallback if no extraction strategy worked
          if (!extractedSuccessfully) {
            if (fallbackContent.length > 0) {
              displayResponse(`×©×’×™××” ×‘×¤×¢× ×•×— ×”×ª×’×•×‘×”, ××š ×”×ª×•×›×Ÿ ×”×ª×§×‘×œ:\n\n${fallbackContent}`);
            } else {
              displayResponse('×©×’×™××” ×‘×§×‘×œ×ª ×ª×’×•×‘×” ××”×©×¨×ª. ×× × × ×¡×” ×©×•×‘.');
            }
            
            // Store failure in debug entry
            debugEntry.parsing_success = false;
            debugEntry.error_type = 'json_parse_failed';
            debugEntry.error_message = jsonError.message;
            debugEntry.extraction_method = 'none';
            debugEntry.has_hebrew = /[\u0590-\u05FF]/.test(fallbackContent);
            debugEntry.fallback_used = fallbackContent.length > 0;
          }
        }
        
        // Store debug entry in session for analysis
        const debugHistory = JSON.parse(sessionStorage.getItem('nicole_debug_history') || '[]');
        debugHistory.push(debugEntry);
        // Keep only last 50 entries
        if (debugHistory.length > 50) debugHistory.shift();
        sessionStorage.setItem('nicole_debug_history', JSON.stringify(debugHistory));
        
        console.log(`âœ… Request completed [${traceId}]:`, {
          duration: requestDuration + 'ms',
          success: debugEntry.parsing_success,
          has_hebrew: debugEntry.has_hebrew
        });
        console.groupEnd();

      } catch (err) {
        console.error('âŒ Request failed:', err);
        console.groupEnd();
        displayResponse('×©×’×™××” ×‘×©×œ×™×—×ª ×”×‘×§×©×”. × ×¡×” ×©×•×‘.');
      }
    }

    // Display response in floating box with manual TTS controls
    function displayResponse(text, audio = null) {
      const responseBox = document.getElementById('agentResponse');
      responseBox.style.display = 'block';
      
      // Clean and format the text content for display
      let displayText = text;
      let textForTTS = text;
      
      // Handle different content types
      if (typeof text === 'object') {
        console.log('ğŸ“ Received object response, converting to readable format');
        displayText = JSON.stringify(text, null, 2);
        textForTTS = Object.values(text).join(' ');
      } else if (typeof text === 'string') {
        // Clean the text for better display
        displayText = text.trim();
        textForTTS = text.replace(/[\n\r]+/g, ' ').trim();
        
        // If text looks like JSON that wasn't parsed, try to format it
        if (displayText.startsWith('{') && displayText.endsWith('}')) {
          try {
            const parsed = JSON.parse(displayText);
            const readable = parsed.text || parsed.message || parsed.response || JSON.stringify(parsed, null, 2);
            displayText = readable;
            textForTTS = readable.replace(/[\n\r]+/g, ' ').trim();
            console.log('ğŸ”„ Reformatted JSON string for better display');
          } catch (e) {
            console.log('ğŸ“ Text looks like JSON but failed to parse, displaying as-is');
          }
        }
        
        // Convert markdown-like formatting to HTML for better display
        displayText = displayText
          .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
          .replace(/\*(.*?)\*/g, '<em>$1</em>')
          .replace(/\n/g, '<br>');
      }
      
      responseBox.innerHTML = `
        <div style="margin-bottom: 10px; font-weight: bold; color: #667eea;">
          ğŸ‘©â€ğŸ’¼ ×ª×©×•×‘×ª × ×™×§×•×œ:
        </div>
        <div style="line-height: 1.5; margin-bottom: 10px; white-space: pre-wrap;">
          ${displayText}
        </div>
        
        <!-- Response Controls -->
        <div style="display: flex; gap: 8px; margin-bottom: 8px; align-items: center; flex-wrap: wrap;">
          <button onclick="showReplyBox()" style="
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
          ">
            ğŸ’¬ ×”×©×‘ ×¢×œ ×”×ª×©×•×‘×”
          </button>
          
          <button onclick="replayReceivedAudio()" style="
            background: #22c55e;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
          ">
            ğŸ”Š ×”×©××¢ ×ª×©×•×‘×”
          </button>
          
          <button onclick="stopCurrentSpeaking()" style="
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
          ">
            â¹ï¸ ×¢×¦×•×¨ ×”×§×¨××”
          </button>
          
          <div id="ttsStatus" style="font-size: 11px; color: #666;"></div>
        </div>
        
        <!-- Reply Box (initially hidden) -->
        <div id="replyBox" style="display: none; margin-top: 12px; padding: 12px; background: rgba(102, 126, 234, 0.05); border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.2);">
          <div style="margin-bottom: 8px; font-weight: 600; color: #667eea; font-size: 13px;">
            ğŸ’¬ ×”××©×š ×”×©×™×—×”:
          </div>
          <div style="position: relative; margin-bottom: 8px;">
            <textarea id="replyInput" placeholder="×›×ª×•×‘ ××ª ×”×©××œ×” ××• ×”×ª×’×•×‘×” ×©×œ×š..." style="
              width: 100%;
              min-height: 60px;
              padding: 8px 35px 8px 12px;
              border: 1px solid #e2e8f0;
              border-radius: 6px;
              font-size: 13px;
              font-family: inherit;
              resize: vertical;
              box-sizing: border-box;
            "></textarea>
            <button type="button" id="replyMicBtn" onclick="startReplyRecording()" style="
              position: absolute;
              left: 8px;
              top: 50%;
              transform: translateY(-50%);
              width: 24px;
              height: 24px;
              border-radius: 50%;
              border: none;
              background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
              color: white;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 12px;
              transition: all 0.3s ease;
            " title="×œ×—×¥ ×›×“×™ ×œ×”×§×œ×™×˜ ×ª×’×•×‘×”">
              ğŸ¤
            </button>
          </div>
          <div style="display: flex; gap: 6px; margin-top: 8px; justify-content: flex-end;">
            <button onclick="cancelReply()" style="
              background: #f3f4f6;
              color: #6b7280;
              border: none;
              border-radius: 4px;
              padding: 4px 8px;
              cursor: pointer;
              font-size: 11px;
            ">
              ×‘×™×˜×•×œ
            </button>
            <button onclick="sendReply()" style="
              background: #667eea;
              color: white;
              border: none;
              border-radius: 4px;
              padding: 4px 12px;
              cursor: pointer;
              font-size: 11px;
              font-weight: 600;
            ">
              ×©×œ×— ×ª×’×•×‘×”
            </button>
          </div>
        </div>
        
        <button onclick="this.parentElement.style.display='none'" style="
          position: absolute; 
          top: 8px; 
          left: 8px; 
          background: #f0f0f0; 
          border: none; 
          border-radius: 50%; 
          width: 24px; 
          height: 24px; 
          cursor: pointer;
          font-size: 12px;
        ">âœ•</button>
      `;


      // Handle audio playback
      if (audio) {
        let audioElement;
        
        // Handle different audio formats
        if (typeof audio === 'string') {
          if (audio.startsWith('data:audio') || audio.startsWith('http')) {
            audioElement = new Audio(audio);
          } else {
            // Assume it's base64 audio content
            audioElement = new Audio('data:audio/mp3;base64,' + audio);
          }
        } else if (audio instanceof Blob) {
          const audioUrl = URL.createObjectURL(audio);
          audioElement = new Audio(audioUrl);
        }
        
        if (audioElement) {
          // Store the audio element globally for replay
          window.currentReceivedAudio = audioElement;
          
          try {
            audioElement.play();
            console.log('ğŸ”Š Auto-playing audio response');
          } catch (e) {
            console.warn("ğŸ”‡ Autoplay blocked. User must click play.");
            window.pendingTTSAudio = audioElement;
          }
        }
      }
      
      // Log response handling success
      console.log('âœ… Response displayed successfully:', {
        text_length: displayText.length,
        has_audio: !!audio,
        text_type: typeof text
      });
      
      // Store this response in conversation context
      storeConversationContext(displayText, 'assistant');
    }
    
    
    


    // Enhanced Text-to-Speech functionality using Google Cloud TTS (original for auto-play)
    async function speakResponse(text) {
      if (!text) {
        console.log('ğŸ”Š No text provided for TTS');
        return;
      }
      
      // Clean text for TTS - remove markdown, special characters, etc.
      let cleanText = text
        .replace(/\*\*/g, '') // Remove ** markdown
        .replace(/\*/g, '') // Remove * markdown
        .replace(/_{2,}/g, '') // Remove __ markdown
        .replace(/`{1,3}/g, '') // Remove code blocks
        .replace(/#{1,6}\s*/g, '') // Remove headings
        .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // Replace links with text
        .replace(/\s+/g, ' ') // Normalize spaces
        .trim();
      
      // Limit text length for TTS (Google TTS has limits)
      const maxLength = 5000;
      const textForTTS = cleanText.length > maxLength ? cleanText.substring(0, maxLength) + '...' : cleanText;
      
      const apiKey = 'AIzaSyCYMIbBVJsGfOv1pbELD41-Lxe7OwsHd1o';
      const voice = 'he-IL-Wavenet-A'; // Female Hebrew voice
      
      console.log('ğŸ”Š Starting TTS for text length:', textForTTS.length);

      try {
        console.log('ğŸ”— Calling Google TTS API...');
        const response = await fetch(`https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            input: { text: textForTTS },
            voice: { 
              languageCode: 'he-IL', 
              name: voice,
              ssmlGender: 'FEMALE'
            },
            audioConfig: { 
              audioEncoding: 'MP3',
              speakingRate: 1.0,
              pitch: 0.0,
              volumeGainDb: 0.0
            }
          })
        });

        console.log('ğŸ“¡ TTS API Response:', {
          status: response.status,
          statusText: response.statusText,
          headers: Object.fromEntries(response.headers.entries())
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error('âŒ TTS API Error Details:', errorText);
          
          // Try to parse error for more specific info
          try {
            const errorData = JSON.parse(errorText);
            console.error('âŒ Parsed API Error:', errorData);
            throw new Error(`TTS API error: ${response.status} - ${errorData.error?.message || errorText}`);
          } catch {
            throw new Error(`TTS API error: ${response.status} ${response.statusText} - ${errorText}`);
          }
        }

        const data = await response.json();
        
        if (data.audioContent) {
          const audio = new Audio('data:audio/mp3;base64,' + data.audioContent);
          
          // Store reference for potential stopping (but don't show stop button for auto-play)
          window.currentTTSAudio = audio;
          
          // Add audio event listeners for better feedback
          audio.addEventListener('loadstart', () => {
            console.log('ğŸ”Š TTS audio loading...');
          });
          
          audio.addEventListener('canplay', () => {
            console.log('ğŸ”Š TTS audio ready to play');
          });
          
          audio.addEventListener('play', () => {
            console.log('ğŸ”Š Nicole is speaking...');
            // Add visual indicator that Nicole is speaking
            updateNicoleSpeakingStatus(true);
            window.isTTSPlaying = true;
          });
          
          audio.addEventListener('ended', () => {
            console.log('ğŸ”Š Nicole finished speaking');
            updateNicoleSpeakingStatus(false);
            window.currentTTSAudio = null;
            window.isTTSPlaying = false;
            resetTTSButtons();
          });
          
          audio.addEventListener('error', (e) => {
            console.error('ğŸ”Š Audio playback error:', e);
            updateNicoleSpeakingStatus(false);
            window.currentTTSAudio = null;
            window.isTTSPlaying = false;
            resetTTSButtons();
          });
          
          // Handle browser autoplay restrictions
          try {
            // Try to play immediately
            await audio.play();
            console.log('âœ… TTS played successfully (auto)');
            
          } catch (autoplayError) {
            console.warn('ğŸ”‡ Browser blocked autoplay:', autoplayError.name);
            
            if (autoplayError.name === 'NotAllowedError') {
              // Browser blocked autoplay - show user notification
              console.log('ğŸ’¡ TTS requires user interaction due to browser autoplay policy');
              
              // Store audio for manual playback and reset UI
              window.pendingTTSAudio = audio;
              window.currentTTSAudio = null;
              resetTTSButtons();
              
              // Show visual notification that speech is ready but needs user click
              const responseBox = document.getElementById('agentResponse');
              if (responseBox) {
                const autoplayNotice = document.createElement('div');
                autoplayNotice.innerHTML = `
                  <div style="
                    background: rgba(249, 168, 37, 0.1);
                    border: 1px solid #f9a825;
                    color: #f57c00;
                    padding: 8px 12px;
                    border-radius: 8px;
                    margin-top: 8px;
                    font-size: 12px;
                    text-align: center;
                  ">
                    ğŸ”Š ×”×ª×©×•×‘×” ××•×›× ×” ×œ×”×©××¢×” - ×œ×—×¥ ×¢×œ ×›×¤×ª×•×¨ "×”×©××¢ ×ª×©×•×‘×”"
                  </div>
                `;
                responseBox.appendChild(autoplayNotice);
                
                // Store audio for manual playback
                window.pendingTTSAudio = audio;
              }
            } else {
              // Other playback error
              throw autoplayError;
            }
          }
          
        } else {
          console.warn('ğŸ”Š No audio content received from TTS API');
        }
      } catch (error) {
        console.error('ğŸ”Š Google TTS Error:', error);
        
        // Don't use automatic fallback - let user choose manually
        console.log('ğŸ’¡ TTS failed. User can use manual TTS buttons if needed.');
        
        // Provide detailed error feedback for debugging
        if (error.message.includes('network') || error.message.includes('fetch')) {
          console.log('ğŸ”Š TTS failed due to network issue');
        } else if (error.message.includes('quota') || error.message.includes('limit')) {
          console.log('ğŸ”Š TTS failed due to API quota limits');
        } else if (error.message.includes('403') || error.message.includes('401')) {
          console.log('ğŸ”Š TTS failed due to API authentication/authorization');
        }
        
        // Throw error so manual TTS can handle it appropriately
        throw error;
      }
    }
    
    
    // Helper function to show Nicole speaking status
    function updateNicoleSpeakingStatus(isSpeaking) {
      const responseBox = document.getElementById('agentResponse');
      if (responseBox && responseBox.style.display !== 'none') {
        const statusDiv = responseBox.querySelector('.nicole-speaking-status');
        
        if (isSpeaking) {
          if (!statusDiv) {
            const speakingIndicator = document.createElement('div');
            speakingIndicator.className = 'nicole-speaking-status';
            speakingIndicator.innerHTML = 'ğŸ”Š × ×™×§×•×œ ××“×‘×¨×ª...';
            speakingIndicator.style.cssText = `
              position: absolute;
              bottom: 8px;
              right: 8px;
              background: rgba(102, 126, 234, 0.1);
              color: #667eea;
              padding: 4px 8px;
              border-radius: 12px;
              font-size: 12px;
              font-weight: 500;
              animation: pulse 1.5s infinite;
            `;
            responseBox.appendChild(speakingIndicator);
          }
        } else {
          if (statusDiv) {
            statusDiv.remove();
          }
        }
      }
    }

    // Save conversation to helper for later reference
    function saveToHelper(question, answer) {
      try {
        const stored = sessionStorage.getItem("helper") || sessionStorage.getItem("expertise");
        if (!stored) return;

        const helper = JSON.parse(stored);
        if (!helper.assistant_history) helper.assistant_history = [];

        helper.assistant_history.push({
          question,
          answer,
          timestamp: new Date().toISOString()
        });

        sessionStorage.setItem("helper", JSON.stringify(helper));
        sessionStorage.setItem("expertise", JSON.stringify(helper));
        console.log('ğŸ’¾ Conversation saved to helper');
      } catch (error) {
        console.error('ğŸ’¾ Save to helper failed:', error);
      }
    }
    
    // Auto-resize textarea
    textarea.addEventListener('input', function() {
      this.style.height = 'auto';
      this.style.height = Math.min(this.scrollHeight, 200) + 'px';
    });
    
    // Enhanced focus states
    textarea.addEventListener('focus', function() {
      this.parentElement.style.transform = 'scale(1.02)';
    });
    
    textarea.addEventListener('blur', function() {
      this.parentElement.style.transform = 'scale(1)';
    });
    
    // Add global debug function for easy console access
    window.nicoleDebug = {
      getHistory: () => {
        const history = JSON.parse(sessionStorage.getItem('nicole_debug_history') || '[]');
        console.table(history);
        return history;
      },
      clearHistory: () => {
        sessionStorage.removeItem('nicole_debug_history');
        console.log('ğŸ§¹ Nicole debug history cleared');
      },
      getLastRequest: () => {
        const history = JSON.parse(sessionStorage.getItem('nicole_debug_history') || '[]');
        return history[history.length - 1] || null;
      },
      exportHistory: () => {
        const history = JSON.parse(sessionStorage.getItem('nicole_debug_history') || '[]');
        const blob = new Blob([JSON.stringify(history, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `nicole_debug_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        console.log('ğŸ’¾ Debug history exported');
      },
      getMicErrors: () => {
        const errors = JSON.parse(sessionStorage.getItem('nicole_mic_errors') || '[]');
        console.table(errors);
        return errors;
      },
      clearMicErrors: () => {
        sessionStorage.removeItem('nicole_mic_errors');
        console.log('ğŸ§¹ Microphone error history cleared');
      },
      getErrorPatterns: () => {
        const errors = JSON.parse(sessionStorage.getItem('nicole_mic_errors') || '[]');
        const patterns = {};
        errors.forEach(error => {
          patterns[error.error_type] = (patterns[error.error_type] || 0) + 1;
        });
        console.log('ğŸ“Š Error Patterns:', patterns);
        return patterns;
      },
      testMicrophone: async () => {
        console.log('ğŸ¤ Testing microphone permissions...');
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          console.log('âœ… Microphone access granted');
          stream.getTracks().forEach(track => track.stop());
          return { success: true, message: 'Microphone working' };
        } catch (error) {
          console.error('âŒ Microphone test failed:', error);
          return { success: false, error: error.message };
        }
      },
      // New debugging tools for JSON and encoding issues
      analyzeText: (text) => {
        console.group('ğŸ” Text Analysis');
        console.log('ğŸ“ Text Info:', {
          length: text.length,
          type: typeof text,
          first_10_chars: text.substring(0, 10),
          last_10_chars: text.substring(text.length - 10),
          char_codes: text.substring(0, 20).split('').map(c => ({ char: c, code: c.charCodeAt(0) })),
          has_bom: text.charCodeAt(0) === 0xFEFF,
          has_hebrew: /[\u0590-\u05FF]/.test(text),
          has_arabic: /[\u0600-\u06FF]/.test(text),
          line_breaks: text.match(/\r?\n/g)?.length || 0,
          is_json_like: text.trim().startsWith('{') && text.trim().endsWith('}')
        });
        
        if (text.trim().startsWith('{')) {
          try {
            const parsed = JSON.parse(text);
            console.log('âœ… Valid JSON:', parsed);
          } catch (e) {
            console.error('âŒ JSON Parse Error:', e.message);
            console.log('ğŸ”§ JSON Syntax Check:', {
              balanced_braces: (text.match(/\{/g)?.length || 0) === (text.match(/\}/g)?.length || 0),
              balanced_brackets: (text.match(/\[/g)?.length || 0) === (text.match(/\]/g)?.length || 0),
              has_quotes: /["']/.test(text),
              has_commas: /,/.test(text)
            });
          }
        }
        console.groupEnd();
        return text;
      },
      testEncoding: () => {
        const testStrings = [
          '×©×œ×•× ×¢×•×œ×', // Hebrew
          'Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…', // Arabic
          'Hello World', // English
          '{"text": "×‘×“×™×§×”"}' // JSON with Hebrew
        ];
        
        console.group('ğŸŒ Character Encoding Test');
        testStrings.forEach((str, index) => {
          console.log(`Test ${index + 1}:`, {
            original: str,
            encoded: encodeURIComponent(str),
            base64: btoa(unescape(encodeURIComponent(str))),
            char_codes: str.split('').map(c => c.charCodeAt(0)),
            json_stringify: JSON.stringify(str),
            roundtrip_test: decodeURIComponent(encodeURIComponent(str)) === str
          });
        });
        console.groupEnd();
      },
      simulateResponse: (responseText) => {
        console.group('ğŸ§ª Simulate Response Processing');
        console.log('Input:', responseText);
        
        try {
          // Simulate the same processing as the real code
          let cleanResponse = responseText.trim();
          
          if (cleanResponse.charCodeAt(0) === 0xFEFF) {
            cleanResponse = cleanResponse.substring(1);
            console.log('ğŸ§¹ Removed BOM');
          }
          
          const responseData = JSON.parse(cleanResponse);
          const textContent = responseData.text || responseData.message || responseData.response || responseData.content;
          
          console.log('âœ… Simulation Success:', {
            parsed_data: responseData,
            extracted_text: textContent,
            would_display: textContent || 'fallback content'
          });
          
        } catch (error) {
          console.error('âŒ Simulation Failed:', error.message);
          console.log('ğŸ”„ Would attempt extraction fallback...');
          
          if (responseText.includes('{') && responseText.includes('}')) {
            const firstBrace = responseText.indexOf('{');
            const lastBrace = responseText.lastIndexOf('}');
            if (firstBrace !== -1 && lastBrace !== -1) {
              const extracted = responseText.substring(firstBrace, lastBrace + 1);
              console.log('ğŸ”§ Extracted JSON:', extracted);
              try {
                const extractedData = JSON.parse(extracted);
                console.log('âœ… Extraction Success:', extractedData);
              } catch (e2) {
                console.error('âŒ Extraction also failed:', e2.message);
              }
            }
          }
        }
        console.groupEnd();
      },
      // Conversation context debugging
      getConversation: () => {
        const context = JSON.parse(sessionStorage.getItem('nicole_conversation') || '{}');
        console.group('ğŸ’¬ Conversation Context');
        console.log('Conversation ID:', context.conversation_id);
        console.log('Started:', context.started_at);
        console.log('Messages:', context.messages?.length || 0);
        console.log('Current Plate:', context.current_plate);
        if (context.messages && context.messages.length > 0) {
          console.table(context.messages.map(msg => ({
            role: msg.role,
            content: msg.content.substring(0, 50) + (msg.content.length > 50 ? '...' : ''),
            timestamp: msg.timestamp
          })));
        }
        console.groupEnd();
        return context;
      },
      clearConversation: () => {
        sessionStorage.removeItem('nicole_conversation');
        console.log('ğŸ§¹ Conversation context cleared');
        initializeConversationContext();
      },
      // Test JSON sanitization with problematic strings
      testJsonSanitization: (testJson) => {
        console.group('ğŸ§ª JSON Sanitization Test');
        console.log('Original JSON:', testJson);
        
        try {
          JSON.parse(testJson);
          console.log('âœ… Original JSON is valid');
        } catch (e) {
          console.log('âŒ Original JSON error:', e.message);
          
          const sanitized = sanitizeJsonString(testJson);
          console.log('Sanitized JSON:', sanitized);
          
          try {
            const parsed = JSON.parse(sanitized);
            console.log('âœ… Sanitized JSON is valid:', parsed);
          } catch (e2) {
            console.log('âŒ Sanitized JSON still invalid:', e2.message);
          }
        }
        console.groupEnd();
      },
      // Generate test cases for Hebrew text with control characters
      generateTestCases: () => {
        const testCases = [
          '{"text": "×©×œ×•×\n×¢×•×œ×"}',  // Newline
          '{"text": "×‘×“×™×§×”\t××¢×¨×›×ª"}', // Tab  
          '{"text": "×˜×§×¡×˜\r×¢×‘×¨×™"}',   // Carriage return
          '{"text": "×”×•×“×¢×” ×¢×\n××¡×¤×¨\n×©×•×¨×•×ª"}', // Multiple newlines
          '{"message": "×ª×’×•×‘×”\n×¢×\t×ª×•×•×™\r×‘×§×¨×”"}',  // Mixed control chars
          // Test case based on actual failing JSON
          '{\n  "text": "×©×œ×•×! ×× ×™ ××‘×™× ×” ×©×–×• ×‘×“×™×§×ª ××¢×¨×›×ª, ×•×× ×™ ×›××Ÿ ×›×“×™ ×œ×”×’×™×‘ ×•×œ×•×•×“× ×©×”×›×œ ×¢×•×‘×“ ×›×¨××•×™. ×× ×™ ×©××—×” ×œ×¢×–×•×¨ ×‘×›×œ ×“×¨×š ×©×ª×¦×˜×¨×š.\n\n×× ×™ ×××©×¨×ª ×©×× ×™ ×¤×¢×™×œ×” ×•××•×›× ×” ×œ×¡×™×™×¢ ×‘×›×œ ×©××œ×” ××• ×‘×§×©×”. ×× ×™×© ××©×”×• ×¡×¤×¦×™×¤×™ ×©××ª×” ×¨×•×¦×” ×©××‘×“×•×§ ××• ××‘×—×Ÿ ×‘××¡×’×¨×ª ×”×‘×“×™×§×” ×”×–×•, ×× × ×¦×™×™×Ÿ, ×•×× ×™ ××¢×©×” ××ª ×”××™×˜×‘."\n}'
        ];
        
        console.group('ğŸ§ª Generated Test Cases');
        testCases.forEach((testCase, index) => {
          console.log(`Test ${index + 1}:`, testCase);
          nicoleDebug.testJsonSanitization(testCase);
        });
        console.groupEnd();
      },
      // Test the exact failing pattern from the error
      testActualError: () => {
        const failingJson = `{
  "text": "×©×œ×•×! ×× ×™ ××‘×™× ×” ×©×–×• ×‘×“×™×§×ª ××¢×¨×›×ª, ×•×× ×™ ×›××Ÿ ×›×“×™ ×œ×”×’×™×‘ ×•×œ×•×•×“× ×©×”×›×œ ×¢×•×‘×“ ×›×¨××•×™. ×× ×™ ×©××—×” ×œ×¢×–×•×¨ ×‘×›×œ ×“×¨×š ×©×ª×¦×˜×¨×š.

×× ×™ ×××©×¨×ª ×©×× ×™ ×¤×¢×™×œ×” ×•××•×›× ×” ×œ×¡×™×™×¢ ×‘×›×œ ×©××œ×” ××• ×‘×§×©×”. ×× ×™×© ××©×”×• ×¡×¤×¦×™×¤×™ ×©××ª×” ×¨×•×¦×” ×©××‘×“×•×§ ××• ××‘×—×Ÿ ×‘××¡×’×¨×ª ×”×‘×“×™×§×” ×”×–×•, ×× × ×¦×™×™×Ÿ, ×•×× ×™ ××¢×©×” ××ª ×”××™×˜×‘.

××™×š ×× ×™ ×™×›×•×œ×” ×œ×¢×–×•×¨ ×œ×š ×”×œ××” ×¢× ×”×‘×“"
}`;
        
        console.group('ğŸš¨ Testing Actual Failing JSON');
        console.log('This is the pattern that was causing the error at position 121');
        nicoleDebug.testJsonSanitization(failingJson);
        console.groupEnd();
      },
      // Test truncated JSON completion
      testTruncatedJson: () => {
        const truncatedJsons = [
          '{"text": "×©×œ×•× ××¢', // Cut off mid-string
          '{"text": "×”×•×“×¢×” ××œ××”", "audio"', // Cut off mid-key
          '{\n  "text": "×©×œ×•×! ×× ×™ ××‘×™× ×” ×©×–×• ×‘×“×™×§×ª ××¢×¨×›×ª, ×•×× ×™ ×›××Ÿ ×›×“×™ ×œ×”×’×™×‘ ×•×œ×•×•×“× ×©×”×›×œ ×¢×•×‘×“ ×›×¨××•×™. ×× ×™ ×©××—×” ×œ×¢×–×•×¨ ×‘×›×œ ×“×¨×š ×©×ª×¦×˜×¨×š.\n\n×× ×™ ×××©×¨×ª ×©×× ×™ ×¤×¢×™×œ×” ×•××•×›× ×” ×œ×¡×™×™×¢ ×‘×›×œ ×©××œ×” ××• ×‘×§×©×”. ×× ×™×© ××©×”×• ×¡×¤×¦×™×¤×™ ×©××ª×” ×¨×•×¦×” ×©××‘×“×•×§ ××• ××‘×—×Ÿ ×‘××¡×’×¨×ª ×”×‘×“×™×§×” ×”×–×•, ×× × ×¦×™×™×Ÿ, ×•×× ×™ ××¢×©×” ××ª ×”××™×˜×‘.\n\n××™×š ×× ×™ ×™×›×•×œ×” ×œ×¢×–×•×¨ ×œ×š ×”×œ××” ×¢× ×”×‘×“' // Real truncated case
        ];
        
        console.group('ğŸ“ Testing Truncated JSON Completion');
        truncatedJsons.forEach((truncated, index) => {
          console.log(`\nTruncated Test ${index + 1}:`);
          console.log('Original (truncated):', truncated);
          
          const completed = completeIncompleteJson(truncated);
          console.log('Completed:', completed);
          
          try {
            const parsed = JSON.parse(completed);
            console.log('âœ… Successfully parsed completed JSON:', parsed);
          } catch (e) {
            console.log('âŒ Completion failed:', e.message);
          }
        });
        console.groupEnd();
      }
    };
    
    console.log('ğŸ”§ Nicole Debug Tools Available:');
    console.log('  - nicoleDebug.getHistory() - View all request/response history');
    console.log('  - nicoleDebug.getLastRequest() - Get the most recent request');
    console.log('  - nicoleDebug.clearHistory() - Clear debug history');
    console.log('  - nicoleDebug.exportHistory() - Export history as JSON file');
    console.log('  - nicoleDebug.getMicErrors() - View microphone error history');
    console.log('  - nicoleDebug.getErrorPatterns() - Analyze error frequency');
    console.log('  - nicoleDebug.testMicrophone() - Test mic permissions');
    console.log('  - nicoleDebug.clearMicErrors() - Clear mic error history');
    console.log('  - nicoleDebug.analyzeText(text) - Analyze text and encoding');
    console.log('  - nicoleDebug.testEncoding() - Test character encoding support');
    console.log('  - nicoleDebug.simulateResponse(text) - Simulate response processing');
    console.log('  - nicoleDebug.getConversation() - View conversation context');
    console.log('  - nicoleDebug.clearConversation() - Clear conversation context');
    console.log('  - nicoleDebug.testJsonSanitization(json) - Test JSON sanitization');
    console.log('  - nicoleDebug.generateTestCases() - Generate Hebrew control character tests');
    console.log('  - nicoleDebug.testActualError() - Test the actual failing JSON pattern');
    console.log('  - nicoleDebug.testTruncatedJson() - Test truncated JSON completion');
    
    // Initialize conversation context
    initializeConversationContext();
  }
  
  // Conversation Context Management
  function initializeConversationContext() {
    if (!sessionStorage.getItem('nicole_conversation')) {
      const initialContext = {
        conversation_id: 'conv_' + Date.now() + '_' + Math.random().toString(36).substring(2, 8),
        started_at: new Date().toISOString(),
        messages: [],
        current_plate: sessionStorage.getItem('plate') || null
      };
      sessionStorage.setItem('nicole_conversation', JSON.stringify(initialContext));
      console.log('ğŸ”„ New conversation context initialized:', initialContext.conversation_id);
    }
  }
  
  function storeConversationContext(message, role = 'user') {
    try {
      const context = JSON.parse(sessionStorage.getItem('nicole_conversation') || '{}');
      if (!context.messages) context.messages = [];
      
      const messageEntry = {
        role: role, // 'user' or 'assistant'
        content: message,
        timestamp: new Date().toISOString(),
        message_id: 'msg_' + Date.now() + '_' + Math.random().toString(36).substring(2, 6)
      };
      
      context.messages.push(messageEntry);
      context.last_activity = new Date().toISOString();
      
      // Keep only last 20 messages for context (10 exchanges)
      if (context.messages.length > 20) {
        context.messages = context.messages.slice(-20);
      }
      
      sessionStorage.setItem('nicole_conversation', JSON.stringify(context));
      console.log(`ğŸ’¬ Stored ${role} message in conversation context`);
      
    } catch (error) {
      console.error('âŒ Failed to store conversation context:', error);
    }
  }
  
  function getConversationContext() {
    try {
      const context = JSON.parse(sessionStorage.getItem('nicole_conversation') || '{}');
      return context.messages || [];
    } catch (error) {
      console.error('âŒ Failed to get conversation context:', error);
      return [];
    }
  }
  
  // Replay Received Audio Function
  window.replayReceivedAudio = function() {
    // Check if we have the received audio from Make.com
    if (window.currentReceivedAudio) {
      try {
        // Reset audio to beginning and play
        window.currentReceivedAudio.currentTime = 0;
        window.currentReceivedAudio.play();
        console.log('ğŸ”Š Replaying received MP3 from Make.com');
      } catch (error) {
        console.error('ğŸ”Š Error replaying received audio:', error);
        alert('×©×’×™××” ×‘×”×©××¢×” ×—×•×–×¨×ª ×©×œ ×”×”×•×“×¢×”');
      }
    } else if (window.pendingTTSAudio) {
      // If we have pending audio from autoplay block, use that
      try {
        window.pendingTTSAudio.play();
        console.log('ğŸ”Š Playing pending audio from autoplay block');
      } catch (error) {
        console.error('ğŸ”Š Error playing pending audio:', error);
        alert('×©×’×™××” ×‘×”×©××¢×ª ×”×”×•×“×¢×”');
      }
    } else {
      console.log('ğŸ”Š No received audio available to replay');
      alert('××™×Ÿ ×”×•×“×¢×” ×§×•×œ×™×ª ×–××™× ×” ×œ×”×©××¢×” ×—×•×–×¨×ª');
    }
  };

  // Stop Speaking Function
  window.stopCurrentSpeaking = function() {
    // Stop current TTS audio if playing
    if (window.currentTTSAudio) {
      window.currentTTSAudio.pause();
      window.currentTTSAudio.currentTime = 0;
      window.currentTTSAudio = null;
      console.log('ğŸ”Š Stopped current TTS audio');
    }
    
    // Stop received audio from Make.com if playing
    if (window.currentReceivedAudio) {
      window.currentReceivedAudio.pause();
      window.currentReceivedAudio.currentTime = 0;
      console.log('ğŸ”Š Stopped received MP3 audio');
    }
    
    // Clear any pending TTS audio
    if (window.pendingTTSAudio) {
      window.pendingTTSAudio.pause();
      window.pendingTTSAudio.currentTime = 0;
      console.log('ğŸ”Š Stopped pending TTS audio');
    }
    
    // Update speaking status
    updateNicoleSpeakingStatus(false);
    window.isTTSPlaying = false;
    
    console.log('â¹ï¸ Speaking stopped by user');
  };

  // Reply Recording Function
  window.startReplyRecording = function() {
    const replyInput = document.getElementById('replyInput');
    const replyMicBtn = document.getElementById('replyMicBtn');
    
    if (!replyInput || !replyMicBtn) return;
    
    // Check if speech recognition is available
    if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
      alert('×–×™×”×•×™ ×§×•×œ ×œ× × ×ª××š ×‘×“×¤×“×¤×Ÿ ×–×”');
      return;
    }
    
    const SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;
    const recognition = new SpeechRecognition();
    recognition.lang = 'he-IL';
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;
    recognition.continuous = false;
    
    // Update button to recording state
    replyMicBtn.innerHTML = 'â¹ï¸';
    replyMicBtn.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%)';
    replyMicBtn.title = '×œ×—×¥ ×›×“×™ ×œ×”×¤×¡×™×§ ×”×§×œ×˜×”';
    replyInput.style.borderColor = '#ff6b6b';
    replyInput.placeholder = 'ğŸ¤ ××§×œ×™×˜ ×ª×’×•×‘×”... ×“×‘×¨ ×¢×›×©×™×•';
    
    recognition.addEventListener('result', (event) => {
      const transcript = event.results[0][0].transcript;
      replyInput.value = transcript;
      resetReplyMicrophone();
      console.log('ğŸ¤ Reply speech recognized:', transcript);
    });
    
    recognition.addEventListener('error', (event) => {
      console.error('ğŸ¤ Reply speech recognition error:', event.error);
      resetReplyMicrophone();
      alert('×©×’×™××” ×‘×–×™×”×•×™ ×§×•×œ: ' + event.error);
    });
    
    recognition.addEventListener('end', () => {
      resetReplyMicrophone();
    });
    
    // Start recognition
    try {
      recognition.start();
    } catch (error) {
      console.error('ğŸ¤ Failed to start reply recognition:', error);
      resetReplyMicrophone();
      alert('×©×’×™××” ×‘×”×¤×¢×œ×ª ×–×™×”×•×™ ×§×•×œ');
    }
    
    // Function to reset microphone button
    function resetReplyMicrophone() {
      replyMicBtn.innerHTML = 'ğŸ¤';
      replyMicBtn.style.background = 'linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%)';
      replyMicBtn.title = '×œ×—×¥ ×›×“×™ ×œ×”×§×œ×™×˜ ×ª×’×•×‘×”';
      replyInput.style.borderColor = '#e2e8f0';
      replyInput.placeholder = '×›×ª×•×‘ ××ª ×”×©××œ×” ××• ×”×ª×’×•×‘×” ×©×œ×š...';
    }
  };

  // Reply Functions
  window.showReplyBox = function() {
    const replyBox = document.getElementById('replyBox');
    const replyInput = document.getElementById('replyInput');
    
    if (replyBox && replyInput) {
      replyBox.style.display = 'block';
      replyInput.focus();
      
      // Scroll the reply box into view
      setTimeout(() => {
        replyBox.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }, 100);
    }
  };
  
  window.cancelReply = function() {
    const replyBox = document.getElementById('replyBox');
    const replyInput = document.getElementById('replyInput');
    
    if (replyBox && replyInput) {
      replyBox.style.display = 'none';
      replyInput.value = '';
    }
  };
  
  window.sendReply = async function() {
    const replyInput = document.getElementById('replyInput');
    const replyText = replyInput?.value?.trim();
    
    if (!replyText) {
      alert('×× × ×›×ª×•×‘ ×ª×’×•×‘×” ××• ×©××œ×”');
      return;
    }
    
    // Hide reply box and clear input
    cancelReply();
    
    // Get current plate from main form or session
    const currentPlate = document.getElementById('plateInput')?.value?.trim() || 
                        sessionStorage.getItem('plate') || '';
    
    // Store user message in context
    storeConversationContext(replyText, 'user');
    
    // Show loading state
    const responseBox = document.getElementById('agentResponse');
    if (responseBox) {
      const loadingDiv = document.createElement('div');
      loadingDiv.id = 'replyLoading';
      loadingDiv.innerHTML = `
        <div style="
          background: rgba(102, 126, 234, 0.1);
          border: 1px solid rgba(102, 126, 234, 0.3);
          padding: 12px;
          border-radius: 8px;
          margin-top: 12px;
          text-align: center;
          color: #667eea;
          font-size: 13px;
        ">
          <div style="display: inline-flex; align-items: center; gap: 8px;">
            <div style="width: 16px; height: 16px; border: 2px solid #667eea; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
            ×©×•×œ×— ×ª×’×•×‘×”...
          </div>
        </div>
      `;
      responseBox.appendChild(loadingDiv);
    }
    
    try {
      // Send reply with conversation context
      await submitQuery(currentPlate, replyText, false, true);
      
    } catch (error) {
      console.error('Reply error:', error);
      alert('×©×’×™××” ×‘×©×œ×™×—×ª ×”×ª×’×•×‘×”: ' + error.message);
    } finally {
      // Remove loading indicator
      const loadingDiv = document.getElementById('replyLoading');
      if (loadingDiv) {
        loadingDiv.remove();
      }
    }
  };
</script>

<style>
  /* Add shake animation for validation feedback */
  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
  }
  
  /* Enhance container animations */
  .input-container {
    transition: transform 0.2s ease;
  }
  
  /* Loading button state */
  .btn-send:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    transform: none !important;
  }
  
  /* Spinner animation for loading states */
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  /* Reply box styling enhancements */
  #replyBox {
    transition: all 0.3s ease;
  }
  
  #replyInput:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
  }
</style>
</body>
</html>
