<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <title>××©×£ ××•××“×Ÿ - ×™×¨×•×Ÿ ×›×™×•×£</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp" type="image/webp">
  <style>
    body {
      font-family: sans-serif;
      background: #f3f6fb;
      margin: 0;
      min-height: 100vh;
      padding: 0;
      padding-top: 90px;
      overflow-x: hidden;
    }
    .container {
      width: 100%;
      max-width:750px;
      background: #fff;
      padding: 32px 24px 24px 24px;
      border-radius: 16px;
      box-shadow: 0 0 20px rgba(0,0,0,0.08);
      margin: 32px auto 32px auto;
      box-sizing: border-box;
    }
    .logo {
      display: flex;
      justify-content: center;
      margin-bottom: 8px;
    }
    .logo img {
      width: 112px;
      height: auto;
      display: block;
    }
    .title { font-size: 27px; font-weight: bold; text-align: center; margin-bottom: 2px; font-weight: 900;}
    .subtitle { font-size: 23px; color: #666; text-align: center; margin-bottom: 10px;}
    h1, h2 { color: #1e3a8a; font-size: 25px; text-align: center; margin: 15px 0 8px 0; font-weight: 600;}
    h3 { color: #1e3a8a; font-size: 24px; margin: 22px 0 12px 0; text-align: right; font-weight: 900;}
    .form-section {
      width: 100%;
      margin-bottom: 20px;
      background: #fafbfe;
      border-radius: 12px;
      padding: 17px 15px 12px 15px;
      box-sizing: border-box;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px 18px;
      width: 100%;
    }
    @media (max-width: 600px) {
      .form-grid { grid-template-columns: 1fr; }
      .container { padding: 14px 2vw 20px 2vw; }
    }
    
    /* Mobile viewport fixes */
    @media (max-width: 768px) {
      body {
        width: 100vw;
        overflow-x: hidden !important;
        position: relative;
      }
      
      html {
        width: 100vw;
        overflow-x: hidden !important;
      }
      
      .container {
        width: 95vw;
        max-width: 95vw;
        margin: 32px 2.5vw 32px 2.5vw;
      }
    }
    label {
      font-size: 18px;
      margin-bottom: 4px;
      display: block;
      text-align: right;
    }
    input, select, textarea {
      width: 100%;
      font-size: 16px;
      border-radius: 8px;
      border: 1px solid #ccc;
      margin-bottom: 0px;
      padding: 8px 9px;
      box-sizing: border-box;
      text-align: right;
      background: #f9f9f9;
      transition: border .15s;
      outline: none;
    }
    input:focus, select:focus, textarea:focus {
      border-color: #3b82f6;
    }
    .readonly-box {
      background: #f4f6fa;
      border-radius: 6px;
      border: 1px solid #eee;
      padding: 7px 8px;
      min-height: 20px;
      font-size: 16px;
      color: #333;
      text-align: right;
    }
    .btn {
      background: #007bff;
      color: white;
      border: none;
      padding: 12px 15px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      display: block;
    }
    
    /* FLOATING SCREENS STYLING - COPIED FROM DEPRECIATION */
    .floating-toggles-top {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.95);
      padding: 8px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .toggle-square {
      width: 80px;
      height: 70px;
      background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      color: white;
      text-align: center;
      border: 2px solid transparent;
    }

    .toggle-square:hover {
      background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
    }

    .toggle-square.active {
      border-color: #fbbf24;
      box-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
    }

    .toggle-icon {
      font-size: 18px;
      margin-bottom: 2px;
    }

    .toggle-text {
      font-size: 10px;
      font-weight: 600;
      line-height: 1.1;
    }
    @media (max-width: 768px) {
      .floating-toggles-top {
        top: 5px;
        gap: 4px;
        padding: 6px;
      }
      .toggle-square {
        width: 65px;
        height: 60px;
      }
      .toggle-icon {
        font-size: 16px;
      }
      .toggle-text {
        font-size: 9px;
      }
      
      /* Mobile fixes for depreciation table */
      #depreciationBulkTable .dep-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #depreciationBulkTable .dep-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #depreciationBulkTable .dep-row > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(1)::before {
        content: "×”×—×œ×§ ×”× ×™×–×•×§:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(2)::before {
        content: "××”×•×ª ×”×ª×™×§×•×Ÿ:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(3)::before {
        content: "% ×™×¨×™×“×ª ×¢×¨×š:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(4)::before {
        content: "×¢×¨×š ×‘-â‚ª:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(5)::before {
        content: "×¤×¢×•×œ×•×ª:";
      }
      
      /* Hide table headers on mobile */
      #depreciationSection > div:first-child {
        display: none !important;
      }
      
      /* Mobile fixes for Full Market Adjustments table */
      #allAdjustmentsList .adjustment-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #allAdjustmentsList .adjustment-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #allAdjustmentsList .adjustment-row > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
        display: block;
        margin-bottom: 4px;
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(1)::before {
        content: "×ª×™××•×¨:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(2)::before {
        content: "×¡×•×’:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(3)::before {
        content: "××—×•×–:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(4)::before {
        content: "×¢×¨×š:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(5)::before {
        content: "×¤×¢×•×œ×•×ª:";
      }
      
      /* Hide Full Market Adjustments table headers on mobile */
      #allAdjustments > div:first-child {
        display: none !important;
      }
      
      /* Mobile fixes for damage center part rows */
      .part-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa !important;
        padding: 12px !important;
        border-radius: 8px !important;
        margin-bottom: 12px !important;
        border: 1px solid #e9ecef !important;
      }
      
      .part-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .part-row > div:nth-child(1) label::after {
        content: " (×©× ×”×—×œ×§)";
      }
      
      .part-row > div:nth-child(2) label::after {
        content: " (×ª×™××•×¨)";
      }
      
      .part-row > div:nth-child(3) label::after {
        content: " (×¢×œ×•×ª)";
      }
      
      /* Mobile fixes for damage center work rows */
      .work-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa !important;
        padding: 12px !important;
        border-radius: 8px !important;
        margin-bottom: 12px !important;
        border: 1px solid #e9ecef !important;
      }
      
      .work-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .work-row > div:nth-child(1) label::after {
        content: " (×¡×•×’ ×¢×‘×•×“×”)";
      }
      
      .work-row > div:nth-child(2) label::after {
        content: " (×”×¢×¨×•×ª)";
      }
      
      .work-row > div:nth-child(3) label::after {
        content: " (×¢×œ×•×ª)";
      }
      
      /* Mobile fixes for damage center repair rows */
      .repair-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa !important;
        padding: 12px !important;
        border-radius: 8px !important;
        margin-bottom: 12px !important;
        border: 1px solid #e9ecef !important;
      }
      
      .repair-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .repair-row > div:nth-child(1) label::after {
        content: " (×ª×™××•×¨ ×ª×™×§×•×Ÿ)";
      }
      
      .repair-row > div:nth-child(2) label::after {
        content: " (×”×¢×¨×•×ª)";
      }
      
      .repair-row > div:nth-child(3) label::after {
        content: " (×¢×œ×•×ª)";
      }
      
      /* Mobile fixes for Features Adjustments section */
      #featuresAdjustments > div:first-child {
        display: none !important;
      }
      
      #featuresAdjustmentsList > div {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #featuresAdjustmentsList > div > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #featuresAdjustmentsList > div > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
        display: block;
        margin-bottom: 4px;
      }
      
      #featuresAdjustmentsList > div > div:nth-child(1)::before {
        content: "×ª×™××•×¨:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(2)::before {
        content: "×¡×•×’:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(3)::before {
        content: "××—×•×–:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(4)::before {
        content: "×¢×¨×š:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(5)::before {
        content: "×¤×¢×•×œ×•×ª:";
      }
      
      /* Mobile fixes for Registration Adjustments section */
      #registrationAdjustments > div:first-child {
        display: none !important;
      }
      
      #registrationAdjustmentsList > div {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #registrationAdjustmentsList > div > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #registrationAdjustmentsList > div > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
        display: block;
        margin-bottom: 4px;
      }
      
      #registrationAdjustmentsList > div > div:nth-child(1)::before {
        content: "×ª×™××•×¨:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(2)::before {
        content: "×¡×•×’:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(3)::before {
        content: "××—×•×–:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(4)::before {
        content: "×¢×¨×š:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(5)::before {
        content: "×¤×¢×•×œ×•×ª:";
      }
      
      /* REMOVED: CSS for deleted "×”×ª×××•×ª ××•××“×Ÿ" section */
      
      /* Fix button spacing on mobile */
      .btn.add {
        width: 100% !important;
        margin-top: 8px !important;
      }
      
      /* Navigation buttons mobile responsive */
      .nav-btn {
        font-size: 14px !important;
        padding: 10px 8px !important;
        min-height: 44px !important;
      }
      
      /* Damage centers mobile responsive */
      #damageCentersContent > div > div > div:nth-child(n+1) {
        grid-template-columns: 1fr 1fr !important;
        gap: 4px !important;
      }
      
      /* Levi adjustments mobile responsive */
      .levi-adjustments-grid {
        grid-template-columns: 1fr !important;
        gap: 4px !important;
      }
      
      .levi-adjustment-row {
        grid-template-columns: 1fr !important;
        gap: 4px !important;
        padding: 8px !important;
      }
      
      .levi-adjustment-row > div {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 4px 0;
      }
      
      .levi-adjustment-row > div:nth-child(1)::after {
        content: "";
      }
      
      .levi-adjustment-row > div:nth-child(2)::before {
        content: "××—×•×–: ";
        font-weight: bold;
        color: #495057;
      }
      
      .levi-adjustment-row > div:nth-child(3)::before {
        content: "×¢×¨×š: ";
        font-weight: bold;
        color: #495057;
      }
      
      /* Custom summary rows mobile responsive */
      .custom-summary-row {
        grid-template-columns: 1fr !important;
        gap: 8px !important;
      }
      
      .custom-summary-row > input {
        margin-bottom: 4px;
      }
    }
    
    .collapsible-btn {
      background: #e0e7f1;
      font-family: sans-serif;
      color: #1e3a8a;
      border: none;
      padding: 7px 18px;
      border-radius: 7px;
      margin-bottom: 8px;
      margin-top: 2px;
      cursor: pointer;
      font-weight: 600;
      font-size: 16px;
      text-align: right;
      width: auto;
      display: inline-block;
    }

    .collapsible-btn:hover {
      background: #d1d9e6;
    }

    .btn.add {
      background: #28a745;
      margin-top: 7px;
      margin-bottom: 0;
      width: auto;
      padding: 8px 18px;
      font-size: 16px;
      display: block;
    }

    /* Navigation Buttons Styling */
    .nav-btn {
      padding: 12px 16px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      min-height: 48px;
    }

    .save-btn {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
    }
    .save-btn:hover {
      background: linear-gradient(135deg, #218838 0%, #1ea085 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
    }

    .preview-btn {
      background: linear-gradient(135deg, #17a2b8 0%, #20c997 100%);
    }
    .preview-btn:hover {
      background: linear-gradient(135deg, #138496 0%, #1ea085 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(23, 162, 184, 0.3);
    }

    .generate-btn {
      background: linear-gradient(135deg, #007bff 0%, #6610f2 100%);
    }
    .generate-btn:hover {
      background: linear-gradient(135deg, #0056b3 0%, #520dc2 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
    }

    .back-btn {
      background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
    }
    .back-btn:hover {
      background: linear-gradient(135deg, #545b62 0%, #3d4142 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
    }
    
    .footer {
      margin-top: 40px;
      font-size: 12px;
      color: #aaa;
      text-align: center;
    }
    
    /* Floating PDF Display Styles */
    .floating-pdf-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 0;
      margin: 0;
      box-sizing: border-box;
    }
    
    .floating-pdf-container {
      background: white;
      border-radius: 12px;
      width: 90%;
      max-width: 900px;
      height: 90%;
      max-height: 700px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }
    
    /* Mobile optimization for floating PDF */
    @media (max-width: 768px) {
      .floating-pdf-overlay {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        padding: 10px !important;
        box-sizing: border-box !important;
        display: block !important;
        z-index: 10000 !important;
      }
      
      .floating-pdf-container {
        position: absolute !important;
        top: 10px !important;
        left: 10px !important;
        right: 10px !important;
        bottom: 10px !important;
        width: calc(100vw - 20px) !important;
        height: calc(100vh - 20px) !important;
        max-width: none !important;
        max-height: none !important;
        margin: 0 !important;
        border-radius: 8px !important;
      }
      
      .floating-pdf-header {
        padding: 12px 16px !important;
        border-radius: 8px 8px 0 0 !important;
        display: flex !important;
        justify-content: space-between !important;
        align-items: center !important;
        min-height: 50px !important;
      }
      
      .floating-pdf-header h3 {
        font-size: 16px !important;
        margin: 0 !important;
        flex: 1 !important;
      }
      
      .toggle-btn, .close-btn {
        width: 40px !important;
        height: 40px !important;
        font-size: 20px !important;
        touch-action: manipulation !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        border-radius: 6px !important;
        flex-shrink: 0 !important;
      }
      
      .floating-pdf-controls {
        gap: 8px !important;
        display: flex !important;
        flex-shrink: 0 !important;
      }
    }
    
    /* Extra small mobile devices */
    @media (max-width: 480px) {
      .floating-pdf-overlay {
        padding: 5px !important;
      }
      
      .floating-pdf-container {
        top: 5px !important;
        left: 5px !important;
        right: 5px !important;
        bottom: 5px !important;
        width: calc(100vw - 10px) !important;
        height: calc(100vh - 10px) !important;
        border-radius: 6px !important;
      }
      
      .floating-pdf-header {
        padding: 10px 12px !important;
      }
      
      .floating-pdf-header h3 {
        font-size: 14px !important;
      }
      
      .toggle-btn, .close-btn {
        width: 36px !important;
        height: 36px !important;
        font-size: 18px !important;
      }
    }
    
    .floating-pdf-header {
      background: #1e3a8a;
      color: white;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 12px 12px 0 0;
    }
    
    .floating-pdf-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    
    .floating-pdf-controls {
      display: flex;
      gap: 10px;
    }
    
    .toggle-btn, .close-btn {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 35px;
      height: 35px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.3s ease;
    }
    
    .toggle-btn:hover, .close-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }
    
    .floating-pdf-content {
      flex: 1;
      padding: 0;
      overflow: hidden;
    }
    
    .floating-pdf-content.minimized {
      display: none;
    }
    
    .floating-pdf-container.minimized {
      height: auto;
      max-height: none;
    }
    
    /* Plate and document actions section styles */
    .plate-actions-section {
      background: #f8fafc;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 25px;
    }
    
    .plate-actions-section label {
      font-size: 16px;
      font-weight: 600;
      color: #1e3a8a;
      margin-bottom: 10px;
      text-align: right;
    }
    
    .plate-actions-section input {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #cbd5e1;
      border-radius: 6px;
      text-align: center;
      box-sizing: border-box;
    }
    
    .load-case-btn {
      padding: 10px 20px;
      background: #1e3a8a;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
    }
    
    .load-case-btn:hover {
      background: #3b82f6;
    }
    
    .document-actions-section {
      margin-top: 20px;
      padding: 15px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
    }
    
    .document-actions-section .nav-btn {
      flex: 1;
      padding: 12px;
      font-size: 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      color: white;
    }
  </style>
</head>
<body>
  <!-- FLOATING SCREEN TOGGLES - TOP OF PAGE -->
  <div class="floating-toggles-top">
    <div class="toggle-square" onclick="toggleFloatingScreen('leviReport')">
      <div class="toggle-icon">ğŸ“Š</div>
      <div class="toggle-text">×“×•"×— ×œ×•×™ ×™×¦×—×§</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('carDetails')">
      <div class="toggle-icon">ğŸš—</div>
      <div class="toggle-text">×¤×¨×˜×™ ×¨×›×‘</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('internalBrowser')">
      <div class="toggle-icon">ğŸŒ</div>
      <div class="toggle-text">×“×¤×“×¤×Ÿ ×¤× ×™××™</div>
    </div>
  </div>

  <div class="container">
    <div class="logo"><img src="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp" alt="Logo"></div>
    <div class="title">×™×¨×•×Ÿ ×›×™×•×£ ×©×××•×ª - ×¤×•×¨×˜×œ</div>
    <div class="subtitle">×©×××•×ª ×•×”×¢×¨×›×ª × ×–×§×™ ×¨×›×‘ ×•×¨×›×•×©</div>
    
    <!-- Plate Input and Document Actions Section -->
    <div class="plate-actions-section">
      <form id="builderLoadCaseForm" onsubmit="event.preventDefault(); loadExistingCaseForBuilder();">
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:15px;">
          <div>
            <label>××¡×¤×¨ ×¨×›×‘:</label>
            <input type="text" id="builderPlateInput" placeholder="×”×›× ×¡ ××¡×¤×¨ ×¨×›×‘" required>
          </div>
          <div>
            <label>×¡×™×¡××” (××•×¤×¦×™×•× ×œ×™):</label>
            <input type="password" id="builderPasswordInput" placeholder="×¡×™×¡××” ×œ××™××•×ª × ×ª×•× ×™×" autocomplete="current-password">
          </div>
        </div>
        
        <div style="text-align:center; margin-bottom:15px;">
          <button type="submit" id="builderLoadCaseBtn" class="load-case-btn">
            ×˜×¢×Ÿ ×ª×™×§ ×§×™×™×
          </button>
        </div>
      </form>
      
      <div id="builderPlateStatus" style="margin-top:10px; font-size:14px; color:#059669; display:none; text-align:right;">
        âœ“ × ×ª×•× ×™ ×”×¨×›×‘ × ×˜×¢× ×• ×‘×”×¦×œ×—×”
      </div>
      
      <!-- Document Actions Section -->
      <div class="document-actions-section">
        <div style="font-size: 16px; font-weight: 600; color: #1e3a8a; margin-bottom: 15px; text-align: center;">
          ×¤×¢×•×œ×•×ª ××¡××›×™×
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
          <button class="nav-btn" id="builderFetchExpertiseBtn" onclick="fetchExpertisePDFForBuilder()" style="background: #8b5cf6; color: white;">
            ×”×¦×’ ××§×¡×¤×™×¨×˜×™×–×” PDF
          </button>
          <button class="nav-btn" id="builderRequestExpertiseBtn" onclick="requestExpertiseForBuilder()" style="background: #059669; color: white;">
            ×‘×§×© ××§×¡×¤×™×¨×˜×™×–×”
          </button>
        </div>
      </div>
    </div>
    
    <h1>×‘× ×™×™×ª ××•××“×Ÿ × ×–×§×™ ×¨×›×‘</h1>
    <h2 id="pageTitle">×¨×›×‘ ××¡. ...</h2>

    <!-- ESTIMATE TYPE SELECTION -->
    <div class="form-section" id="estimate-type">
      <h3>×¡×•×’ ×”××•××“×Ÿ</h3>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 14px;">
        <label style="border: 1px solid #ddd; padding: 10px; border-radius: 6px; cursor: pointer;">
          <input type="radio" name="estimate-type" value="××•×‘×“×Ÿ_×œ×”×œ×›×”" checked style="width: auto; margin-left: 8px;">
          ××•××“×Ÿ ×¨××©×•× ×™ - ××•×‘×“×Ÿ ×œ×”×œ×›×”
        </label>
        <label style="border: 1px solid #ddd; padding: 10px; border-radius: 6px; cursor: pointer;">
          <input type="radio" name="estimate-type" value="×˜×•×˜×œ×•×¡" style="width: auto; margin-left: 8px;">
          ××•××“×Ÿ ×¨××©×•× ×™ - ×˜×•×˜×œ×•×¡
        </label>
      </div>
    </div>

    <!-- VEHICLE DATA - EDITABLE FROM HELPER -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('vehicleData')">× ×ª×•× ×™ ×¨×›×‘ (×”×¦×’/×”×¡×ª×¨)</button>
      <div id="vehicleData" style="display:none;">
        <div class="form-grid">
          <div><label>××¡×¤×¨ ×¨×›×‘:</label><input type="text" id="carPlate" onchange="updateHelperFromField(event);" /></div>
          <div><label>×ª×•×¦×¨×ª:</label><input type="text" id="carManufacturer" onchange="updateHelperFromField(event);" /></div>
          <div><label>×“×’×:</label><input type="text" id="carModel" onchange="updateHelperFromField(event);" /></div>
          <div><label>×©× ×ª ×™×™×¦×•×¨:</label><input type="text" id="carYear" onchange="updateHelperFromField(event);" /></div>
          <div><label>×§×•×“ ×“×’×:</label><input type="text" id="carModelCode" onchange="updateHelperFromField(event);" /></div>
          <div><label>××—×™×¨ ×‘×¡×™×¡:</label><input type="text" id="carBasePrice" onchange="updateHelperFromField(event);" /></div>
          <div><label>×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘:</label><input type="text" id="carMarketValue" onchange="updateHelperFromField(event);" /></div>
          <div><label>×ª××¨×™×š ×”×¤×§×”:</label><input type="date" id="carReportDate" onchange="updateHelperFromField(event);" /></div>
        </div>
      </div>
    </div>


    <!-- COLLAPSIBLE CONTACT DATA -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('contactData')">× ×ª×•× ×™ ×”×ª×§×©×¨×•×ª (×”×¦×’/×”×¡×ª×¨)</button>
      <div id="contactData" style="display:none;">
        <div class="form-grid">
          <div><label>×©× ×‘×¢×œ ×”×¨×›×‘:</label><input type="text" id="ownerName" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>×›×ª×•×‘×ª ×‘×¢×œ ×”×¨×›×‘:</label><input type="text" id="ownerAddress" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>×˜×œ×¤×•×Ÿ ×‘×¢×œ ×”×¨×›×‘:</label><input type="text" id="ownerPhone" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>×—×‘×¨×ª ×‘×™×˜×•×—:</label><input type="text" id="insuranceCompany" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>××™××™×™×œ ×—×‘×¨×ª ×‘×™×˜×•×—:</label><input type="text" id="insuranceEmail" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>×¡×•×›×Ÿ ×‘×™×˜×•×—:</label><input type="text" id="insuranceAgent" onchange="updateHelperFromContactField(this); triggerFloatingScreenRefresh();" /></div>
          <div><label>×˜×œ×¤×•×Ÿ ×¡×•×›×Ÿ ×‘×™×˜×•×—:</label><input type="text" id="agentPhone" onchange="updateHelperFromContactField(this); triggerFloatingScreenRefresh();" /></div>
          <div><label>××™××™×™×œ ×¡×•×›×Ÿ ×‘×™×˜×•×—:</label><input type="text" id="agentEmail" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>×©× ××•×¡×š:</label><input type="text" id="garageName" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>×˜×œ×¤×•×Ÿ ××•×¡×š:</label><input type="text" id="garagePhone" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>××™××™×™×œ ××•×¡×š:</label><input type="text" id="garageEmail" onchange="updateHelperFromContactField(this);" /></div>
        </div>
      </div>
    </div>

    <!-- DAMAGE CENTERS SUMMARY SECTION - EDITABLE -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('damageCentersSummary')">×¡×™×›×•× ××•×§×“×™ × ×–×§ (×”×¦×’/×”×¡×ª×¨)</button>
      <div id="damageCentersSummary" style="display:none;">
        <h3>×¡×™×›×•× ××•×§×“×™ × ×–×§ (× ×™×ª×Ÿ ×œ×¢×¨×™×›×”) </h3>
        <div style="background: #f8f9fa; border-radius: 6px; padding: 15px; min-height: 50px;" id="damageCentersContent">
          <div style="color: #666; text-align: center;">×˜×•×¢×Ÿ × ×ª×•× ×™ ××•×§×“×™ × ×–×§...</div>
        </div>
      </div>
    </div>

    <!-- GROSS DAMAGE PERCENTAGE CALCULATION -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('grossCalc')">×¢×¨×š ×”×¨×›×‘ ×”×’×•×œ××™ - ×××¤×™×™× ×™× ×•×¢×œ×™×” ×œ×›×‘×™×© ×‘×œ×‘×“ (×”×¦×’/×”×¡×ª×¨)</button>
      <div id="grossCalc" style="display:none;">
        <div class="form-grid">
          <div><label>×¢×¨×š ×”×¨×›×‘ ×¢"×¤ ××—×™×¨×•×Ÿ ×›×•×œ×œ ××¢"×:</label><input type="text" id="basicPrice" placeholder="â‚ª" onchange="updateHelperFromField(event); updateGrossMarketValueCalculation(); updateHelperFromAdjustments();" /></div>
          <div></div>
        </div>
        
        <!-- Features Adjustments -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">×ª×•×¡×¤×•×ª ×××¤×™×™× ×™× (×ª×›×•× ×•×ª ×”×¨×›×‘):</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            ğŸ—ï¸ ×ª×•×¡×¤×•×ª ×”×§×©×•×¨×•×ª ×œ×ª×›×•× ×•×ª ×¤×™×–×™×•×ª ×©×œ ×”×¨×›×‘ ×¢×¦××•
          </div>
          <div id="featuresAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>×ª×™××•×¨:</label></div>
              <div><label>×¡×•×’:</label></div>
              <div><label>××—×•×–:</label></div>
              <div><label>×¢×¨×š:</label></div>
              <div><label>×¤×¢×•×œ×•×ª:</label></div>
            </div>
            <div id="featuresAdjustmentsList"></div>
            <button class="btn add" type="button" onclick="addFeatureAdjustment()">×”×•×¡×£ ×ª×•×¡×¤×ª ×××¤×™×™×Ÿ</button>
          </div>
        </div>
        
        <!-- Registration Adjustments -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">×¢×œ×™×” ×œ×›×‘×™×© (×ª××¨×™×š ×¨×™×©×•×):</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            ğŸ“… ×”×ª×××•×ª ×‘×’×™×Ÿ ×ª××¨×™×š ×¨×™×©×•× ×”×¨×›×‘ (×××¤×™×™×Ÿ ×§×‘×•×¢ ×©×œ ×”×¨×›×‘)
          </div>
          <div id="registrationAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>×ª×™××•×¨:</label></div>
              <div><label>×¡×•×’:</label></div>
              <div><label>××—×•×–:</label></div>
              <div><label>×¢×¨×š:</label></div>
              <div><label>×¤×¢×•×œ×•×ª:</label></div>
            </div>
            <div id="registrationAdjustmentsList"></div>
            <button class="btn add" type="button" onclick="addRegistrationAdjustment()">×”×•×¡×£ ×ª×•×¡×¤×ª ×¢×œ×™×” ×œ×›×‘×™×©</button>
          </div>
        </div>
        
        <!-- Gross Market Value Result -->
        <div style="margin-top: 20px; padding: 15px; background: #f0f8ff; border-radius: 8px; border: 2px solid #4a90e2;">
          <div class="form-grid">
            <div><label><strong>×¢×¨×š ×”×¨×›×‘ ×œ× ×–×§ ×’×•×œ××™ ×›×•×œ×œ ××¢"×:</strong></label><input type="text" id="grossMarketValueResult" style="background: #f8f9fa; font-weight: bold;" readonly /></div>
            <div></div>
          </div>
        </div>
      </div>
    </div>


    <!-- GROSS DAMAGE PERCENTAGE RESULT -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('grossPercentageResult')">××—×•×– ×”× ×–×§ ×”×’×•×œ××™ - ×‘×¡×™×¡ ×”×¨×›×‘ ×‘×œ×‘×“ (×”×¦×’/×”×¡×ª×¨)</button>
      <div id="grossPercentageResult" style="display:none;">
        <div class="form-grid">
          <div><label>×¡×”×´×› ×¢×œ×•×ª × ×–×§×™×:</label><input type="text" id="totalClaim" style="background: #f8f9fa;" readonly /></div>
          <div><label>×¢×¨×š ×”×¨×›×‘ ×œ× ×–×§ ×’×•×œ××™:</label><input type="text" id="leviPriceList" style="background: #f8f9fa;" readonly /></div>
        </div>
        
        <!-- Gross Percentage Result -->
        <div style="margin-top: 15px; padding: 15px; background: #f0f8ff; border-radius: 8px; border: 2px solid #e74c3c;">
          <div class="form-grid">
            <div><label><strong>××—×•×– ×”× ×–×§ ×”×’×•×œ××™:</strong></label><input type="text" id="grossPercent" style="background: #f8f9fa; font-weight: bold; color: #e74c3c;" readonly /></div>
            <div></div>
          </div>
          <div style="margin-top: 10px; font-size: 14px; color: #666;">
            <strong>×—×™×©×•×‘:</strong> ×¡×”×´×› ×¢×œ×•×ª × ×–×§×™× Ã· ×¢×¨×š ×”×¨×›×‘ ×œ× ×–×§ ×’×•×œ××™ Ã— 100
          </div>
        </div>
        
        <!-- Additional Claims Data -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">× ×ª×•× ×™× × ×•×¡×¤×™×:</h4>
          <div class="form-grid">
            <div><label>×¡×”"×› ×ª×‘×™×¢×” (×××•×©×¨):</label><input type="text" id="authorizedClaim" /></div>
            <div></div>
          </div>
        </div>
      </div>
    </div>

    <!-- FULL MARKET VALUE CALCULATION -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('fullMarketValue')">×¢×¨×š ×”×©×•×§ ×”××œ× - ×›×•×œ×œ ×’×•×¨××™ ×©×™××•×© (×”×¦×’/×”×¡×ª×¨)</button>
      <div id="fullMarketValue" style="display:none;">
        <div class="form-grid">
          <div><label>×¢×¨×š ×”×¨×›×‘ ×¢"×¤ ××—×™×¨×•×Ÿ ×›×•×œ×œ ××¢"×:</label><input type="text" id="fullBasicPrice" placeholder="â‚ª" readonly style="background: #f8f9fa;" /></div>
          <div></div>
        </div>
        
        <!-- Usage Factors Section -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">×’×•×¨××™ ×©×™××•×© (×§"×, ×¡×•×’ ×‘×¢×œ×•×ª, ××¡×¤×¨ ×‘×¢×œ×™×):</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            ğŸ’¡ ×”×ª×××•×ª ×”××‘×•×¡×¡×•×ª ×¢×œ ×©×™××•×© ×‘×¤×•×¢×œ ×‘×¨×›×‘ - ×œ× ×¢×œ ×ª×›×•× ×•×ª ×”×¨×›×‘ ×¢×¦××•
          </div>
          <div id="allAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>×ª×™××•×¨:</label></div>
              <div><label>×¡×•×’:</label></div>
              <div><label>××—×•×–:</label></div>
              <div><label>×¢×¨×š:</label></div>
              <div><label>×¤×¢×•×œ×•×ª:</label></div>
            </div>
            <div id="allAdjustmentsList">
              <!-- This will be populated from helper data -->
            </div>
            <button class="btn add" type="button" onclick="addFullMarketAdjustment()">×”×•×¡×£ ×”×ª×××”</button>
          </div>
        </div>
        
        <!-- Full Market Value Result -->
        <div style="margin-top: 20px; padding: 15px; background: #f0f8ff; border-radius: 8px; border: 2px solid #28a745;">
          <div class="form-grid">
            <div><label><strong>×¢×¨×š ×”×©×•×§ ×”××œ× ×©×œ ×”×¨×›×‘ ×›×•×œ×œ ××¢"×:</strong></label><input type="text" id="fullMarketValueResult" style="background: #f8f9fa; font-weight: bold; color: #28a745;" readonly /></div>
            <div></div>
          </div>
          <div style="margin-top: 10px; font-size: 14px; color: #666;">
            <strong>×—×™×©×•×‘:</strong> ×©×œ×‘ ×': ××—×™×¨ ×‘×¡×™×¡ + ×××¤×™×™× ×™× + ×¢×œ×™×” ×œ×›×‘×™×©. ×©×œ×‘ ×‘': ×”×ª×××•×ª ×©×•×§ ×¨×¦×™×¤×•×ª
          </div>
        </div>
      </div>
    </div>

    <!-- DEPRECIATION CALCULATION SECTION -->
    <div class="form-section" id="depreciationSection">
      <button class="collapsible-btn" type="button" onclick="toggleSection('depreciationContent')">×—×™×©×•×‘ ×™×¨×™×“×ª ×¢×¨×š ×œ×¤×™ ××•×§×“×™ × ×–×§ (×”×¦×’/×”×¡×ª×¨)</button>
      <div id="depreciationContent" style="display: none;">
        <h3>×—×™×©×•×‘ ×™×¨×™×“×ª ×¢×¨×š ×œ×¤×™ ××•×§×“×™ × ×–×§</h3>
      <div style="display:grid; grid-template-columns:1fr 1fr 120px 120px 80px; gap:14px; margin-bottom:10px;">
        <div><label>×”×—×œ×§ ×”× ×™×–×•×§:</label></div>
        <div><label>××”×•×ª ×”×ª×™×§×•×Ÿ:</label></div>
        <div><label>% ×™×¨×™×“×ª ×¢×¨×š:</label></div>
        <div><label>×¢×¨×š ×‘-â‚ª:</label></div>
        <div><label>×¤×¢×•×œ×•×ª:</label></div>
      </div>
      <div id="depreciationBulkTable"></div>
      <button class="btn add" type="button" onclick="addDepField()">×”×•×¡×£ ×©×“×”</button>
      <div style="margin-top:14px;">
        <label>×™×¨×™×“×ª ×¢×¨×š ×’×œ×•×‘×œ×™:</label>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:14px;">
          <input type="text" id="globalDep1" placeholder="% ×™×¨×™×“×ª ×¢×¨×š" onchange="saveDepreciationData();" />
          <input type="text" id="globalDepValue" placeholder="×¢×¨×š ×‘-â‚ª" readonly style="background:#f4f6fa;" />
        </div>
      </div>
      <div style="margin-top:14px;">
        <label>×™××™ ××•×¡×š ××©×•×¢×¨×™×:</label>
        <input type="number" id="garageDays" placeholder="××¡×¤×¨ ×™××™ ×¢×‘×•×“×”" style="width: 200px;" />
      </div>
      </div>
    </div>

    <!-- SUMMARY SECTION WITH ORANGE STYLING -->
    <div class="form-section" style="background: linear-gradient(135deg, #ff8c00 0%, #ff7300 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">×¡×™×›×•× ×”××•××“×Ÿ</h3>
      
      <div style="background: rgba(255,255,255,0.95); color: #333; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
        <div class="form-grid">
          <div>
            <label style="color: #333;">×¡×•×’ ×“×•"×—:</label>
            <input type="text" id="reportType" style="background: #f0f0f0; color: #333;" readonly />
          </div>
          <div>
            <label style="color: #333;">×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘:</label>
            <input type="text" id="sumMarketValue" style="background: white; color: #333;" />
          </div>
        </div>
        <div class="form-grid">
          <div>
            <label style="color: #333;">×¡×”×´×› ×ª×‘×™×¢×”:</label>
            <input type="text" id="sumClaim" style="background: white; color: #333;" />
          </div>
          <div>
            <label style="color: #333;">×¤×™×¦×•×™ ×‘×’×™×Ÿ ×™×¨×™×“×ª ×¢×¨×š:</label>
            <input type="text" id="depCompensation" style="background: white; color: #333;" />
          </div>
        </div>
        <div class="form-grid">
          <div>
            <label style="color: #333;">×©×•×•×™ ×”×©×¨×™×“×™× (××•×¤×¦×™×•× ×œ×™) - ××•×¤×—×ª ××”×¡×›×•×:</label>
            <input type="text" id="salvageValue" style="background: #fff5f5; color: #333; border: 1px solid #f87171;" placeholder="â‚ª0" />
          </div>
          <div style="display: flex; align-items: center; font-size: 13px; color: #666; padding: 8px;">
            â– ×©×“×” ××•×¤×¦×™×•× ×œ×™ - ××•×¤×—×ª ××”×¡×›×•× ×”×¡×•×¤×™ ×× ××•×œ×
          </div>
        </div>
      </div>
      
      <!-- VAT AND TOTAL CALCULATION SECTION -->
      <div style="background: rgba(255,255,255,0.95); color: #333; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
        <div class="form-grid">
          <div>
            <label style="color: #333;">××¢×´× (18%):</label>
            <input type="text" id="sumVAT" style="background: white; color: #333;" readonly />
          </div>
          <div>
            <label style="color: #333;">×¡×”×´×› × ×›×œ×œ ×‘××•××“×Ÿ</label>
            <input type="text" id="sumTotalClaim" style="background: #e8f5e8; color: #333; font-weight: bold;" readonly />
          </div>
        </div>
      </div>
    </div>

    <!-- ADDITIONAL NOTES -->
    <div class="form-section">
      <h3>×”×¢×¨×•×ª × ×•×¡×¤×•×ª ×œ××•××“×Ÿ</h3>
      <textarea id="additional-notes" placeholder="×”×•×¡×£ ×”×¢×¨×•×ª, ×”××œ×¦×•×ª ××• ××™×“×¢ × ×•×¡×£ ×œ××•××“×Ÿ..." style="min-height: 80px;"></textarea>
    </div>

    <!-- LEGAL TEXT SECTION - EDITABLE (MOVED BEFORE NAVIGATION) -->
    <div class="form-section" id="legal-text">
      <h3>×˜×§×¡×˜ ××©×¤×˜×™ ×œ××•××“×Ÿ</h3>
      <div style="margin-bottom: 10px;">
        <button type="button" onclick="loadLegalTextFromVault()" style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-left: 10px;">×˜×¢×Ÿ ××”×›×¡×¤×ª</button>
        <button type="button" onclick="resetLegalText()" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">××™×¤×•×¡ ×˜×§×¡×˜</button>
      </div>
      <textarea id="legal-text-content" style="width: 100%; min-height: 200px; padding: 15px; border: 1px solid #e2e8f0; border-radius: 6px; background: #f8f9fa; line-height: 1.6; font-family: inherit; resize: vertical; box-sizing: border-box;" placeholder="×”×˜×§×¡×˜ ×”××©×¤×˜×™ ×™×˜×¢×Ÿ ×›××Ÿ ×¢× ×”× ×ª×•× ×™× ×”××¢×•×“×›× ×™×...">×”×˜×§×¡×˜ ×”××©×¤×˜×™ ×™×˜×¢×Ÿ ×›××Ÿ ×¢× ×”× ×ª×•× ×™× ×”××¢×•×“×›× ×™×...</textarea>
      <div style="margin-top: 8px; font-size: 14px; color: #666;">
        ğŸ’¡ ×”×˜×§×¡×˜ × ×™×ª×Ÿ ×œ×¢×¨×™×›×” ×œ×¦×•×¨×š ×”×ª×××” ×œ×“×•×— ×”×¡×¤×¦×™×¤×™. ×”×©×™× ×•×™×™× ×œ× ×™×©×¤×™×¢×• ×¢×œ ×”×›×¡×¤×ª ×”××§×•×¨×™×ª.
      </div>
    </div>

    <!-- ATTACHMENTS SECTION - EDITABLE -->
    <div class="form-section" id="attachments-section">
      <h3>×¨×©×™××ª × ×¡×¤×—×™×</h3>
      <div style="margin-bottom: 10px;">
        <button type="button" onclick="loadAttachmentsFromVault()" style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-left: 10px;">×˜×¢×Ÿ ××”×›×¡×¤×ª</button>
        <button type="button" onclick="resetAttachments()" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">××™×¤×•×¡ ×¨×©×™××”</button>
      </div>
      <textarea id="attachments-content" style="width: 100%; min-height: 120px; padding: 15px; border: 1px solid #e2e8f0; border-radius: 6px; background: #f8f9fa; line-height: 1.6; font-family: inherit; resize: vertical; box-sizing: border-box;" placeholder="×¨×©×™××ª ×”× ×¡×¤×—×™× ×ª×˜×¢×Ÿ ×›××Ÿ..."><strong>×œ×•×˜×”</strong>
×ª×¦×œ×•××™ ×”×¨×›×‘ ×”× ×™×–×•×§
×—×©×‘×•× ×™×•×ª ×ª×™×§×•×Ÿ
×¢×¨×š ×¨×›×‘ ×××•×—×©×‘
×¦×™×œ×•× ×¨×™×©×™×•×Ÿ ×”×¨×›×‘
×—×©×›"×˜</textarea>
      <div style="margin-top: 8px; font-size: 14px; color: #666;">
        ğŸ’¡ ×”×¨×©×™××” × ×™×ª× ×ª ×œ×¢×¨×™×›×” ×œ×¦×•×¨×š ×”×ª×××” ×œ×“×•×— ×”×¡×¤×¦×™×¤×™. ×”×©×™× ×•×™×™× ×œ× ×™×©×¤×™×¢×• ×¢×œ ×”×›×¡×¤×ª ×”××§×•×¨×™×ª.
      </div>
    </div>

    <!-- Navigation Buttons -->
    <div class="form-section">
      <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px;">
        <button type="button" class="nav-btn save-btn" onclick="saveEstimate()">×©××•×¨ ××•××“×Ÿ</button>
        <button type="button" class="nav-btn preview-btn" onclick="previewEstimate()">×ª×¦×•×’×” ××§×“×™××”</button>
        <button type="button" class="nav-btn generate-btn" onclick="generateEstimate()">×¦×•×¨ ×“×•"×— ××•××“×Ÿ</button>
        <button type="button" class="nav-btn back-btn" onclick="window.location.href='selection.html'">×—×–×•×¨ ×œ×“×£ ×”×‘×—×™×¨×”</button>
      </div>
    </div>

    <div class="footer">All rights reserved Â© Carmel Cayouf</div>
  </div>

  
  <!-- Load Legal Text Engine -->
  <script src="legal-text-engine.js"></script>
  
  <script>
    // IMMEDIATE FUNCTION DEFINITIONS - MUST BE AVAILABLE BEFORE DOM LOADS
    window.toggleFloatingScreen = function(screenType) {
      console.log('Toggling floating screen:', screenType);
      
      const screens = {
        leviReport: () => {
          if (window.toggleLeviReport) {
            window.toggleLeviReport();
          } else {
            console.log('Levi report floating screen not available');
          }
        },
        carDetails: () => {
          if (window.toggleCarDetails) {
            window.toggleCarDetails();
          } else {
            console.log('Car details floating screen not available');
          }
        },
        internalBrowser: () => {
          if (window.showBrowserMenu) {
            showBrowserMenuUnderToggle();
          } else {
            console.log('Internal browser not available');
          }
        }
      };
      
      if (screens[screenType]) {
        screens[screenType]();
      } else {
        console.log('Unknown screen type:', screenType);
      }
    };
    
    window.toggleSection = function(sectionId) {
      console.log(`ğŸ”„ toggleSection called with: ${sectionId}`);
      
      const section = document.getElementById(sectionId);
      if (section) {
        const isVisible = section.style.display !== 'none';
        section.style.display = isVisible ? 'none' : 'block';
        console.log(`Section ${sectionId} is now ${isVisible ? 'hidden' : 'visible'}`);
      } else {
        console.error(`Section with id ${sectionId} not found`);
      }
    };
    // Authentication check
    const auth = sessionStorage.getItem("auth");
    if (!auth) {
      alert("×”×’×™×©×” ×—×¡×•××” - ×× × ×”×ª×—×‘×¨ ×“×¨×š ×“×£ ×”×‘×™×ª");
      window.location.href = "index.html";
    }

    // FLOATING SCREENS TOGGLE FUNCTION - COPIED FROM DEPRECIATION MODULE

    // CUSTOM BROWSER MENU - COPIED FROM DEPRECIATION MODULE
    function showBrowserMenuUnderToggle() {
      const menu = document.createElement('div');
      menu.style.cssText = `
        position: fixed;
        top: 90px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 20px;
        z-index: 99999;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        font-family: sans-serif;
        direction: rtl;
        min-width: 280px;
      `;
      
      menu.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 15px; color: #2c3e50; font-size: 16px;">×‘×—×¨ ××ª×¨ ×œ×¤×ª×™×—×”:</div>
        <button onclick="window.openInternalBrowser('car-part.co.il'); this.parentElement.remove();" style="width: 100%; padding: 12px; margin-bottom: 8px; border: none; background: #28a745; color: white; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: 500;">
          ğŸ”§ Car Part - ×—×œ×§×™ ×¨×›×‘
        </button>
        <button onclick="window.openInternalBrowser('portal.levi-itzhak.co.il'); this.parentElement.remove();" style="width: 100%; padding: 12px; margin-bottom: 8px; border: none; background: #007bff; color: white; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: 500;">
          ğŸ“Š ×¤×•×¨×˜×œ ×œ×•×™ ×™×¦×—×§
        </button>
        <button onclick="this.parentElement.remove();" style="width: 100%; padding: 10px; border: 1px solid #ccc; background: white; color: #666; border-radius: 6px; cursor: pointer; font-size: 14px;">
          ×‘×™×˜×•×œ
        </button>
      `;
      
      document.body.appendChild(menu);
      
      // Remove menu when clicking outside
      setTimeout(() => {
        document.addEventListener('click', function removeMenu(e) {
          if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', removeMenu);
          }
        });
      }, 100);
    }

    // COLLAPSIBLE SECTION TOGGLE
    function toggleSection(sectionId) {
      const section = document.getElementById(sectionId);
      if (section) {
        section.style.display = section.style.display === 'none' ? 'block' : 'none';
        
        // Save state to sessionStorage
        const isVisible = section.style.display !== 'none';
        sessionStorage.setItem(`section-${sectionId}`, isVisible ? 'expanded' : 'collapsed');
      } else {
        console.error(`Section with ID '${sectionId}' not found.`);
      }
    }
    
    // ADD DEPRECIATION FIELD FUNCTION
    function addDepField(data = {}) {
      const container = document.getElementById('depreciationBulkTable');
      if (!container) {
        console.error('Depreciation bulk table container not found');
        return;
      }
      
      const rowId = 'depRow_' + Date.now();
      const newRow = `
        <div id="${rowId}" class="dep-row" style="display:grid; grid-template-columns:2fr 2fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
          <div><input type="text" placeholder="×”×—×œ×§ ×”× ×™×–×•×§" value="${data.damaged_part || ''}" onchange="saveDepreciationData();" /></div>
          <div><input type="text" placeholder="××”×•×ª ×”×ª×™×§×•×Ÿ" value="${data.repair_type || ''}" onchange="saveDepreciationData();" /></div>
          <div><input type="text" placeholder="%" value="${data.percent || ''}" onchange="saveDepreciationData();" /></div>
          <div><input type="text" placeholder="â‚ª" value="${data.value || ''}" onchange="saveDepreciationData();" /></div>
          <div><button class="btn remove" onclick="removeDepField('${rowId}')">××—×§</button></div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      
      // Add auto-calculation functionality to the percentage field
      const row = document.getElementById(rowId);
      const percentInput = row.querySelector('input[placeholder="%"]');
      const valueInput = row.querySelector('input[placeholder="â‚ª"]');
      
      percentInput.addEventListener('input', function() {
        let percent = parseFloat(this.value) || 0;
        
        // Auto-add % symbol if not present and user enters a number
        if (this.value && !this.value.includes('%') && !isNaN(percent)) {
          this.value = percent + '%';
        }
        
        // Calculate value from market price automatically
        const marketValueField = document.getElementById('carMarketValue') || document.getElementById('sumMarketValue');
        const marketValueStr = marketValueField?.value.replace(/[â‚ª,]/g, '') || '0';
        const marketValue = parseFloat(marketValueStr) || 0;
        
        const calculatedValue = (marketValue * percent) / 100;
        valueInput.value = calculatedValue ? `â‚ª${Math.round(calculatedValue).toLocaleString()}` : '';
        
        // Save data after calculation
        saveDepreciationData();
      });
    }
    
    // REMOVE DEPRECIATION FIELD FUNCTION
    function removeDepField(rowId) {
      const row = document.getElementById(rowId);
      if (row) {
        row.remove();
        // Save after removal
        saveDepreciationData();
      }
    }

    // SAVE DEPRECIATION DATA TO HELPER
    function saveDepreciationData() {
      try {
        // Get global depreciation values
        const globalPercent = document.getElementById('globalDep1')?.value || '';
        const globalValue = document.getElementById('globalDepValue')?.value || '';
        
        // Collect depreciation data
        const depreciationData = {
          global_percent: globalPercent,
          global_value: globalValue,
          bulk_items: []
        };
        
        // Collect data from all depreciation rows
        const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
        depRows.forEach(row => {
          const inputs = row.querySelectorAll('input');
          if (inputs.length >= 4) {
            const item = {
              damaged_part: inputs[0].value,
              repair_type: inputs[1].value,
              percent: inputs[2].value,
              value: inputs[3].value
            };
            console.log('ğŸ’¾ Saving depreciation item:', item);
            depreciationData.bulk_items.push(item);
          }
        });
        
        // Save to helper using proper function
        if (typeof updateHelper === 'function') {
          updateHelper('estimate_depreciation', depreciationData, 'estimate_builder_depreciation');
        } else {
          // ğŸ”§ PHASE 2.4: Fallback - use window.helper (single source)
          if (typeof window.helper === 'object') {
            window.helper.estimate_depreciation = depreciationData;
            // Save to primary storage only
            try {
              sessionStorage.setItem('helper', JSON.stringify(window.helper));
              console.log('âš ï¸ PHASE 2.4: Estimate depreciation saved via emergency fallback');
            } catch(e) {
              console.error('âŒ PHASE 2.4: Failed to save estimate depreciation:', e);
            }
          }
        }
        
        // âœ… BIDIRECTIONAL INTEGRATION: Update builder current state
        updateBuilderCurrentState('estimate_depreciation', depreciationData);
        
        console.log('ğŸ’¾ Depreciation data saved to helper:', depreciationData);
      } catch (error) {
        console.error('Error saving depreciation data:', error);
      }
    }

    // ADD AUTO-CALCULATION TO EXISTING ROWS
    function addAutoCalculationToExistingRows() {
      const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
      depRows.forEach(row => {
        const percentInput = row.querySelector('input[placeholder="%"]');
        const valueInput = row.querySelector('input[placeholder="â‚ª"]');
        
        if (percentInput && valueInput) {
          // Remove any existing event listeners first
          percentInput.removeEventListener('input', percentInput.autoCalcHandler);
          
          // Create the auto-calculation handler
          const autoCalcHandler = function() {
            let percent = parseFloat(this.value) || 0;
            
            // Auto-add % symbol if not present and user enters a number
            if (this.value && !this.value.includes('%') && !isNaN(percent)) {
              this.value = percent + '%';
            }
            
            // Calculate value from market price automatically
            const marketValueField = document.getElementById('carMarketValue') || document.getElementById('sumMarketValue');
            const marketValueStr = marketValueField?.value.replace(/[â‚ª,]/g, '') || '0';
            const marketValue = parseFloat(marketValueStr) || 0;
            
            const calculatedValue = (marketValue * percent) / 100;
            valueInput.value = calculatedValue ? `â‚ª${Math.round(calculatedValue).toLocaleString()}` : '';
            
            // Save data after calculation
            saveDepreciationData();
          };
          
          // Store the handler reference for potential removal
          percentInput.autoCalcHandler = autoCalcHandler;
          
          // Add the event listener
          percentInput.addEventListener('input', autoCalcHandler);
          
          // Trigger calculation for existing values
          if (percentInput.value) {
            autoCalcHandler.call(percentInput);
          }
        }
      });
    }

    // MAKE FUNCTIONS GLOBALLY ACCESSIBLE
    window.toggleSection = toggleSection;
    window.addDepField = addDepField;
    window.removeDepField = removeDepField;
    window.saveDepreciationData = saveDepreciationData;

    // BUTTON FUNCTIONS - NO DEBUG ALERTS
    window.saveEstimate = function() {
      const selectedTypeElement = document.querySelector('input[name="estimate-type"]:checked');
      if (!selectedTypeElement) {
        alert('×× × ×‘×—×¨ ×¡×•×’ ××•××“×Ÿ');
        return;
      }
      
      const selectedType = selectedTypeElement.value;
      const additionalNotes = document.getElementById('additional-notes')?.value || '';
      const garageDays = document.getElementById('garageDays')?.value || '';
      
      // Get summary data
      const summaryData = {
        market_value: document.getElementById('sumMarketValue')?.value || '',
        total_claim: document.getElementById('sumClaim')?.value || '',
        vat: document.getElementById('sumVAT')?.value || '',
        total_with_vat: document.getElementById('sumTotalClaim')?.value || '',
        dep_compensation: document.getElementById('depCompensation')?.value || '',
        salvage_value: document.getElementById('salvageValue')?.value || ''
      };
      
      // Get depreciation data
      const depreciationData = {
        global_percent: document.getElementById('globalDep1')?.value || '',
        global_value: document.getElementById('globalDepValue')?.value || '',
        bulk_items: []
      };
      
      // Collect depreciation bulk items
      const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
      depRows.forEach(row => {
        const inputs = row.querySelectorAll('input');
        if (inputs.length >= 4) {
          depreciationData.bulk_items.push({
            damaged_part: inputs[0].value,
            repair_type: inputs[1].value,
            percent: inputs[2].value,
            value: inputs[3].value
          });
        }
      });
      
      // Collect adjustment data (×ª×•×¡×¤×•×ª ×•×”×•×¨×“×•×ª)
      const adjustmentsData = {
        features: [],
        registration: [],
        estimate: [],
        full_market: []
      };
      
      // Collect feature adjustments (×ª×•×¡×¤×•×ª ×××¤×™×™× ×™×)
      const featureRows = document.querySelectorAll('#featuresAdjustmentsList > div');
      featureRows.forEach(row => {
        const inputs = row.querySelectorAll('input, select');
        if (inputs.length >= 4) {
          adjustmentsData.features.push({
            description: inputs[0].value,
            type: inputs[1].value,
            percentage: parseFloat(inputs[2].value) || 0,
            value: parseFloat(inputs[3].value.replace(/[â‚ª,]/g, '')) || 0
          });
        }
      });
      
      // Collect registration adjustments (×¢×œ×™×” ×œ×›×‘×™×©)
      const registrationRows = document.querySelectorAll('#registrationAdjustmentsList > div');
      registrationRows.forEach(row => {
        const inputs = row.querySelectorAll('input, select');
        if (inputs.length >= 4) {
          adjustmentsData.registration.push({
            description: inputs[0].value,
            type: inputs[1].value,
            percentage: parseFloat(inputs[2].value) || 0,
            value: parseFloat(inputs[3].value.replace(/[â‚ª,]/g, '')) || 0
          });
        }
      });
      
      // Collect estimate adjustments (×”×ª×××•×ª ××•××“×Ÿ)
      const estimateRows = document.querySelectorAll('#allAdjustmentsRows-estimate div[data-source="custom"]');
      estimateRows.forEach(row => {
        const inputs = row.querySelectorAll('input');
        const select = row.querySelector('select');
        if (inputs.length >= 3) {
          adjustmentsData.estimate.push({
            description: inputs[0].value,
            type: select?.value || 'plus',
            percentage: parseFloat(inputs[1].value) || 0,
            value: parseFloat(inputs[2].value.replace(/[â‚ª,]/g, '')) || 0
          });
        }
      });
      
      // Collect full market adjustments (×›×œ ×”×”×ª×××•×ª)
      const fullMarketRows = document.querySelectorAll('#allAdjustments > div');
      fullMarketRows.forEach(row => {
        const inputs = row.querySelectorAll('input');
        const select = row.querySelector('select');
        if (inputs.length >= 3) {
          adjustmentsData.full_market.push({
            description: inputs[0].value,
            type: select?.value || 'plus',
            percentage: parseFloat(inputs[1].value) || 0,
            value: parseFloat(inputs[2].value.replace(/[â‚ª,]/g, '')) || 0
          });
        }
      });
      
      // Collect legal text
      const legalText = document.getElementById('legal-text-content')?.value || '';
      
      // Save to helper using proper functions
      if (typeof updateHelper === 'function') {
        updateHelper('estimate_type', selectedType, 'estimate_builder_save');
        updateHelper('estimate_notes', additionalNotes, 'estimate_builder_save');
        updateHelper('estimate_work_days', garageDays, 'estimate_builder_save');
        updateHelper('estimate_summary', summaryData, 'estimate_builder_save');
        updateHelper('estimate_depreciation', depreciationData, 'estimate_builder_save');
        updateHelper('valuation', { adjustments: adjustmentsData }, 'estimate_builder_save');
        updateHelper('estimate_legal_text', legalText, 'estimate_builder_save');
      } else {
        // ğŸ”§ PHASE 2.4: Fallback - use window.helper (single source)
        if (typeof window.helper === 'object') {
          window.helper.estimate_type = selectedType;
          window.helper.estimate_notes = additionalNotes;
          window.helper.estimate_work_days = garageDays;
          window.helper.estimate_summary = summaryData;
          window.helper.estimate_depreciation = depreciationData;
          
          // Initialize valuation object if it doesn't exist
          if (!window.helper.valuation) {
            window.helper.valuation = {};
          }
          window.helper.valuation.adjustments = adjustmentsData;
          
          window.helper.estimate_legal_text = legalText;
          
          // Save to primary storage only
          try {
            sessionStorage.setItem('helper', JSON.stringify(window.helper));
            console.log('âš ï¸ PHASE 2.4: Estimate data saved via emergency fallback');
          } catch(e) {
            console.error('âŒ PHASE 2.4: Failed to save estimate data:', e);
          }
        }
      }
      
      // âœ… BIDIRECTIONAL INTEGRATION: Update builder current state with all estimate data
      updateBuilderCurrentState('estimate_type', selectedType);
      updateBuilderCurrentState('estimate_notes', additionalNotes);
      updateBuilderCurrentState('estimate_work_days', garageDays);
      updateBuilderCurrentState('estimate_summary', summaryData);
      updateBuilderCurrentState('estimate_depreciation', depreciationData);
      updateBuilderCurrentState('estimate_adjustments', adjustmentsData);
      updateBuilderCurrentState('estimate_legal_text', legalText);
      
      alert('××•××“×Ÿ × ×©××¨ ×‘×”×¦×œ×—×”');
    };

    window.previewEstimate = function() {
      // First save all data
      window.saveEstimate();
      
      // Set report type and navigate
      sessionStorage.setItem('selectedReportType', 'estimate');
      window.location.href = 'estimate-validation.html';
    };

    window.generateEstimate = function() {
      // First save all data
      window.saveEstimate();
      
      // Set report type and navigate to final report generation
      sessionStorage.setItem('selectedReportType', 'estimate');
      window.location.href = 'estimate-report-builder.html';
    };

    // Convert various date formats to YYYY-MM-DD for date input
    function convertToDateInputFormat(dateString) {
      if (!dateString) return '';
      
      try {
        // Handle various date formats
        let date;
        
        // If already in YYYY-MM-DD format, return as is
        if (/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
          return dateString;
        }
        
        // Handle DD/MM/YYYY format
        if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateString)) {
          const parts = dateString.split('/');
          const day = parts[0].padStart(2, '0');
          const month = parts[1].padStart(2, '0');
          const year = parts[2];
          return `${year}-${month}-${day}`;
        }
        
        // Handle DD-MM-YYYY format
        if (/^\d{1,2}-\d{1,2}-\d{4}$/.test(dateString)) {
          const parts = dateString.split('-');
          const day = parts[0].padStart(2, '0');
          const month = parts[1].padStart(2, '0');
          const year = parts[2];
          return `${year}-${month}-${day}`;
        }
        
        // Handle DD.MM.YYYY format
        if (/^\d{1,2}\.\d{1,2}\.\d{4}$/.test(dateString)) {
          const parts = dateString.split('.');
          const day = parts[0].padStart(2, '0');
          const month = parts[1].padStart(2, '0');
          const year = parts[2];
          return `${year}-${month}-${day}`;
        }
        
        // Try to parse as a general date
        date = new Date(dateString);
        if (!isNaN(date.getTime())) {
          return date.toISOString().split('T')[0];
        }
        
        return '';
      } catch (error) {
        console.warn('Error converting date:', dateString, error);
        return '';
      }
    }

    // LOAD DATA FROM HELPER
    function loadDataFromHelper() {
      try {
        console.log('ğŸ”„ PHASE 2.4: Loading estimate builder data from helper ONLY (single source)...');
        
        // ğŸ”§ PHASE 2.4: SINGLE SOURCE LOADING - window.helper is authoritative
        const helper = window.helper || {};
        
        // Helper function to get nested values
        const getNestedValue = (obj, path, defaultValue = '') => {
          const keys = path.split('.');
          let current = obj;
          for (const key of keys) {
            if (current && typeof current === 'object' && key in current) {
              current = current[key];
            } else {
              return defaultValue;
            }
          }
          return current || defaultValue;
        };
        
        // Load car details (now editable) and sync vehicle structure
        if (helper.car_details || helper.meta) {
          document.getElementById('carPlate').value = helper.meta?.plate || helper.car_details?.plate || '';
          document.getElementById('carManufacturer').value = helper.car_details?.manufacturer || '';
          document.getElementById('carModel').value = helper.car_details?.model || '';
          document.getElementById('carYear').value = helper.car_details?.year || '';
          document.getElementById('carModelCode').value = helper.car_details?.model_code || helper.vehicle?.model_code || '';
          // Base price from standardized valuation structure (with legacy fallback)
          const rawBasePrice = helper.valuation?.base_price || helper.car_details?.base_price || helper.levi_report?.base_price;
          // Clean any existing currency symbols and parse as number
          const basePrice = rawBasePrice ? parseFloat(String(rawBasePrice).replace(/[â‚ª,]/g, '')) : null;
          document.getElementById('carBasePrice').value = basePrice ? `â‚ª${basePrice.toLocaleString()}` : '';
          
          // Also populate the basicPrice field (marked price field) with levi base price
          const basicPriceField = document.getElementById('basicPrice');
          if (basicPriceField && basePrice) {
            basicPriceField.value = `â‚ª${basePrice.toLocaleString()}`;
          }
          // Market value from standardized vehicle structure (with legacy fallback) 
          const rawMarketValue = helper.vehicle?.market_value || helper.expertise?.calculations?.market_value || helper.valuation?.market_value;
          // Clean any existing currency symbols and parse as number
          const marketValue = rawMarketValue ? parseFloat(String(rawMarketValue).replace(/[â‚ª,]/g, '')) : null;
          document.getElementById('carMarketValue').value = marketValue ? `â‚ª${marketValue.toLocaleString()}` : '';
          // Issue date from standardized case_info structure (with legacy fallback)
          const issueDate = helper.case_info?.issue_date || helper.car_details?.report_date || helper.levi_report?.report_date || '';
          document.getElementById('carReportDate').value = convertToDateInputFormat(issueDate);
          
          // Ensure vehicle structure is populated on load
          const vehicleData = {
            manufacturer: helper.car_details?.manufacturer || helper.vehicle?.manufacturer || '',
            model: helper.car_details?.model || helper.vehicle?.model || '',
            year: helper.car_details?.year || helper.vehicle?.year || '',
            model_code: helper.car_details?.model_code || helper.vehicle?.model_code || '',
            plate_number: helper.meta?.plate || helper.car_details?.plate || helper.vehicle?.plate_number || ''
          };
          
          if (typeof updateHelper === 'function') {
            updateHelper('vehicle', vehicleData, 'estimate_builder_vehicle_load');
          } else {
            // Fallback for compatibility
            helper.vehicle = helper.vehicle || {};
            helper.vehicle.manufacturer = vehicleData.manufacturer;
            helper.vehicle.model = vehicleData.model;
            helper.vehicle.year = vehicleData.year;
            helper.vehicle.model_code = vehicleData.model_code;
            // ğŸ”§ FIELD MAPPING FIX: Use correct helper structure field name
            helper.vehicle.plate = vehicleData.plate_number || vehicleData.plate;
            sessionStorage.setItem('helper', JSON.stringify(helper));
          }
        }
        
        // ğŸ”§ FIELD MAPPING FIX: Use correct helper structure for claims data
        const claimsData = helper.claims_data || {};
        const damageAssessment = helper.damage_assessment?.summary || {};
        const valuation = helper.valuation || {};
        const financials = helper.financials || {};
        
        // Load with proper field mapping priority: manual input > calculated data > valuation data
        document.getElementById('totalClaim').value = claimsData.total_claim || 
          (damageAssessment.total_damage_amount ? `â‚ª${damageAssessment.total_damage_amount.toLocaleString()}` : '') ||
          (financials.totals?.total_compensation ? `â‚ª${financials.totals.total_compensation.toLocaleString()}` : '');
          
        document.getElementById('leviPriceList').value = claimsData.gross_value || 
          (valuation.final_price ? `â‚ª${valuation.final_price.toLocaleString()}` : '') ||
          (valuation.calculations?.market_price?.total ? `â‚ª${valuation.calculations.market_price.total.toLocaleString()}` : '');
          
        document.getElementById('grossPercent').value = claimsData.gross_percent || 
          (damageAssessment.damage_percentage ? `${damageAssessment.damage_percentage}%` : '');
          
        document.getElementById('authorizedClaim').value = claimsData.authorized_claim || 
          (financials.totals?.after_tax ? `â‚ª${financials.totals.after_tax.toLocaleString()}` : '') ||
          (damageAssessment.total_damage_amount ? `â‚ª${damageAssessment.total_damage_amount.toLocaleString()}` : '');
          
        console.log('ğŸ’° PHASE 2.4: Loaded claims data with correct field mapping:', { 
          from_claims_data: claimsData, 
          from_damage_assessment: damageAssessment,
          from_valuation: valuation,
          from_financials: financials
        });
        
        // Update gross market value field with calculated value
        updateGrossMarketValueField();
        
        // Force refresh of all cost displays and calculations
        setTimeout(() => {
          updateAllCostDisplays();
          updateSummaryTotalsFromDamageCenters();
          loadGrossCalculationData(); // Load gross calculation data from helper
        }, 200);
        
        // Load contact data using standardized helper structure - Populate ALL fields from standardized helper structure paths (with legacy fallback)
        document.getElementById('ownerName').value = getNestedValue(helper, 'stakeholders.owner.name') || helper.client?.name || '';
        document.getElementById('ownerAddress').value = getNestedValue(helper, 'stakeholders.owner.address') || helper.client?.address || '';  
        document.getElementById('ownerPhone').value = getNestedValue(helper, 'stakeholders.owner.phone') || helper.client?.phone || '';
        document.getElementById('insuranceCompany').value = getNestedValue(helper, 'stakeholders.insurance.company') || helper.client?.insurance_company || '';
        document.getElementById('insuranceEmail').value = getNestedValue(helper, 'stakeholders.insurance.email') || helper.client?.insurance_email || '';
        document.getElementById('insuranceAgent').value = getNestedValue(helper, 'stakeholders.insurance.agent.name') || helper.client?.insurance_agent || '';
        document.getElementById('agentPhone').value = getNestedValue(helper, 'stakeholders.insurance.agent.phone') || helper.client?.insurance_agent_phone || '';
        document.getElementById('agentEmail').value = getNestedValue(helper, 'stakeholders.insurance.agent.email') || helper.client?.insurance_agent_email || '';
        
        console.log('âœ… All contact fields populated FROM helper structure');
          
        // Sync data to both standardized and legacy structures for compatibility
        const carDetailsData = {
          owner: getNestedValue(helper, 'stakeholders.owner.name') || helper.client?.name || '',
          ownerAddress: getNestedValue(helper, 'stakeholders.owner.address') || helper.client?.address || '',
          ownerPhone: getNestedValue(helper, 'stakeholders.owner.phone') || helper.client?.phone || '',
          insuranceCompany: getNestedValue(helper, 'stakeholders.insurance.company') || helper.client?.insurance_company || '',
          agentName: getNestedValue(helper, 'stakeholders.insurance.agent.name') || helper.client?.insurance_agent || '',
          insurance_agent_phone: getNestedValue(helper, 'stakeholders.insurance.agent.phone') || helper.client?.insurance_agent_phone || '',
          insurance_agent_email: getNestedValue(helper, 'stakeholders.insurance.agent.email') || helper.client?.insurance_agent_email || '',
          // Note: garageName and garagePhone are not in the builder, so they'll remain empty
          garageName: helper.car_details?.garageName || '',
          garagePhone: helper.car_details?.garagePhone || ''
        };
        
        if (typeof updateHelper === 'function') {
          updateHelper('car_details', carDetailsData, 'estimate_builder_contact_sync');
        } else {
          // Fallback for compatibility
          helper.car_details = helper.car_details || {};
          Object.assign(helper.car_details, carDetailsData);
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        
        // Update page title with plate
        // Apply plate standardization (remove dashes for Israeli format XXXXXXXX)
        const rawPlate = helper.meta?.plate || helper.car_details?.plate || '...';
        const standardizedPlate = rawPlate !== '...' ? String(rawPlate).replace(/[-\s]/g, '') : rawPlate;
        document.getElementById('pageTitle').textContent = `×¨×›×‘ ××¡. ${standardizedPlate}`;
        
        // Load summary data
        loadSummaryData(helper);
        
        // Load depreciation data
        loadDepreciationData(helper);
        
        // Load garage days data
        if (helper.estimate_work_days || helper.expertise?.depreciation?.work_days) {
          document.getElementById('garageDays').value = helper.estimate_work_days || helper.expertise?.depreciation?.work_days || '';
        }
        
        // Load damage centers summary
        loadDamageCentersSummary(helper);
        
        // Load features and registration adjustments for gross calculation
        loadGrossAdjustments(helper);
        
        // Load all adjustments (Levi + custom) using unified system
        loadAllAdjustments(helper);
        
        // Note: addFieldChangeListeners() is called in DOMContentLoaded event
        
      } catch (error) {
        console.error('Error loading data from helper:', error);
      }
    }

    // LOAD SUMMARY DATA AND CALCULATIONS
    function loadSummaryData(helper) {
      try {
        // Set report type based on estimate type selection
        const selectedType = document.querySelector('input[name="estimate-type"]:checked')?.value || '××•×‘×“×Ÿ_×œ×”×œ×›×”';
        const reportTypeText = selectedType === '××•×‘×“×Ÿ_×œ×”×œ×›×”' ? '××•××“×Ÿ ×¨××©×•× ×™ - ××•×‘×“×Ÿ ×œ×”×œ×›×”' : '××•××“×Ÿ ×¨××©×•× ×™ - ×˜×•×˜×œ×•×¡';
        document.getElementById('reportType').value = reportTypeText;
        
        // Check if we have saved summary data first
        if (helper.estimate_summary) {
          document.getElementById('sumMarketValue').value = helper.estimate_summary.market_value || '';
          document.getElementById('sumClaim').value = helper.estimate_summary.total_claim || '';
          document.getElementById('sumVAT').value = helper.estimate_summary.vat || '';
          document.getElementById('sumTotalClaim').value = helper.estimate_summary.total_with_vat || '';
          document.getElementById('depCompensation').value = helper.estimate_summary.dep_compensation || '';
          document.getElementById('salvageValue').value = helper.estimate_summary.salvage_value || '';
        } else {
          // Load from helper calculations if no saved summary
          const marketValue = helper.expertise?.calculations?.market_value || 0;
          const totalClaim = helper.expertise?.calculations?.total_damage || 0;
          
          // Set market value and claim
          document.getElementById('sumMarketValue').value = marketValue ? `â‚ª${marketValue.toLocaleString()}` : '';
          document.getElementById('sumClaim').value = totalClaim ? `â‚ª${totalClaim.toLocaleString()}` : '';
          
          // Calculate VAT (18%)
          const vat = totalClaim * 0.18;
          document.getElementById('sumVAT').value = vat ? `â‚ª${Math.round(vat).toLocaleString()}` : '';
          
          // Calculate total with VAT
          const totalWithVAT = totalClaim + vat;
          document.getElementById('sumTotalClaim').value = totalWithVAT ? `â‚ª${Math.round(totalWithVAT).toLocaleString()}` : '';
          
          // Set depreciation compensation
          const depCompensation = helper.expertise?.calculations?.depreciation_compensation || 0;
          document.getElementById('depCompensation').value = depCompensation ? `â‚ª${depCompensation.toLocaleString()}` : '';
        }
        
        // Load saved estimate notes if available
        if (helper.estimate_notes) {
          document.getElementById('additional-notes').value = helper.estimate_notes;
        }
        
        // Add event listeners for real-time calculations
        addSummaryCalculationListeners();
        
        // TRIGGER INITIAL AUTO-FILL FOR SUMMARY FIELDS
        setTimeout(() => {
          if (window.addSummaryCalculationListeners) {
            const calculateEvent = new Event('input', { bubbles: true });
            
            // Trigger auto-fill from totalClaim to sumClaim
            const totalClaimField = document.getElementById('totalClaim');
            if (totalClaimField && totalClaimField.value) {
              totalClaimField.dispatchEvent(calculateEvent);
            }
            
            // Trigger auto-fill from globalDepValue to depCompensation
            const globalDepField = document.getElementById('globalDepValue');
            if (globalDepField && globalDepField.value) {
              globalDepField.dispatchEvent(calculateEvent);
            }
          }
        }, 200);
        
      } catch (error) {
        console.error('Error loading summary data:', error);
      }
    }

    // ADD CALCULATION LISTENERS FOR SUMMARY WITH MATH.JS - CORRECTED LOGIC
    function addSummaryCalculationListeners() {
      const sumMarketValueInput = document.getElementById('sumMarketValue');
      const sumClaimInput = document.getElementById('sumClaim');
      const depCompensationInput = document.getElementById('depCompensation');
      const sumVATInput = document.getElementById('sumVAT');
      const sumTotalInput = document.getElementById('sumTotalClaim');

      function calculateSummaryTotals() {
        try {
          // Auto-fill market value from car details market price
          const carMarketValue = document.getElementById('carMarketValue')?.value.replace(/[â‚ª,]/g, '') || '0';
          if (carMarketValue && carMarketValue !== '0' && sumMarketValueInput) {
            sumMarketValueInput.value = `â‚ª${parseFloat(carMarketValue).toLocaleString()}`;
          }
          
          // AUTO-FILL SUMMARY CLAIM FROM CLAIMS SECTION
          const totalClaimValue = document.getElementById('totalClaim')?.value;
          if (totalClaimValue && sumClaimInput) {
            sumClaimInput.value = totalClaimValue;
          }
          
          // AUTO-FILL DEPRECIATION COMPENSATION FROM GLOBAL DEPRECIATION VALUE
          const globalDepValue = document.getElementById('globalDepValue')?.value;
          if (globalDepValue && depCompensationInput) {
            depCompensationInput.value = globalDepValue;
          }
          
          // Get values - market price + claim + compensation - salvage = total
          const marketValue = parseFloat(sumMarketValueInput?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
          const claimValue = parseFloat(sumClaimInput?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
          const depValue = parseFloat(depCompensationInput?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
          const salvageValue = parseFloat(document.getElementById('salvageValue')?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
          
          // Calculate subtotal: claim + compensation - salvage value = subtotal (market price is separate)
          const subtotal = claimValue + depValue - salvageValue;
          
          // Automatic calculation with math.js - Calculate VAT (18% on subtotal)
          const vatRate = 0.18;
          const vat = Math.round(subtotal * vatRate);
          
          // Calculate final total (subtotal + VAT) - automatic calculation with math.js
          const total = subtotal + vat;
          
          // Update readonly fields with formatted values - auto-filled from relevant fields
          if (sumVATInput) {
            sumVATInput.value = vat ? `â‚ª${vat.toLocaleString()}` : '';
            sumVATInput.readOnly = true;
            sumVATInput.style.background = '#f4f6fa';
          }
          
          if (sumTotalInput) {
            sumTotalInput.value = total ? `â‚ª${total.toLocaleString()}` : '';
            sumTotalInput.readOnly = true;
            sumTotalInput.style.background = '#e8f5e8';
          }
          
        } catch (error) {
          console.error('Error in summary calculations:', error);
        }
      }

      // Add listeners to trigger calculations for all relevant fields
      if (sumMarketValueInput) {
        sumMarketValueInput.addEventListener('input', calculateSummaryTotals);
      }
      if (sumClaimInput) {
        sumClaimInput.addEventListener('input', calculateSummaryTotals);
      }
      if (depCompensationInput) {
        depCompensationInput.addEventListener('input', calculateSummaryTotals);
      }
      
      // Auto-update when car market value changes
      const carMarketValueInput = document.getElementById('carMarketValue');
      if (carMarketValueInput) {
        carMarketValueInput.addEventListener('input', () => {
          calculateSummaryTotals();
          triggerGlobalDepreciationCalc(); // Recalculate global depreciation when market value changes
        });
      }
      
      // Auto-update when summary market value changes
      if (sumMarketValueInput) {
        sumMarketValueInput.addEventListener('input', () => {
          calculateSummaryTotals();
          triggerGlobalDepreciationCalc(); // Recalculate global depreciation when market value changes
        });
      }
      
      // ADD EVENT LISTENERS FOR SOURCE FIELDS TO AUTO-UPDATE SUMMARY
      const totalClaimInput = document.getElementById('totalClaim');
      if (totalClaimInput) {
        totalClaimInput.addEventListener('input', calculateSummaryTotals);
      }
      
      const globalDepValueInput = document.getElementById('globalDepValue');
      if (globalDepValueInput) {
        globalDepValueInput.addEventListener('input', calculateSummaryTotals);
      }
      
      // ADD EVENT LISTENER FOR SALVAGE VALUE TO TRIGGER RECALCULATION
      const salvageValueInput = document.getElementById('salvageValue');
      if (salvageValueInput) {
        salvageValueInput.addEventListener('input', calculateSummaryTotals);
      }
      
      // Add listeners for custom additions if they exist
      function addCustomFieldListeners() {
        const customFields = document.querySelectorAll('#sumAdditionsGridEstimate input');
        customFields.forEach(field => {
          field.addEventListener('input', calculateSummaryTotals);
        });
      }
      
      // Initial calculation and setup
      calculateSummaryTotals();
      addCustomFieldListeners();
      
      // Re-add listeners when custom fields are added
      const originalAddField = window.addCustomSummaryField;
      window.addCustomSummaryField = function(summaryType) {
        originalAddField(summaryType);
        setTimeout(addCustomFieldListeners, 100);
      };
    }

    // LOAD DEPRECIATION DATA
    function loadDepreciationData(helper) {
      try {
        console.log('ğŸ”„ loadDepreciationData called with helper:', helper);
        console.log('ğŸ”„ helper.estimate_depreciation:', helper.estimate_depreciation);
        
        // Load saved depreciation data if available
        if (helper.estimate_depreciation) {
          console.log('âœ… Found saved depreciation data, loading it');
          // Load global depreciation
          document.getElementById('globalDep1').value = helper.estimate_depreciation.global_percent || '';
          document.getElementById('globalDepValue').value = helper.estimate_depreciation.global_value || '';
          
          // Load bulk depreciation table
          if (helper.estimate_depreciation.bulk_items) {
            // Clear existing rows to prevent duplication
            const depreciationContainer = document.getElementById('depreciationBulkTable');
            if (depreciationContainer) {
              depreciationContainer.innerHTML = '';
            }
            
            helper.estimate_depreciation.bulk_items.forEach(item => {
              console.log('ğŸ”„ Loading depreciation item:', item);
              addDepField(item);
            });
            
            // Add auto-calculation to all existing rows after loading
            setTimeout(() => {
              addAutoCalculationToExistingRows();
            }, 100);
          }
        } else {
          console.log('âŒ No saved depreciation data, trying to populate from damage centers');
          // If no saved depreciation data, populate from damage centers
          const damageCenterNames = [];
          
          // Try multiple possible data structures for damage centers
          console.log('ğŸ” Full helper structure:', JSON.stringify(helper, null, 2));
          console.log('ğŸ” Checking helper.expertise?.damage_blocks:', helper.expertise?.damage_blocks);
          console.log('ğŸ” Checking helper.damage_blocks:', helper.damage_blocks);
          console.log('ğŸ” Checking helper.expertise?.damage_centers:', helper.expertise?.damage_centers);
          console.log('ğŸ” Checking helper.damage_centers:', helper.damage_centers);
          
          // Extract damage center names from helper data - try multiple structures
          if (helper.expertise?.damage_blocks) {
            console.log('ğŸ” Found damage_blocks in expertise');
            helper.expertise.damage_blocks.forEach(block => {
              console.log('ğŸ” Processing damage block:', block);
              const centerName = block.damage_center_name || block.name || block.center_name || `××•×§×“ × ×–×§`;
              console.log('ğŸ” Center name:', centerName);
              if (centerName && !damageCenterNames.includes(centerName)) {
                damageCenterNames.push(centerName);
              }
            });
          } else if (helper.damage_blocks) {
            console.log('ğŸ” Found damage_blocks in root');
            helper.damage_blocks.forEach(block => {
              console.log('ğŸ” Processing damage block:', block);
              const centerName = block.damage_center_name || block.name || block.center_name || `××•×§×“ × ×–×§`;
              console.log('ğŸ” Center name:', centerName);
              if (centerName && !damageCenterNames.includes(centerName)) {
                damageCenterNames.push(centerName);
              }
            });
          } else if (helper.expertise?.damage_centers) {
            console.log('ğŸ” Found damage_centers in expertise');
            helper.expertise.damage_centers.forEach(center => {
              console.log('ğŸ” Processing damage center:', center);
              const centerName = center.name || center.center_name || center.damage_center_name || `××•×§×“ × ×–×§`;
              console.log('ğŸ” Center name:', centerName);
              if (centerName && !damageCenterNames.includes(centerName)) {
                damageCenterNames.push(centerName);
              }
            });
          } else if (helper.damage_centers) {
            console.log('ğŸ” Found damage_centers in root');
            helper.damage_centers.forEach(center => {
              console.log('ğŸ” Processing damage center:', center);
              const centerName = center.name || center.center_name || center.damage_center_name || `××•×§×“ × ×–×§`;
              console.log('ğŸ” Center name:', centerName);
              if (centerName && !damageCenterNames.includes(centerName)) {
                damageCenterNames.push(centerName);
              }
            });
          }
          
          console.log('ğŸ” Extracted damage center names:', damageCenterNames);
          
          // If we have damage center names, populate depreciation section
          if (damageCenterNames.length > 0) {
            console.log('ğŸ”„ Populating depreciation from damage centers:', damageCenterNames);
            updateDepreciationFromDamageCenters(damageCenterNames);
          } else {
            console.log('âŒ No damage center names found to populate depreciation');
          }
        }
      } catch (error) {
        console.error('Error loading depreciation data:', error);
      }
    }

    // ESTIMATE-SPECIFIC DAMAGE CENTERS LOADING FUNCTION
    function loadDamageCentersSummary(helper) {
      try {
        const damageCentersContent = document.getElementById('damageCentersContent');
        
        // ESTIMATE WORKFLOW: Load from multiple sources with preference for estimate data
        let damageData = null;
        
        // First priority: Load from estimate data if exists
        if (helper.estimate?.damage_centers && helper.estimate.damage_centers.length > 0) {
          damageData = helper.estimate.damage_centers.map(center => ({
            damage_center_name: center.center_name,
            area_name: center.center_location,
            description: center.damage_description,
            parts: center.estimated_parts?.map(p => ({
              name: p.name,
              desc: p.description,
              price: p.estimated_cost,
              source: p.source
            })) || [],
            works: center.estimated_works?.map(w => ({
              type: w.work_type,
              note: w.work_notes,
              cost: w.estimated_cost
            })) || [],
            repairs: center.estimated_repairs?.map(r => ({
              description: r.repair_description,
              cost: r.estimated_cost
            })) || [],
            parts_cost: center.costs_breakdown?.parts_cost || 0,
            work_cost: center.costs_breakdown?.work_cost || 0,
            repairs_cost: center.costs_breakdown?.repairs_cost || 0
          }));
          console.log('ğŸ“Š Loading estimate damage centers from helper.estimate.damage_centers');
        }
        // Second priority: Load from helper.centers (source data)
        else if (helper.centers && helper.centers.length > 0) {
          damageData = helper.centers.map(center => ({
            damage_center_name: center.Location || `××•×§×“ × ×–×§ ${center['Damage center Number'] || ''}`,
            area_name: center.Location,
            description: center.Description,
            parts: center.Parts?.parts_required?.map(p => ({
              name: p.name,
              desc: p.desc,
              price: p.price,
              source: p.source
            })) || [],
            works: center.Works?.works?.map(w => ({
              type: w.type,
              note: w.note,
              cost: w.cost
            })) || [],
            repairs: center.Repairs?.repairs?.map(r => ({
              description: r.description,
              cost: r.cost
            })) || [],
            parts_cost: center.Parts?.parts_meta?.total_cost || 0,
            work_cost: center.Works?.works_meta?.total_cost || 0,
            repairs_cost: center.Repairs?.repairs_meta?.total_cost || 0
          }));
          console.log('ğŸ“‹ Loading damage centers from helper.centers (source data)');
        }
        // Third priority: Load from damage_blocks (compatibility)
        else if (helper.expertise?.damage_blocks && helper.expertise.damage_blocks.length > 0) {
          damageData = helper.expertise.damage_blocks;
          console.log('ğŸ”„ Loading from helper.expertise.damage_blocks (compatibility)');
        }
        
        if (damageData && damageData.length > 0) {
          let summaryHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters">';
          
          damageData.forEach((block, index) => {
            summaryHTML += createEditableDamageCenterCard(block, index);
          });
          
          summaryHTML += '</div>';
          
          // Add damage centers totals summary container
          summaryHTML += createDamageCentersSubtotal();
          
          damageCentersContent.innerHTML = summaryHTML;
          
          // Add event listeners after HTML is created
          setTimeout(addDamageCenterEventListeners, 100);
          
          // Update totals display after data is loaded
          setTimeout(updateDamageCentersSubtotal, 200);
          
          console.log(`âœ… Loaded ${damageData.length} damage centers for estimate`);
          
        } else {
          // When no damage centers exist, show empty state with totals container and add button
          let emptyStateHTML = '<div style="color: #666; text-align: center;">×œ× × ××¦××• × ×ª×•× ×™ ××•×§×“×™ × ×–×§</div>';
          emptyStateHTML += '<div style="display: grid; gap: 15px;" id="editableDamageCenters"></div>';
          emptyStateHTML += createDamageCentersSubtotal();
          damageCentersContent.innerHTML = emptyStateHTML;
          
          // Update totals display (should show all zeros)
          setTimeout(updateDamageCentersSubtotal, 200);
          
          console.log('â„¹ï¸ No damage centers found, showing empty state with totals container');
        }
      } catch (error) {
        console.error('âŒ Error loading estimate damage centers summary:', error);
        document.getElementById('damageCentersContent').innerHTML = '<div style="color: #dc3545; text-align: center;">×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™ ××•×§×“×™ × ×–×§</div>';
      }
    }

    // CREATE EDITABLE DAMAGE CENTER CARD
    function createEditableDamageCenterCard(block, index) {
      
      const centerNum = block.damage_center_number || (index + 1);
      const centerLocation = block.damage_center_name || block.Location || `××•×§×“ × ×–×§ ${centerNum}`;
      const workCosts = block.work_cost || 0;
      const partsCosts = block.parts_cost || 0;
      const repairsCosts = workCosts + partsCosts;
      const totalWithVAT = repairsCosts * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100);
      
      // Get existing parts, works, repairs from block
      const parts = block.parts || [];
      const works = block.works || [];
      const repairs = block.repairs || [];
      
      console.log(`ğŸ”§ Card ${index} data - Parts: ${parts.length}, Works: ${works.length}, Repairs: ${repairs.length}`);
      console.log(`ğŸ“‹ Parts content:`, parts);
      console.log(`ğŸ”¨ Works content:`, works);
      
      return `
        <div class="editable-damage-card" data-center-index="${index}" style="background: white; border-radius: 8px; padding: 15px; border: 1px solid #e2e8f0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <!-- Card Header -->
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="font-weight: bold; color: #1e3a8a; font-size: 16px;">××•×§×“ × ×–×§ ××¡'</span>
              <input type="text" value="${centerNum}" class="damage-center-number" style="font-weight: bold; color: #1e3a8a; font-size: 16px; border: 1px solid #ddd; padding: 8px; border-radius: 4px; width: 50px; text-align: center;" />
            </div>
            <button onclick="removeDamageCenter(${index})" style="background: #dc3545; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">××—×§</button>
          </div>
          
          <!-- Damage Center Location Field -->
          <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #1e3a8a;">×©× ××•×§×“ ×”× ×–×§:</label>
            <input type="text" class="damage-center-location" style="width: 100%; border: 1px solid #ddd; padding: 8px; border-radius: 4px; font-size: 14px;" placeholder="×”×–×Ÿ ×©×/××™×–×•×¨ ××•×§×“ ×”× ×–×§ (×œ×“×•×’××”: ×¤×’×•×© ×§×“××™, ×“×œ×ª × ×”×’, ×•×›×•')" value="${centerLocation}" />
          </div>
          
          <!-- Damage Description Field -->
          <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #1e3a8a;">×ª×™××•×¨ ×”× ×–×§:</label>
            <textarea class="damage-center-description" style="width: 100%; min-height: 60px; border: 1px solid #ddd; padding: 8px; border-radius: 4px; font-size: 14px; resize: vertical;" placeholder="×”×–×Ÿ ×ª×™××•×¨ ××¤×•×¨×˜ ×©×œ ×”× ×–×§ ×‘××•×§×“ ×–×”...">${block.description || ''}</textarea>
          </div>

          <!-- Parts Section (Full Width Row) -->
          <div style="border: 1px solid #e2e8f0; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
            <h4 style="margin: 0 0 10px 0; color: #1e3a8a;">×—×œ×§×™× × ×“×¨×©×™×:</h4>
            <div class="parts-list" data-center="${index}">
              ${parts.map((part, partIndex) => createEditablePartRow(part, index, partIndex)).join('')}
            </div>
            <button onclick="addPartRow(${index})" class="btn" style="background: #28a745; color: white; padding: 6px 12px; margin-top: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">×”×•×¡×£ ×—×œ×§</button>
          </div>

          <!-- Works Section (Full Width Row) -->
          <div style="border: 1px solid #e2e8f0; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
            <h4 style="margin: 0 0 10px 0; color: #1e3a8a;">×¢×‘×•×“×•×ª × ×“×¨×©×•×ª:</h4>
            <div class="works-list" data-center="${index}">
              ${works.map((work, workIndex) => createEditableWorkRow(work, index, workIndex)).join('')}
            </div>
            <button onclick="addWorkRow(${index})" class="btn" style="background: #17a2b8; color: white; padding: 6px 12px; margin-top: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">×”×•×¡×£ ×¢×‘×•×“×”</button>
          </div>

          <!-- Repairs Section (Full Width Row) -->
          <div style="border: 1px solid #e2e8f0; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
            <h4 style="margin: 0 0 10px 0; color: #1e3a8a;">×ª×™×§×•× ×™× × ×“×¨×©×™×:</h4>
            <div class="repairs-list" data-center="${index}">
              ${repairs.map((repair, repairIndex) => createEditableRepairRow(repair, index, repairIndex)).join('')}
            </div>
            <button onclick="addRepairRow(${index})" class="btn" style="background: #ffc107; color: #212529; padding: 6px 12px; margin-top: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">×”×•×¡×£ ×ª×™×§×•×Ÿ</button>
          </div>

          <!-- Cost Summary (Auto-calculated) -->
          <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; border: 1px solid #e2e8f0;">
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; font-size: 14px;">
              <div><strong>×¢×‘×•×“×•×ª:</strong> <span class="work-costs-display">â‚ª${workCosts.toLocaleString()}</span></div>
              <div><strong>×—×œ×¤×™×:</strong> <span class="parts-costs-display">â‚ª${partsCosts.toLocaleString()}</span></div>
              <div><strong>×ª×™×§×•× ×™×:</strong> <span class="repairs-costs-display">â‚ª${repairsCosts.toLocaleString()}</span></div>
              <div><strong>×›×•×œ×œ ××¢"×:</strong> <span class="total-with-vat-display">â‚ª${Math.round(totalWithVAT).toLocaleString()}</span></div>
            </div>
          </div>
        </div>
      `;
    }

    // CREATE EDITABLE PART ROW WITH SEARCH DROPDOWN
    function createEditablePartRow(part, centerIndex, partIndex) {
      const partName = part?.name || '';
      const partDesc = part?.desc || part?.description || part?.×ª×™××•×¨ || '';
      const partPrice = part?.price || 0;
      const partSource = part?.source || part?.××§×•×¨ || '';
      
      return `
        <div class="part-row" data-center="${centerIndex}" data-part="${partIndex}" style="display: grid; grid-template-columns: 2fr 2fr 1fr auto; gap: 8px; margin-bottom: 8px; padding: 8px; background: #f9f9f9; border-radius: 4px;">
          <div style="position: relative;">
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">×©× ×”×—×œ×§:</label>
            <input type="text" value="${partName}" placeholder="×©× ×”×—×œ×§" class="part-name" 
                   style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"
                   onkeyup="showPartSuggestions(this, ${centerIndex}, ${partIndex})" />
            <div class="part-suggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ddd; border-top: none; border-radius: 0 0 4px 4px; display: none; z-index: 1000; max-height: 200px; overflow-y: auto;"></div>
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">×ª×™××•×¨:</label>
            <input type="text" value="${partDesc}" placeholder="×ª×™××•×¨ ×”×—×œ×§" class="part-desc" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">×¢×œ×•×ª (â‚ª):</label>
            <input type="number" value="${partPrice}" placeholder="0" class="part-price" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" min="0" step="0.01" onchange="updateDamageCentersSubtotal()" oninput="updateDamageCentersSubtotal()" />
          </div>
          <button onclick="removePartRow(${centerIndex}, ${partIndex})" style="background: #dc3545; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; align-self: end;">××—×§</button>
          <input type="hidden" value="${partSource}" class="part-source" />
        </div>
      `;
    }

    // CREATE EDITABLE WORK ROW WITH DROPDOWN
    function createEditableWorkRow(work, centerIndex, workIndex) {
      const workTypes = [
        '×›×œ ×¢×‘×•×“×•×ª ×”×¤×—×—×•×ª ×›×•×œ×œ ×¤×™×¨×•×§×™× ×•×”×¨×›×‘×•×ª','×¢×‘×•×“×•×ª ×¦×‘×¢', '×¢×‘×•×“×•×ª ×—×©××œ', '×¢×‘×•×“×•×ª ××›×•× ××•×ª', 
        '×¢×‘×•×“×•×ª ××–×’×Ÿ', '×¢×‘×•×“×•×ª ×¨×™×¤×•×“', '×¢×‘×•×“×•×ª ×–×’×’×•×ª',
        '××™×˜×•× ×•×–×™×¤×•×ª', '×‘×“×™×§×ª ××ª×œ×”', '×”× ×–×§ ××—×™×™×‘ ×ª×§× ×” 309',
        '×›×™×•×œ ×¨×“××¨', '×”×¢×‘×¨×ª ×—×™×™×©× ×™×', '××—×¨'
      ];
      
      const workType = typeof work === 'object' ? (work.category || work.type) : work;
      const workNote = typeof work === 'object' ? (work.comments || work.note || '') : '';
      const workCost = typeof work === 'object' ? work.cost : 0;
      
      return `
        <div class="work-row" data-center="${centerIndex}" data-work="${workIndex}" style="display: grid; grid-template-columns: 2fr 2fr 1fr auto; gap: 8px; margin-bottom: 8px; padding: 8px; background: #f9f9f9; border-radius: 4px;">
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">×¡×•×’ ×¢×‘×•×“×”:</label>
            <select class="work-type" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" onchange="handleWorkTypeChange(this, ${centerIndex}, ${workIndex})">
              ${workTypes.map(type => `<option value="${type}" ${type === workType ? 'selected' : ''}>${type}</option>`).join('')}
            </select>
            <input type="text" class="work-type-other" placeholder="×”×›× ×¡ ×¡×•×’ ×¢×‘×•×“×” ××—×¨" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; margin-top: 4px; display: ${workType === '××—×¨' ? 'block' : 'none'};" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">×”×¢×¨×•×ª:</label>
            <input type="text" value="${workNote}" placeholder="×”×¢×¨×•×ª × ×•×¡×¤×•×ª" class="work-note" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">×¢×œ×•×ª (â‚ª):</label>
            <input type="number" value="${workCost}" placeholder="0" class="work-cost" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" min="0" step="0.01" onchange="updateDamageCentersSubtotal()" oninput="updateDamageCentersSubtotal()" />
          </div>
          <button onclick="removeWorkRow(${centerIndex}, ${workIndex})" style="background: #dc3545; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; align-self: end;">××—×§</button>
        </div>
      `;
    }

    // CREATE EDITABLE REPAIR ROW
    function createEditableRepairRow(repair, centerIndex, repairIndex) {
      const repairText = typeof repair === 'object' ? repair.description : repair;
      const repairCost = typeof repair === 'object' ? repair.cost : 0;
      
      return `
        <div class="repair-row" data-center="${centerIndex}" data-repair="${repairIndex}" style="display: grid; grid-template-columns: 3fr 1fr auto; gap: 8px; margin-bottom: 8px; padding: 8px; background: #f9f9f9; border-radius: 4px;">
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">×ª×™××•×¨ ×”×ª×™×§×•×Ÿ:</label>
            <textarea placeholder="×ª×™××•×¨ ×”×ª×™×§×•×Ÿ" class="repair-text" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; min-height: 60px; resize: vertical;">${repairText}</textarea>
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">×¢×œ×•×ª (â‚ª):</label>
            <input type="number" value="${repairCost}" placeholder="0" class="repair-cost" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" min="0" step="0.01" onchange="updateDamageCentersSubtotal()" oninput="updateDamageCentersSubtotal()" />
          </div>
          <button onclick="removeRepairRow(${centerIndex}, ${repairIndex})" style="background: #dc3545; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; height: 32px; margin-top: 14px;">××—×§</button>
        </div>
      `;
    }

    // LOAD LEVI ADJUSTMENTS
    // UNIFIED ADJUSTMENTS SYSTEM - Combines Levi adjustments and custom additions
    // Debounce mechanism to prevent duplicate loading
    let loadAdjustmentsTimeout;
    
    // CRITICAL FIX: Function to clean up duplicate data in helper
    function cleanupHelperDuplicates(helper) {
      try {
        // Clean up levi_report adjustments
        if (helper.levi_report?.adjustments) {
          const seenAdjustments = new Set();
          const cleanedAdjustments = [];
          
          helper.levi_report.adjustments.forEach(adj => {
            const key = `${adj.description}-${adj.value}-${adj.percent}`;
            if (!seenAdjustments.has(key)) {
              seenAdjustments.add(key);
              cleanedAdjustments.push(adj);
            }
          });
          
          const removedCount = helper.levi_report.adjustments.length - cleanedAdjustments.length;
          if (removedCount > 0) {
            console.log(`ğŸ§¹ Removed ${removedCount} duplicate levi_report adjustments`);
          }
          
          helper.levi_report.adjustments = cleanedAdjustments;
        }
        
        // Clean up custom adjustments
        if (helper.levi?.custom_adjustments) {
          const seenCustom = new Set();
          const cleanedCustom = [];
          
          helper.levi.custom_adjustments.forEach(adj => {
            const key = `${adj.description}-${adj.value}-${adj.percentage}`;
            if (!seenCustom.has(key)) {
              seenCustom.add(key);
              cleanedCustom.push(adj);
            }
          });
          
          const removedCustomCount = helper.levi.custom_adjustments.length - cleanedCustom.length;
          if (removedCustomCount > 0) {
            console.log(`ğŸ§¹ Removed ${removedCustomCount} duplicate custom adjustments`);
          }
          
          helper.levi.custom_adjustments = cleanedCustom;
        }
        
        return helper;
      } catch (error) {
        console.error('Error cleaning helper duplicates:', error);
        return helper;
      }
    }
    
    function loadAllAdjustments(helper) {
      try {
        // Get caller information for debugging
        const caller = new Error().stack.split('\n')[2].trim();
        console.log('ğŸ”„ loadAllAdjustments called (will be debounced) from:', caller);
        
        // Clear any existing timeout to prevent duplicate calls
        if (loadAdjustmentsTimeout) {
          clearTimeout(loadAdjustmentsTimeout);
          console.log('âš ï¸ Cleared previous loadAllAdjustments timeout');
        }
        
        // Debounce the loading to prevent rapid multiple calls
        loadAdjustmentsTimeout = setTimeout(() => {
          loadAllAdjustmentsImmediate(helper);
        }, 100);
        
      } catch (error) {
        console.error('Error in loadAllAdjustments debounce:', error);
      }
    }
    
    // TRANSFORM LEVI DATA TO VALUATION STRUCTURE - Critical Data Flow Fix
    function populateValuationAdjustmentsFromLevi(helper) {
      try {
        // Initialize valuation structure if needed
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        
        console.log('ğŸ”„ Transforming Levi data to valuation structure...');
        console.log('Levi adjustments:', helper.levi_report?.adjustments);
        console.log('Current valuation adjustments:', helper.valuation.adjustments);
        
        // If we already have valuation adjustments, don't override (user may have edited)
        const hasExistingData = Object.keys(helper.valuation.adjustments).some(key => 
          helper.valuation.adjustments[key]?.percent || helper.valuation.adjustments[key]?.amount
        );
        
        if (hasExistingData) {
          console.log('âœ… Using existing valuation adjustments (user edited)');
          return;
        }
        
        // Transform Levi adjustments to valuation structure
        // CRITICAL FIX: Check both possible locations for Levi adjustments
        const leviAdjustments = helper.expertise?.levi_report?.adjustments || helper.levi_report?.adjustments;
        
        if (leviAdjustments && Array.isArray(leviAdjustments)) {
          console.log('ğŸ” Found Levi adjustments in:', helper.expertise?.levi_report?.adjustments ? 'helper.expertise.levi_report' : 'helper.levi_report');
          leviAdjustments.forEach(adj => {
            const desc = (adj.description || '').toLowerCase();
            const percentage = adj.percentage || adj.percent || 0;
            const value = adj.value || 0;
            const reason = adj.description || '';
            
            console.log(`ğŸ” Processing Levi adjustment: "${reason}" (${percentage}%, â‚ª${value})`);
            
            // ğŸ”§ FIELD MAPPING FIX: Map to correct helper structure fields
            if (desc.includes('×‘×¢×œ') || desc.includes('×‘×¢×œ×•×ª') || desc.includes('×‘×¢×œ×™× ×§×•×“×')) {
              helper.valuation.adjustments.ownership_type = {
                reason: reason, // ACTUAL description from Levi, not generic category
                percent: percentage,
                amount: value,
                description: reason, // Keep the full detailed description
                detailed_description: reason,
                category: 'ownership_type'
              };
              console.log('ğŸ“Š PHASE 2.4: Fixed field mapping - OWNERSHIP TYPE:', helper.valuation.adjustments.ownership_type);
              
            } else if (desc.includes('×§"×') || desc.includes('×§×™×œ×•××˜×¨') || desc.includes('××¨×—×§') || desc.includes('× ×¡×™×¢×”')) {
              helper.valuation.adjustments.mileage = {
                reason: reason, // ACTUAL description from Levi
                percent: percentage,
                amount: value,
                description: reason, // Keep the full detailed description
                detailed_description: reason,
                category: 'mileage'
              };
              console.log('ğŸ“Š Mapped to MILEAGE with actual description:', helper.valuation.adjustments.mileage);
              
            } else if (desc.includes('×‘×¢×œ×™×') && !desc.includes('×‘×¢×œ×•×ª')) {
              helper.valuation.adjustments.ownership_history = {
                reason: reason, // ACTUAL description from Levi
                percent: percentage,
                amount: value,
                description: reason, // Keep the full detailed description
                detailed_description: reason,
                category: 'num_owners'
              };
              console.log('ğŸ“Š Mapped to NUMBER OF OWNERS with actual description:', helper.valuation.adjustments.ownership_history);
              
            } else if (desc.includes('×××¤×™×™×Ÿ') || desc.includes('×¦×™×•×“') || desc.includes('×ª×•×¡×¤×ª')) {
              // Features go to GROSS section, not market value
              helper.valuation.adjustments.features = {
                reason: reason, // ACTUAL description from Levi
                percent: percentage,
                amount: value,
                description: reason, // Keep the full detailed description
                detailed_description: reason,
                category: 'features'
              };
              console.log('ğŸ“Š Mapped to FEATURES (gross section) with actual description:', helper.valuation.adjustments.features);
              
            } else if (desc.includes('×¨×™×©×•×™') || desc.includes('×¢×œ×™×” ×œ×›×‘×™×©') || desc.includes('×¨×™×©×•×')) {
              // Registration goes to GROSS section, not market value
              helper.valuation.adjustments.registration = {
                reason: reason, // ACTUAL description from Levi
                percent: percentage,
                amount: value,
                description: reason, // Keep the full detailed description
                detailed_description: reason,
                category: 'registration'
              };
              console.log('ğŸ“Š Mapped to REGISTRATION (gross section) with actual description:', helper.valuation.adjustments.registration);
              
            } else {
              // ğŸ”§ FIELD MAPPING FIX: Generic market adjustment - use market_factors field
              if (!helper.valuation.adjustments.market_factors?.percent && !helper.valuation.adjustments.market_factors?.amount) {
                helper.valuation.adjustments.market_factors = {
                  reason: reason || '×”×ª×××ª ×©×•×§ ×›×œ×œ×™×ª',
                  percent: percentage,
                  amount: value,
                  description: reason || '×”×ª×××ª ×©×•×§ ×›×œ×œ×™×ª'
                };
                console.log('ğŸ“Š PHASE 2.4: Fixed field mapping - MARKET FACTORS:', helper.valuation.adjustments.market_factors);
              }
            }
          });
        }
        
        // Save updated helper
        if (typeof updateHelper === 'function') {
          updateHelper('valuation', { adjustments: helper.valuation.adjustments }, 'estimate_builder_levi_transform');
        } else {
          // Fallback for compatibility
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        console.log('âœ… Levi data transformed to valuation structure:', helper.valuation.adjustments);
        
      } catch (error) {
        console.error('âŒ Error transforming Levi data to valuation structure:', error);
      }
    }
    
    function loadAllAdjustmentsImmediate(helper) {
      // SECTION REMOVED: The "×”×ª×××•×ª ××•××“×Ÿ" section has been deleted from the UI
      // This function is now a no-op but kept for compatibility with existing code
      console.log('ğŸ“ Market value adjustments section has been removed from UI');
      
      // Still transform Levi data for other sections that might need it
      populateValuationAdjustmentsFromLevi(helper);
    }
    
    // REMOVED: Market adjustment functions no longer needed since section was deleted
    // These functions were for the deleted "×”×ª×××•×ª ××•××“×Ÿ" section
    
    // REMOVED: All market adjustment functions since the section was deleted
    
    // Create unified adjustment row HTML
    function createAdjustmentRow(params) {
      const { description, percentage, value, source, index, readonly, adjustmentType } = params;
      const rowId = `adjustment-${source}-${index}`;
      
      // Determine type and colors
      let typeLabel, typeColor;
      if (source === 'levi') {
        typeLabel = '×œ×•×™ ×™×¦×—×§';
        typeColor = '#007bff';
      } else {
        // For custom adjustments, use the explicit type or infer from values
        const currentType = adjustmentType || (percentage < 0 || value < 0 ? 'subtraction' : 'addition');
        typeLabel = currentType === 'addition' ? '×ª×•×¡×¤×ª' : '×”×¤×—×ª×”';
        typeColor = currentType === 'addition' ? '#28a745' : '#dc3545';
      }
      
      if (readonly) {
        // Read-only Levi adjustments (5-column layout)
        return `
          <div class="adjustment-row" id="${rowId}" style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr auto; gap: 8px; padding: 8px; border-bottom: 1px solid #e9ecef; background: #f8f9fa;">
            <div style="font-size: 13px;">
              <span style="background: ${typeColor}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 8px;">${typeLabel}</span>
              ${description}
            </div>
            <div style="font-size: 13px; text-align: center; color: ${typeColor}; font-weight: bold;">${typeLabel}</div>
            <div style="font-size: 13px; text-align: center;">${percentage}%</div>
            <div style="font-size: 13px; text-align: center;">â‚ª${value.toLocaleString()}</div>
            <div style="font-size: 11px; color: #666;">×§×¨×™××” ×‘×œ×‘×“</div>
          </div>
        `;
      } else {
        // Editable custom adjustments with type dropdown (5-column layout)
        const currentAdjustmentType = adjustmentType || 'addition';
        return `
          <div class="adjustment-row" id="${rowId}" style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr auto; gap: 8px; padding: 8px; border-bottom: 1px solid #e9ecef;" data-source="${source}" data-loaded-from-helper="true">
            <input type="text" value="${description}" data-field="description" data-source="${source}" data-index="${index}" 
                   style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px;" 
                   placeholder="×ª×™××•×¨ ×”×”×ª×××”" />
            <select data-field="adjustmentType" data-source="${source}" data-index="${index}"
                    style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px; background: white;">
              <option value="addition" ${currentAdjustmentType === 'addition' ? 'selected' : ''} style="color: #28a745;">×ª×•×¡×¤×ª</option>
              <option value="subtraction" ${currentAdjustmentType === 'subtraction' ? 'selected' : ''} style="color: #dc3545;">×”×¤×—×ª×”</option>
            </select>
            <input type="number" value="${Math.abs(percentage)}" data-field="percentage" data-source="${source}" data-index="${index}"
                   style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px; text-align: center;" 
                   placeholder="0" step="0.1" min="0" />
            <input type="number" value="${Math.abs(value)}" data-field="value" data-source="${source}" data-index="${index}"
                   style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px; text-align: center; background: #f8f9fa;" 
                   placeholder="××•×˜×•××˜×™" step="100" min="0" readonly title="××—×•×©×‘ ××•×˜×•××˜×™×ª: ××—×•×– Ã— ××—×™×¨ ×‘×¡×™×¡" />
            <button type="button" onclick="removeCustomAdjustment('${source}', ${index})" 
                    style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">××—×§</button>
          </div>
        `;
      }
    }

    // ADD CUSTOM ADJUSTMENT FIELD - Unified system
    function addCustomAdjustmentField() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Initialize custom adjustments array if it doesn't exist
      const leviData = helper.levi || {};
      const customAdjustments = leviData.custom_adjustments || [];
      
      // Add new empty adjustment with default type
      const newAdjustment = {
        description: '',
        percentage: 0,
        value: 0,
        adjustmentType: 'addition'
      };
      
      customAdjustments.push(newAdjustment);
      const updatedLeviData = { ...leviData, custom_adjustments: customAdjustments };
      
      // Save to helper using proper function
      if (typeof updateHelper === 'function') {
        updateHelper('levi', updatedLeviData, 'estimate_builder_custom_adjustment_add');
      } else {
        // Fallback for compatibility
        helper.levi = updatedLeviData;
        sessionStorage.setItem('helper', JSON.stringify(helper));
      }
      
      // Reload all adjustments to show the new one
      loadAllAdjustments(helper);
      
      console.log('Added new custom adjustment, total custom adjustments:', helper.levi.custom_adjustments.length);
      
      // Ensure event listeners are attached to the new row
      const newIndex = helper.levi.custom_adjustments.length - 1;
      setTimeout(() => {
        console.log('ğŸ†• Setting up new adjustment row with event listeners');
        addAdjustmentEventListeners();
        
        // Focus on the new row's description field
        const newDescriptionInput = document.querySelector(`input[data-field="description"][data-source="custom"][data-index="${newIndex}"]`);
        if (newDescriptionInput) {
          newDescriptionInput.focus();
        }
        
        // Trigger initial calculation if it has a percentage
        const newAdjustment = helper.levi.custom_adjustments[newIndex];
        if (newAdjustment && newAdjustment.percentage !== 0) {
          calculateAdjustmentValue('custom', newIndex, newAdjustment.percentage);
        }
      }, 150);
    }
    
    // REMOVE CUSTOM ADJUSTMENT
    function removeCustomAdjustment(source, index) {
      if (source !== 'custom') return; // Only allow removing custom adjustments
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments[index]) {
        const leviData = { ...helper.levi };
        leviData.custom_adjustments = [...leviData.custom_adjustments];
        leviData.custom_adjustments.splice(index, 1);
        
        // Save using proper helper function
        if (typeof updateHelper === 'function') {
          updateHelper('levi', leviData, 'estimate_builder_custom_adjustment_remove');
        } else {
          // Fallback for compatibility
          helper.levi.custom_adjustments.splice(index, 1);
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        
        // Reload all adjustments
        loadAllAdjustments(helper);
        
        // Re-attach event listeners after removal
        setTimeout(() => {
          addAdjustmentEventListeners();
        }, 100);
        
        console.log('Removed custom adjustment at index:', index);
      }
    }
    
    // ADD EVENT LISTENERS FOR ADJUSTMENT FIELDS
    function addAdjustmentEventListeners() {
      // Remove existing event listeners to prevent duplicates
      const existingInputs = document.querySelectorAll('#allAdjustmentsRows-estimate input[data-source], #allAdjustmentsRows-estimate select[data-source]');
      existingInputs.forEach(element => {
        // Clone element to remove all event listeners
        const newElement = element.cloneNode(true);
        element.parentNode.replaceChild(newElement, element);
      });
      
      // Add fresh event listeners to all adjustment inputs (both custom and levi)
      const adjustmentInputs = document.querySelectorAll('#allAdjustmentsRows-estimate input[data-source], #allAdjustmentsRows-estimate select[data-source]');
      
      console.log(`ğŸ”— Adding event listeners to ${adjustmentInputs.length} adjustment inputs`);
      
      adjustmentInputs.forEach(element => {
        // Input event for real-time updates
        element.addEventListener('input', function() {
          const source = this.dataset.source;
          const index = parseInt(this.dataset.index);
          const field = this.dataset.field;
          
          console.log(`ğŸ“ Input changed: ${field} for ${source}[${index}] = ${this.value}`);
          
          let value;
          if (field === 'description') {
            value = this.value;
          } else if (field === 'adjustmentType') {
            value = this.value;
          } else {
            value = parseFloat(this.value) || 0;
          }
          
          // Update helper based on source type
          if (source === 'custom') {
            updateCustomAdjustmentInHelper(source, index, field, value);
          } else if (source === 'levi') {
            updateLeviAdjustmentInHelper(source, index, field, value);
          }
          
          // Auto-calculate value when percentage changes
          if (field === 'percentage') {
            console.log(`ğŸ”¢ Triggering auto-calculation for percentage: ${value}%`);
            calculateAdjustmentValue(source, index, value);
          }
          
          // Debug: Check if helper is updated
          const currentHelper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          console.log(`ğŸ” DEBUG: Helper after adjustment update:`, currentHelper.levi?.custom_adjustments);
          console.log(`ğŸ” DEBUG: Helper expertise.levi_report:`, currentHelper.expertise?.levi_report);
          
          // Trigger floating screen refresh when adjustments change
          triggerFloatingScreenRefresh();
        });
        
        // Change event for final updates
        element.addEventListener('change', function() {
          // Trigger calculation update on change
          calculateSummaryTotals();
          
          // Trigger floating screen refresh when adjustments change
          triggerFloatingScreenRefresh();
          
          // If adjustment type changed, reload to update display
          if (this.dataset.field === 'adjustmentType') {
            const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
            setTimeout(() => loadAllAdjustments(helper), 50);
          }
        });
        
        // For percentage fields, trigger auto-calculation on focus out
        if (element.dataset.field === 'percentage') {
          element.addEventListener('blur', function() {
            const value = parseFloat(this.value) || 0;
            if (value !== 0) {
              console.log(`ğŸ¯ Blur event: Recalculating for percentage ${value}%`);
              calculateAdjustmentValue(this.dataset.source, parseInt(this.dataset.index), value);
            }
          });
        }
      });
    }
    
    // AUTO-CALCULATE ADJUSTMENT VALUE FROM PERCENTAGE
    function calculateAdjustmentValue(source, index, percentage) {
      // Get base price from car details
      const basePrice = getBasePriceForCalculation();
      
      if (basePrice > 0 && percentage !== 0) {
        const calculatedValue = Math.round((basePrice * Math.abs(percentage)) / 100);
        
        console.log(`Auto-calculating adjustment value: ${percentage}% Ã— â‚ª${basePrice.toLocaleString()} = â‚ª${calculatedValue.toLocaleString()}`);
        
        // Update the value field in DOM
        const valueInput = document.querySelector(`input[data-field="value"][data-source="${source}"][data-index="${index}"]`);
        if (valueInput) {
          valueInput.value = calculatedValue;
        }
        
        // Update helper with calculated value (works for both custom and levi)
        if (source === 'custom') {
          updateCustomAdjustmentInHelper(source, index, 'value', calculatedValue);
        } else if (source === 'levi') {
          updateLeviAdjustmentInHelper(source, index, 'value', calculatedValue);
        }
      }
    }
    
    // UPDATE LEVI ADJUSTMENT IN HELPER
    function updateLeviAdjustmentInHelper(source, index, field, value) {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Ensure Levi report structure exists
        if (!helper.levi_report) helper.levi_report = {};
        if (!helper.levi_report.adjustments) helper.levi_report.adjustments = [];
        
        // Update the specific adjustment
        if (helper.levi_report.adjustments[index]) {
          helper.levi_report.adjustments[index][field] = value;
          
          // Save back to helper using proper function
          if (typeof updateHelper === 'function') {
            updateHelper('levi_report', helper.levi_report, 'estimate_builder_levi_adjustment_update');
          } else {
            // Fallback for compatibility
            sessionStorage.setItem('helper', JSON.stringify(helper));
          }
          console.log(`âœ… Updated Levi adjustment ${index}.${field} = ${value}`);
        }
      } catch (error) {
        console.error('Error updating Levi adjustment in helper:', error);
      }
    }
    
    // GET BASE PRICE FOR CALCULATION
    function getBasePriceForCalculation() {
      // Try multiple sources for base price
      let basePrice = 0;
      
      // Priority 1: Car base price field
      const carBasePriceField = document.getElementById('carBasePrice');
      if (carBasePriceField && carBasePriceField.value) {
        const carBasePriceStr = carBasePriceField.value.replace(/[â‚ª,]/g, '') || '0';
        basePrice = parseFloat(carBasePriceStr) || 0;
      }
      
      // Priority 2: Helper data
      if (basePrice === 0) {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        basePrice = helper?.vehicle_value_base || 
                   helper?.car_details?.base_price || 
                   helper?.levi?.base_price || 
                   helper?.levi_report?.base_price || 0;
      }
      
      return basePrice;
    }
    
    // RECALCULATE ALL ADJUSTMENT VALUES (when base price changes)
    function recalculateAllAdjustmentValues() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments.length > 0) {
        console.log('ğŸ”„ Recalculating all adjustment values due to base price change');
        
        helper.levi.custom_adjustments.forEach((adjustment, index) => {
          if (adjustment.percentage && adjustment.percentage !== 0) {
            calculateAdjustmentValue('custom', index, adjustment.percentage);
          }
        });
      }
    }
    
    // UPDATE CUSTOM ADJUSTMENT IN HELPER
    function updateCustomAdjustmentInHelper(source, index, field, value) {
      if (source !== 'custom') return;
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments[index]) {
        const adjustment = helper.levi.custom_adjustments[index];
        
        // Update the field
        adjustment[field] = value;
        
        // Apply proper signs based on adjustment type when updating numeric fields
        if (field === 'percentage' || field === 'value') {
          const adjustmentType = adjustment.adjustmentType || 'addition';
          const absoluteValue = Math.abs(value);
          
          if (adjustmentType === 'subtraction') {
            adjustment[field] = -absoluteValue;
          } else {
            adjustment[field] = absoluteValue;
          }
        }
        
        // Save using proper helper function
        if (typeof updateHelper === 'function') {
          updateHelper('levi', helper.levi, 'estimate_builder_custom_adjustment_update');
        } else {
          // Fallback for compatibility
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        
        console.log(`Updated custom adjustment ${index}.${field} to:`, adjustment[field]);
        console.log('Full adjustment object:', adjustment);
        
        // Update the structured Levi data for floating screen compatibility
        updateLeviDataStructure(helper);
        
        // Helper is already updated above with sessionStorage.setItem
        console.log('âœ… Helper updated with adjustment data');
      }
    }
    
    // UPDATE LEVI DATA STRUCTURE FOR FLOATING SCREEN COMPATIBILITY
    function updateLeviDataStructure(helper) {
      try {
        // Ensure expertise.levi_report exists
        if (!helper.expertise) helper.expertise = {};
        if (!helper.expertise.levi_report) helper.expertise.levi_report = {};
        
        // Map basic vehicle info from other helper sections
        if (helper.car_details) {
          helper.expertise.levi_report.manufacturer = helper.car_details.manufacturer || helper.vehicle?.manufacturer;
          helper.expertise.levi_report.year = helper.car_details.year || helper.vehicle?.year;
          helper.expertise.levi_report.base_price = helper.car_details.base_price;
          helper.expertise.levi_report.final_price = helper.car_details.market_value;
          helper.expertise.levi_report.vehicle_type = helper.vehicle?.vehicle_type || '';
          helper.expertise.levi_report.model_code = helper.vehicle?.model_code || '';
          helper.expertise.levi_report.category = helper.vehicle?.category || '';
          helper.expertise.levi_report.full_model = helper.vehicle?.model || helper.car_details.model;
        }
        
        // Process custom adjustments into the structure expected by Levi floating screen
        if (helper.levi?.custom_adjustments) {
          // Initialize all adjustment fields to ensure they exist
          helper.expertise.levi_report.registration = '';
          helper.expertise.levi_report.registration_percent = '';
          helper.expertise.levi_report.registration_value = '';
          helper.expertise.levi_report.registration_total = '';
          helper.expertise.levi_report.ownership = '';
          helper.expertise.levi_report.ownership_percent = '';
          helper.expertise.levi_report.ownership_value = '';
          helper.expertise.levi_report.ownership_total = '';
          helper.expertise.levi_report.km = '';
          helper.expertise.levi_report.km_percent = '';
          helper.expertise.levi_report.km_value = '';
          helper.expertise.levi_report.km_total = '';
          helper.expertise.levi_report.owners = '';
          helper.expertise.levi_report.owners_percent = '';
          helper.expertise.levi_report.owners_value = '';
          helper.expertise.levi_report.owners_total = '';
          helper.expertise.levi_report.features = '';
          helper.expertise.levi_report.features_percent = '';
          helper.expertise.levi_report.features_value = '';
          helper.expertise.levi_report.features_total = '';
          
          helper.levi.custom_adjustments.forEach((adjustment, index) => {
            const desc = adjustment.description ? adjustment.description.toLowerCase() : '';
            
            console.log(`ğŸ” Mapping adjustment ${index}: "${adjustment.description}" (${adjustment.percentage}%, â‚ª${adjustment.value})`);
            
            // Map based on description keywords ONLY (check specific terms first to avoid conflicts)
            if (desc.includes('×¢×œ×™×” ×œ×›×‘×™×©') || desc.includes('registration') || desc.includes('×¨×™×©×•×™')) {
              helper.expertise.levi_report.registration = adjustment.description || '×¢×œ×™×” ×œ×›×‘×™×©';
              helper.expertise.levi_report.registration_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.registration_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.registration_total = Math.abs(adjustment.value || 0);
              console.log(`âœ… Mapped to registration: ${adjustment.description}`);
            } else if (desc.includes('××¡×¤×¨ ×‘×¢×œ×™×') || desc.includes('owners')) {
              helper.expertise.levi_report.owners = adjustment.description || '××¡×¤×¨ ×‘×¢×œ×™×';
              helper.expertise.levi_report.owners_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.owners_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.owners_total = Math.abs(adjustment.value || 0);
              console.log(`âœ… Mapped to owners: ${adjustment.description}`);
            } else if (desc.includes('×‘×¢×œ×•×ª') || desc.includes('ownership')) {
              helper.expertise.levi_report.ownership = adjustment.description || '×‘×¢×œ×•×ª';
              helper.expertise.levi_report.ownership_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.ownership_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.ownership_total = Math.abs(adjustment.value || 0);
              console.log(`âœ… Mapped to ownership: ${adjustment.description}`);
            } else if (desc.includes('×§×´×') || desc.includes('km') || desc.includes('×§×™×œ×•××˜×¨×™×')) {
              helper.expertise.levi_report.km = adjustment.description || '××¡ ×§×´×';
              helper.expertise.levi_report.km_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.km_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.km_total = Math.abs(adjustment.value || 0);
              console.log(`âœ… Mapped to km: ${adjustment.description}`);
            } else if (desc.includes('×××¤×™×™× ×™×') || desc.includes('features')) {
              helper.expertise.levi_report.features = adjustment.description || '×××¤×™×™× ×™×';
              helper.expertise.levi_report.features_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.features_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.features_total = Math.abs(adjustment.value || 0);
              console.log(`âœ… Mapped to features: ${adjustment.description}`);
            } else {
              console.log(`âš ï¸ No mapping found for: "${adjustment.description}" - will be stored in helper for validation/report`);
            }
          });
        }
        
        // Update helper using proper function
        if (typeof updateHelper === 'function') {
          updateHelper('levi', helper.levi, 'estimate_builder_adjustment_recalculate');
        } else {
          // Fallback for compatibility
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        
        console.log('ğŸ“Š Updated Levi data structure for floating screen compatibility');
        
      } catch (error) {
        console.error('Error updating Levi data structure:', error);
      }
    }
    
    // CALCULATE SUMMARY TOTALS - Updates helper with calculated totals
    function calculateSummaryTotals() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Calculate Levi adjustment totals
        let leviTotal = 0;
        if (helper.levi?.adjustments) {
          leviTotal = helper.levi.adjustments.reduce((sum, adj) => sum + (parseFloat(adj.value) || 0), 0);
        }
        if (helper.levi?.custom_adjustments) {
          leviTotal += helper.levi.custom_adjustments.reduce((sum, adj) => sum + (parseFloat(adj.value) || 0), 0);
        }
        
        // Calculate damage center totals
        let damageTotal = 0;
        if (helper.expertise?.damage_blocks) {
          helper.expertise.damage_blocks.forEach(block => {
            damageTotal += (parseFloat(block.parts_cost) || 0) + (parseFloat(block.work_cost) || 0) + (parseFloat(block.repairs_cost) || 0);
          });
        }
        
        // Update helper with calculated totals
        const summaryTotals = {
          levi_total: leviTotal,
          damage_total: damageTotal,
          total_before_vat: leviTotal + damageTotal,
          total_with_vat: Math.round((leviTotal + damageTotal) * 1.18),
          calculated_at: new Date().toISOString()
        };
        
        // Save using proper helper function
        if (typeof updateHelper === 'function') {
          updateHelper('summary_totals', summaryTotals, 'estimate_builder_summary_calculation');
        } else {
          // Fallback for compatibility
          helper.summary_totals = summaryTotals;
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        console.log('âœ… Summary totals calculated and updated in helper:', helper.summary_totals);
        
        // Trigger floating screen updates when helper changes
        triggerFloatingScreenRefresh();
        
      } catch (error) {
        console.error('Error calculating summary totals:', error);
      }
    }

    // TRIGGER FLOATING SCREEN REFRESH - Updates all helper-dependent floating screens
    function triggerFloatingScreenRefresh() {
      try {
        console.log('ğŸ”„ Triggering floating screen refresh after helper update');
        
        // Update helper with current 3-bulk calculations
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Ensure calculations structure exists
        helper.calculations = helper.calculations || {};
        helper.expertise = helper.expertise || {};
        helper.expertise.calculations = helper.expertise.calculations || {};
        
        // Update with current bulk calculations - with safety checks
        let grossMarketValue = 0;
        let fullMarketValue = 0;
        let totalClaim = 0;
        let grossPercentage = 0;
        
        if (window.EstimateCalculations && typeof window.EstimateCalculations === 'object') {
          grossMarketValue = window.EstimateCalculations.getGrossMarketValue();
          fullMarketValue = window.EstimateCalculations.getFullMarketValue();
          totalClaim = window.EstimateCalculations.getTotalClaim();
          grossPercentage = window.EstimateCalculations.getGrossPercentage();
        } else {
          console.warn('EstimateCalculations not yet initialized, using fallback values');
          // Try to get values from DOM or helper as fallback
          grossMarketValue = parseFloat(document.getElementById('grossMarketValueResult')?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
          fullMarketValue = parseFloat(document.getElementById('fullMarketValueResult')?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
          totalClaim = parseFloat(document.getElementById('totalClaim')?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
          grossPercentage = parseFloat(document.getElementById('grossPercent')?.value.replace(/[%]/g, '') || '0') || 0;
        }
        
        helper.calculations.vehicle_value_gross = grossMarketValue;
        helper.calculations.market_value = fullMarketValue;
        helper.calculations.full_market_value = fullMarketValue;
        helper.calculations.total_damage = totalClaim;
        helper.calculations.damage_percent = grossPercentage;
        
        // Update expertise calculations for compatibility
        helper.expertise.calculations.vehicle_value_gross = grossMarketValue;
        helper.expertise.calculations.market_value = fullMarketValue;
        helper.expertise.calculations.total_damage = totalClaim;
        helper.expertise.calculations.damage_percent = grossPercentage;
        
        // Update claims_data for UI consistency
        const claimsData = {
          gross_value: `â‚ª${grossMarketValue.toLocaleString()}`,
          total_claim: `â‚ª${totalClaim.toLocaleString()}`,
          gross_percent: `${grossPercentage.toFixed(2)}%`
        };
        
        // Save updated helper using proper function
        if (typeof updateHelper === 'function') {
          updateHelper('calculations', helper.calculations, 'estimate_builder_calculation_refresh');
          updateHelper('expertise', helper.expertise, 'estimate_builder_expertise_refresh'); 
          updateHelper('claims_data', claimsData, 'estimate_builder_claims_refresh');
        } else {
          // Fallback for compatibility
          helper.claims_data = helper.claims_data || {};
          Object.assign(helper.claims_data, claimsData);
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        
        // Debug: Check which refresh functions are available
        console.log('Debug: Available refresh functions:', {
          refreshLeviData: typeof window.refreshLeviData,
          refreshCarData: typeof window.refreshCarData, 
          refreshInvoiceData: typeof window.refreshInvoiceData,
          refreshPartsResults: typeof window.refreshPartsResults
        });
        
        // Refresh Levi floating screen if open
        if (window.refreshLeviData && typeof window.refreshLeviData === 'function') {
          console.log('ğŸ”„ Refreshing Levi floating screen');
          window.refreshLeviData();
        }
        
        // Refresh Car Details floating screen if open
        if (window.refreshCarData && typeof window.refreshCarData === 'function') {
          console.log('ğŸ”„ Refreshing Car Details floating screen');
          window.refreshCarData();
        }
        
        // Refresh Invoice floating screen if open
        if (window.refreshInvoiceData && typeof window.refreshInvoiceData === 'function') {
          console.log('ğŸ”„ Refreshing Invoice floating screen');
          window.refreshInvoiceData();
        }
        
        // Refresh Parts Search floating screen
        if (window.refreshPartsResults && typeof window.refreshPartsResults === 'function') {
          console.log('ğŸ”„ Refreshing Parts Search floating screen');
          window.refreshPartsResults();
        }
        
        // Alternative: Try to reload data directly from iframe/floating screens
        setTimeout(() => {
          // Try to refresh via postMessage to floating screens
          const floatingScreens = document.querySelectorAll('.floating-screen[style*="block"]');
          floatingScreens.forEach(screen => {
            console.log('ğŸ”„ Found open floating screen:', screen.id);
            const iframe = screen.querySelector('iframe');
            if (iframe && iframe.contentWindow) {
              try {
                iframe.contentWindow.postMessage({
                  type: 'refreshData',
                  source: 'estimate-builder',
                  calculations: helper.calculations,
                  timestamp: new Date().toISOString()
                }, '*');
              } catch (e) {
                console.log('Could not post message to iframe:', e);
              }
            }
          });
        }, 100);
        
        // Dispatch custom event for any other modules listening
        window.dispatchEvent(new CustomEvent('helperDataUpdated', {
          detail: { 
            timestamp: new Date().toISOString(),
            source: 'estimate-builder',
            calculations: helper.calculations
          }
        }));
        
        console.log('âœ… Helper updated with 3-bulk calculations:', {
          grossMarketValue,
          fullMarketValue,
          totalClaim,
          grossPercentage
        });
        
      } catch (error) {
        console.error('Error triggering floating screen refresh:', error);
      }
    }

    // LEGACY FUNCTION - Keep for compatibility but redirect to unified system
    function addCustomSummaryField(summaryType) {
      // Redirect to new unified system
      addCustomAdjustmentField();
    }
    
    // DEBUG FUNCTION - Test the complete data flow chain
    window.testDataFlow = function() {
      console.log('ğŸ§ª TESTING DATA FLOW CHAIN');
      
      // 1. Check if helper exists
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('1ï¸âƒ£ Helper exists:', !!helper);
      console.log('   Helper keys:', Object.keys(helper));
      
      // 2. Test manual helper update
      console.log('2ï¸âƒ£ Testing manual helper update...');
      const testData = {
        test_field: 'test_value_' + Date.now(),
        car_details: {
          ...helper.car_details,
          manufacturer: 'TEST_MANUFACTURER'
        }
      };
      
      // Use proper helper update function
      if (typeof updateHelper === 'function') {
        updateHelper('test_field', testData.test_field, 'estimate_builder_debug_test');
        updateHelper('car_details', testData.car_details, 'estimate_builder_debug_test');
      } else {
        // Fallback for compatibility
        helper.test_field = testData.test_field;
        helper.car_details = helper.car_details || {};
        helper.car_details.manufacturer = 'TEST_MANUFACTURER';
        sessionStorage.setItem('helper', JSON.stringify(helper));
      }
      console.log('   Helper updated with test data');
      
      // 3. Test floating screen refresh
      console.log('3ï¸âƒ£ Testing floating screen refresh...');
      triggerFloatingScreenRefresh();
      
      // 4. Check if refresh functions are available
      console.log('4ï¸âƒ£ Checking refresh function availability:');
      console.log('   refreshLeviData:', typeof window.refreshLeviData);
      console.log('   refreshCarData:', typeof window.refreshCarData);
      console.log('   refreshInvoiceData:', typeof window.refreshInvoiceData);
      console.log('   refreshPartsResults:', typeof window.refreshPartsResults);
      
      // 5. Test manual adjustment input
      console.log('5ï¸âƒ£ Testing manual adjustment input...');
      const adjustmentInputs = document.querySelectorAll('#allAdjustmentsRows-estimate input[data-source="custom"]');
      console.log('   Found adjustment inputs:', adjustmentInputs.length);
      
      if (adjustmentInputs.length > 0) {
        const firstInput = adjustmentInputs[0];
        console.log('   First input element:', firstInput);
        console.log('   First input data attributes:', {
          source: firstInput.dataset.source,
          index: firstInput.dataset.index,
          field: firstInput.dataset.field
        });
        
        // Simulate input change
        firstInput.value = 'TEST_ADJUSTMENT_' + Date.now();
        firstInput.dispatchEvent(new Event('input', { bubbles: true }));
        console.log('   Simulated input change');
      }
      
      console.log('ğŸ§ª DATA FLOW TEST COMPLETE');
    };

    // REMOVED DUPLICATE FUNCTION - Using the enhanced version above

    // UPDATE HELPER FROM FIELD
    function updateHelperFromField(event) {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        const fieldId = event.target.id;
        const value = event.target.value;
        
        console.log(`ğŸ“ Field change detected: ${fieldId} = "${value}"`);
        
        // Update the appropriate helper section based on field
        if (['carPlate', 'carManufacturer', 'carModel', 'carYear', 'carModelCode', 'carBasePrice', 'carMarketValue', 'carReportDate', 'basicPrice'].includes(fieldId)) {
          helper.car_details = helper.car_details || {};
          helper.vehicle = helper.vehicle || {};
          
          const mapping = {
            'carPlate': 'plate',
            'carManufacturer': 'manufacturer',
            'carModel': 'model',
            'carYear': 'year',
            'carModelCode': 'model_code',
            'carBasePrice': 'base_price',
            'carMarketValue': 'market_value',
            'carReportDate': 'report_date',
            'basicPrice': 'basic_price'
          };
          
          // Update car_details (builder format)
          helper.car_details[mapping[fieldId]] = value;
          
          // Also update vehicle structure (floating screen format)
          if (fieldId === 'carManufacturer') {
            helper.vehicle.manufacturer = value;
            console.log('ğŸš— Updated vehicle manufacturer:', value);
          } else if (fieldId === 'carModel') {
            helper.vehicle.model = value;
            console.log('ğŸš— Updated vehicle model:', value);
          } else if (fieldId === 'carYear') {
            helper.vehicle.year = value;
            console.log('ğŸš— Updated vehicle year:', value);
          } else if (fieldId === 'carModelCode') {
            helper.vehicle.model_code = value;
            console.log('ğŸš— Updated vehicle model code:', value);
          } else if (fieldId === 'carPlate') {
            // CRITICAL FIX: Use centralized plate standardization function
            if (window.setPlateNumber) {
              window.setPlateNumber(value, 'estimate-builder');
            } else {
              // Fallback: standardize manually
              const standardizedPlate = value ? String(value).replace(/[-\s]/g, '') : '';
              helper.vehicle.plate_number = standardizedPlate;
              helper.meta = helper.meta || {};
              helper.meta.plate = standardizedPlate;
            }
            console.log('ğŸš— Updated vehicle plate:', value);
          } else if (fieldId === 'basicPrice') {
            // Update levi_report structure for basic price
            helper.levi_report = helper.levi_report || {};
            helper.levi_report.base_price = value.replace(/[â‚ª,]/g, '');
            helper.expertise = helper.expertise || {};
            helper.expertise.levi_report = helper.expertise.levi_report || {};
            helper.expertise.levi_report.base_price = value.replace(/[â‚ª,]/g, '');
            console.log('ğŸš— Updated basic price:', value);
          }
          
          // Plate update is now handled above with centralized function
        } else if (['ownerName', 'ownerAddress', 'ownerPhone', 'insuranceCompany', 'insuranceEmail', 'insuranceAgent', 'agentPhone', 'agentEmail'].includes(fieldId)) {
          helper.client = helper.client || {};
          helper.car_details = helper.car_details || {};
          
          const mapping = {
            'ownerName': 'name',
            'ownerAddress': 'address',
            'ownerPhone': 'phone',
            'insuranceCompany': 'insurance_company',
            'insuranceEmail': 'insurance_email',
            'insuranceAgent': 'insurance_agent',
            'agentPhone': 'insurance_agent_phone',
            'agentEmail': 'insurance_agent_email'
          };
          
          // Update client structure (main format)
          helper.client[mapping[fieldId]] = value;
          
          // Also update car_details structure (floating screen format)
          if (fieldId === 'ownerName') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.name = value;
            helper.car_details.owner = value;
          } else if (fieldId === 'ownerAddress') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.address = value;
            helper.car_details.ownerAddress = value;
          } else if (fieldId === 'ownerPhone') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.phone_number = value;
            helper.car_details.ownerPhone = value;
          } else if (fieldId === 'insuranceCompany') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_company = value;
            helper.car_details.insuranceCompany = value;
          } else if (fieldId === 'insuranceAgent') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_agent = value;
            helper.car_details.agentName = value;
          } else if (fieldId === 'agentPhone') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_agent_phone = value;
            helper.car_details.insurance_agent_phone = value;
          } else if (fieldId === 'agentEmail') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_agent_email = value;
            helper.car_details.insurance_agent_email = value;
          }
        } else if (['totalClaim', 'authorizedClaim'].includes(fieldId)) {
          // Claims data mapping
          helper.claims_data = helper.claims_data || {};
          const mapping = {
            'totalClaim': 'total_claim',
            'authorizedClaim': 'authorized_claim'
          };
          helper.claims_data[mapping[fieldId]] = value;
          
          // Also update expertise.calculations for compatibility
          helper.expertise = helper.expertise || {};
          helper.expertise.calculations = helper.expertise.calculations || {};
          if (fieldId === 'totalClaim' || fieldId === 'authorizedClaim') {
            // Remove currency formatting and parse number
            const numericValue = parseFloat(value.replace(/[â‚ª,]/g, '')) || 0;
            helper.expertise.calculations.total_damage = numericValue;
          }
          
          console.log(`ğŸ’° Updated claims data: ${fieldId} = "${value}"`);
        } else if (['sumMarketValue', 'sumClaim', 'sumVAT', 'sumTotalClaim', 'depCompensation', 'salvageValue', 'garageDays'].includes(fieldId)) {
          // Handle garage days separately
          if (fieldId === 'garageDays') {
            helper.estimate_work_days = value;
          } else {
            helper.estimate_summary = helper.estimate_summary || {};
            const mapping = {
              'sumMarketValue': 'market_value',
              'sumClaim': 'total_claim',
              'sumVAT': 'vat',
              'sumTotalClaim': 'total_with_vat',
              'depCompensation': 'dep_compensation',
              'salvageValue': 'salvage_value'
            };
            helper.estimate_summary[mapping[fieldId]] = value;
          }
        }
        
        // ENHANCED DATA PERSISTENCE: Write to both source fields and helper.estimate for reference
        // Initialize helper.estimate if not exists
        helper.estimate = helper.estimate || {};
        
        // Write complete state to helper.estimate for historical reference
        helper.estimate.vehicle_data = {
          plate: helper.car_details?.plate || helper.vehicle?.plate_number,
          manufacturer: helper.car_details?.manufacturer || helper.vehicle?.manufacturer,
          model: helper.car_details?.model || helper.vehicle?.model,
          year: helper.car_details?.year || helper.vehicle?.year,
          model_code: helper.car_details?.model_code || helper.vehicle?.model_code,
          base_price: helper.car_details?.base_price,
          market_value: helper.car_details?.market_value || helper.vehicle?.market_value,
          report_date: helper.car_details?.report_date
        };
        
        helper.estimate.contact_data = {
          owner_name: helper.client?.name,
          owner_address: helper.client?.address, 
          owner_phone: helper.client?.phone,
          insurance_company: helper.client?.insurance_company,
          insurance_email: helper.client?.insurance_email,
          insurance_agent: helper.client?.insurance_agent,
          agent_phone: helper.client?.insurance_agent_phone,
          agent_email: helper.client?.insurance_agent_email
        };
        
        helper.estimate.claims_data = helper.claims_data || {};
        helper.estimate.summary_data = helper.estimate_summary || {};
        helper.estimate.work_days = helper.estimate_work_days;
        helper.estimate.timestamp = new Date().toISOString();
        
        // Save updated helper using proper function  
        if (typeof updateHelper === 'function') {
          updateHelper('car_details', helper.car_details, 'estimate_builder_field_update');
          updateHelper('vehicle', helper.vehicle, 'estimate_builder_field_update');
          updateHelper('estimate_summary', helper.estimate_summary, 'estimate_builder_field_update');
          updateHelper('estimate', helper.estimate, 'estimate_builder_reference_update');
        } else {
          // Fallback for compatibility
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        
        // Trigger floating screen updates when helper changes
        triggerFloatingScreenRefresh();
        
        // Update page title if plate changed
        if (fieldId === 'carPlate') {
          // Apply plate standardization (remove dashes for Israeli format XXXXXXXX) 
          const standardizedValue = value && value !== '...' ? String(value).replace(/[-\s]/g, '') : (value || '...');
          document.getElementById('pageTitle').textContent = `×¨×›×‘ ××¡. ${standardizedValue}`;
        }
        
        // Update legal text with new data
        loadLegalText().catch(console.error);
        
        // Special handling for salvage value changes
        if (fieldId === 'salvageValue') {
          console.log('Salvage value updated:', value);
        }
        
        // Trigger calculations if field affects calculations
        const calculationFields = ['basicPrice', 'carBasePrice', 'carMarketValue', 'totalClaim'];
        if (calculationFields.includes(fieldId)) {
          setTimeout(() => {
            if (window.EstimateCalculations && typeof window.EstimateCalculations.refresh3BulkCalculations === 'function') {
              window.EstimateCalculations.refresh3BulkCalculations();
            }
          }, 100);
        }
        
      } catch (error) {
        console.error('Error updating helper from field:', error);
      }
    }

    // UPDATE REPORT TYPE
    function updateReportType() {
      const selectedType = document.querySelector('input[name="estimate-type"]:checked')?.value || '××•×‘×“×Ÿ_×œ×”×œ×›×”';
      const reportTypeText = selectedType === '××•×‘×“×Ÿ_×œ×”×œ×›×”' ? '××•××“×Ÿ ×¨××©×•× ×™ - ××•×‘×“×Ÿ ×œ×”×œ×›×”' : '××•××“×Ÿ ×¨××©×•× ×™ - ×˜×•×˜×œ×•×¡';
      document.getElementById('reportType').value = reportTypeText;
    }


    // LOAD LEGAL TEXT USING CENTRALIZED ENGINE
    async function loadLegalText() {
      const selectedType = document.querySelector('input[name="estimate-type"]:checked')?.value || '××•×‘×“×Ÿ_×œ×”×œ×›×”';
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      console.log('ğŸ”„ Loading estimate legal text for type:', selectedType);
      
      // Map estimate types to UI dropdown format for the engine
      const estimateTypeMapping = {
        '××•×‘×“×Ÿ_×œ×”×œ×›×”': '××•××“×Ÿ ×¨××©×•× ×™ - ××•×‘×“×Ÿ ×œ×”×œ×›×”',
        '×˜×•×˜×œ×•×¡': '××•××“×Ÿ ×¨××©×•× ×™ - ×˜×•×˜×œ×•×¡'
      };
      
      const uiType = estimateTypeMapping[selectedType] || estimateTypeMapping['××•×‘×“×Ÿ_×œ×”×œ×›×”'];
      
      // Collect values for placeholder replacement
      const placeholderValues = {
        plate: document.getElementById('carPlate')?.value || helper.meta?.plate,
        manufacturer: document.getElementById('carManufacturer')?.value || helper.car_details?.manufacturer,
        model: document.getElementById('carModel')?.value || helper.car_details?.model,
        year: document.getElementById('carYear')?.value || helper.car_details?.year,
        ownerName: document.getElementById('ownerName')?.value || helper.client?.name,
        modelCode: document.getElementById('carModelCode')?.value || helper.car_details?.model_code || helper.levi_report?.model_code,
        damagePercent: document.getElementById('grossPercent')?.value || helper.claims_data?.gross_percent || calculateDamagePercentage() || helper.expertise?.calculations?.damage_percent,
        depreciation: document.getElementById('globalDep1')?.value || helper.estimate_depreciation?.global_percent,
        damageCenters: helper.expertise?.damage_blocks?.length,
        garageDays: document.getElementById('garageDays')?.value || helper.estimate_work_days || helper.expertise?.depreciation?.work_days,
        carValue: document.getElementById('carMarketValue')?.value || document.getElementById('sumMarketValue')?.value || (helper.expertise?.calculations?.market_value ? `â‚ª${helper.expertise.calculations.market_value.toLocaleString()}` : undefined),
        salvageValue: (() => {
          const salvageInput = document.getElementById('salvageValue')?.value;
          const helperSalvage = helper.estimate_summary?.salvage_value || helper.estimate_salvage_value;
          
          if (salvageInput && salvageInput.trim() !== '' && salvageInput !== 'â‚ª0') {
            return salvageInput;
          } else if (helperSalvage && helperSalvage !== 'â‚ª0') {
            return helperSalvage;
          }
          return undefined;
        })()
      };
      
      try {
        // Use the centralized legal text engine for estimates
        const legalText = await window.LegalTextEngine.getProcessedText(
          uiType, 
          placeholderValues, 
          'estimate'
        );
        
        const legalTextElement = document.getElementById('legal-text-content');
        if (legalTextElement) {
          legalTextElement.value = legalText;
          console.log('âœ… Estimate legal text loaded successfully from vault for:', uiType);
        } else {
          console.error('âŒ Legal text element not found: legal-text-content');
        }
        
      } catch (error) {
        console.error('âŒ Error loading estimate legal text:', error);
        const legalTextElement = document.getElementById('legal-text-content');
        if (legalTextElement) {
          legalTextElement.value = '×©×’×™××” ×‘×˜×¢×™× ×ª ×˜×§×¡×˜ ××©×¤×˜×™ ××”×›×¡×¤×ª - ×× × ×‘×“×•×§ ××ª ×”×—×™×‘×•×¨';
        }
      }
    }

    // LOAD LEGAL TEXT FROM VAULT - SEPARATE FUNCTION FOR BUTTON
    function loadLegalTextFromVault() {
      loadLegalText().catch(console.error);
      
      // Save the legal text to helper for the specific estimate
      const legalTextContent = document.getElementById('legal-text-content').value;
      
      if (typeof updateHelper === 'function') {
        updateHelper('estimate_legal_text', legalTextContent, 'estimate_builder_legal_text_load');
      } else {
        // Fallback for compatibility
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        helper.estimate_legal_text = legalTextContent;
        sessionStorage.setItem('helper', JSON.stringify(helper));
      }
      
      console.log('Legal text loaded from vault and saved to estimate');
    }

    // RESET LEGAL TEXT
    function resetLegalText() {
      const selectedType = document.querySelector('input[name="estimate-type"]:checked')?.value || '××•×‘×“×Ÿ_×œ×”×œ×›×”';
      const typeText = selectedType === '××•×‘×“×Ÿ_×œ×”×œ×›×”' ? '××•×‘×“×Ÿ ×œ×”×œ×›×”' : '×˜×•×˜×œ×•×¡';
      
      document.getElementById('legal-text-content').value = `×˜×§×¡×˜ ××©×¤×˜×™ ×œ××•××“×Ÿ ${typeText} - ××•×›×Ÿ ×œ×¢×¨×™×›×”`;
      
      // Clear saved legal text from helper
      if (typeof updateHelper === 'function') {
        updateHelper('estimate_legal_text', null, 'estimate_builder_legal_text_reset');
      } else {
        // Fallback for compatibility
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        delete helper.estimate_legal_text;
        sessionStorage.setItem('helper', JSON.stringify(helper));
      }
      
      console.log('Legal text reset');
    }

    // LOAD ATTACHMENTS FROM VAULT
    function loadAttachmentsFromVault() {
      // Get selected type from page selection (same logic as legal text)
      const selectedType = document.querySelector('input[name="estimate-type"]:checked')?.value || '××•×‘×“×Ÿ_×œ×”×œ×›×”';
      
      // Attachments vault (inline, like legal text)
      const attachmentsVault = {
        '××•×‘×“×Ÿ_×œ×”×œ×›×”': '**×œ×•×˜×”**\n×ª×¦×œ×•××™ ×”×¨×›×‘ ×”× ×™×–×•×§\n×¢×¨×š ×¨×›×‘ ×××•×—×©×‘\n×¦×™×œ×•× ×¨×™×©×™×•×Ÿ ×”×¨×›×‘',
        '×˜×•×˜×œ×•×¡': '**×œ×•×˜×”**\n×ª×¦×œ×•××™ ×”×¨×›×‘ ×”× ×™×–×•×§\n×¢×¨×š ×¨×›×‘ ×××•×—×©×‘\n×¦×™×œ×•× ×¨×™×©×™×•×Ÿ ×”×¨×›×‘'
      };
      
      // Get attachments for selected type
      const attachmentsText = attachmentsVault[selectedType] || '**×œ×•×˜×”**\n×ª×¦×œ×•××™ ×”×¨×›×‘ ×”× ×™×–×•×§\n×—×©×‘×•× ×™×•×ª ×ª×™×§×•×Ÿ\n×¢×¨×š ×¨×›×‘ ×××•×—×©×‘\n×¦×™×œ×•× ×¨×™×©×™×•×Ÿ ×”×¨×›×‘\n×—×©×›"×˜';
      
      document.getElementById('attachments-content').value = attachmentsText;
      
      // Save to helper and LOCK the selection
      const attachmentsData = {
        estimate_attachments: attachmentsText,
        estimate_attachments_locked: true
      };
      
      if (typeof updateHelper === 'function') {
        updateHelper('estimate_attachments', attachmentsText, 'estimate_builder_attachments_load');
        updateHelper('estimate_attachments_locked', true, 'estimate_builder_attachments_lock');
      } else {
        // Fallback for compatibility
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        helper.estimate_attachments = attachmentsText;
        helper.estimate_attachments_locked = true;
        sessionStorage.setItem('helper', JSON.stringify(helper));
      }
      
      console.log('ğŸ“ Attachments loaded from vault for type:', selectedType, 'and LOCKED');
    }

    // RESET ATTACHMENTS
    function resetAttachments() {
      // Reset to default attachments
      const defaultAttachments = '**×œ×•×˜×”**\n×ª×¦×œ×•××™ ×”×¨×›×‘ ×”× ×™×–×•×§\n×—×©×‘×•× ×™×•×ª ×ª×™×§×•×Ÿ\n×¢×¨×š ×¨×›×‘ ×××•×—×©×‘\n×¦×™×œ×•× ×¨×™×©×™×•×Ÿ ×”×¨×›×‘\n×—×©×›"×˜';
      document.getElementById('attachments-content').value = defaultAttachments;
      
      // Clear from helper
      if (typeof updateHelper === 'function') {
        updateHelper('estimate_attachments', null, 'estimate_builder_attachments_reset');
        updateHelper('estimate_attachments_locked', null, 'estimate_builder_attachments_unlock');
      } else {
        // Fallback for compatibility
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        delete helper.estimate_attachments;
        delete helper.estimate_attachments_locked;
        sessionStorage.setItem('helper', JSON.stringify(helper));
      }
      
      console.log('Attachments reset');
    }

    // LOAD ATTACHMENTS DATA FROM HELPER
    function loadAttachmentsData() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Load saved attachments if they exist and are locked
      if (helper.estimate_attachments && helper.estimate_attachments_locked) {
        const attachmentsElement = document.getElementById('attachments-content');
        if (attachmentsElement) {
          attachmentsElement.value = helper.estimate_attachments;
          console.log('ğŸ“ Loaded LOCKED attachments from helper - will not revert to default');
        }
      } else if (helper.estimate_attachments) {
        const attachmentsElement = document.getElementById('attachments-content');
        if (attachmentsElement) {
          attachmentsElement.value = helper.estimate_attachments;
          console.log('ğŸ“ Loaded saved attachments from helper (not locked)');
        }
      } else {
        console.log('ğŸ“ No saved attachments found, keeping default');
      }
    }

    // ADD GLOBAL DEPRECIATION CALCULATION
    function updateGlobalDepreciationCalculation() {
      const globalDepInput = document.getElementById('globalDep1');
      const globalDepValueInput = document.getElementById('globalDepValue');
      
      if (globalDepInput && globalDepValueInput) {
        globalDepInput.addEventListener('input', function() {
          let percent = parseFloat(this.value) || 0;
          
          // Auto-add % symbol if not present and user enters a number
          if (this.value && !this.value.includes('%') && !isNaN(percent)) {
            this.value = percent + '%';
          }
          
          // Calculate value from market price automatically - try multiple sources
          let marketValue = 0;
          
          // First try summary market value (priority)
          const sumMarketValueField = document.getElementById('sumMarketValue');
          if (sumMarketValueField && sumMarketValueField.value) {
            const sumMarketStr = sumMarketValueField.value.replace(/[â‚ª,]/g, '') || '0';
            marketValue = parseFloat(sumMarketStr) || 0;
          }
          
          // If no summary value, try car details market value
          if (marketValue === 0) {
            const carMarketValueField = document.getElementById('carMarketValue');
            if (carMarketValueField && carMarketValueField.value) {
              const carMarketStr = carMarketValueField.value.replace(/[â‚ª,]/g, '') || '0';
              marketValue = parseFloat(carMarketStr) || 0;
            }
          }
          
          console.log('Global depreciation calculation:', {
            percent,
            marketValue,
            calculation: (marketValue * percent) / 100
          });
          
          const calculatedValue = (marketValue * percent) / 100;
          globalDepValueInput.value = calculatedValue ? `â‚ª${Math.round(calculatedValue).toLocaleString()}` : '';
          
          // TRIGGER SUMMARY UPDATE when global depreciation value changes
          if (window.addSummaryCalculationListeners) {
            const sumCalculate = document.querySelector('[data-summary-calculate]');
            if (sumCalculate) {
              sumCalculate.click();
            }
          }
          
          // Direct trigger for summary calculations
          setTimeout(() => {
            const event = new Event('input', { bubbles: true });
            globalDepValueInput.dispatchEvent(event);
          }, 100);
        });
      }
    }
    
    // CALCULATE DAMAGE PERCENTAGE
    function calculateDamagePercentage() {
      try {
        const totalClaim = parseFloat(document.getElementById('sumClaim')?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
        
        // Try to get vehicle_value_gross from helper first (gross market value for damage calculation)
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        const vehicleValueGross = helper.calculations?.vehicle_value_gross || 0;
        
        // Fallback to market value if vehicle_value_gross not available
        const marketValue = parseFloat(document.getElementById('sumMarketValue')?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
        const calculationBase = vehicleValueGross > 0 ? vehicleValueGross : marketValue;
        
        if (calculationBase > 0 && totalClaim > 0) {
          const percentage = (totalClaim / calculationBase) * 100;
          console.log(`ğŸ“Š Damage percentage calculation: ${totalClaim.toLocaleString()} Ã· ${calculationBase.toLocaleString()} = ${Math.round(percentage)}%`);
          return Math.round(percentage) + '%';
        }
        return '[××—×•×– × ×–×§]';
      } catch (error) {
        return '[××—×•×– × ×–×§]';
      }
    }

    // UPDATE GROSS MARKET VALUE FIELD
    function updateGrossMarketValueField() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        let vehicleValueGross = helper.calculations?.vehicle_value_gross;
        
        console.log('ğŸ” Checking vehicle_value_gross:', {
          helper_calculations: helper.calculations,
          vehicle_value_gross: vehicleValueGross,
          levi_report_final_price: helper.levi_report?.final_price,
          expertise_calculations: helper.expertise?.calculations
        });
        
        // If vehicle_value_gross is missing, try to calculate it from Levi data
        if (!vehicleValueGross && helper.levi_report) {
          const leviReport = helper.levi_report;
          const basePrice = parseFloat(leviReport.base_price || 0);
          const featuresValue = parseFloat(leviReport.features_value || 0);
          const registrationValue = parseFloat(leviReport.registration_value || 0);
          
          if (basePrice > 0) {
            vehicleValueGross = basePrice + featuresValue + registrationValue;
            console.log(`ğŸ”§ Calculated vehicle_value_gross from Levi data: ${basePrice} + ${featuresValue} + ${registrationValue} = ${vehicleValueGross}`);
            
            // Update helper with calculated value
            const calculationsData = {
              ...helper.calculations,
              vehicle_value_gross: vehicleValueGross
            };
            
            if (typeof updateHelper === 'function') {
              updateHelper('calculations', calculationsData, 'estimate_builder_gross_value_calculation');
            } else {
              // Fallback for compatibility
              helper.calculations = helper.calculations || {};
              helper.calculations.vehicle_value_gross = vehicleValueGross;
              sessionStorage.setItem('helper', JSON.stringify(helper));
            }
          }
        }
        
        // If still no value, try other fallbacks
        if (!vehicleValueGross) {
          const fallbackSources = [
            helper.levi_report?.final_price,
            helper.expertise?.calculations?.market_value,
            helper.expertise?.calculations?.vehicle_value_gross,
            helper.levisummary?.final_price
          ];
          
          for (const fallback of fallbackSources) {
            if (fallback && fallback > 0) {
              vehicleValueGross = fallback;
              console.log(`ğŸ”§ Using fallback for vehicle_value_gross: ${vehicleValueGross}`);
              break;
            }
          }
        }
        
        // Update the field if we have a value
        if (vehicleValueGross && vehicleValueGross > 0) {
          const leviPriceListField = document.getElementById('leviPriceList');
          if (leviPriceListField) {
            leviPriceListField.value = `â‚ª${vehicleValueGross.toLocaleString()}`;
            
            // Update helper claims data to maintain consistency
            const claimsData = {
              ...helper.claims_data,
              gross_value: vehicleValueGross
            };
            
            if (typeof updateHelper === 'function') {
              updateHelper('claims_data', claimsData, 'estimate_builder_claims_consistency');
            } else {
              // Fallback for compatibility
              helper.claims_data = helper.claims_data || {};
              helper.claims_data.gross_value = vehicleValueGross;
              sessionStorage.setItem('helper', JSON.stringify(helper));
            }
            
            console.log(`ğŸ’° Updated gross market value field: â‚ª${vehicleValueGross.toLocaleString()}`);
          }
        } else {
          console.warn('âš ï¸ No vehicle_value_gross found after all fallback attempts');
        }
        
        // Do NOT call updateGrossPercentageField here to avoid infinite loop
      } catch (error) {
        console.error('Error updating gross market value field:', error);
      }
    }

    // LOAD GROSS ADJUSTMENTS - ONLY Features + Registration (Base Price Independent)
    function loadGrossAdjustments(helper) {
      try {
        const featuresContainer = document.getElementById('featuresAdjustmentsList');
        const registrationContainer = document.getElementById('registrationAdjustmentsList');
        if (featuresContainer) featuresContainer.innerHTML = '';
        if (registrationContainer) registrationContainer.innerHTML = '';

        // CRITICAL FIX: Transform Levi data to valuation structure if needed
        populateValuationAdjustmentsFromLevi(helper);

        // Get data from helper.valuation.adjustments (single source of truth)
        const adjustments = helper.valuation?.adjustments || {};
        
        console.log('ğŸ” Loading GROSS adjustments (Features + Registration only):', adjustments);

        // ===== Features Adjustments =====

        let featureItems = [];
        
        // Load ONLY features data for GROSS calculation (independent of other adjustments)
        const featuresData = adjustments.features || {};
        if (featuresData.amount || featuresData.percent || featuresData.description || featuresData.reason) {
          featureItems = [{
            description: featuresData.reason || featuresData.description || '',
            amount: featuresData.amount || 0,
            percent: featuresData.percent || 0
          }];
        }
        
        // Always show at least one row for editing
        if (featureItems.length === 0) {
          featureItems = [{}];
        }
        
        console.log('ğŸš— Loading Features for GROSS calculation only:', featureItems);

        featureItems.forEach(item => {
          if (typeof addFeatureAdjustment === 'function') {
            addFeatureAdjustment();
            const row = document.querySelector('#featuresAdjustmentsList > div:last-child');
            if (row) {
              const inputs = row.querySelectorAll('input, select');
              const amount = parseFloat(item.amount) || 0;
              const percent = parseFloat(item.percent) || 0;
              
              console.log('ğŸ” Loading feature adjustment:', {
                item: item,
                amount: amount,
                percent: percent,
                isNegative: (amount < 0 || percent < 0)
              });
              
              if (inputs.length >= 4) {
                // Use the real property value for the description if available
                const desc = item.description || item.desc || item.feature || featuresData.description || featuresData.reason || '';
                inputs[0].value = desc;
                
                // Determine type based on negative values in helper data
                const isNegative = (amount < 0 || percent < 0);
                inputs[1].value = isNegative ? 'minus' : 'plus';
                console.log(`ğŸ“ Set type to: ${isNegative ? 'minus (×”×¤×—×ª×”)' : 'plus (×ª×•×¡×¤×ª)'}`);
              
                inputs[2].value = percent ? Math.abs(percent) : '';
                
                // If amount exists in helper, use it; otherwise calculate from percentage
                if (amount) {
                  inputs[3].value = `â‚ª${Math.abs(amount).toLocaleString()}`;
                } else if (percent && typeof calculateAdjustmentValueSimple === 'function') {
                  // Trigger calculation from percentage Ã— base price
                  setTimeout(() => calculateAdjustmentValueSimple(inputs[2]), 100);
                }
              }
            }
          }
        });

        // ===== Registration Adjustment (GROSS SECTION ONLY) =====
        // Load ONLY from helper.valuation.adjustments.registration - single source of truth
        
        const registrationData = adjustments.registration || {};
        let showRegistration = registrationData.amount || registrationData.percent || registrationData.date || registrationData.description || registrationData.reason;
        
        if (!showRegistration) {
          // Always show one row for user entry
          showRegistration = true;
        }
        if (showRegistration && typeof addRegistrationAdjustment === 'function') {
          addRegistrationAdjustment();
          const row = document.querySelector('#registrationAdjustmentsList > div:last-child');
          if (row) {
            const inputs = row.querySelectorAll('input, select');
            
            // Load registration data for GROSS calculation only
            const amount = parseFloat(registrationData.amount) || 0;
            const percent = parseFloat(registrationData.percent) || 0;
            
            console.log('ğŸ” Loading registration adjustment for GROSS calculation:', {
              registrationData: registrationData,
              amount: amount,
              percent: percent,
              isNegative: (amount < 0 || percent < 0)
            });
            
            if (inputs.length >= 4) {
              // Use actual description/reason from helper data
              const desc = registrationData.reason || registrationData.description || registrationData.date || 
                          helper.vehicle?.registration_date || '';
              inputs[0].value = desc;
              
              // Determine type based on negative values
              const isNegative = (amount < 0 || percent < 0);
              inputs[1].value = isNegative ? 'minus' : 'plus';
              console.log(`ğŸ“ Set registration type to: ${isNegative ? 'minus (×”×¤×—×ª×”)' : 'plus (×ª×•×¡×¤×ª)'}`);
            
              inputs[2].value = percent ? Math.abs(percent) : '';
              
              // If amount exists, use it; otherwise calculate from percentage
              if (amount) {
                inputs[3].value = `â‚ª${Math.abs(amount).toLocaleString()}`;
              } else if (percent && typeof calculateAdjustmentValueSimple === 'function') {
                // Trigger calculation from percentage Ã— base price
                setTimeout(() => calculateAdjustmentValueSimple(inputs[2]), 100);
              }
            }
          }
        }

        updateGrossMarketValueCalculation();
      } catch (error) {
        console.error('Error loading gross adjustments:', error);
      }
    }
    
    // GROSS DAMAGE PERCENTAGE CALCULATION FUNCTIONS
    
    // Add feature adjustment row
    function addFeatureAdjustment() {
      const container = document.getElementById('featuresAdjustmentsList');
      const rowId = 'featureAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
          <div><input type="text" placeholder="×ª×™××•×¨ ×”×××¤×™×™×Ÿ" onchange="updateGrossMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'features');" /></div>
          <div><select onchange="updateGrossMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'features');">
            <option value="plus">×ª×•×¡×¤×ª (+)</option>
            <option value="minus">×”×¤×—×ª×” (-)</option>
          </select></div>
          <div><input type="text" placeholder="%" oninput="calculateAdjustmentValueSimple(this);" onchange="updateGrossMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'features');" /></div>
          <div><input type="text" placeholder="â‚ª" onchange="updateGrossMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'features');" /></div>
          <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">××—×§</button></div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      updateGrossMarketValueCalculation();
    }
    
    // Add registration adjustment row
    function addRegistrationAdjustment() {
      const container = document.getElementById('registrationAdjustmentsList');
      const rowId = 'regAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
          <div><input type="text" placeholder="×ª×™××•×¨ ×¢×œ×™×” ×œ×›×‘×™×©" onchange="updateGrossMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'registration');" /></div>
          <div><select onchange="updateGrossMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'registration');">
            <option value="plus">×ª×•×¡×¤×ª (+)</option>
            <option value="minus">×”×¤×—×ª×” (-)</option>
          </select></div>
          <div><input type="text" placeholder="%" oninput="calculateAdjustmentValueSimple(this);" onchange="updateGrossMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'registration');" /></div>
          <div><input type="text" placeholder="â‚ª" onchange="updateGrossMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'registration');" /></div>
          <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">××—×§</button></div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      updateGrossMarketValueCalculation();
    }
    
    // ============================================================================
    // AUTO-POPULATION FROM LEVI SUMMARY
    // ============================================================================
    
    // Flag to prevent multiple executions
    let autoPopulationInProgress = false;
    let autoPopulationCompleted = sessionStorage.getItem('autoPopulationCompleted') === 'true';
    
    /**
     * Auto-populate features and registration adjustments from Levi summary data
     */
    function autoPopulateFromLeviSummary() {
      if (autoPopulationInProgress) {
        console.log('âš ï¸ Auto-population already in progress, skipping...');
        return;
      }
      
      if (autoPopulationCompleted) {
        console.log('âš ï¸ Auto-population already completed, skipping...');
        return;
      }
      
      autoPopulationInProgress = true;
      console.log('ğŸš€ Starting auto-population from Levi summary...');
      
      // ENHANCED: Ensure EstimateCalculations is ready before proceeding
      if (!window.EstimateCalculations) {
        console.log('â³ EstimateCalculations not ready, waiting...');
        setTimeout(() => {
          autoPopulationInProgress = false;
          autoPopulateFromLeviSummary();
        }, 200);
        return;
      }
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Check for valuation adjustments (primary source) and fallback sources
      if (!helper.valuation?.adjustments && !helper.levisummary && !helper.levi_report && !helper.expertise?.levi_report) {
        autoPopulationInProgress = false;
        return;
      }
      
      clearLeviAdjustments();
      
      // Get Levi data from valuation adjustments (primary) or fallback sources
      const leviData = helper.valuation?.adjustments || helper.levisummary || helper.levi_report || helper.expertise?.levi_report || {};
      const featuresData = leviData.features || {};
      const registrationData = leviData.registration || {};
      
      // Auto-populate features adjustments (×××¤×™×™× ×™×) - GROSS section only
      // ENHANCED: Try multiple possible field locations for better data capture
      const featuresPercent = featuresData.percent || featuresData.percentage || 
                             leviData['××—×™×¨ ×××¤×™×™× ×™× %'] || leviData['×××¤×™×™× ×™× %'] || 
                             helper['××—×™×¨ ×××¤×™×™× ×™× %'] || helper['×××¤×™×™× ×™× %'] ||
                             helper.levi?.['××—×™×¨ ×××¤×™×™× ×™× %'] ||
                             helper.expertise?.levi_report?.['××—×™×¨ ×××¤×™×™× ×™× %'] || '';
      const featuresAmount = featuresData.amount || featuresData.value || 
                            leviData['×¢×¨×š ×©"×— ×××¤×™×™× ×™×'] || leviData['×¢×¨×š ×××¤×™×™× ×™×'] || 
                            helper['×¢×¨×š ×©"×— ×××¤×™×™× ×™×'] || helper['×¢×¨×š ×××¤×™×™× ×™×'] ||
                            helper.levi?.['×¢×¨×š ×©"×— ×××¤×™×™× ×™×'] ||
                            helper.expertise?.levi_report?.['×¢×¨×š ×©"×— ×××¤×™×™× ×™×'] || '';
      const featuresDescription = featuresData.description || featuresData.reason || '×ª×•×¡×¤×•×ª ×××¤×™×™× ×™×';
      
      if (featuresPercent || featuresAmount) {
        if (typeof addFeatureAdjustment === 'function') {
          addFeatureAdjustment();
        }
        
        const rows = document.querySelectorAll('#featuresAdjustmentsList > div');
        const lastRow = rows[rows.length - 1];
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            inputs[0].value = featuresDescription || '×ª×•×¡×¤×•×ª ×××¤×™×™× ×™× (××œ×•×™ ×™×¦×—×§)';
            inputs[1].value = String(featuresPercent).includes('-') ? 'minus' : 'plus';
            inputs[2].value = Math.abs(parseFloat(String(featuresPercent).replace(/[%\s+]/g, ''))) || '';
            inputs[3].value = featuresAmount ? `â‚ª${Math.abs(parseFloat(String(featuresAmount).replace(/[â‚ª,\s]/g, ''))).toLocaleString()}` : '';
            
            lastRow.setAttribute('data-source', 'levi');
            lastRow.style.background = '#f0f8ff';
          }
        }
      }
      
      // Auto-populate registration adjustments (×¢×œ×™×” ×œ×›×‘×™×©) - GROSS section only  
      // ENHANCED: Try multiple possible field locations for better data capture
      const registrationPercent = registrationData.percent || registrationData.percentage || 
                                 leviData['×¢×œ×™×” ×œ×›×‘×™×© %'] || 
                                 helper['×¢×œ×™×” ×œ×›×‘×™×© %'] ||
                                 helper.levi?.['×¢×œ×™×” ×œ×›×‘×™×© %'] ||
                                 helper.expertise?.levi_report?.['×¢×œ×™×” ×œ×›×‘×™×© %'] || '';
      const registrationAmount = registrationData.amount || registrationData.value ||
                                leviData['×¢×¨×š ×©"×— ×¢×œ×™×” ×œ×›×‘×™×©'] || leviData['×¢×¨×š ×¢×œ×™×” ×œ×›×‘×™×©'] ||
                                helper['×¢×¨×š ×©"×— ×¢×œ×™×” ×œ×›×‘×™×©'] || helper['×¢×¨×š ×¢×œ×™×” ×œ×›×‘×™×©'] ||
                                helper.levi?.['×¢×¨×š ×©"×— ×¢×œ×™×” ×œ×›×‘×™×©'] ||
                                helper.expertise?.levi_report?.['×¢×¨×š ×©"×— ×¢×œ×™×” ×œ×›×‘×™×©'] || '';
      const registrationDescription = registrationData.description || registrationData.reason || '×¢×œ×™×” ×œ×›×‘×™×©';
      
      if (registrationPercent || registrationAmount) {
        if (typeof addRegistrationAdjustment === 'function') {
          addRegistrationAdjustment();
        }
        
        const rows = document.querySelectorAll('#registrationAdjustmentsList > div');
        const lastRow = rows[rows.length - 1];
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            inputs[0].value = registrationDescription || '×¢×œ×™×” ×œ×›×‘×™×© (××œ×•×™ ×™×¦×—×§)';
            inputs[1].value = String(registrationPercent).includes('-') ? 'minus' : 'plus';
            inputs[2].value = Math.abs(parseFloat(String(registrationPercent).replace(/[%\s+]/g, ''))) || '';
            inputs[3].value = registrationAmount ? `â‚ª${Math.abs(parseFloat(String(registrationAmount).replace(/[â‚ª,\s]/g, ''))).toLocaleString()}` : '';
            
            lastRow.setAttribute('data-source', 'levi');
            lastRow.style.background = '#f0f8ff';
          }
        }
      }
      
      // ===== END OF GROSS ADJUSTMENTS =====
      // Note: Market adjustments (mileage, ownership, owners) belong in "Full Market Value" section,
      // not in the gross value section which is only for car properties (features + registration)
      
      // Trigger calculations after auto-population
      setTimeout(() => {
        if (typeof updateGrossMarketValueCalculation === 'function') {
          updateGrossMarketValueCalculation();
        }
        if (typeof updateHelperFromAdjustments === 'function') {
          updateHelperFromAdjustments();
        }
        if (window.EstimateCalculations && typeof window.EstimateCalculations.refresh3BulkCalculations === 'function') {
          window.EstimateCalculations.refresh3BulkCalculations();
        }
      }, 100);
      
      autoPopulationInProgress = false;
      autoPopulationCompleted = true;
      sessionStorage.setItem('autoPopulationCompleted', 'true');
    }
    
    /**
     * Auto-populate market adjustments (mileage, ownership) for Full Market Value section
     */
    function autoPopulateMarketAdjustments() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const leviData = helper.valuation?.adjustments || {};
      
      console.log('ğŸª Auto-populating market adjustments for Full Market Value section');
      
      // Clear existing market adjustments
      const container = document.getElementById('allAdjustmentsList');
      if (container) {
        // Remove only Levi market adjustments
        const leviRows = container.querySelectorAll('div[data-source="levi"]');
        leviRows.forEach(row => row.remove());
      }
      
      // --- Features Adjustment (×××¤×™×™× ×™×) ---
      const featuresData = leviData.features || {};
      let featuresPercent = featuresData.percent || featuresData.percentage || '';
      let featuresAmount = featuresData.amount || featuresData.value || '';
      
      // Parse percentage (PRESERVE NEGATIVE SIGN!)
      if (typeof featuresPercent === 'string') {
        featuresPercent = parseFloat(featuresPercent.replace('%', '')) || 0;
      }
      
      // Parse amount (PRESERVE NEGATIVE SIGN!)
      if (typeof featuresAmount === 'string' && featuresAmount.includes('â‚ª')) {
        // Extract number including negative sign
        const cleanAmount = featuresAmount.replace(/[â‚ª,]/g, '');
        featuresAmount = parseFloat(cleanAmount) || 0;
      }
      
      console.log('ğŸ” Features data extracted:', { percent: featuresPercent, amount: featuresAmount });
      // Use actual feature list if available, and show only the value (no prefix)
      let featuresList = '';
      if (Array.isArray(featuresData.feature_list) && featuresData.feature_list.length > 0) {
        featuresList = featuresData.feature_list.map(f => f.description || f.name || f).join(', ');
      } else if (helper.car_details?.features && Array.isArray(helper.car_details.features)) {
        featuresList = helper.car_details.features.map(f => f.description || f.name || f).join(', ');
      }
      // Always use the .description field from helper for features
      let featuresDescription = featuresData.description || '';

      if (featuresPercent || featuresAmount) {
        addFullMarketAdjustment();
        const lastRow = document.querySelector('#allAdjustmentsList > div:last-child');
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input');
          const select = lastRow.querySelector('select');
          if (inputs.length >= 2 && select) {
            // Always use the .description field from helper for features
            inputs[0].value = featuresDescription || '×××¤×™×™× ×™×';
            select.value = featuresPercent < 0 ? 'minus' : 'plus';
            inputs[1].value = featuresPercent || '';
            inputs[2].value = featuresAmount ? `â‚ª${featuresAmount.toLocaleString()}` : '';
            lastRow.setAttribute('data-source', 'levi');
            lastRow.style.background = '#f0f8ff';
            console.log('âœ… Features adjustment populated:', { 
              description: inputs[0].value, 
              type: select.value, 
              percent: inputs[1].value, 
              amount: inputs[2].value,
              originalPercent: featuresPercent,
              originalAmount: featuresAmount
            });
          }
        }
      }

      // --- Registration Adjustment (×¢×œ×™×” ×œ×›×‘×™×©) ---
      const registrationData = leviData.registration || {};
      const registrationPercent = registrationData.percent || registrationData.percentage ||
                                 leviData['×¢×œ×™×” ×œ×›×‘×™×© %'] ||
                                 helper['×¢×œ×™×” ×œ×›×‘×™×© %'] ||
                                 helper.levi?.['×¢×œ×™×” ×œ×›×‘×™×© %'] ||
                                 helper.expertise?.levi_report?.['×¢×œ×™×” ×œ×›×‘×™×© %'] || '';
      const registrationAmount = registrationData.amount || registrationData.value ||
                                leviData['×¢×¨×š ×©"×— ×¢×œ×™×” ×œ×›×‘×™×©'] || leviData['×¢×¨×š ×¢×œ×™×” ×œ×›×‘×™×©'] ||
                                helper['×¢×¨×š ×©"×— ×¢×œ×™×” ×œ×›×‘×™×©'] || helper['×¢×¨×š ×¢×œ×™×” ×œ×›×‘×™×©'] ||
                                helper.levi?.['×¢×¨×š ×©"×— ×¢×œ×™×” ×œ×›×‘×™×©'] ||
                                helper.expertise?.levi_report?.['×¢×¨×š ×©"×— ×¢×œ×™×” ×œ×›×‘×™×©'] || '';
      // Use actual registration date if available, and show only the value (no prefix)
      // Always use the .description field from helper for registration
      let registrationDescription = registrationData.description || '';

      if (registrationPercent || registrationAmount) {
        addFullMarketAdjustment();
        const lastRow = document.querySelector('#allAdjustmentsList > div:last-child');
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input');
          const select = lastRow.querySelector('select');
          if (inputs.length >= 2 && select) {
            // Always use the .description field from helper for registration
            inputs[0].value = registrationDescription || '';
            const regPercent = parseFloat(String(registrationPercent).replace('%', '')) || 0;
            select.value = regPercent < 0 ? 'minus' : 'plus';
            inputs[1].value = regPercent || '';
            const regAmount = parseFloat(String(registrationAmount).replace(/[â‚ª,]/g, '')) || 0;
            inputs[2].value = regAmount ? `â‚ª${regAmount.toLocaleString()}` : '';
            lastRow.setAttribute('data-source', 'levi');
            lastRow.style.background = '#f0f8ff';
            console.log('âœ… Registration adjustment populated:', { 
              description: inputs[0].value, 
              type: select.value, 
              percent: inputs[1].value, 
              amount: inputs[2].value,
              originalPercent: registrationPercent,
              originalAmount: registrationAmount
            });
          }
        }
      }

      // --- Mileage Adjustment (××¡ ×§"×) ---
      const mileageData = leviData.mileage || {};
      let mileagePercent = mileageData.percent || mileageData.percentage || '';
      let mileageAmount = mileageData.amount || mileageData.value || '';
      
      // Parse percentage (PRESERVE NEGATIVE SIGN!)
      if (typeof mileagePercent === 'string') {
        mileagePercent = parseFloat(mileagePercent.replace('%', '')) || 0;
      }
      
      // Parse amount (PRESERVE NEGATIVE SIGN!)
      if (typeof mileageAmount === 'string' && mileageAmount.includes('â‚ª')) {
        const cleanAmount = mileageAmount.replace(/[â‚ª,]/g, '');
        mileageAmount = parseFloat(cleanAmount) || 0;
      }
      
      console.log('ğŸ” Mileage data extracted:', { percent: mileagePercent, amount: mileageAmount });
      
      const mileageDescription = mileageData.description || '××¡ ×§"×';

      if (mileagePercent || mileageAmount) {
        addFullMarketAdjustment();
        const lastRow = document.querySelector('#allAdjustmentsList > div:last-child');
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input');
          const select = lastRow.querySelector('select');
          if (inputs.length >= 2 && select) {
            inputs[0].value = mileageDescription || '××¡ ×§"×';
            select.value = mileagePercent < 0 ? 'minus' : 'plus';
            inputs[1].value = mileagePercent || '';
            inputs[2].value = mileageAmount ? `â‚ª${mileageAmount.toLocaleString()}` : '';
            lastRow.setAttribute('data-source', 'levi');
            lastRow.style.background = '#f0f8ff';
            console.log('âœ… Mileage adjustment populated:', { 
              description: inputs[0].value, 
              type: select.value, 
              percent: inputs[1].value, 
              amount: inputs[2].value,
              originalPercent: mileagePercent,
              originalAmount: mileageAmount
            });
          }
        }
      }

      // --- Ownership Type Adjustment (×‘×¢×œ×•×ª) ---
      const ownershipData = leviData.ownership_type || {};
      let ownershipPercent = ownershipData.percent || ownershipData.percentage || '';
      let ownershipAmount = ownershipData.amount || ownershipData.value || '';
      
      // Parse percentage (PRESERVE NEGATIVE SIGN!)
      if (typeof ownershipPercent === 'string') {
        ownershipPercent = parseFloat(ownershipPercent.replace('%', '')) || 0;
      }
      
      // Parse amount (PRESERVE NEGATIVE SIGN!)
      if (typeof ownershipAmount === 'string' && ownershipAmount.includes('â‚ª')) {
        const cleanAmount = ownershipAmount.replace(/[â‚ª,]/g, '');
        ownershipAmount = parseFloat(cleanAmount) || 0;
      }
      
      console.log('ğŸ” Ownership data extracted:', { percent: ownershipPercent, amount: ownershipAmount });
      
      const ownershipDescription = ownershipData.description || '×‘×¢×œ×•×ª';

      if (ownershipPercent || ownershipAmount) {
        addFullMarketAdjustment();
        const lastRow = document.querySelector('#allAdjustmentsList > div:last-child');
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input');
          const select = lastRow.querySelector('select');
          if (inputs.length >= 2 && select) {
            inputs[0].value = ownershipDescription || '×‘×¢×œ×•×ª';
            select.value = ownershipPercent < 0 ? 'minus' : 'plus';
            inputs[1].value = ownershipPercent || '';
            inputs[2].value = ownershipAmount ? `â‚ª${ownershipAmount.toLocaleString()}` : '';
            lastRow.setAttribute('data-source', 'levi');
            lastRow.style.background = '#f0f8ff';
            console.log('âœ… Ownership adjustment populated:', { 
              description: inputs[0].value, 
              type: select.value, 
              percent: inputs[1].value, 
              amount: inputs[2].value,
              originalPercent: ownershipPercent,
              originalAmount: ownershipAmount
            });
          }
        }
      }

      // --- Ownership History Adjustment (××¡×¤×¨ ×‘×¢×œ×™×) ---
      const ownersPercent = leviData.ownership_history?.percent || leviData.ownership_history?.percentage ||
                           leviData['××¡×¤×¨ ×‘×¢×œ×™× %'] || helper['××¡×¤×¨ ×‘×¢×œ×™× %'] || '';
      const ownersAmount = leviData.ownership_history?.amount || leviData.ownership_history?.value ||
                          leviData['×¢×¨×š ×©"×— ××¡×¤×¨ ×‘×¢×œ×™×'] || leviData['×¢×¨×š ××¡×¤×¨ ×‘×¢×œ×™×'] ||
                          helper['×¢×¨×š ×©"×— ××¡×¤×¨ ×‘×¢×œ×™×'] || helper['×¢×¨×š ××¡×¤×¨ ×‘×¢×œ×™×'] || '';
      // Use actual owner count if available
      const ownerCount = leviData.ownership_history?.owner_count || helper.vehicle?.owner_count || helper.car_details?.owner_count || '';
      const ownersDescription = ownerCount ? `××¡×¤×¨ ×‘×¢×œ×™×: ${ownerCount}` : (leviData.ownership_history?.description || leviData.ownership_history?.reason || '××¡×¤×¨ ×‘×¢×œ×™×');

      if (ownersPercent || ownersAmount) {
        addFullMarketAdjustment();
        const lastRow = document.querySelector('#allAdjustmentsList > div:last-child');
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input');
          const select = lastRow.querySelector('select');
          if (inputs.length >= 2 && select) {
            inputs[0].value = ownersDescription || '××¡×¤×¨ ×‘×¢×œ×™× (××œ×•×™ ×™×¦×—×§)';
            const ownerPercent = parseFloat(String(ownersPercent).replace('%', '')) || 0;
            select.value = ownerPercent < 0 ? 'minus' : 'plus';
            inputs[1].value = ownerPercent || '';
            const ownerAmount = parseFloat(String(ownersAmount).replace(/[â‚ª,]/g, '')) || 0;
            inputs[2].value = ownerAmount ? `â‚ª${ownerAmount.toLocaleString()}` : '';
            lastRow.setAttribute('data-source', 'levi');
            lastRow.style.background = '#f0f8ff';
            console.log('âœ… Previous owners adjustment populated:', { 
              description: inputs[0].value, 
              type: select.value, 
              percent: inputs[1].value, 
              amount: inputs[2].value,
              originalPercent: ownersPercent,
              originalAmount: ownersAmount
            });
          }
        }
      }
      
      console.log('âœ… Market adjustments auto-population completed');
    }
    
    /**
     * Clear existing auto-populated Levi adjustments before re-populating
     */
    function clearLeviAdjustments() {
      // Clear features adjustments marked as Levi data
      const featureRows = document.querySelectorAll('#featuresAdjustmentsList div[data-source="levi"]');
      console.log(`ğŸ§¹ Clearing ${featureRows.length} Levi feature rows`);
      featureRows.forEach(row => row.remove());
      
      // Clear registration adjustments marked as Levi data
      const registrationRows = document.querySelectorAll('#registrationAdjustmentsList div[data-source="levi"]');
      console.log(`ğŸ§¹ Clearing ${registrationRows.length} Levi registration rows`);
      registrationRows.forEach(row => row.remove());
      
      // Clear market adjustments marked as Levi data 
      const marketRows = document.querySelectorAll('#allAdjustmentsList div[data-source="levi"]');
      console.log(`ğŸ§¹ Clearing ${marketRows.length} Levi market rows`);
      marketRows.forEach(row => row.remove());
      
      console.log('âœ… Cleared all existing Levi adjustments');
    }
    
    /**
     * Enhanced two-way data binding: sync individual adjustment changes to helper
     */
    function syncAdjustmentToHelper(element, category) {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        const row = element.closest('div[id^="featureAdj_"], div[id^="regAdj_"]');
        if (!row) return;
        
        const inputs = row.querySelectorAll('input, select');
        if (inputs.length < 4) return;
        
        const adjustmentData = {
          description: inputs[0].value || '',
          type: inputs[1].value || 'plus',
          percentage: parseFloat(inputs[2].value) || 0,
          value: parseFloat(inputs[3].value.replace(/[â‚ª,]/g, '')) || 0,
          category: category,
          source: row.getAttribute('data-source') || 'manual',
          timestamp: new Date().toISOString()
        };
        
        // Initialize helper structure
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.valuation.adjustments[category]) helper.valuation.adjustments[category] = [];
        
        // Find existing adjustment by row ID or add new one
        const rowId = row.id;
        
        // DEFENSIVE CHECK: Ensure it's still an array before findIndex
        if (!Array.isArray(helper.valuation.adjustments[category])) {
          helper.valuation.adjustments[category] = [];
        }
        
        const existingIndex = helper.valuation.adjustments[category].findIndex(adj => adj.rowId === rowId);
        
        adjustmentData.rowId = rowId;
        
        if (existingIndex >= 0) {
          helper.valuation.adjustments[category][existingIndex] = adjustmentData;
        } else {
          helper.valuation.adjustments[category].push(adjustmentData);
        }
        
        // Save to storage using proper function
        if (typeof updateHelper === 'function') {
          updateHelper('valuation', helper.valuation, 'estimate_builder_adjustment_sync');
        } else {
          // Fallback for compatibility
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        
        // Trigger UI updates
        if (window.forcePopulateFields) {
          window.forcePopulateFields();
        }
        
      } catch (error) {
        console.error('âŒ Error syncing adjustment to helper:', error);
      }
    }
    
    // Remove adjustment row
    function removeAdjustmentRow(rowId) {
      const row = document.getElementById(rowId);
      if (row) {
        row.remove();
        updateGrossMarketValueCalculation();
        updateHelperFromAdjustments();
      }
    }
    
    // Calculate adjustment value for simple percentage input
    function calculateAdjustmentValueSimple(percentInput) {
      const row = percentInput.closest('div');
      if (!row) return;
      
      const inputs = row.querySelectorAll('input, select');
      if (inputs.length < 4) return;
      
      const percent = parseFloat(percentInput.value) || 0;
      const basicPrice = parseFloat(document.getElementById('basicPrice')?.value?.replace(/[â‚ª,]/g, '')) || 0;
      
      if (basicPrice > 0) {
        const calculatedValue = (basicPrice * percent) / 100;
        inputs[3].value = calculatedValue ? `â‚ª${Math.abs(calculatedValue).toLocaleString()}` : '';
      }
    }
    
    // ============================================================================
    // END OF AUTO-POPULATION FUNCTIONS
    // ============================================================================
    
    // LOAD SUMMARY DATA AND CALCULATIONS
    function loadSummaryData(helper) {
      try {
        // Set report type based on estimate type selection
        const selectedType = document.querySelector('input[name="estimate-type"]:checked')?.value || '××•×‘×“×Ÿ_×œ×”×œ×›×”';
        const reportTypeText = selectedType === '××•×‘×“×Ÿ_×œ×”×œ×›×”' ? '××•××“×Ÿ ×¨××©×•× ×™ - ××•×‘×“×Ÿ ×œ×”×œ×›×”' : '××•××“×Ÿ ×¨××©×•× ×™ - ×˜×•×˜×œ×•×¡';
        document.getElementById('reportType').value = reportTypeText;
        
        // Implementation continues...
        
      } catch (error) {
        console.error('Error loading summary data:', error);
      }
    }
    
    /**
     * Enhanced two-way data binding: sync individual adjustment changes to helper
     */
    function syncAdjustmentToHelper(element, category) {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        const row = element.closest('div[id^="featureAdj_"], div[id^="regAdj_"]');
        if (!row) return;
        
        const inputs = row.querySelectorAll('input, select');
        if (inputs.length < 4) return;
        
        const adjustmentData = {
          description: inputs[0].value || '',
          type: inputs[1].value || 'plus',
          percentage: parseFloat(inputs[2].value) || 0,
          value: parseFloat(inputs[3].value.replace(/[â‚ª,]/g, '')) || 0,
          category: category,
          source: row.getAttribute('data-source') || 'manual',
          timestamp: new Date().toISOString()
        };
        
        // Initialize helper structure
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.valuation.adjustments[category]) helper.valuation.adjustments[category] = [];
        
        // Find existing adjustment by row ID or add new one
        const rowId = row.id;
        
        // DEFENSIVE CHECK: Ensure it's still an array before findIndex
        if (!Array.isArray(helper.valuation.adjustments[category])) {
          helper.valuation.adjustments[category] = [];
        }
        
        const existingIndex = helper.valuation.adjustments[category].findIndex(adj => adj.rowId === rowId);
        
        adjustmentData.rowId = rowId;
        
        if (existingIndex >= 0) {
          helper.valuation.adjustments[category][existingIndex] = adjustmentData;
          console.log(`ğŸ”„ Updated ${category} adjustment:`, adjustmentData);
        } else {
          helper.valuation.adjustments[category].push(adjustmentData);
          console.log(`â• Added new ${category} adjustment:`, adjustmentData);
        }
        
        // Save to storage using proper function
        if (typeof updateHelper === 'function') {
          updateHelper('valuation', helper.valuation, 'estimate_builder_adjustment_sync_2');
        } else {
          // Fallback for compatibility
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        
        // Trigger UI updates
        if (window.forcePopulateFields) {
          window.forcePopulateFields();
        }
        
      } catch (error) {
        console.error('âŒ Error syncing adjustment to helper:', error);
      }
    }
    
    /**
     * Listen for helper updates to trigger re-population when Levi data changes
     */
    function setupLeviDataListener() {
      // Listen for storage events (when helper data changes)
      window.addEventListener('storage', (event) => {
        if (event.key === 'helper' && event.newValue) {
          try {
            const newHelper = JSON.parse(event.newValue);
            if (newHelper.levisummary || newHelper.levi_report) {
              console.log('ğŸ“¡ Detected Levi data update, re-populating adjustments...');
              clearLeviAdjustments();
              helper = newHelper; // Update global helper
              autoPopulateFromLeviSummary();
            }
          } catch (error) {
            console.error('âŒ Error processing helper update:', error);
          }
        }
      });
      
      // Also listen for custom events
      document.addEventListener('helperUpdate', (event) => {
        if (event.detail && (event.detail.section === 'levisummary' || event.detail.section === 'levi_report')) {
          console.log('ğŸ“¡ Detected Levi data event, re-populating adjustments...');
          
          // CRITICAL FIX: When Levi data updates, refresh both estimate adjustments AND gross adjustments
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          
          // Transform Levi data to valuation structure first
          populateValuationAdjustmentsFromLevi(helper);
          
          // Refresh gross adjustments (features & registration) with new Levi data
          setTimeout(() => {
            console.log('ğŸ”„ Refreshing gross adjustments with updated Levi data...');
            loadGrossAdjustments(helper);
          }, 100);
        }
      });
      
      console.log('ğŸ“¡ Levi data listener setup completed');
    }
    
    // Remove adjustment row
    function removeAdjustmentRow(rowId) {
      const row = document.getElementById(rowId);
      if (row) {
        row.remove();
        updateGrossMarketValueCalculation();
        updateHelperFromAdjustments();
      }
    }
    
    // Calculate adjustment value from percentage - ENHANCED
    function calculateAdjustmentValue(percentInput) {
      const row = percentInput.closest('div[id^="featureAdj_"], div[id^="regAdj_"]');
      if (!row) {
        console.warn('âš ï¸ Cannot find adjustment row for calculation');
        return;
      }
      
      const percent = parseFloat(percentInput.value.replace('%', '')) || 0;
      let basicPrice = parseFloat(document.getElementById('basicPrice')?.value.replace(/[â‚ª,]/g, '')) || 0;
      
      // Try alternative price sources if basicPrice is empty
      if (basicPrice === 0) {
        // Try grossMarketValue first (from calculations)
        const grossMarketValue = parseFloat(document.getElementById('grossMarketValue')?.value.replace(/[â‚ª,]/g, '')) || 0;
        if (grossMarketValue > 0) {
          basicPrice = grossMarketValue;
          console.log('ğŸ“Š Using grossMarketValue for calculation:', basicPrice);
        }
      }
      
      // If still no price, try to get BASE PRICE from helper
      if (basicPrice === 0) {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (helper.levi_report?.base_price) {
          basicPrice = parseFloat(helper.levi_report.base_price);
        } else if (helper.expertise?.levi_report?.base_price) {
          basicPrice = parseFloat(helper.expertise.levi_report.base_price);
        } else if (helper.levisummary?.base_price) {
          basicPrice = parseFloat(helper.levisummary.base_price);
        } else if (helper.car_details?.base_price) {
          basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[â‚ª,]/g, ''));
        } else {
          // REMOVED market_value fallback - we need BASE price only for calculations
          console.warn('âš ï¸ No Levi BASE PRICE found for adjustment calculation');
        }
        
        // If we found a basic price, update the field
        if (basicPrice > 0) {
          const basicPriceField = document.getElementById('basicPrice');
          if (basicPriceField) {
            basicPriceField.value = `â‚ª${basicPrice.toLocaleString()}`;
          }
        }
      }
      
      const valueInput = row.querySelector('input[placeholder="â‚ª"]');
      
      if (!valueInput) {
        console.error('âš ï¸ Cannot find value input field in adjustment row');
        return;
      }
      
      if (basicPrice > 0 && percent !== 0) {
        const calculatedValue = (basicPrice * percent) / 100;
        valueInput.value = `â‚ª${Math.round(calculatedValue).toLocaleString()}`;
        console.log(`ğŸ’° Calculated adjustment value: ${percent}% Ã— â‚ª${basicPrice.toLocaleString()} = â‚ª${Math.round(calculatedValue).toLocaleString()}`);
        
        // Trigger change event to update other calculations
        valueInput.dispatchEvent(new Event('change', { bubbles: true }));
      } else {
        console.warn(`âš ï¸ Cannot calculate adjustment value - basicPrice: ${basicPrice}, percent: ${percent}`);
        if (basicPrice === 0) {
          console.warn('âš ï¸ No car price found. Please set the basic price first.');
        }
      }
    }
    
    // SIMPLE ADJUSTMENT CALCULATION - COPIED FROM WORKING DEPRECIATION
    function calculateAdjustmentValueSimple(percentInput) {
      let percent = parseFloat(percentInput.value) || 0;
      
      // Find the value field in the same row
      const row = percentInput.closest('div[id^="featureAdj_"], div[id^="regAdj_"]');
      if (!row) return;
      
      const valueInput = row.querySelector('input[placeholder="â‚ª"]');
      if (!valueInput) return;
      
      // Get market value - try multiple sources like depreciation does
      let marketValue = 0;
      
      // First try summary market value (priority)
      const sumMarketValueField = document.getElementById('sumMarketValue');
      if (sumMarketValueField && sumMarketValueField.value) {
        const sumMarketStr = sumMarketValueField.value.replace(/[â‚ª,]/g, '') || '0';
        marketValue = parseFloat(sumMarketStr) || 0;
      }
      
      // If no summary value, try car details market value
      if (marketValue === 0) {
        const carMarketValueField = document.getElementById('carMarketValue');
        if (carMarketValueField && carMarketValueField.value) {
          const carMarketStr = carMarketValueField.value.replace(/[â‚ª,]/g, '') || '0';
          marketValue = parseFloat(carMarketStr) || 0;
        }
      }
      
      // If still no value, try basicPrice
      if (marketValue === 0) {
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField && basicPriceField.value) {
          const basicPriceStr = basicPriceField.value.replace(/[â‚ª,]/g, '') || '0';
          marketValue = parseFloat(basicPriceStr) || 0;
        }
      }
      
      // Calculate and display value
      if (marketValue > 0 && percent > 0) {
        const calculatedValue = (marketValue * percent) / 100;
        valueInput.value = `â‚ª${Math.round(calculatedValue).toLocaleString()}`;
      } else {
        valueInput.value = '';
      }
    }

    // SIMPLE ESTIMATE ADJUSTMENT CALCULATION - COPIED FROM WORKING DEPRECIATION
    function calculateEstimateAdjustmentValueSimple(percentInput) {
      const percent = parseFloat(percentInput.value) || 0;
      const row = percentInput.closest('div');
      
      if (!row) return;
      
      // Get helper data like the working depreciation does
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const marketValue = parseFloat(helper.expertise?.levi_report?.final_price) || 0;
      
      // Calculate value exactly like working depreciation
      const calculatedValue = Math.round((marketValue * percent) / 100);
      
      // Find value input (third input in row)
      const inputs = row.querySelectorAll('input');
      if (inputs.length > 2) {
        const valueInput = inputs[2];
        valueInput.value = calculatedValue || '';
      }
    }

    // Test function to manually add adjustment data for debugging
    function addTestAdjustments() {
      console.log('ğŸ§ª Adding test adjustments for debugging');
      
      // Add test features adjustment
      addFeatureAdjustment();
      const featuresContainer = document.getElementById('featuresAdjustmentsList');
      const lastFeaturesRow = featuresContainer.querySelector('div:last-child');
      if (lastFeaturesRow) {
        const inputs = lastFeaturesRow.querySelectorAll('input[type="text"]');
        inputs[0].value = '×××¤×™×™×Ÿ ×‘×“×™×§×”';
        inputs[1].value = '5%';
        inputs[2].value = 'â‚ª1000';
        lastFeaturesRow.querySelector('select').value = 'plus';
      }
      
      // Add test registration adjustment
      addRegistrationAdjustment();
      const registrationContainer = document.getElementById('registrationAdjustmentsList');
      const lastRegistrationRow = registrationContainer.querySelector('div:last-child');
      if (lastRegistrationRow) {
        const inputs = lastRegistrationRow.querySelectorAll('input[type="text"]');
        inputs[0].value = '×¢×œ×™×” ×œ×›×‘×™×© ×‘×“×™×§×”';
        inputs[1].value = '10%';
        inputs[2].value = 'â‚ª2000';
        lastRegistrationRow.querySelector('select').value = 'plus';
      }
      
      // Trigger the update
      updateHelperFromAdjustments();
    }
    
    // Expose test function globally
    window.addTestAdjustments = addTestAdjustments;
    
    // CRITICAL FIX: Add function to completely reset adjustment data
    function resetAdjustmentData() {
      console.log('ğŸ§¹ RESET: Completely clearing all adjustment data');
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Clear all adjustment data
      if (helper.levi_report) {
        helper.levi_report.adjustments = [];
      }
      if (helper.levi) {
        helper.levi.custom_adjustments = [];
      }
      
      // Clear DOM
      const adjustmentsContainer = document.getElementById('allAdjustmentsRows-estimate');
      if (adjustmentsContainer) {
        adjustmentsContainer.innerHTML = '<div style="color: #666; text-align: center; padding: 10px; font-size: 13px;">× ×ª×•× ×™ ×”×ª×××•×ª × ××—×§×• - ×”×©×ª××© ×‘×›×¤×ª×•×¨ "×”×•×¡×£ ×”×ª×××” × ×•×¡×¤×ª"</div>';
      }
      
      // Save cleaned helper using proper function
      if (typeof updateHelper === 'function') {
        updateHelper('levi_report', helper.levi_report, 'estimate_builder_reset_adjustments');
        updateHelper('levi', helper.levi, 'estimate_builder_reset_adjustments');
      } else {
        // Fallback for compatibility
        sessionStorage.setItem('helper', JSON.stringify(helper));
      }
      
      console.log('âœ… RESET: All adjustment data cleared');
    }
    
    // Expose reset function globally for testing
    window.resetAdjustmentData = resetAdjustmentData;
    
    // Update helper from adjustments
    function updateHelperFromAdjustments() {
      try {
        console.log('ğŸ”„ updateHelperFromAdjustments called');
        
        // CRITICAL FIX: Check if there are any user-created adjustments
        // If not, don't process anything to prevent circular data creation
        const userCreatedRows = document.querySelectorAll('#allAdjustmentsRows-estimate div[data-user-created="true"]');
        const featuresRows = document.querySelectorAll('#featuresAdjustmentsList > div');
        const registrationRows = document.querySelectorAll('#registrationAdjustmentsList > div');
        
        const hasUserInput = userCreatedRows.length > 0 || featuresRows.length > 0 || registrationRows.length > 0;
        
        console.log('ğŸ” DEBUG: User input check:', {
          userCreatedRows: userCreatedRows.length,
          featuresRows: featuresRows.length,
          registrationRows: registrationRows.length,
          hasUserInput
        });
        
        if (!hasUserInput) {
          console.log('âš ï¸ No user input detected - skipping updateHelperFromAdjustments to prevent circular data creation');
          return;
        }
        
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        console.log('ğŸ“Š Current helper before update:', helper);
        
        // Debug: Check if DOM elements exist
        console.log('ğŸ” DEBUG: DOM elements check:', {
          featuresAdjustmentsList: !!document.getElementById('featuresAdjustmentsList'),
          registrationAdjustmentsList: !!document.getElementById('registrationAdjustmentsList'),
          allAdjustmentsRows: !!document.getElementById('allAdjustmentsRows-estimate')
        });
        
        // Initialize structures
        helper.levi_report = helper.levi_report || {};
        // CRITICAL FIX: Clear adjustments since we already verified user input exists
        helper.levi_report.adjustments = [];
        if (helper.levi) {
          helper.levi.custom_adjustments = [];
        }
        console.log('ğŸ§¹ Cleared existing adjustments - processing user input');
        
        helper.expertise = helper.expertise || {};
        helper.expertise.levi_report = helper.expertise.levi_report || {};
        
        // First, preserve existing vehicle data from the main form
        const basicPrice = parseFloat(document.getElementById('basicPrice')?.value.replace(/[â‚ª,]/g, '')) || 
                          parseFloat(document.getElementById('carBasePrice')?.value.replace(/[â‚ª,]/g, '')) || 0;
        const vehicleData = {
          plate: document.getElementById('carPlate')?.value || helper.vehicle?.plate || '',
          manufacturer: document.getElementById('carManufacturer')?.value || helper.vehicle?.manufacturer || '',
          model: document.getElementById('carModel')?.value || helper.vehicle?.model || '',
          year: document.getElementById('carYear')?.value || helper.vehicle?.year || '',
          model_code: document.getElementById('carModelCode')?.value || helper.vehicle?.model_code || '',
          base_price: basicPrice,
          market_value: parseFloat(document.getElementById('carMarketValue')?.value.replace(/[â‚ª,]/g, '')) || basicPrice,
          final_price: basicPrice // Will be updated with adjustments
        };
        
        console.log('ğŸ” DEBUG: Vehicle data from form:', vehicleData);
        
        // Initialize parameter data for aggregation
        const parameterData = {
          registration: { percent: 0, value: 0, total: 0 },
          features: { percent: 0, value: 0, total: 0 },
          ownership: { percent: 0, value: 0, total: 0 },
          km: { percent: 0, value: 0, total: 0 },
          owners: { percent: 0, value: 0, total: 0 }
        };
        
        // Collect features adjustments
        const featuresAdjustmentRows = document.querySelectorAll('#featuresAdjustmentsList > div');
        console.log('ğŸ” DEBUG: Found features rows:', featuresAdjustmentRows.length);
        featuresAdjustmentRows.forEach((row, index) => {
          const description = row.querySelector('input[placeholder="×ª×™××•×¨ ×”×××¤×™×™×Ÿ"]')?.value || '';
          const type = row.querySelector('select')?.value || 'plus';
          const percent = parseFloat(row.querySelector('input[placeholder="%"]')?.value.replace('%', '')) || 0;
          const value = parseFloat(row.querySelector('input[placeholder="â‚ª"]')?.value.replace(/[â‚ª,]/g, '')) || 0;
          console.log(`ğŸ” DEBUG: Features row ${index}:`, { description, type, percent, value });
          
          if (description && value !== 0) {
            const adjustmentValue = type === 'plus' ? value : -value;
            helper.levi_report.adjustments.push({
              description,
              type: 'features',
              percent,
              value: adjustmentValue,
              total: adjustmentValue
            });
            
            // Aggregate features data
            parameterData.features.percent += type === 'plus' ? percent : -percent;
            parameterData.features.value += adjustmentValue;
            parameterData.features.total += adjustmentValue;
          }
        });
        
        // Collect registration adjustments
        // registrationRows already declared above
        console.log('ğŸ” DEBUG: Found registration rows:', registrationRows.length);
        registrationRows.forEach((row, index) => {
          const description = row.querySelector('input[placeholder="×ª×™××•×¨ ×¢×œ×™×” ×œ×›×‘×™×©"]')?.value || '';
          const type = row.querySelector('select')?.value || 'plus';
          const percent = parseFloat(row.querySelector('input[placeholder="%"]')?.value.replace('%', '')) || 0;
          const value = parseFloat(row.querySelector('input[placeholder="â‚ª"]')?.value.replace(/[â‚ª,]/g, '')) || 0;
          console.log(`ğŸ” DEBUG: Registration row ${index}:`, { description, type, percent, value });
          
          if (description && value !== 0) {
            const adjustmentValue = type === 'plus' ? value : -value;
            helper.levi_report.adjustments.push({
              description,
              type: 'registration',
              percent,
              value: adjustmentValue,
              total: adjustmentValue
            });
            
            // Aggregate registration data
            parameterData.registration.percent += type === 'plus' ? percent : -percent;
            parameterData.registration.value += adjustmentValue;
            parameterData.registration.total += adjustmentValue;
          }
        });
        
        // Collect other adjustments from allAdjustmentsRows-estimate and map to parameters
        // CRITICAL FIX: Only process manually added adjustments, not ones loaded from helper
        const allAdjustmentRows = document.querySelectorAll('#allAdjustmentsRows-estimate div[data-source="custom"][data-user-created="true"]');
        console.log('ğŸ” DEBUG: Found user-created adjustment rows:', allAdjustmentRows.length);
        allAdjustmentRows.forEach((row, index) => {
          const inputs = row.querySelectorAll('input');
          if (inputs.length >= 3) {
            const description = inputs[0].value || '';
            const type = row.querySelector('select')?.value || 'plus';
            const percent = parseFloat(inputs[1].value) || 0;
            const value = parseFloat(inputs[2].value.replace(/[â‚ª,]/g, '')) || 0;
            console.log(`ğŸ” DEBUG: All adjustment row ${index}:`, { description, type, percent, value });
            
            if (description && value !== 0) {
              const adjustmentValue = type === 'plus' ? value : -value;
              let parameterType = 'other';
              
              // Detect parameter type from description
              const descLower = description.toLowerCase();
              if (description.includes('×‘×¢×œ×•×ª') || descLower.includes('ownership')) {
                parameterType = 'ownership';
              } else if (description.includes('×§×´×') || descLower.includes('km') || description.includes('×§×™×œ×•××˜×¨')) {
                parameterType = 'km';
              } else if (description.includes('××¡×¤×¨ ×‘×¢×œ×™×') || descLower.includes('owners')) {
                parameterType = 'owners';
              }
              
              helper.levi_report.adjustments.push({
                description,
                type: parameterType,
                percent,
                value: adjustmentValue,
                total: adjustmentValue
              });
              
              // Aggregate parameter data if recognized
              if (parameterData[parameterType]) {
                parameterData[parameterType].percent += type === 'plus' ? percent : -percent;
                parameterData[parameterType].value += adjustmentValue;
                parameterData[parameterType].total += adjustmentValue;
              }
            }
          }
        });
        
        // Calculate final price with adjustments
        const totalAdjustments = parameterData.registration.value + parameterData.features.value + 
                                parameterData.ownership.value + parameterData.km.value + parameterData.owners.value;
        vehicleData.final_price = vehicleData.base_price + totalAdjustments;
        
        // Update structured helper.expertise.levi_report with Hebrew keys for floating screen
        Object.assign(helper.expertise.levi_report, {
          // Basic vehicle info
          '×¡×•×’ ×¨×›×‘': '×¨×›×‘ ×¤×¨×˜×™',
          '×™×¦×¨×Ÿ': vehicleData.manufacturer,
          '×§×•×“ ×“×’×': vehicleData.model_code,
          '×§×˜×’×•×¨×™×”': '×¨×›×‘ ×¤×¨×˜×™',
          '×©× ×ª ×™×¦×•×¨': vehicleData.year,
          '×©× ×“×’× ××œ×': `${vehicleData.manufacturer} ${vehicleData.model}`,
          '××—×™×¨ ×‘×¡×™×¡': vehicleData.base_price,
          '××—×™×¨ ×¡×•×¤×™ ×œ×¨×›×‘': vehicleData.final_price,
          
          // Registration
          '×¢×œ×™×” ×œ×›×‘×™×©': parameterData.registration.percent > 0 ? `${parameterData.registration.percent}%` : '',
          '×¢×œ×™×” ×œ×›×‘×™×© %': parameterData.registration.percent,
          '×¢×¨×š ×©×´×— ×¢×œ×™×” ×œ×›×‘×™×©': parameterData.registration.value,
          '×©×•×•×™ ××¦×˜×‘×¨ ×¢×œ×™×” ×œ×›×‘×™×©': parameterData.registration.total,
          // Features
          '×××¤×™×™× ×™×': parameterData.features.percent > 0 ? `${parameterData.features.percent}%` : '',
          '×××¤×™×™× ×™× %': parameterData.features.percent,
          '×¢×¨×š ×©×´×— ×××¤×™×™× ×™×': parameterData.features.value,
          '×©×•×•×™ ××¦×˜×‘×¨ ×××¤×™×™× ×™×': parameterData.features.total,
          // Ownership
          '×‘×¢×œ×•×ª': parameterData.ownership.percent > 0 ? `${parameterData.ownership.percent}%` : '',
          '×‘×¢×œ×•×ª %': parameterData.ownership.percent,
          '×¢×¨×š ×©×´×— ×‘×¢×œ×•×ª': parameterData.ownership.value,
          '×©×•×•×™ ××¦×˜×‘×¨ ×‘×¢×œ×•×ª': parameterData.ownership.total,
          // KM
          '××¡ ×§×´×': parameterData.km.percent > 0 ? `${parameterData.km.percent}%` : '',
          '××¡ ×§×´× %': parameterData.km.percent,
          '×¢×¨×š ×©×´×— ××¡ ×§×´×': parameterData.km.value,
          '×©×•×•×™ ××¦×˜×‘×¨ ××¡ ×§×´×': parameterData.km.total,
          // Owners
          '××¡×¤×¨ ×‘×¢×œ×™×': parameterData.owners.percent > 0 ? `${parameterData.owners.percent}%` : '',
          '××¡×¤×¨ ×‘×¢×œ×™× %': parameterData.owners.percent,
          '×¢×¨×š ×©×´×— ××¡×¤×¨ ×‘×¢×œ×™×': parameterData.owners.value,
          '×©×•×•×™ ××¦×˜×‘×¨ ××¡×¤×¨ ×‘×¢×œ×™×': parameterData.owners.total
        });
        
        // Update helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Trigger floating screen refresh
        triggerFloatingScreenRefresh();
        
        console.log('âœ… Helper updated from adjustments:', {
          adjustments: helper.levi_report.adjustments,
          parameters: parameterData,
          structured: helper.expertise.levi_report
        });
        
        // Additional debug: Check if the Hebrew keys are correctly set
        console.log('ğŸ” DEBUG: Hebrew keys in helper.expertise.levi_report:', {
          '×¢×œ×™×” ×œ×›×‘×™×©': helper.expertise.levi_report['×¢×œ×™×” ×œ×›×‘×™×©'],
          '×‘×¢×œ×•×ª': helper.expertise.levi_report['×‘×¢×œ×•×ª'],
          '××¡ ×§×´×': helper.expertise.levi_report['××¡ ×§×´×'],
          '××¡×¤×¨ ×‘×¢×œ×™×': helper.expertise.levi_report['××¡×¤×¨ ×‘×¢×œ×™×'],
          '×××¤×™×™× ×™×': helper.expertise.levi_report['×××¤×™×™× ×™×']
        });
        
        // Debug: Final parameter data summary
        console.log('ğŸ” DEBUG: Final parameter data summary:', parameterData);
        
      } catch (error) {
        console.error('Error updating helper from adjustments:', error);
      }
    }
    
    // Calculate and update GROSS PRICE (car properties only: base + features + registration)
    function updateGrossMarketValueCalculation() {
      try {
        // Get basic price
        const basicPriceField = document.getElementById('basicPrice');
        const basicPrice = parseFloat(basicPriceField.value.replace(/[â‚ª,]/g, '')) || 0;
        
        // Collect features adjustments (car properties)
        const featuresAdjustments = [];
        const featuresRows = document.querySelectorAll('#featuresAdjustmentsList > div');
        featuresRows.forEach(row => {
          const type = row.querySelector('select').value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const description = inputs[0]?.value || '';
          const percent = parseFloat(inputs[1]?.value) || 0;
          const rawValue = parseFloat(inputs[2]?.value.replace(/[â‚ª,]/g, '')) || 0;
          const signedValue = type === 'minus' ? -Math.abs(rawValue) : Math.abs(rawValue);

          if (signedValue !== 0) {
            featuresAdjustments.push({
              description,
              type,
              percent,
              value: signedValue,
              category: 'features'
            });
          }
        });
        
        // Collect registration adjustments (car properties)
        const registrationAdjustments = [];
        const registrationRows = document.querySelectorAll('#registrationAdjustmentsList > div');
        registrationRows.forEach(row => {
          const type = row.querySelector('select').value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const description = inputs[0]?.value || '';
          const percent = parseFloat(inputs[1]?.value) || 0;
          const rawValue = parseFloat(inputs[2]?.value.replace(/[â‚ª,]/g, '')) || 0;
          const signedValue = type === 'minus' ? -Math.abs(rawValue) : Math.abs(rawValue);

          if (signedValue !== 0) {
            registrationAdjustments.push({
              description,
              type,
              percent,
              value: signedValue,
              category: 'registration'
            });
          }
        });
        
        // Calculate GROSS price using the original math logic
        const featuresTotal = featuresAdjustments.reduce((sum, adj) => sum + adj.value, 0);
        const registrationTotal = registrationAdjustments.reduce((sum, adj) => sum + adj.value, 0);
        const grossPrice = basicPrice + featuresTotal + registrationTotal;
        
        // Update result field
        const resultField = document.getElementById('grossMarketValueResult');
        if (resultField) {
          resultField.value = `â‚ª${grossPrice.toLocaleString()}`;
        }
        
        console.log(`ğŸ  GROSS PRICE (Car Properties Only): ${basicPrice} + adjustments = ${grossPrice}`);
        console.log('ğŸ“‹ Features adjustments:', featuresAdjustments);
        console.log('ğŸ“‹ Registration adjustments:', registrationAdjustments);
        
        // Update gross percentage calculation immediately
        setTimeout(() => {
          updateGrossPercentageFromGrossValue();
        }, 100);
        
      } catch (error) {
        console.error('Error calculating gross price:', error);
      }
    }
    
    // Load data from helper for gross calculation
    function loadGrossCalculationData() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Load basic price from multiple sources
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField) {
          let basicPrice = 0;
          
          // Priority 1: Check carBasePrice field first
          const carBasePriceField = document.getElementById('carBasePrice');
          if (carBasePriceField && carBasePriceField.value) {
            const carBasePriceStr = carBasePriceField.value.replace(/[â‚ª,]/g, '') || '0';
            basicPrice = parseFloat(carBasePriceStr) || 0;
          }
          
          // Priority 2: Try helper data sources if field is empty
          if (basicPrice === 0) {
            if (helper.valuation?.base_price) {
              basicPrice = parseFloat(helper.valuation.base_price.toString().replace(/[â‚ª,]/g, ''));
            } else if (helper.levi_report?.base_price) {
              basicPrice = parseFloat(helper.levi_report.base_price);
            } else if (helper.expertise?.levi_report?.base_price) {
              basicPrice = parseFloat(helper.expertise.levi_report.base_price);
            } else if (helper.levisummary?.base_price) {
              basicPrice = parseFloat(helper.levisummary.base_price);
            } else if (helper.car_details?.base_price) {
              basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[â‚ª,]/g, ''));
            }
          }
          
          if (basicPrice > 0) {
            basicPriceField.value = `â‚ª${basicPrice.toLocaleString()}`;
          }
        }
        
        // Clear containers first to prevent duplication
        const featuresContainer = document.getElementById('featuresAdjustmentsList');
        const registrationContainer = document.getElementById('registrationAdjustmentsList');
        if (featuresContainer) featuresContainer.innerHTML = '';
        if (registrationContainer) registrationContainer.innerHTML = '';
        
        // Load features adjustments from helper (from Levi data)
        if (helper.levi_report?.adjustments) {
          const featuresAdjustments = helper.levi_report.adjustments.filter(adj => {
            const desc = adj.description?.toLowerCase() || '';
            return adj.type === 'features' || 
                   desc.includes('×××¤×™×™× ×™×') || 
                   desc.includes('features') ||
                   desc.includes('××‘×–×•×¨') ||
                   desc.includes('×¦×™×•×“');
          });
          
          console.log('ğŸ”§ Loading features adjustments from Levi:', featuresAdjustments);
          
          featuresAdjustments.forEach(adj => {
            addFeatureAdjustment();
            // Populate the last added row with data
            const lastRow = document.querySelector('#featuresAdjustmentsList > div:last-child');
            if (lastRow) {
              const inputs = lastRow.querySelectorAll('input[type="text"]');
              inputs[0].value = adj.description || '';
              lastRow.querySelector('select').value = adj.value >= 0 ? 'plus' : 'minus';
              inputs[1].value = (adj.percentage || adj.percent) ? `${adj.percentage || adj.percent}%` : '';
              inputs[2].value = `â‚ª${Math.abs(adj.value).toLocaleString()}`;
              
              // Trigger calculation for the percentage field
              const percentInput = inputs[1];
              if (percentInput && percentInput.value) {
                setTimeout(() => {
                  calculateAdjustmentValue(percentInput);
                }, 100);
              }
            }
          });
        }
        
        // Load registration adjustments from helper (from Levi data) - FIXED
        if (helper.levi_report?.adjustments) {
          const registrationAdjustments = helper.levi_report.adjustments.filter(adj => {
            const desc = adj.description?.toLowerCase() || '';
            return adj.type === 'registration' || 
                   desc.includes('×¢×œ×™×” ×œ×›×‘×™×©') || 
                   desc.includes('registration') ||
                   desc.includes('×¨×™×©×•×') ||
                   desc.includes('×”×¢×œ×™×” ×œ×›×‘×™×©');
          });
          
          console.log('ğŸ”§ Loading registration adjustments from Levi:', registrationAdjustments);
          
          registrationAdjustments.forEach(adj => {
            addRegistrationAdjustment();
            // Populate the last added row with data
            const lastRow = document.querySelector('#registrationAdjustmentsList > div:last-child');
            if (lastRow) {
              const inputs = lastRow.querySelectorAll('input[type="text"]');
              inputs[0].value = adj.description || '';
              lastRow.querySelector('select').value = adj.value >= 0 ? 'plus' : 'minus';
              inputs[1].value = (adj.percentage || adj.percent) ? `${adj.percentage || adj.percent}%` : '';
              inputs[2].value = `â‚ª${Math.abs(adj.value).toLocaleString()}`;
              
              // Trigger calculation for the percentage field
              const percentInput = inputs[1];
              if (percentInput && percentInput.value) {
                setTimeout(() => {
                  calculateAdjustmentValue(percentInput);
                }, 100);
              }
            }
          });
        }
        
        // Also check for direct registration fields in levi_report (structured data)
        if (helper.expertise?.levi_report?.adjustments?.registration) {
          const regAdj = helper.expertise.levi_report.adjustments.registration;
          const registrationValue = parseFloat(regAdj.value || regAdj.total || 0);
          
          if (registrationValue !== 0) {
            console.log('ğŸ”§ Loading registration from expertise.levi_report.adjustments:', regAdj);
            addRegistrationAdjustment();
            const lastRow = document.querySelector('#registrationAdjustmentsList > div:last-child');
            if (lastRow) {
              lastRow.querySelector('input[type="text"]:first-of-type').value = '×¢×œ×™×” ×œ×›×‘×™×©';
              lastRow.querySelector('select').value = registrationValue >= 0 ? 'plus' : 'minus';
              lastRow.querySelector('input[type="text"]:last-of-type').value = `â‚ª${Math.abs(registrationValue).toLocaleString()}`;
            }
          }
        }
        
        // Also check for features in structured data
        if (helper.expertise?.levi_report?.adjustments?.features) {
          const featAdj = helper.expertise.levi_report.adjustments.features;
          const featuresValue = parseFloat(featAdj.value || featAdj.total || 0);
          
          if (featuresValue !== 0) {
            console.log('ğŸ”§ Loading features from expertise.levi_report.adjustments:', featAdj);
            addFeatureAdjustment();
            const lastRow = document.querySelector('#featuresAdjustmentsList > div:last-child');
            if (lastRow) {
              lastRow.querySelector('input[type="text"]:first-of-type').value = '×××¤×™×™× ×™×';
              lastRow.querySelector('select').value = featuresValue >= 0 ? 'plus' : 'minus';
              lastRow.querySelector('input[type="text"]:last-of-type').value = `â‚ª${Math.abs(featuresValue).toLocaleString()}`;
            }
          }
        }
        
        // Check for additional adjustments from levisummary (backup structure) - Handle object or array
        if (helper.levisummary?.adjustments) {
          const adjustments = Array.isArray(helper.levisummary.adjustments) ? helper.levisummary.adjustments : Object.values(helper.levisummary.adjustments);
          adjustments.forEach(adj => {
            const desc = adj.description?.toLowerCase() || '';
            const value = parseFloat(adj.value || 0);
            
            if (value !== 0) {
              if (desc.includes('×¢×œ×™×” ×œ×›×‘×™×©') || desc.includes('registration')) {
                console.log('ğŸ”§ Loading registration from levisummary:', adj);
                addRegistrationAdjustment();
                const lastRow = document.querySelector('#registrationAdjustmentsList > div:last-child');
                if (lastRow) {
                  lastRow.querySelector('input[type="text"]:first-of-type').value = adj.description || '×¢×œ×™×” ×œ×›×‘×™×©';
                  lastRow.querySelector('select').value = value >= 0 ? 'plus' : 'minus';
                  lastRow.querySelector('input[type="text"]:last-of-type').value = `â‚ª${Math.abs(value).toLocaleString()}`;
                }
              } else if (desc.includes('×××¤×™×™× ×™×') || desc.includes('features')) {
                console.log('ğŸ”§ Loading features from levisummary:', adj);
                addFeatureAdjustment();
                const lastRow = document.querySelector('#featuresAdjustmentsList > div:last-child');
                if (lastRow) {
                  lastRow.querySelector('input[type="text"]:first-of-type').value = adj.description || '×××¤×™×™× ×™×';
                  lastRow.querySelector('select').value = value >= 0 ? 'plus' : 'minus';
                  lastRow.querySelector('input[type="text"]:last-of-type').value = `â‚ª${Math.abs(value).toLocaleString()}`;
                }
              }
            }
          });
        }
        
        // Calculate initial gross market value
        updateGrossMarketValueCalculation();
        
        // Trigger calculation for all existing adjustment rows
        setTimeout(() => {
          const allPercentInputs = document.querySelectorAll('#featuresAdjustmentsList input[placeholder="%"], #registrationAdjustmentsList input[placeholder="%"]');
          allPercentInputs.forEach(input => {
            if (input.value) {
              calculateAdjustmentValue(input);
            }
          });
          
          // Recalculate final values
          updateGrossMarketValueCalculation();
        }, 300);
        
        // Load second bulk data if available
        setTimeout(() => {
          loadSecondBulkData();
        }, 500);
        
      } catch (error) {
        console.error('Error loading gross calculation data:', error);
      }
    }
    
    // Load data for second bulk (gross percentage)
    function loadSecondBulkData() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Load claims data if available
        if (helper.claims_data) {
          const totalClaimField = document.getElementById('totalClaim');
          const leviPriceListField = document.getElementById('leviPriceList');
          const grossPercentField = document.getElementById('grossPercent');
          
          if (totalClaimField && helper.claims_data.total_claim) {
            totalClaimField.value = helper.claims_data.total_claim;
          }
          
          if (leviPriceListField && helper.claims_data.gross_value) {
            leviPriceListField.value = helper.claims_data.gross_value;
          }
          
          if (grossPercentField && helper.claims_data.gross_percent) {
            grossPercentField.value = helper.claims_data.gross_percent;
          }
        }
        
        // If no saved data, calculate from current state
        if (!helper.claims_data?.total_claim) {
          updateGrossPercentageFromGrossValue();
        }
        
      } catch (error) {
        console.error('Error loading second bulk data:', error);
      }
    }
    
    // Update gross percentage when gross market value changes
    function updateGrossPercentageFromGrossValue() {
      // Get GROSS price (car properties only)
      let grossPrice = 0;
      
      if (window.CalculationInterface && typeof window.CalculationInterface.getGrossMarketValue === 'function') {
        grossPrice = window.CalculationInterface.getGrossMarketValue();
      } else {
        // Fallback: calculate gross price directly from fields
        const grossResultField = document.getElementById('grossMarketValueResult');
        if (grossResultField && grossResultField.value) {
          grossPrice = parseFloat(grossResultField.value.replace(/[â‚ª,]/g, '')) || 0;
        } else {
          // Further fallback: use basic price
          const basicPriceField = document.getElementById('basicPrice');
          if (basicPriceField && basicPriceField.value) {
            grossPrice = parseFloat(basicPriceField.value.replace(/[â‚ª,]/g, '')) || 0;
          }
        }
      }
      
      // Get total claim from damage centers calculation
      const totalClaim = calculateTotalClaimFromDamageCenters();
      
      console.log('ğŸ” Updating GROSS DAMAGE PERCENTAGE (using gross price, not market price):', {
        grossPrice,
        totalClaim
      });
      
      // Update the display fields
      const totalClaimField = document.getElementById('totalClaim');
      const leviPriceListField = document.getElementById('leviPriceList');
      
      if (totalClaimField && totalClaim > 0) {
        totalClaimField.value = `â‚ª${totalClaim.toLocaleString()}`;
      }
      
      if (leviPriceListField && grossPrice > 0) {
        leviPriceListField.value = `â‚ª${grossPrice.toLocaleString()}`;
      }
      
      // Calculate and update GROSS DAMAGE PERCENTAGE (damage Ã· gross price)
      if (grossPrice > 0 && totalClaim > 0) {
        const grossDamagePercentage = (totalClaim / grossPrice) * 100;
        const grossPercentField = document.getElementById('grossPercent');
        if (grossPercentField) {
          const formattedPercentage = `${Math.round(grossDamagePercentage * 100) / 100}%`;
          grossPercentField.value = formattedPercentage;
          
          // Update helper with GROSS damage percentage (separate from market damage percentage)
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          
          const calculationsData = {
            ...helper.calculations,
            damage_percent_gross: grossDamagePercentage,
            total_damage: totalClaim
          };
          
          const claimsData = {
            ...helper.claims_data,
            gross_percent: formattedPercentage,
            total_claim: `â‚ª${totalClaim.toLocaleString()}`,
            gross_value: `â‚ª${grossPrice.toLocaleString()}`
          };
          
          // Save using proper helper function
          if (typeof updateHelper === 'function') {
            updateHelper('calculations', calculationsData, 'estimate_builder_gross_damage_calculation');
            updateHelper('claims_data', claimsData, 'estimate_builder_claims_damage_update');
          } else {
            // Fallback for compatibility
            helper.calculations = helper.calculations || {};
            helper.calculations.damage_percent_gross = grossDamagePercentage;
            helper.calculations.total_damage = totalClaim;
            helper.claims_data = helper.claims_data || {};
            Object.assign(helper.claims_data, claimsData);
            sessionStorage.setItem('helper', JSON.stringify(helper));
          }
          
          console.log(`ğŸ“Š GROSS DAMAGE %: ${totalClaim.toLocaleString()} Ã· ${grossPrice.toLocaleString()} = ${formattedPercentage}`);
          console.log(`ğŸ  This uses GROSS PRICE (car properties only), not market price`);
        }
      }
    }
    
    // CALCULATE TOTAL CLAIM FROM DAMAGE CENTERS
    function calculateTotalClaimFromDamageCenters() {
      try {
        let totalClaim = 0;
        
        // Get damage centers from the summary or helper
        const damageCentersContent = document.getElementById('damageCentersContent');
        if (damageCentersContent) {
          const damageRows = damageCentersContent.querySelectorAll('.damage-center-row');
          damageRows.forEach(row => {
            const totalField = row.querySelector('.total-field');
            if (totalField && totalField.value) {
              const total = parseFloat(totalField.value.replace(/[â‚ª,]/g, '')) || 0;
              totalClaim += total;
            }
          });
        }
        
        // Fallback: try to get from summary section
        if (totalClaim === 0) {
          const sumClaimField = document.getElementById('sumClaim');
          if (sumClaimField && sumClaimField.value) {
            totalClaim = parseFloat(sumClaimField.value.replace(/[â‚ª,]/g, '')) || 0;
          }
        }
        
        // Fallback: try to get from helper
        if (totalClaim === 0) {
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          if (helper.expertise?.damage_blocks) {
            helper.expertise.damage_blocks.forEach(block => {
              totalClaim += (parseFloat(block.parts_cost) || 0) + 
                           (parseFloat(block.work_cost) || 0) + 
                           (parseFloat(block.repairs_cost) || 0);
            });
          }
        }
        
        console.log('ğŸ’° Total claim from damage centers:', totalClaim);
        return totalClaim;
      } catch (error) {
        console.error('Error calculating total claim from damage centers:', error);
        return 0;
      }
    }
    
    // SIMPLE CALCULATION FUNCTIONS FOR NEW SYSTEM
    /**
     * Calculate the final appraised vehicle value based on adjustments.
     * Implements the correct calculation order from todo.md lines 337-391
     *
     * @param {number} basePrice - The anchor/base vehicle price.
     * @param {object} adjustments - An object with optional adjustment parameters:
     *   {
     *     features: { percent?: number, fixed?: number },
     *     registration: { percent?: number, fixed?: number },
     *     ownershipType: { percent?: number, fixed?: number },
     *     mileage: { percent?: number, fixed?: number },
     *     numOwners: { percent?: number, fixed?: number }
     *   }
     * @returns {number} - The final appraised value.
     */
    function calculateVehicleValue(basePrice, adjustments) {
      if (typeof basePrice !== 'number' || isNaN(basePrice)) {
        throw new Error('Invalid base price');
      }

      const safeAdj = (adj, current) => {
        if (!adj) return 0;
        if (adj.percent && typeof adj.percent === 'number') {
          return current * (adj.percent / 100);
        }
        if (adj.fixed && typeof adj.fixed === 'number') {
          return adj.fixed;
        }
        return 0;
      };

      // Step 1: Independent adjustments (Features + Registration) using Base Price
      const featuresAdj = safeAdj(adjustments.features, basePrice);
      const registrationAdj = safeAdj(adjustments.registration, basePrice);

      const grossValue = basePrice + featuresAdj + registrationAdj;

      // Step 2: Sequential adjustments (Ownership â†’ Mileage â†’ Number of Owners)
      let currentValue = grossValue;

      for (const key of ['ownershipType', 'mileage', 'numOwners']) {
        const adj = adjustments[key];
        if (!adj) continue; // skip if missing or zero
        const adjAmount = safeAdj(adj, currentValue);
        currentValue += adjAmount; // apply sequentially
      }

      return Math.round(currentValue); // round to nearest whole currency unit
    }

    function calculateGrossMarketValue() {
      updateGrossMarketValueCalculation();
    }
    
    function calculateGrossPercentage() {
      updateGrossPercentageFromGrossValue();
    }
    
    function calculateFullMarketValue() {
      updateFullMarketValueCalculation();
    }
    
    // FULL MARKET VALUE CALCULATION FUNCTIONS
    
    // Add full market adjustment row
    function addFullMarketAdjustment() {
      const container = document.getElementById('allAdjustmentsList');
      const rowId = 'fullAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
          <div><input type="text" placeholder="×ª×™××•×¨ ×”×”×ª×××”" onchange="updateFullMarketValueCalculation()" /></div>
          <div><select onchange="updateAdjustmentSigns(this); updateFullMarketValueCalculation()">
            <option value="plus">×ª×•×¡×¤×ª (+)</option>
            <option value="minus">×”×¤×—×ª×” (-)</option>
          </select></div>
          <div><input type="number" step="0.01" placeholder="%" oninput="calculateFullMarketAdjustmentValue(this);" onchange="updateFullMarketValueCalculation();" /></div>
          <div><input type="text" placeholder="â‚ª" onchange="updateFullMarketValueCalculation()" /></div>
          <div><button class="btn remove" onclick="removeFullMarketAdjustmentRow('${rowId}')">××—×§</button></div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      updateFullMarketValueCalculation();
    }
    
    // Remove full market adjustment row
    function removeFullMarketAdjustmentRow(rowId) {
      const row = document.getElementById(rowId);
      if (row) {
        row.remove();
        updateFullMarketValueCalculation();
      }
    }
    
    /**
     * Calculate the final appraised vehicle value based on adjustments.
     * Uses the correct two-phase calculation method from todo.md documentation.
     *
     * @param {number} basePrice - The anchor/base vehicle price.
     * @param {object} adjustments - An object with optional adjustment parameters
     * @returns {number} - The final appraised value.
     */
    function calculateVehicleValue(basePrice, adjustments) {
      if (typeof basePrice !== 'number' || isNaN(basePrice)) {
        throw new Error('Invalid base price');
      }
      
      const safeAdj = (adj, current) => {
        if (!adj) return 0;
        if (adj.percent && typeof adj.percent === 'number') {
          return current * (adj.percent / 100);
        }
        if (adj.fixed && typeof adj.fixed === 'number') {
          return adj.fixed;
        }
        return 0;
      };
      
      // Step 1: Independent adjustments (Features + Registration) using Base Price
      const featuresAdj = safeAdj(adjustments.features, basePrice);
      const registrationAdj = safeAdj(adjustments.registration, basePrice);
      const grossValue = basePrice + featuresAdj + registrationAdj;
      
      console.log('ğŸ“Š Phase 1 - Independent adjustments:', {
        basePrice,
        featuresAdj,
        registrationAdj,
        grossValue
      });
      
      // Step 2: Sequential adjustments (Ownership â†’ Mileage â†’ Number of Owners)
      let currentValue = grossValue;
      for (const key of ['ownershipType', 'mileage', 'numOwners']) {
        const adj = adjustments[key];
        if (!adj) continue; // skip if missing or zero
        const adjAmount = safeAdj(adj, currentValue);
        const previousValue = currentValue;
        currentValue += adjAmount; // apply sequentially
        console.log(`ğŸ“Š Phase 2 - ${key}: ${previousValue.toLocaleString()} + ${adjAmount.toLocaleString()} = ${currentValue.toLocaleString()}`);
      }
      
      return Math.round(currentValue); // round to nearest whole currency unit
    }

    // Calculate and update full market value using CORRECT TWO-PHASE LOGIC
    function updateFullMarketValueCalculation() {
      try {
        console.log('ğŸ”¥ğŸ”¥ğŸ”¥ CLAUDE FIXED CALCULATION STARTING - Two-phase logic...');
        
        // Step 1: DYNAMIC - Get base price from current case helper data ONLY
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        let basePrice = 0; // NO HARDCODED VALUES - must come from current case
        
        // Priority 1: UI field for this case
        const basicPriceField = document.getElementById('fullBasicPrice');
        if (basicPriceField && basicPriceField.value) {
          const cleanBasePrice = basicPriceField.value.replace(/[â‚ª,]/g, '');
          basePrice = parseFloat(cleanBasePrice) || 0;
        }
        
        // Priority 2: Helper data from current case
        if (basePrice === 0) {
          basePrice = helper.valuation?.base_price || 
                     helper.levi_report?.base_price || 
                     helper.car_details?.base_price || 
                     helper.vehicle?.base_price || 0;
          
          if (typeof basePrice === 'string') {
            basePrice = parseFloat(basePrice.replace(/[â‚ª,]/g, '')) || 0;
          }
        }
        
        // CRITICAL: If no base price available, cannot calculate - must alert user
        if (basePrice === 0) {
          console.error('âŒ CRITICAL: No base price available for calculation');
          alert('×©×’×™××”: ×œ× × ××¦× ××—×™×¨ ×‘×¡×™×¡ ×œ×¨×›×‘. ×× × ×•×•×“× ×©×”× ×ª×•× ×™× × ×˜×¢× ×• ×-Levi ×™×¦×—×§');
          return;
        }
        
        console.log('ğŸ“Š Base price:', basePrice);
        
        // Step 2: Parse adjustments from UI fields and categorize them
        const adjustmentRows = document.querySelectorAll('#allAdjustmentsList > div');
        const adjustments = {
          features: null,
          registration: null,
          ownershipType: null,
          mileage: null,
          numOwners: null
        };
        
        console.log('ğŸ” Found', adjustmentRows.length, 'adjustment rows');
        
        adjustmentRows.forEach((row, index) => {
          const inputs = row.querySelectorAll('input');
          const select = row.querySelector('select');
          
          if (inputs.length >= 3 && select) {
            const description = inputs[0].value.toLowerCase();
            const adjustmentType = select.value; // 'plus' or 'minus'
            const percentage = parseFloat(inputs[1].value) || 0;
            const isNegative = adjustmentType === 'minus';
            
            // Determine adjustment category and type
            let adjValue = null;
            let category = null;
            
            if (percentage > 0) {
              // Check if percentage already has negative sign
              const hasNegativeSign = inputs[1].value.includes('-');
              const finalPercent = hasNegativeSign ? -Math.abs(percentage) : (isNegative ? -percentage : percentage);
              adjValue = { percent: finalPercent };
            } else if (inputs[2].value) {
              // Check if amount already has negative sign
              const hasNegativeSign = inputs[2].value.includes('-');
              let fixedAmount = parseFloat(inputs[2].value.replace(/[â‚ª,-]/g, '')) || 0;
              if (hasNegativeSign || isNegative) {
                fixedAmount = -Math.abs(fixedAmount);
              }
              adjValue = { fixed: fixedAmount };
            }
            
            // Categorize adjustments based on description
            console.log(`ğŸ” Analyzing description: "${description}"`);
            if (description.includes('×××¤×™×™× ×™×') || description.includes('features')) {
              category = 'features';
            } else if (description.includes('×¢×œ×™×” ×œ×›×‘×™×©') || description.includes('registration')) {
              category = 'registration';
            } else if (description.includes('×‘×¢×œ×•×ª') || description.includes('ownership')) {
              category = 'ownershipType';
            } else if (description.includes('×§"×') || description.includes('××§"×') || description.includes('mileage')) {
              category = 'mileage';
            } else if (description.includes('×‘×¢×œ×™×') || description.includes('owners')) {
              category = 'numOwners';
            } else {
              console.log(`âš ï¸ Unknown category for description: "${description}"`);
            }
            
            if (category && adjValue) {
              adjustments[category] = adjValue;
              console.log(`ğŸ“‹ Row ${index + 1}: ${category} = ${JSON.stringify(adjValue)}`);
            }
          }
        });
        
        // Step 3: Calculate using the correct two-phase method
        const finalValue = calculateVehicleValue(basePrice, adjustments);
        
        console.log('âœ… FINAL MARKET VALUE (two-phase calculation):', finalValue);
        
        // Step 4: Update the basic price field if it was empty
        if (basicPriceField && !basicPriceField.value) {
          basicPriceField.value = `â‚ª${basePrice.toLocaleString()}`;
        }
        
        // Step 5: Update the final result field
        const fullMarketValueResult = document.getElementById('fullMarketValueResult');
        if (fullMarketValueResult) {
          fullMarketValueResult.value = `â‚ª${finalValue.toLocaleString()}`;
          console.log('âœ… Updated fullMarketValueResult field with:', finalValue);
        }
        
        // Step 6: Also update summary field if it exists
        const sumMarketValueField = document.getElementById('sumMarketValue');
        if (sumMarketValueField) {
          sumMarketValueField.value = `â‚ª${finalValue.toLocaleString()}`;
          console.log('âœ… Updated sumMarketValue field with:', finalValue);
        }
        
        // Step 7: VALIDATION LOGIC - Force correct calculation if wrong value detected
        setTimeout(() => {
          const currentValue = document.getElementById('fullMarketValueResult')?.value;
          if (currentValue) {
            const numericValue = parseFloat(currentValue.replace(/[â‚ª,]/g, '')) || 0;
            // If the value is wrong (like 80,487 or 128,620), force recalculation
            if (numericValue === 80487 || numericValue === 128620 || numericValue > 100000) {
              console.log('ğŸš¨ WRONG VALUE DETECTED:', numericValue, '- Forcing correct calculation');
              const correctedValue = calculateVehicleValue(basePrice, adjustments);
              document.getElementById('fullMarketValueResult').value = `â‚ª${correctedValue.toLocaleString()}`;
              if (sumMarketValueField) {
                sumMarketValueField.value = `â‚ª${correctedValue.toLocaleString()}`;
              }
              console.log('âœ… FORCED CORRECTION Applied:', correctedValue);
            }
          }
        }, 100);
        
        console.log('ğŸ¯ Full Market Value Calculation completed using correct two-phase logic!');
        
      } catch (error) {
        console.error('Error calculating full market value:', error);
      }
    }
    
    /**
     * Update visual signs in percentage and amount fields when dropdown changes
     */
    function updateAdjustmentSigns(selectElement) {
      try {
        const row = selectElement.closest('div[id^="fullMarketAdj_"]');
        if (!row) return;
        
        const inputs = row.querySelectorAll('input');
        const isReduction = selectElement.value === 'minus';
        
        if (inputs.length >= 3) {
          const percentInput = inputs[1]; // percentage field
          const amountInput = inputs[2];  // amount field
          
          // Update percentage field sign
          if (percentInput.value) {
            let percentValue = parseFloat(percentInput.value) || 0;
            if (isReduction) {
              percentInput.value = -Math.abs(percentValue);
            } else {
              percentInput.value = Math.abs(percentValue);
            }
          }
          
          // Update amount field sign
          if (amountInput.value) {
            const cleanAmount = amountInput.value.replace(/[â‚ª,]/g, '');
            let amountValue = parseFloat(cleanAmount) || 0;
            if (isReduction) {
              amountInput.value = `â‚ª${(-Math.abs(amountValue)).toLocaleString()}`;
            } else {
              amountInput.value = `â‚ª${Math.abs(amountValue).toLocaleString()}`;
            }
          }
          
          console.log(`ğŸ”„ Updated signs for ${isReduction ? 'reduction' : 'addition'}:`, {
            percent: percentInput.value,
            amount: amountInput.value
          });
        }
      } catch (error) {
        console.error('Error updating adjustment signs:', error);
      }
    }
    
    // Load data from helper for full market value calculation
    function loadFullMarketValueData() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        console.log('ğŸ”„ Loading full market value data...');
        console.log('ğŸ“Š Helper levi_report adjustments:', helper.levi_report?.adjustments);
        console.log('ğŸ“Š Helper custom full_market_adjustments:', helper.custom_adjustments?.full_market_adjustments);
        
        // Load basic price (same as gross calculation)
        const fullBasicPriceField = document.getElementById('fullBasicPrice');
        const basicPriceField = document.getElementById('basicPrice');
        if (fullBasicPriceField && basicPriceField) {
          fullBasicPriceField.value = basicPriceField.value;
        } else if (fullBasicPriceField && helper.levi_report?.base_price) {
          fullBasicPriceField.value = `â‚ª${parseFloat(helper.levi_report.base_price).toLocaleString()}`;
        }
        
        // AGGRESSIVE FIX: Clear container completely and verify it's empty
        const container = document.getElementById('allAdjustmentsList');
        if (container) {
          // Remove all child elements one by one to ensure proper cleanup
          while (container.firstChild) {
            container.removeChild(container.firstChild);
          }
          // Double-check with innerHTML as backup
          container.innerHTML = '';
          // Force DOM refresh
          container.offsetHeight;
          console.log('ğŸ§¹ Cleared allAdjustmentsList container, children count:', container.children.length);
          
          // Add a flag to prevent duplicate loading
          if (container.hasAttribute('data-loading')) {
            console.log('âš ï¸ Container already being loaded, skipping duplicate load');
            return;
          }
          console.log('ğŸ”„ Setting loading flag on container');
          container.setAttribute('data-loading', 'true');
        }
        
        // Create a unified adjustments array to prevent duplicates
        const allAdjustments = [];
        const seenAdjustments = new Set();
        
        // FOLLOW HELPER ARCHITECTURE: Load ONLY from helper.valuation.adjustments
        // The helper is god - everyone else adjusts to it
        if (helper.valuation?.adjustments) {
          Object.entries(helper.valuation.adjustments).forEach(([category, adjData]) => {
            if (adjData && (adjData.percent || adjData.amount) && adjData.description) {
              const adjustmentType = (adjData.percent < 0 || adjData.amount < 0) ? 'minus' : 'plus';
              const key = `${category}-${adjData.description}`;
              if (!seenAdjustments.has(key)) {
                allAdjustments.push({
                  description: adjData.description || adjData.reason || `×”×ª×××” - ${category}`,
                  percentage: Math.abs(adjData.percent || 0),
                  value: Math.abs(adjData.amount || 0),
                  type: adjustmentType,
                  source: 'levi',
                  category: category
                });
                seenAdjustments.add(key);
                console.log('âœ… Added adjustment from helper.valuation:', adjData.description, adjData.percent);
              }
            }
          });
        }
        
        // Add custom adjustments only if they're not duplicates
        if (helper.custom_adjustments?.full_market_adjustments) {
          helper.custom_adjustments.full_market_adjustments.forEach(adj => {
            const adjustmentType = adj.type || 'plus';
            const key = `${adj.description}-${adj.percentage || adj.percent || 0}-${adjustmentType}`;
            if (!seenAdjustments.has(key)) {
              allAdjustments.push({
                description: adj.description || '×”×ª×××” ××•×ª×××ª',
                percentage: adj.percentage || adj.percent || 0,
                value: adj.value || 0,
                type: adjustmentType,
                source: 'custom'
              });
              seenAdjustments.add(key);
              console.log('âœ… Added custom adjustment:', adj.description, adj.percentage || adj.percent || 0, adjustmentType);
            } else {
              console.log('âš ï¸ Skipped duplicate custom adjustment:', adj.description, adj.percentage || adj.percent || 0, adjustmentType);
            }
          });
        }
        
        console.log(`ğŸ“Š Total unique adjustments to load: ${allAdjustments.length}`);
        
        // Now load all unique adjustments
        allAdjustments.forEach((adj, index) => {
          console.log(`ğŸ“ Loading adjustment ${index + 1}/${allAdjustments.length}:`, adj);
          addFullMarketAdjustment();
          const lastRow = document.querySelector('#allAdjustmentsList > div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input');
            inputs[0].value = adj.description; // description
            lastRow.querySelector('select').value = adj.type;
            inputs[1].value = adj.percentage || ''; // percentage
            inputs[2].value = adj.value ? `â‚ª${Math.abs(adj.value).toLocaleString()}` : ''; // value
            
            // ADD EVENT LISTENERS TO LOADED ROWS FOR TWO-WAY DATA BINDING
            inputs.forEach(input => {
              input.addEventListener('change', () => {
                updateFullMarketValueCalculation();
              });
            });
            lastRow.querySelector('select').addEventListener('change', () => {
              updateFullMarketValueCalculation();
            });
            
            console.log(`âœ… Loaded row with event listeners: ${adj.description} - ${adj.type} - ${adj.percentage}% - â‚ª${adj.value}`);
          } else {
            console.log('âŒ Failed to find last row after adding adjustment');
          }
        });
        
        // Calculate initial full market value
        updateFullMarketValueCalculation();
        
        // Add validation logic after calculation
        setTimeout(() => {
          const currentValue = document.getElementById('fullMarketValueResult')?.value;
          if (currentValue) {
            const numericValue = parseFloat(currentValue.replace(/[â‚ª,]/g, '')) || 0;
            // If wrong value detected, force correct calculation
            if (numericValue === 80487 || numericValue === 128620 || numericValue > 100000) {
              console.log('ğŸš¨ LOAD DATA: Wrong value detected:', numericValue, '- Forcing recalculation');
              updateFullMarketValueCalculation();
            }
          }
        }, 200);
        
        // CRITICAL: Add market adjustments from helper.valuation.adjustments after loading existing data
        setTimeout(() => {
          autoPopulateMarketAdjustments();
        }, 100);
        
        // Remove loading flag
        if (container) {
          container.removeAttribute('data-loading');
        }
        
        console.log('âœ… Full market value data loading completed');
        
      } catch (error) {
        console.error('Error loading full market value data:', error);
        // Remove loading flag on error too
        const container = document.getElementById('allAdjustmentsList');
        if (container) {
          container.removeAttribute('data-loading');
        }
      }
    }
    
    
    // FULL MARKET ADJUSTMENT CALCULATION - COPIED FROM WORKING DEPRECIATION
    function calculateFullMarketAdjustmentValue(percentInput) {
      console.log('ğŸ”„ calculateFullMarketAdjustmentValue called with:', percentInput.value);
      const percent = parseFloat(percentInput.value) || 0;
      const row = percentInput.closest('.adjustment-row');
      
      if (!row) {
        console.log('âŒ No adjustment row found for percentage input');
        return;
      }
      
      // Get market value from same sources as depreciation calculation
      let marketValue = 0;
      
      // First try the basic price field from the same section
      const basicPriceField = document.getElementById('fullBasicPrice');
      if (basicPriceField && basicPriceField.value) {
        marketValue = parseFloat(basicPriceField.value.replace(/[â‚ª,]/g, '')) || 0;
        console.log('ğŸ“Š Using fullBasicPrice:', marketValue);
      }
      
      // If no basic price, try summary market value (priority)
      if (marketValue === 0) {
        const sumMarketValueField = document.getElementById('sumMarketValue');
        if (sumMarketValueField && sumMarketValueField.value) {
          marketValue = parseFloat(sumMarketValueField.value.replace(/[â‚ª,]/g, '')) || 0;
          console.log('ğŸ“Š Using sumMarketValue:', marketValue);
        }
      }
      
      // If still no value, try car market value
      if (marketValue === 0) {
        const carMarketValueField = document.getElementById('carMarketValue');
        if (carMarketValueField && carMarketValueField.value) {
          marketValue = parseFloat(carMarketValueField.value.replace(/[â‚ª,]/g, '')) || 0;
          console.log('ğŸ“Š Using carMarketValue:', marketValue);
        }
      }
      
      if (marketValue === 0) {
        console.log('âŒ No market value found for calculation');
      }
      
      // Calculate value exactly like working depreciation
      const calculatedValue = Math.round((marketValue * percent) / 100);
      console.log('ğŸ’° Calculation:', { marketValue, percent, calculatedValue });
      
      // Find value input (fourth column in the grid)
      const inputs = row.querySelectorAll('input');
      console.log('ğŸ“ Found inputs:', inputs.length);
      // Row structure: [description, select, percentage, value, button]
      // Input indices: [0=description, 1=percentage, 2=value]
      if (inputs.length >= 3) {
        const valueInput = inputs[2]; // Third input (value field)
        valueInput.value = calculatedValue ? `â‚ª${calculatedValue.toLocaleString()}` : '';
        console.log('âœ… Set value input to:', valueInput.value);
      } else {
        console.log('âŒ Not enough inputs found, expected >= 3, got:', inputs.length);
      }
      
      // Trigger calculation update
      updateFullMarketValueCalculation();
    }
    
    // ESTIMATE ADJUSTMENTS FUNCTIONS
    
    // Add estimate adjustment row
    function addEstimateAdjustment() {
      const container = document.getElementById('allAdjustmentsRows-estimate');
      if (!container) {
        console.error('Container allAdjustmentsRows-estimate not found');
        return;
      }
      
      const rowId = 'estAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px; padding:8px; border:1px solid #e0e0e0; border-radius:4px;" data-source="custom" data-user-created="true">
          <div><input type="text" placeholder="×ª×™××•×¨ ×”×”×ª×××”" onchange="updateEstimateAdjustments()" /></div>
          <div><select onchange="updateEstimateAdjustments()">
            <option value="plus">×ª×•×¡×¤×ª (+)</option>
            <option value="minus">×”×¤×—×ª×” (-)</option>
          </select></div>
          <div><input type="number" step="0.01" placeholder="%" oninput="calculateEstimateAdjustmentValueSimple(this);" onchange="updateEstimateAdjustments();" /></div>
          <div><input type="text" placeholder="â‚ª" onchange="updateEstimateAdjustments()" /></div>
          <div><button class="btn remove" onclick="removeEstimateAdjustmentRow('${rowId}')">××—×§</button></div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      updateEstimateAdjustments();
    }
    
    // Remove estimate adjustment row
    function removeEstimateAdjustmentRow(rowId) {
      const row = document.getElementById(rowId);
      if (row) {
        row.remove();
        updateEstimateAdjustments();
      }
    }
    
    // Calculate estimate adjustment value from percentage
    function calculateEstimateAdjustmentValue(percentageInput) {
      const row = percentageInput.closest('div');
      let basicPrice = parseFloat(document.getElementById('basicPrice')?.value.replace(/[â‚ª,]/g, '')) || 0;
      const percentage = parseFloat(percentageInput.value) || 0;
      
      // Try alternative price sources if basicPrice is empty
      if (basicPrice === 0) {
        // Try grossMarketValue first (from calculations)
        const grossMarketValue = parseFloat(document.getElementById('grossMarketValue')?.value.replace(/[â‚ª,]/g, '')) || 0;
        if (grossMarketValue > 0) {
          basicPrice = grossMarketValue;
          console.log('ğŸ“Š Using grossMarketValue for estimate adjustment calculation:', basicPrice);
        }
      }
      
      // If still no price, try to get from helper
      if (basicPrice === 0) {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (helper.levi_report?.base_price) {
          basicPrice = parseFloat(helper.levi_report.base_price);
        } else if (helper.expertise?.levi_report?.base_price) {
          basicPrice = parseFloat(helper.expertise.levi_report.base_price);
        } else if (helper.car_details?.base_price) {
          basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[â‚ª,]/g, ''));
        }
        console.log('ğŸ“Š Using helper price for estimate adjustment calculation:', basicPrice);
      }
      
      if (percentage && basicPrice) {
        const calculatedValue = basicPrice * percentage / 100;
        const inputs = row.querySelectorAll('input');
        if (inputs.length > 2) {
          const valueInput = inputs[2]; // value field is the third input
          valueInput.value = `â‚ª${Math.round(calculatedValue).toLocaleString()}`;
          console.log(`ğŸ’° Calculated estimate adjustment value: ${percentage}% Ã— â‚ª${basicPrice.toLocaleString()} = â‚ª${Math.round(calculatedValue).toLocaleString()}`);
          
          // Trigger change event to update other calculations
          valueInput.dispatchEvent(new Event('change', { bubbles: true }));
        } else {
          console.error('Cannot find value input field for estimate adjustment calculation');
        }
      } else {
        console.warn(`âš ï¸ Cannot calculate estimate adjustment value - basicPrice: ${basicPrice}, percentage: ${percentage}`);
        if (basicPrice === 0) {
          console.warn('âš ï¸ No car price found. Please set the basic price first.');
        }
      }
    }
    
    // Update estimate adjustments in helper
    function updateEstimateAdjustments() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const adjustmentRows = document.querySelectorAll('#allAdjustmentsRows-estimate div[data-source="custom"]');
      const adjustments = [];
      
      adjustmentRows.forEach(row => {
        const inputs = row.querySelectorAll('input');
        const description = inputs[0].value;
        const type = row.querySelector('select').value;
        const percentage = parseFloat(inputs[1].value) || 0;
        const value = parseFloat(inputs[2].value.replace(/[â‚ª,]/g, '')) || 0;
        
        if (description && (percentage || value)) {
          adjustments.push({ description, type, percentage, value });
        }
      });
      
      // Save to helper
      if (!helper.levi) helper.levi = {};
      helper.levi.custom_adjustments = adjustments;
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      console.log('Estimate adjustments updated:', adjustments);
      
      // Update Levi parameter mapping
      updateHelperFromAdjustments();
    }
    
    // REFRESH SECOND BULK FIELDS
    function refreshSecondBulkFields() {
      updateGrossPercentageFromGrossValue();
    }
    
    // UPDATE GROSS PERCENTAGE FIELD
    function updateGrossPercentageField() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        let vehicleValueGross = helper.calculations?.vehicle_value_gross;
        
        // Get total claim from the field or helper
        const totalClaimField = document.getElementById('totalClaim');
        const totalClaimValue = totalClaimField?.value || '';
        const totalClaim = parseFloat(totalClaimValue.replace(/[â‚ª,]/g, '')) || 0;
        
        // If vehicle_value_gross is missing, try to get it from the leviPriceList field
        if (!vehicleValueGross) {
          const leviPriceListField = document.getElementById('leviPriceList');
          if (leviPriceListField && leviPriceListField.value) {
            vehicleValueGross = parseFloat(leviPriceListField.value.replace(/[â‚ª,]/g, '')) || 0;
            console.log(`ğŸ”§ Got vehicle_value_gross from leviPriceList field: ${vehicleValueGross}`);
          }
        }
        
        console.log('ğŸ” Gross percentage calculation:', {
          vehicleValueGross: vehicleValueGross,
          totalClaim: totalClaim,
          totalClaimRaw: totalClaimValue,
          helperCalculations: helper.calculations
        });
        
        if (vehicleValueGross && vehicleValueGross > 0 && totalClaim > 0) {
          // Calculate gross percentage: (Total Claim Ã· Gross Market Value) Ã— 100
          const grossPercentage = (totalClaim / vehicleValueGross) * 100;
          const formattedPercentage = `${Math.round(grossPercentage * 100) / 100}%`;
          
          const grossPercentField = document.getElementById('grossPercent');
          if (grossPercentField) {
            grossPercentField.value = formattedPercentage;
            
            // Update helper claims data to maintain consistency
            helper.claims_data = helper.claims_data || {};
            helper.claims_data.gross_percent = formattedPercentage;
            
            // Also update expertise.calculations for system compatibility
            helper.expertise = helper.expertise || {};
            helper.expertise.calculations = helper.expertise.calculations || {};
            helper.expertise.calculations.damage_percent = Math.round(grossPercentage * 100) / 100;
            
            sessionStorage.setItem('helper', JSON.stringify(helper));
            
            console.log(`ğŸ“Š Updated gross percentage: ${totalClaim.toLocaleString()} Ã· ${vehicleValueGross.toLocaleString()} = ${formattedPercentage}`);
          }
        } else {
          console.warn('âš ï¸ Cannot calculate gross percentage - missing values:', {
            vehicleValueGross: vehicleValueGross,
            totalClaim: totalClaim,
            leviPriceListFieldValue: document.getElementById('leviPriceList')?.value
          });
          
          // Do NOT call updateGrossMarketValueField here to avoid infinite loop
        }
      } catch (error) {
        console.error('Error updating gross percentage field:', error);
      }
    }
    
    // UPDATE GROSS MARKET VALUE FIELD
    function updateGrossMarketValueField() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        let vehicleValueGross = helper.calculations?.vehicle_value_gross;
        
        console.log('ğŸ” Updating gross market value field:', {
          vehicleValueGross: vehicleValueGross,
          helperCalculations: helper.calculations
        });
        
        // If no vehicle_value_gross, try to calculate from current gross calculation
        if (!vehicleValueGross) {
          const grossMarketValueField = document.getElementById('grossMarketValueResult');
          if (grossMarketValueField && grossMarketValueField.value) {
            vehicleValueGross = parseFloat(grossMarketValueField.value.replace(/[â‚ª,]/g, '')) || 0;
            console.log(`ğŸ”§ Got vehicle_value_gross from grossMarketValueResult field: ${vehicleValueGross}`);
          }
        }
        
        // If still no value, try to get from gross value field
        if (!vehicleValueGross) {
          const leviPriceListField = document.getElementById('leviPriceList');
          if (leviPriceListField && leviPriceListField.value) {
            vehicleValueGross = parseFloat(leviPriceListField.value.replace(/[â‚ª,]/g, '')) || 0;
            console.log(`ğŸ”§ Got vehicle_value_gross from leviPriceList field: ${vehicleValueGross}`);
          }
        }
        
        // Update the leviPriceList field with the gross market value
        const leviPriceListField = document.getElementById('leviPriceList');
        if (leviPriceListField && vehicleValueGross > 0) {
          leviPriceListField.value = `â‚ª${vehicleValueGross.toLocaleString()}`;
          console.log(`ğŸ“Š Updated leviPriceList field with gross market value: ${vehicleValueGross}`);
        }
        
        // Update helper if we found a value
        if (vehicleValueGross > 0) {
          helper.calculations = helper.calculations || {};
          helper.calculations.vehicle_value_gross = vehicleValueGross;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          console.log(`âœ… Updated helper with vehicle_value_gross: ${vehicleValueGross}`);
        } else {
          console.warn('âš ï¸ No vehicle_value_gross found after all fallback attempts');
        }
        
      } catch (error) {
        console.error('Error updating gross market value field:', error);
      }
    }
    
    // DEBUG CALCULATIONS
    function debugCalculations() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        console.log('ğŸ› DEBUG CALCULATIONS:', {
          helper_calculations: helper.calculations,
          helper_expertise_calculations: helper.expertise?.calculations,
          helper_claims_data: helper.claims_data,
          grossMarketValueResult: document.getElementById('grossMarketValueResult')?.value,
          fullMarketValueResult: document.getElementById('fullMarketValueResult')?.value,
          totalClaim: document.getElementById('totalClaim')?.value,
          leviPriceList: document.getElementById('leviPriceList')?.value,
          grossPercent: document.getElementById('grossPercent')?.value,
          basicPrice: document.getElementById('basicPrice')?.value,
          carMarketValue: document.getElementById('carMarketValue')?.value,
          sumMarketValue: document.getElementById('sumMarketValue')?.value,
          sumClaim: document.getElementById('sumClaim')?.value,
          sumTotalClaim: document.getElementById('sumTotalClaim')?.value
        });
        
      } catch (error) {
        console.error('Error in debug calculations:', error);
      }
    }
    
    // CALCULATE DAMAGE PERCENTAGE
    function calculateDamagePercentage() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Get total claim from damage centers or helper
        let totalClaim = 0;
        const totalClaimField = document.getElementById('totalClaim');
        if (totalClaimField && totalClaimField.value) {
          totalClaim = parseFloat(totalClaimField.value.replace(/[â‚ª,]/g, '')) || 0;
        } else {
          totalClaim = calculateTotalClaimFromDamageCenters();
        }
        
        // Get gross market value from helper or DOM
        let grossMarketValue = helper.calculations?.vehicle_value_gross || 0;
        if (!grossMarketValue) {
          const grossMarketValueField = document.getElementById('grossMarketValueResult');
          if (grossMarketValueField && grossMarketValueField.value) {
            grossMarketValue = parseFloat(grossMarketValueField.value.replace(/[â‚ª,]/g, '')) || 0;
          }
        }
        
        // Calculate damage percentage
        let damagePercentage = 0;
        if (grossMarketValue > 0 && totalClaim > 0) {
          damagePercentage = (totalClaim / grossMarketValue) * 100;
        }
        
        console.log('ğŸ”¢ Damage percentage calculation:', {
          totalClaim,
          grossMarketValue,
          damagePercentage
        });
        
        return damagePercentage;
        
      } catch (error) {
        console.error('Error calculating damage percentage:', error);
        return 0;
      }
    }

    // TRIGGER GLOBAL DEPRECIATION CALCULATION
    function triggerGlobalDepreciationCalc() {
      const globalDepInput = document.getElementById('globalDep1');
      if (globalDepInput && globalDepInput.value) {
        const event = new Event('input', { bubbles: true });
        globalDepInput.dispatchEvent(event);
      }
    }

    // Initialize on load - FIXED ORDER
    document.addEventListener('DOMContentLoaded', () => {
      // First initialize the EstimateCalculations object
      console.log('ğŸš€ Initializing EstimateCalculations object first');
      
      // Then load data from helper after EstimateCalculations is available
      setTimeout(() => {
        loadDataFromHelper();
        loadAttachmentsData();
        loadLegalText().catch(console.error);
        updateGlobalDepreciationCalculation();
      }, 100);
      
      // Initialize adjustment system with event listeners
      setTimeout(() => {
        console.log('ğŸš€ Initializing adjustment system on page load');
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Load all adjustments if they exist
        if (helper.levi?.custom_adjustments || helper.levi?.adjustments) {
          loadAllAdjustments(helper);
        }
        
        // Ensure event listeners are attached
        addAdjustmentEventListeners();
        
        // Trigger initial auto-calculation for existing adjustments
        if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments.length > 0) {
          console.log('ğŸ”„ Running initial auto-calculation for existing adjustments');
          helper.levi.custom_adjustments.forEach((adjustment, index) => {
            if (adjustment.percentage && adjustment.percentage !== 0) {
              calculateAdjustmentValue('custom', index, adjustment.percentage);
            }
          });
        }
      }, 400);
      
      // Trigger initial calculation after page loads
      setTimeout(triggerGlobalDepreciationCalc, 500);
      
      // Add listener to garage days field
      const garageDaysField = document.getElementById('garageDays');
      if (garageDaysField) {
        garageDaysField.addEventListener('input', loadLegalText);
      }
      
      // Add listener to legal text textarea to save changes
      const legalTextArea = document.getElementById('legal-text-content');
      if (legalTextArea) {
        legalTextArea.addEventListener('input', function() {
          // Save using proper helper function
          if (typeof updateHelper === 'function') {
            updateHelper('estimate_legal_text', this.value, 'estimate_builder_legal_text_autosave');
          } else {
            // Fallback for compatibility
            const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
            helper.estimate_legal_text = this.value;
            sessionStorage.setItem('helper', JSON.stringify(helper));
          }
          
          // âœ… BIDIRECTIONAL INTEGRATION: Update builder state in real-time
          updateBuilderCurrentState('estimate_legal_text', this.value);
        });
      }
      
      // AUTO-SAVE ATTACHMENTS ON INPUT
      const attachmentsArea = document.getElementById('attachments-content');
      if (attachmentsArea) {
        attachmentsArea.addEventListener('input', function() {
          // Save using proper helper function
          if (typeof updateHelper === 'function') {
            updateHelper('estimate_attachments', this.value, 'estimate_builder_attachments_autosave');
          } else {
            // Fallback for compatibility
            const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
            helper.estimate_attachments = this.value;
            sessionStorage.setItem('helper', JSON.stringify(helper));
          }
          
          // âœ… BIDIRECTIONAL INTEGRATION: Update builder state in real-time
          updateBuilderCurrentState('estimate_attachments', this.value);
        });
      }
      
      // Update legal text when estimate type changes
      document.querySelectorAll('input[name="estimate-type"]').forEach(radio => {
        radio.addEventListener('change', function() {
          updateReportType();
          loadLegalText().catch(console.error);
        });
      });
    });

    // PARTS SEARCH FUNCTIONALITY
    function showPartSuggestions(input, centerIndex, partIndex) {
      const query = input.value.toLowerCase().trim();
      const suggestionsDiv = input.nextElementSibling;
      
      if (query.length < 2) {
        suggestionsDiv.style.display = 'none';
        return;
      }
      
      // Get stored search results from helper
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const storedResults = helper.parts_search?.results || [];
      
      // Filter results based on query
      const filteredResults = storedResults.filter(part => 
        part.name?.toLowerCase().includes(query) || 
        part.desc?.toLowerCase().includes(query)
      );
      
      if (filteredResults.length > 0) {
        let suggestionsHTML = '';
        filteredResults.slice(0, 10).forEach(part => {
          suggestionsHTML += `
            <div onclick="selectPartSuggestion('${part.name}', '${part.desc}', '${part.price || 0}', '${part.source || ''}', ${centerIndex}, ${partIndex})" 
                 style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 13px;"
                 onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='white'">
              <strong>${part.name}</strong><br>
              <small style="color: #666;">${part.desc || ''} ${part.price ? '- â‚ª' + part.price : ''}</small>
            </div>
          `;
        });
        
        // Add option to search for new parts
        suggestionsHTML += `
          <div onclick="openPartsSearchModule('${query}', ${centerIndex}, ${partIndex})" 
               style="padding: 8px; cursor: pointer; background: #e3f2fd; border-top: 1px solid #ddd; font-size: 13px; color: #1976d2;"
               onmouseover="this.style.background='#bbdefb'" onmouseout="this.style.background='#e3f2fd'">
            ğŸ” ×—×¤×© ×—×œ×§×™× ×—×“×©×™× ×¢×‘×•×¨: "${query}"
          </div>
        `;
        
        suggestionsDiv.innerHTML = suggestionsHTML;
        suggestionsDiv.style.display = 'block';
      } else {
        // Show only search option if no stored results
        suggestionsDiv.innerHTML = `
          <div onclick="openPartsSearchModule('${query}', ${centerIndex}, ${partIndex})" 
               style="padding: 8px; cursor: pointer; background: #e3f2fd; font-size: 13px; color: #1976d2;"
               onmouseover="this.style.background='#bbdefb'" onmouseout="this.style.background='#e3f2fd'">
            ğŸ” ×—×¤×© ×—×œ×§×™× ×¢×‘×•×¨: "${query}"
          </div>
        `;
        suggestionsDiv.style.display = 'block';
      }
    }

    // SELECT PART FROM SUGGESTIONS
    function selectPartSuggestion(name, desc, price, source, centerIndex, partIndex) {
      const partRow = document.querySelector(`.part-row[data-center="${centerIndex}"][data-part="${partIndex}"]`);
      if (partRow) {
        partRow.querySelector('.part-name').value = name;
        partRow.querySelector('.part-desc').value = desc;
        partRow.querySelector('.part-price').value = price;
        partRow.querySelector('.part-source').value = source;
        
        // Hide suggestions
        partRow.querySelector('.part-suggestions').style.display = 'none';
        
        // Trigger save and recalculation
        saveDamageCenterChanges();
      }
    }

    // OPEN PARTS SEARCH MODULE
    function openPartsSearchModule(query, centerIndex, partIndex) {
      // Store the target location for the search result
      sessionStorage.setItem('partSearchTarget', JSON.stringify({
        centerIndex,
        partIndex,
        query
      }));
      
      // Open independent parts search module
      const partsSearchUrl = 'parts search.html?query=' + encodeURIComponent(query);
      window.open(partsSearchUrl, 'partsSearch', 'width=1000,height=700,scrollbars=yes,resizable=yes');
    }

    // ADD/REMOVE ROW FUNCTIONS
    function addPartRow(centerIndex) {
      const partsList = document.querySelector(`.parts-list[data-center="${centerIndex}"]`);
      const newPartIndex = partsList.children.length;
      const newPartHTML = createEditablePartRow({}, centerIndex, newPartIndex);
      partsList.insertAdjacentHTML('beforeend', newPartHTML);
      
      // Add event listeners to new row
      setTimeout(addDamageCenterEventListeners, 50);
    }

    function addWorkRow(centerIndex) {
      const worksList = document.querySelector(`.works-list[data-center="${centerIndex}"]`);
      const newWorkIndex = worksList.children.length;
      const newWorkHTML = createEditableWorkRow('', centerIndex, newWorkIndex);
      worksList.insertAdjacentHTML('beforeend', newWorkHTML);
      
      // Add event listeners to new row
      setTimeout(addDamageCenterEventListeners, 50);
    }

    function addRepairRow(centerIndex) {
      const repairsList = document.querySelector(`.repairs-list[data-center="${centerIndex}"]`);
      const newRepairIndex = repairsList.children.length;
      const newRepairHTML = createEditableRepairRow('', centerIndex, newRepairIndex);
      repairsList.insertAdjacentHTML('beforeend', newRepairHTML);
      
      // Add event listeners to new row
      setTimeout(addDamageCenterEventListeners, 50);
    }

    function removePartRow(centerIndex, partIndex) {
      const partRow = document.querySelector(`.part-row[data-center="${centerIndex}"][data-part="${partIndex}"]`);
      if (partRow) {
        partRow.remove();
        saveDamageCenterChanges();
      }
    }

    function removeWorkRow(centerIndex, workIndex) {
      const workRow = document.querySelector(`.work-row[data-center="${centerIndex}"][data-work="${workIndex}"]`);
      if (workRow) {
        workRow.remove();
        saveDamageCenterChanges();
      }
    }

    function removeRepairRow(centerIndex, repairIndex) {
      const repairRow = document.querySelector(`.repair-row[data-center="${centerIndex}"][data-repair="${repairIndex}"]`);
      if (repairRow) {
        repairRow.remove();
        saveDamageCenterChanges();
      }
    }

    function removeDamageCenter(centerIndex) {
      if (confirm('×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª ××•×§×“ ×”× ×–×§ ×”×–×”?')) {
        const centerCard = document.querySelector(`.editable-damage-card[data-center-index="${centerIndex}"]`);
        if (centerCard) {
          centerCard.remove();
          saveDamageCenterChanges();
        }
      }
    }

    function addNewDamageCenter() {
      const container = document.getElementById('editableDamageCenters');
      if (!container) {
        // If no container exists, create it with totals summary
        const contentHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters"></div>' + createDamageCentersSubtotal();
        document.getElementById('damageCentersContent').innerHTML = contentHTML;
      }
      
      const newIndex = document.querySelectorAll('.editable-damage-card').length;
      const newBlock = {
        damage_center_name: `××•×§×“ × ×–×§ ${newIndex + 1}`,
        parts: [],
        works: [],
        repairs: [],
        work_cost: 0,
        parts_cost: 0
      };
      
      const newCardHTML = createEditableDamageCenterCard(newBlock, newIndex);
      document.getElementById('editableDamageCenters').insertAdjacentHTML('beforeend', newCardHTML);
      
      setTimeout(addDamageCenterEventListeners, 100);
      
      // If totals container doesn't exist, add it now
      if (!document.getElementById('damageCentersSubtotal')) {
        document.getElementById('damageCentersContent').insertAdjacentHTML('beforeend', createDamageCentersSubtotal());
      }
      
      // Update totals display
      setTimeout(updateDamageCentersSubtotal, 200);
    }

    // SAVE DAMAGE CENTER CHANGES TO HELPER
    // WORKING DAMAGE CENTERS SAVE FUNCTION (ADAPTED FOR ESTIMATE)
    function saveDamageCenterChanges() {
      try {
        // ğŸ”§ 2-WAY DATA FLOW: Save back to helper.centers (the source of truth)
        const helper = window.helper || {};
        
        // Initialize centers if not exists
        if (!helper.centers) helper.centers = [];
        
        // ğŸ†• ESTIMATE WORKFLOW: Initialize estimate structure
        if (!helper.estimate) helper.estimate = {};
        if (!helper.estimate.damage_centers) helper.estimate.damage_centers = [];
        
        // Clean up any redundant damage_assessment.centers (duplicate section)
        // BUT preserve damage_assessment.summary which contains totals data
        if (helper.damage_assessment?.centers) {
          console.log('ğŸ§¹ Cleaning up redundant damage_assessment.centers');
          delete helper.damage_assessment.centers;
          
          // Only delete damage_assessment object if it has no important data left
          // Preserve .summary, .totals, and any other important sections
          const remainingKeys = Object.keys(helper.damage_assessment);
          const importantSections = ['summary', 'totals', 'total_centers', 'total_items', 'last_updated', 'totals_after_differentials'];
          const hasImportantData = remainingKeys.some(key => importantSections.includes(key));
          
          if (!hasImportantData && remainingKeys.length === 0) {
            console.log('ğŸ§¹ Deleting empty damage_assessment object');
            delete helper.damage_assessment;
          } else {
            console.log('ğŸ”’ Preserving damage_assessment with important sections:', remainingKeys);
          }
        }
        
        // Also maintain expertise.damage_blocks for backward compatibility
        if (!helper.expertise) helper.expertise = {};
        if (!helper.expertise.damage_blocks) helper.expertise.damage_blocks = [];
        
        // Clear all structures
        helper.centers = [];
        helper.expertise.damage_blocks = [];
        helper.estimate.damage_centers = [];
        
        // Store damage center names for depreciation section
        const damageCenterNames = [];
        
        // Collect data from all damage center cards
        document.querySelectorAll('.editable-damage-card').forEach((card, index) => {
          // Extract just the number from the damage center number field
          const centerNumberField = card.querySelector('.damage-center-number').value;
          // Extract the number (e.g., "××•×§×“ × ×–×§ ××¡' 1" -> "1")
          const numberMatch = centerNumberField.match(/\d+$/);
          const centerNumber = numberMatch ? numberMatch[0] : String(index + 1);
          const centerLocation = card.querySelector('.damage-center-location').value;
          const centerDescription = card.querySelector('.damage-center-description').value;
          
          // Collect parts
          const parts = [];
          card.querySelectorAll('.part-row').forEach(row => {
            const name = row.querySelector('.part-name').value;
            const desc = row.querySelector('.part-desc').value;
            const price = row.querySelector('.part-price').value;
            const source = row.querySelector('.part-source').value;
            
            if (name.trim()) {
              parts.push({ name, desc, price: parseFloat(price) || 0, source });
            }
          });
          
          // Collect works
          const works = [];
          card.querySelectorAll('.work-row').forEach(row => {
            let type = row.querySelector('.work-type').value;
            const note = row.querySelector('.work-note').value;
            const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
            
            // If "××—×¨" is selected, get the custom text from the input
            if (type === '××—×¨') {
              const otherInput = row.querySelector('.work-type-other');
              if (otherInput && otherInput.value.trim()) {
                type = otherInput.value.trim();
              }
            }
            
            if (type) {
              works.push({ category: type, comments: note, cost });
            }
          });
          
          // Collect repairs
          const repairs = [];
          card.querySelectorAll('.repair-row').forEach(row => {
            const text = row.querySelector('.repair-text').value;
            const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
            
            if (text.trim()) {
              repairs.push({ description: text, cost });
            }
          });
          
          // Calculate costs using individual cost fields
          const partsCost = parts.reduce((sum, part) => sum + (parseFloat(part.price) || 0), 0);
          const workCost = works.reduce((sum, work) => sum + (parseFloat(work.cost) || 0), 0);
          const repairsCost = repairs.reduce((sum, repair) => sum + (parseFloat(repair.cost) || 0), 0);
          const totalCost = partsCost + workCost + repairsCost;
          
          // Create center object in helper.centers format (source of truth)
          const centerObject = {
            Id: `dc_${Date.now()}_${index + 1}`, // Generate unique ID
            "Damage center Number": centerNumber || (index + 1),
            Location: centerLocation,
            Description: centerDescription,
            Parts: {
              parts_required: parts,
              parts_meta: {
                total_items: parts.length,
                total_cost: partsCost
              }
            },
            Works: {
              works: works,
              works_meta: {
                total_items: works.length,
                total_cost: workCost
              }
            },
            Repairs: {
              repairs: repairs,
              repairs_meta: {
                total_items: repairs.length,
                total_cost: repairsCost
              }
            },
            Summary: {
              "Total with VAT": totalCost * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100)
            }
          };
          
          // Save to helper.centers (primary source)
          helper.centers.push(centerObject);
          
          // ğŸ†• ESTIMATE WORKFLOW: Save to helper.estimate.damage_centers
          helper.estimate.damage_centers.push({
            center_number: centerNumber || (index + 1),
            location: centerLocation,
            description: centerDescription,
            parts: parts,
            works: works,
            repairs: repairs,
            costs: {
              parts_cost: partsCost,
              work_cost: workCost,
              repairs_cost: repairsCost,
              total_cost: totalCost,
              total_with_vat: totalCost * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100)
            }
          });
          
          // Also save to damage_blocks for backward compatibility
          helper.expertise.damage_blocks.push({
            damage_center_name: centerLocation,
            damage_center_number: index + 1,
            center_header: centerNumber,
            description: centerDescription,
            parts,
            works,
            repairs,
            parts_cost: partsCost,
            work_cost: workCost,
            repairs_cost: repairsCost
          });
          
          // Store damage center data for depreciation section (complete object)
          if (centerLocation.trim()) {
            damageCenterNames.push({
              name: centerLocation.trim(),
              number: centerNumber || (index + 1),
              description: centerDescription || ''
            });
          }
          
          // Update cost display for this card
          updateCostDisplay(card, partsCost, workCost, repairsCost);
        });
        
        // ğŸ†• ESTIMATE WORKFLOW: Calculate estimate totals and save to calculations
        const totalEstimateCost = helper.estimate.damage_centers.reduce((sum, center) => sum + center.costs.total_cost, 0);
        const totalEstimateWithVAT = helper.estimate.damage_centers.reduce((sum, center) => sum + center.costs.total_with_vat, 0);
        
        if (!helper.calculations) helper.calculations = {};
        helper.calculations.total_estimate = totalEstimateCost;
        helper.calculations.total_estimate_with_vat = totalEstimateWithVAT;
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Update depreciation section with damage center names
        updateDepreciationFromDamageCenters(damageCenterNames);
        
        // Trigger floating screen refresh
        triggerFloatingScreenRefresh();
        
        console.log('âœ… Damage centers saved to multiple locations:');
        console.log('- helper.centers:', helper.centers);
        console.log('- helper.estimate.damage_centers:', helper.estimate.damage_centers);
        console.log('- helper.expertise.damage_blocks:', helper.expertise.damage_blocks);
        console.log('- Calculations:', helper.calculations);
        
        // Update damage centers totals display
        setTimeout(updateDamageCentersSubtotal, 100);
        
      } catch (error) {
        console.error('Error saving damage center changes:', error);
      }
    }

    // SAVE DAMAGE CENTERS WITH VISUAL FEEDBACK
    function saveDamageCenterChangesWithFeedback() {
      const saveBtn = document.getElementById('damageCenterSaveBtn');
      if (!saveBtn) return;
      
      try {
        // Show loading state
        const originalText = saveBtn.textContent;
        saveBtn.textContent = '×©×•××¨...';
        saveBtn.style.background = '#6c757d';
        saveBtn.disabled = true;
        
        // Save the changes
        saveDamageCenterChanges();
        
        // Show success state
        setTimeout(() => {
          saveBtn.textContent = 'âœ… × ×©××¨';
          saveBtn.style.background = '#28a745';
          
          // Show success message matching other sections
          showSectionMessage('damage-centers', 'âœ… ××¨×›×–×™ × ×–×§ × ×©××¨×• ×‘×”×¦×œ×—×”', 'success');
          
          // Reset button after 2 seconds
          setTimeout(() => {
            saveBtn.textContent = originalText;
            saveBtn.style.background = '#007bff';
            saveBtn.disabled = false;
          }, 2000);
        }, 500);
        
      } catch (error) {
        console.error('Error saving damage centers:', error);
        
        // Show error state
        setTimeout(() => {
          saveBtn.textContent = 'âŒ ×©×’×™××”';
          saveBtn.style.background = '#dc3545';
          
          showSectionMessage('damage-centers', 'âŒ ×©×’×™××” ×‘×©××™×¨×ª ××¨×›×–×™ × ×–×§', 'error');
          
          // Reset button after 3 seconds
          setTimeout(() => {
            saveBtn.textContent = '×©××•×¨';
            saveBtn.style.background = '#007bff';
            saveBtn.disabled = false;
          }, 3000);
        }, 500);
      }
    }

    // UPDATE DAMAGE CENTERS SUBTOTAL DISPLAY
    function updateDamageCentersSubtotal() {
      // Get helper first for VAT rate and for updating
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const vatRate = helper.calculations?.vat_rate || 18; // Always use calculations.vat_rate
      
      let totalWorks = 0;
      let totalParts = 0;
      let totalRepairs = 0;
      
      // Calculate totals from all damage center cards
      document.querySelectorAll('.editable-damage-card').forEach(card => {
        // Sum parts costs
        card.querySelectorAll('.part-row').forEach(row => {
          const price = parseFloat(row.querySelector('.part-price').value) || 0;
          totalParts += price;
        });
        
        // Sum work costs
        card.querySelectorAll('.work-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
          totalWorks += cost;
        });
        
        // Sum repair costs
        card.querySelectorAll('.repair-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
          totalRepairs += cost;
        });
      });
      
      let rawTotalWithoutVat = totalWorks + totalParts + totalRepairs;
      let rawTotalWithVat = rawTotalWithoutVat * (1 + vatRate / 100);
      
      // For estimate builder, no differentials, so use simple totals
      let finalTotalWorks = totalWorks;
      let finalTotalParts = totalParts;
      let finalTotalRepairs = totalRepairs;
      let finalTotalWithoutVat = rawTotalWithoutVat;
      let finalTotalWithVat = rawTotalWithVat;
      
      console.log('ğŸ§® Calculated totals:', {
        totalWorks, totalParts, totalRepairs, 
        finalTotalWithoutVat, finalTotalWithVat, vatRate,
        cardsFound: document.querySelectorAll('.editable-damage-card').length
      });
      
      // Update display elements
      const formatCurrency = (amount) => amount > 0 ? `â‚ª${Math.round(amount).toLocaleString()}` : 'â‚ª0';
      
      // Update individual category totals
      const totalWorksSubtotal = document.getElementById('totalWorksSubtotal');
      if (totalWorksSubtotal) totalWorksSubtotal.innerText = formatCurrency(finalTotalWorks);
      
      const totalPartsSubtotal = document.getElementById('totalPartsSubtotal');
      if (totalPartsSubtotal) totalPartsSubtotal.innerText = formatCurrency(finalTotalParts);
      
      const totalRepairsSubtotal = document.getElementById('totalRepairsSubtotal');
      if (totalRepairsSubtotal) totalRepairsSubtotal.innerText = formatCurrency(finalTotalRepairs);
      
      // Update main totals
      const totalWithoutVatSubtotal = document.getElementById('totalWithoutVatSubtotal');
      if (totalWithoutVatSubtotal) totalWithoutVatSubtotal.innerText = formatCurrency(finalTotalWithoutVat);
      
      const totalWithVatSubtotal = document.getElementById('totalWithVatSubtotal');
      if (totalWithVatSubtotal) totalWithVatSubtotal.innerText = formatCurrency(finalTotalWithVat);
      
      // Update both sections in one block to prevent interruption
      try {
        // 1. Update damage_assessment.summary with corresponding fields
        if (!helper.damage_assessment) {
          helper.damage_assessment = {};
          console.log('ğŸ”§ Created damage_assessment object');
        }
        if (!helper.damage_assessment.summary) {
          helper.damage_assessment.summary = {};
          console.log('ğŸ”§ Created damage_assessment.summary object');
        }
        
        helper.damage_assessment.summary.total_works = finalTotalWorks;
        helper.damage_assessment.summary.total_parts = finalTotalParts;
        helper.damage_assessment.summary.total_repairs = finalTotalRepairs;
        helper.damage_assessment.summary.total_without_vat = finalTotalWithoutVat;
        helper.damage_assessment.summary.total_with_vat = finalTotalWithVat;
        helper.damage_assessment.summary.vat_rate = vatRate;
        helper.damage_assessment.summary.last_updated = new Date().toISOString();
        
        console.log('ğŸ“ Updated damage_assessment.summary:', helper.damage_assessment.summary);
        
        // 2. Update estimate.damage_centers_totals subsection
        if (!helper.estimate) helper.estimate = {};
        if (!helper.estimate.damage_centers_totals) helper.estimate.damage_centers_totals = {};
        
        helper.estimate.damage_centers_totals = {
          works_total: finalTotalWorks,
          parts_total: finalTotalParts,
          repairs_total: finalTotalRepairs,
          subtotal_without_vat: finalTotalWithoutVat,
          subtotal_with_vat: finalTotalWithVat,
          vat_rate: vatRate,
          last_updated: new Date().toISOString()
        };
        
        console.log('ğŸ“ Updated estimate.damage_centers_totals:', helper.estimate.damage_centers_totals);
        
        // Save updated helper using the SAME pattern as claims_data.total_claim
        if (typeof updateHelper === 'function') {
          updateHelper('damage_assessment', helper.damage_assessment, 'estimate_builder_damage_summary_update');
          updateHelper('estimate', helper.estimate, 'estimate_builder_totals_update');
        } else {
          // Fallback for compatibility (same as claims_data pattern)
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        console.log('âœ… Both sections saved using updateHelper pattern');
        
      } catch (error) {
        console.error('âŒ Error updating helper sections:', error);
      }
      
      // Verify the data was saved correctly
      const savedHelper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('ğŸ’° BEFORE SAVE - damage_assessment.summary:', helper.damage_assessment?.summary);
      console.log('ğŸ’° BEFORE SAVE - estimate.damage_centers_totals:', helper.estimate?.damage_centers_totals);
      console.log('ğŸ’¾ AFTER SAVE - damage_assessment.summary:', savedHelper.damage_assessment?.summary);
      console.log('ğŸ’¾ AFTER SAVE - estimate.damage_centers_totals:', savedHelper.estimate?.damage_centers_totals);
      
      console.log('ğŸ’° Updated damage centers subtotal and helper data:', {
        originalWorks: totalWorks,
        originalParts: totalParts,
        originalRepairs: totalRepairs,
        finalWorks: finalTotalWorks,
        finalParts: finalTotalParts,
        finalRepairs: finalTotalRepairs,
        finalWithoutVat: finalTotalWithoutVat,
        finalWithVat: finalTotalWithVat,
        damage_assessment_summary: helper.damage_assessment.summary,
        estimate_totals: helper.estimate.damage_centers_totals,
        helper_saved_successfully: !!savedHelper.damage_assessment?.summary
      });
    }

    // MANUAL TEST FUNCTION - Force update helper data
    window.testDamageCentersUpdate = function() {
      console.log('ğŸ§ª TESTING: Manual trigger of updateDamageCentersSubtotal');
      updateDamageCentersSubtotal();
      
      // Also check current helper state
      const currentHelper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('ğŸ” Current helper state check:');
      console.log('damage_assessment exists:', !!currentHelper.damage_assessment);
      console.log('damage_assessment.summary exists:', !!currentHelper.damage_assessment?.summary);
      console.log('estimate exists:', !!currentHelper.estimate);
      console.log('estimate.damage_centers_totals exists:', !!currentHelper.estimate?.damage_centers_totals);
      console.log('Full damage_assessment.summary:', currentHelper.damage_assessment?.summary);
      console.log('Full estimate.damage_centers_totals:', currentHelper.estimate?.damage_centers_totals);
    };

    // CREATE DAMAGE CENTERS SUBTOTAL SECTION
    function createDamageCentersSubtotal() {
      // Just totals container, add button, and collapse button - NO LEFT SIDE BUTTONS
      return `
        <div id="damageCentersSubtotal" style="background: #f8f9fa; border: 2px solid #28a745; border-radius: 6px; padding: 12px; margin-top: 15px;">
          <h4 style="margin: 0 0 10px 0; color: #28a745; text-align: center; font-size: 14px; font-weight: bold;">ğŸ§® ×¡×™×›×•× ×›×œ×œ×™ - ××¨×›×–×™ × ×–×§</h4>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 8px;">
            <div style="background: #17a2b8; color: white; padding: 8px; border-radius: 4px; text-align: center;">
              <div style="font-size: 16px; font-weight: bold;" id="totalWorksSubtotal">â‚ª0</div>
              <div style="font-size: 10px; opacity: 0.9;">×¡×”"×› ×¢×‘×•×“×•×ª</div>
            </div>
            <div style="background: #28a745; color: white; padding: 8px; border-radius: 4px; text-align: center;">
              <div style="font-size: 16px; font-weight: bold;" id="totalPartsSubtotal">â‚ª0</div>
              <div style="font-size: 10px; opacity: 0.9;">×¡×”"×› ×—×œ×§×™×</div>
            </div>
            <div style="background: #ffc107; color: #212529; padding: 8px; border-radius: 4px; text-align: center;">
              <div style="font-size: 16px; font-weight: bold;" id="totalRepairsSubtotal">â‚ª0</div>
              <div style="font-size: 10px; opacity: 0.9;">×¡×”"×› ×ª×™×§×•× ×™×</div>
            </div>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
            <div style="background: #6c757d; color: white; padding: 8px; border-radius: 4px; text-align: center;">
              <div style="font-size: 18px; font-weight: bold;" id="totalWithoutVatSubtotal">â‚ª0</div>
              <div style="font-size: 11px; opacity: 0.9;">×¡×”"×› ×œ×œ× ××¢"×</div>
            </div>
            <div style="background: #dc3545; color: white; padding: 8px; border-radius: 4px; text-align: center;">
              <div style="font-size: 18px; font-weight: bold;" id="totalWithVatSubtotal">â‚ª0</div>
              <div style="font-size: 11px; opacity: 0.9;">×¡×”"×› ×›×•×œ×œ ××¢"×</div>
            </div>
          </div>
        </div>
        <div style="display: flex; justify-content: flex-start; gap: 15px; margin-top: 15px;">
          <button type="button" class="btn save-btn" id="damageCenterSaveBtn" onclick="saveDamageCenterChangesWithFeedback()" style="background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.3s ease;">×©××•×¨</button>
          <button type="button" class="btn add" onclick="addNewDamageCenter()" style="background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">×”×•×¡×£ ××•×§×“ × ×–×§ ×—×“×©</button>
        </div>
        <div style="text-align: center; margin-top: 10px;">
          <button type="button" class="btn section-collapse-button" onclick="toggleSection('damageCentersSummary')" style="background: #6c757d; color: white; border: none; padding: 8px 15px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600;">×›×•×•×¥ ×¡×¢×™×£</button>
        </div>
      `;
    }
    
    // UPDATE DEPRECIATION SECTION FROM DAMAGE CENTERS
    function updateDepreciationFromDamageCenters(damageCenterNames) {
      try {
        console.log('ğŸ”„ updateDepreciationFromDamageCenters called with:', damageCenterNames);
        
        const depreciationTable = document.getElementById('depreciationBulkTable');
        if (!depreciationTable) {
          console.log('âŒ depreciationBulkTable not found');
          return;
        }
        
        // Clear existing depreciation rows
        depreciationTable.innerHTML = '';
        console.log('ğŸ§¹ Cleared depreciation table');
        
        // Add a row for each damage center
        damageCenterNames.forEach(centerName => {
          console.log('ğŸ”„ Adding depreciation row for:', centerName);
          const row = document.createElement('div');
          row.className = 'dep-row';
          row.style.cssText = 'display:grid; grid-template-columns:1fr 1fr 120px 120px 80px; gap:14px; margin-bottom:10px;';
          
          row.innerHTML = `
            <div><input type="text" placeholder="×”×—×œ×§ ×”× ×™×–×•×§" value="${centerName}" onchange="saveDepreciationData()" /></div>
            <div><input type="text" placeholder="××”×•×ª ×”×ª×™×§×•×Ÿ" onchange="saveDepreciationData()" /></div>
            <div><input type="text" placeholder="% ×™×¨×™×“×ª ×¢×¨×š" onchange="saveDepreciationData()" /></div>
            <div><input type="text" placeholder="×¢×¨×š ×‘-â‚ª" readonly style="background:#f4f6fa;" /></div>
            <div><button type="button" onclick="this.parentElement.parentElement.remove()" style="background:#dc3545; color:white; border:none; padding:5px 10px; border-radius:4px; cursor:pointer;">××—×§</button></div>
          `;
          
          depreciationTable.appendChild(row);
          
          // Add calculation listener to the percentage field
          const percentInput = row.querySelector('input[placeholder="% ×™×¨×™×“×ª ×¢×¨×š"]');
          const valueInput = row.querySelector('input[placeholder="×¢×¨×š ×‘-â‚ª"]');
          
          percentInput.addEventListener('input', function() {
            let percent = parseFloat(this.value) || 0;
            
            // Auto-add % symbol if not present and user enters a number
            if (this.value && !this.value.includes('%') && !isNaN(percent)) {
              this.value = percent + '%';
            }
            
            // Calculate value from market price automatically
            const marketValueField = document.getElementById('carMarketValue') || document.getElementById('sumMarketValue');
            const marketValueStr = marketValueField?.value.replace(/[â‚ª,]/g, '') || '0';
            const marketValue = parseFloat(marketValueStr) || 0;
            
            const calculatedValue = (marketValue * percent) / 100;
            valueInput.value = calculatedValue ? `â‚ª${Math.round(calculatedValue).toLocaleString()}` : '';
            
            // Update helper with depreciation data
            updateHelperFromField({ target: this });
          });
        });
        
        console.log('âœ… Depreciation section updated with damage centers:', damageCenterNames);
        
      } catch (error) {
        console.error('Error updating depreciation from damage centers:', error);
      }
    }
    
    // ESTIMATE-SPECIFIC DEPRECIATION UPDATE FUNCTION  
    function updateEstimateDepreciationFromDamageCenters(estimateDamageCenterNames) {
      try {
        console.log('ğŸ”„ updateEstimateDepreciationFromDamageCenters called with:', estimateDamageCenterNames);
        
        const depreciationTable = document.getElementById('depreciationBulkTable');
        if (!depreciationTable) {
          console.log('âŒ depreciationBulkTable not found');
          return;
        }
        
        // Clear existing depreciation rows  
        depreciationTable.innerHTML = '';
        console.log('ğŸ§¹ Cleared estimate depreciation table');
        
        // Add a row for each estimate damage center
        estimateDamageCenterNames.forEach(centerData => {
          console.log('ğŸ”„ Adding estimate depreciation row for:', centerData);
          const row = document.createElement('div');
          row.className = 'dep-row';
          row.style.cssText = 'display:grid; grid-template-columns:1fr 1fr 120px 120px 80px; gap:14px; margin-bottom:10px;';
          
          row.innerHTML = `
            <div><input type="text" placeholder="×”×—×œ×§ ×”× ×™×–×•×§" value="${centerData.name} - ${centerData.location}" onchange="saveEstimateDepreciationData()" /></div>
            <div><input type="text" placeholder="××”×•×ª ×”×ª×™×§×•×Ÿ" value="×ª×™×§×•×Ÿ ×œ×¤×™ ××•××“×Ÿ" onchange="saveEstimateDepreciationData()" /></div>
            <div><input type="text" placeholder="% ×™×¨×™×“×ª ×¢×¨×š" onchange="saveEstimateDepreciationData(); calculateEstimateDepreciation(this);" /></div>
            <div><input type="text" placeholder="×¢×¨×š ×‘-â‚ª" readonly style="background:#f4f6fa;" /></div>
            <div><button type="button" onclick="this.parentElement.parentElement.remove(); saveEstimateDepreciationData();" style="background:#dc3545; color:white; border:none; padding:5px 10px; border-radius:4px; cursor:pointer;">××—×§</button></div>
          `;
          
          depreciationTable.appendChild(row);
          
          // Add calculation listener to the percentage field for estimate
          const percentInput = row.querySelector('input[placeholder="% ×™×¨×™×“×ª ×¢×¨×š"]');
          const valueInput = row.querySelector('input[placeholder="×¢×¨×š ×‘-â‚ª"]');
          
          percentInput.addEventListener('input', function() {
            calculateEstimateDepreciation(this);
            saveEstimateDepreciationData();
          });
        });
        
        console.log('âœ… Estimate depreciation section updated with damage centers:', estimateDamageCenterNames);
        
      } catch (error) {
        console.error('âŒ Error updating estimate depreciation from damage centers:', error);
      }
    }
    
    // CALCULATE ESTIMATE DEPRECIATION VALUE
    function calculateEstimateDepreciation(percentInput) {
      try {
        const row = percentInput.closest('.dep-row');
        const valueInput = row.querySelector('input[placeholder="×¢×¨×š ×‘-â‚ª"]');
        
        let percent = parseFloat(percentInput.value) || 0;
        
        // Auto-add % symbol if not present and user enters a number
        if (percentInput.value && !percentInput.value.includes('%') && !isNaN(percent)) {
          percentInput.value = percent + '%';
        }
        
        // Calculate value from estimate market price  
        const estimateMarketValueField = document.getElementById('carMarketValue') || document.getElementById('sumMarketValue');
        const marketValueStr = estimateMarketValueField?.value.replace(/[â‚ª,]/g, '') || '0';
        const marketValue = parseFloat(marketValueStr) || 0;
        
        const calculatedValue = (marketValue * percent) / 100;
        valueInput.value = calculatedValue ? `â‚ª${Math.round(calculatedValue).toLocaleString()}` : '';
        
        console.log(`ğŸ’° Estimate depreciation calculated: ${percent}% of â‚ª${marketValue.toLocaleString()} = â‚ª${Math.round(calculatedValue).toLocaleString()}`);
        
      } catch (error) {
        console.error('âŒ Error calculating estimate depreciation:', error);
      }
    }
    
    // SAVE ESTIMATE DEPRECIATION DATA TO HELPER.ESTIMATE
    function saveEstimateDepreciationData() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Initialize estimate depreciation section
        if (!helper.estimate) helper.estimate = {};
        helper.estimate.depreciation = {
          depreciation_items: [],
          total_depreciation: 0,
          last_updated: new Date().toISOString()
        };
        
        // Collect depreciation data for estimate
        document.querySelectorAll('#depreciationBulkTable .dep-row').forEach(row => {
          const damagedPart = row.querySelector('input[placeholder="×”×—×œ×§ ×”× ×™×–×•×§"]').value;
          const repairType = row.querySelector('input[placeholder="××”×•×ª ×”×ª×™×§×•×Ÿ"]').value;
          const percentage = row.querySelector('input[placeholder="% ×™×¨×™×“×ª ×¢×¨×š"]').value;
          const value = row.querySelector('input[placeholder="×¢×¨×š ×‘-â‚ª"]').value;
          
          if (damagedPart.trim() || repairType.trim() || percentage.trim()) {
            helper.estimate.depreciation.depreciation_items.push({
              damaged_part: damagedPart,
              repair_type: repairType,
              depreciation_percentage: percentage,
              depreciation_value: parseFloat(value.replace(/[â‚ª,]/g, '')) || 0,
              estimate_based: true
            });
          }
        });
        
        // Calculate total depreciation for estimate
        helper.estimate.depreciation.total_depreciation = helper.estimate.depreciation.depreciation_items.reduce(
          (sum, item) => sum + (item.depreciation_value || 0), 0
        );
        
        // Also get global depreciation for estimate
        const globalDepField = document.getElementById('globalDep1');
        const globalDepValue = document.getElementById('globalDepValue');
        if (globalDepField && globalDepField.value) {
          helper.estimate.depreciation.global_depreciation = {
            percentage: globalDepField.value,
            value: parseFloat(globalDepValue.value.replace(/[â‚ª,]/g, '')) || 0
          };
        }
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('ğŸ“Š Estimate depreciation data saved:', helper.estimate.depreciation);
        
      } catch (error) {
        console.error('âŒ Error saving estimate depreciation data:', error);
      }
    }

    // ADD EVENT LISTENERS
    function addDamageCenterEventListeners() {
      // Remove existing listeners by cloning elements (prevents duplicates)
      document.querySelectorAll('.damage-center-name, .damage-center-area-name, .damage-center-description, .part-name, .part-desc, .part-price, .work-type, .work-type-other, .work-note, .work-cost, .repair-text, .repair-cost').forEach(input => {
        // Check if already has listeners
        if (!input.hasAttribute('data-listeners-added')) {
          input.addEventListener('change', () => {
            saveDamageCenterChanges();
            updateAllCostDisplays();
          });
          input.addEventListener('blur', () => {
            saveDamageCenterChanges();
            updateAllCostDisplays();
          });
          input.addEventListener('input', () => {
            updateAllCostDisplays();
          });
          
          // Mark as having listeners to prevent duplicates
          input.setAttribute('data-listeners-added', 'true');
          console.log(`ğŸ“ Added event listeners to: ${input.className}`);
        }
      });
      
      // Hide suggestions when clicking outside
      document.addEventListener('click', function(e) {
        if (!e.target.closest('.part-row')) {
          document.querySelectorAll('.part-suggestions').forEach(div => {
            div.style.display = 'none';
          });
        }
      });
    }

    // UPDATE WORK COST FROM TYPE SELECTION
    function updateWorkCostFromType(selectElement, centerIndex, workIndex) {
      // REMOVED: Predefined work rates that were forcing costs
      // Work costs should be manually entered based on specific case requirements
      
      // Only trigger save and recalculation without changing cost
      saveDamageCenterChanges();
      updateAllCostDisplays();
      
      console.log(`ğŸ”§ Work type changed: ${selectElement.value} (cost remains manual)`);
    }

    function handleWorkTypeChange(selectElement, centerIndex, workIndex) {
      const workRow = selectElement.closest('.work-row');
      const otherInput = workRow.querySelector('.work-type-other');
      
      if (selectElement.value === '××—×¨') {
        otherInput.style.display = 'block';
        otherInput.focus();
      } else {
        otherInput.style.display = 'none';
        otherInput.value = '';
      }
      
      // Call the original function
      updateWorkCostFromType(selectElement, centerIndex, workIndex);
    }

    // COST CALCULATION FUNCTIONS
    function calculateWorkCost(works) {
      return works.reduce((total, work) => {
        const cost = typeof work === 'object' ? (work.cost || 0) : 0;
        return total + parseFloat(cost);
      }, 0);
    }

    function calculateRepairsCost(repairs) {
      return repairs.reduce((total, repair) => {
        const cost = typeof repair === 'object' ? (repair.cost || 0) : 0;
        return total + parseFloat(cost);
      }, 0);
    }

    function calculatePartsCost(parts) {
      return parts.reduce((total, part) => {
        const cost = typeof part === 'object' ? (part.price || 0) : 0;
        return total + parseFloat(cost);
      }, 0);
    }

    function updateCostDisplay(card, partsCost, workCost, repairsCost) {
      const totalCost = partsCost + workCost + repairsCost;
      const totalWithVAT = totalCost * 1.18;
      
      // Update display elements
      const workDisplay = card.querySelector('.work-costs-display');
      const partsDisplay = card.querySelector('.parts-costs-display');
      const repairsDisplay = card.querySelector('.repairs-costs-display');
      const totalDisplay = card.querySelector('.total-with-vat-display');
      
      if (workDisplay) {
        workDisplay.textContent = `â‚ª${workCost.toLocaleString()}`;
        console.log(`ğŸ’¼ Work costs updated: â‚ª${workCost.toLocaleString()}`);
      }
      if (partsDisplay) {
        partsDisplay.textContent = `â‚ª${partsCost.toLocaleString()}`;
        console.log(`ğŸ”§ Parts costs updated: â‚ª${partsCost.toLocaleString()}`);
      }
      if (repairsDisplay) {
        repairsDisplay.textContent = `â‚ª${repairsCost.toLocaleString()}`;
        console.log(`ğŸ”¨ Repairs costs updated (ONLY repairs): â‚ª${repairsCost.toLocaleString()}`);
      }
      if (totalDisplay) {
        totalDisplay.textContent = `â‚ª${Math.round(totalWithVAT).toLocaleString()}`;
        console.log(`ğŸ’° Total with VAT updated: â‚ª${Math.round(totalWithVAT).toLocaleString()}`);
      }
    }

    function updateAllCostDisplays() {
      document.querySelectorAll('.editable-damage-card').forEach(card => {
        // Recalculate costs for this card using individual cost fields
        let partsCost = 0;
        card.querySelectorAll('.part-row').forEach(row => {
          const price = parseFloat(row.querySelector('.part-price').value) || 0;
          partsCost += price;
        });
        
        let workCost = 0;
        card.querySelectorAll('.work-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
          workCost += cost;
        });
        
        let repairsCost = 0;
        card.querySelectorAll('.repair-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
          repairsCost += cost;
        });
        
        updateCostDisplay(card, partsCost, workCost, repairsCost);
      });
      
      // Update summary section totals
      updateSummaryTotalsFromDamageCenters();
    }

    function updateSummaryTotalsFromDamageCenters() {
      let totalClaimBeforeVAT = 0;
      
      document.querySelectorAll('.editable-damage-card').forEach(card => {
        // Calculate total cost for each damage center (parts + works + repairs)
        let partsCost = 0;
        card.querySelectorAll('.part-row').forEach(row => {
          const price = parseFloat(row.querySelector('.part-price').value) || 0;
          partsCost += price;
        });
        
        let workCost = 0;
        card.querySelectorAll('.work-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
          workCost += cost;
        });
        
        let repairsCost = 0;
        card.querySelectorAll('.repair-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
          repairsCost += cost;
        });
        
        totalClaimBeforeVAT += partsCost + workCost + repairsCost;
      });
      
      // Calculate total claim with VAT (18%)
      const totalClaimWithVAT = Math.round(totalClaimBeforeVAT * 1.18);
      
      // Update summary fields
      const sumClaimField = document.getElementById('sumClaim');
      const totalClaimField = document.getElementById('totalClaim');
      
      if (totalClaimWithVAT > 0) {
        const formattedAmount = `â‚ª${totalClaimWithVAT.toLocaleString()}`;
        
        // Update both summary claim and total claim fields WITH VAT
        if (sumClaimField) {
          sumClaimField.value = formattedAmount;
        }
        if (totalClaimField) {
          totalClaimField.value = formattedAmount;
        }
        
        console.log(`ğŸ’° Updated total claim with VAT: ${totalClaimBeforeVAT.toLocaleString()} â†’ ${totalClaimWithVAT.toLocaleString()}`);
        
        // Trigger summary recalculation
        setTimeout(() => {
          if (sumClaimField) {
            const event = new Event('input', { bubbles: true });
            sumClaimField.dispatchEvent(event);
          }
        }, 100);
        
        // New bulk system will handle gross calculations when total claim changes
      }
    }

    // Make functions global
    window.loadDataFromHelper = loadDataFromHelper;
    window.loadLegalText = loadLegalText;
    window.loadLegalTextFromVault = loadLegalTextFromVault;
    window.resetLegalText = resetLegalText;
    window.loadAttachmentsFromVault = loadAttachmentsFromVault;
    window.resetAttachments = resetAttachments;
    window.addDepField = addDepField;
    window.updateReportType = updateReportType;
    window.addCustomSummaryField = addCustomSummaryField;
    window.loadDamageCentersSummary = loadDamageCentersSummary;
    window.loadAllAdjustments = loadAllAdjustments;
    window.populateValuationAdjustmentsFromLevi = populateValuationAdjustmentsFromLevi;
    window.updateGlobalDepreciationCalculation = updateGlobalDepreciationCalculation;
    window.calculateDamagePercentage = calculateDamagePercentage;
    window.triggerGlobalDepreciationCalc = triggerGlobalDepreciationCalc;
    window.showPartSuggestions = showPartSuggestions;
    window.selectPartSuggestion = selectPartSuggestion;
    window.openPartsSearchModule = openPartsSearchModule;
    window.addPartRow = addPartRow;
    window.addWorkRow = addWorkRow;
    window.addRepairRow = addRepairRow;
    window.removePartRow = removePartRow;
    window.removeWorkRow = removeWorkRow;
    window.removeRepairRow = removeRepairRow;
    window.removeDamageCenter = removeDamageCenter;
    window.addNewDamageCenter = addNewDamageCenter;
    window.saveDamageCenterChanges = saveDamageCenterChanges;
    window.addDamageCenterEventListeners = addDamageCenterEventListeners;
    window.calculateWorkCost = calculateWorkCost;
    window.updateWorkCostFromType = updateWorkCostFromType;
    window.updateCostDisplay = updateCostDisplay;
    window.updateAllCostDisplays = updateAllCostDisplays;
    window.updateSummaryTotalsFromDamageCenters = updateSummaryTotalsFromDamageCenters;
    window.updateGrossMarketValueField = updateGrossMarketValueField;
    window.updateGrossPercentageField = updateGrossPercentageField;
    window.calculateGrossMarketValue = calculateGrossMarketValue;
    window.calculateGrossPercentage = calculateGrossPercentage;
    window.calculateFullMarketValue = calculateFullMarketValue;
    window.addFeatureAdjustment = addFeatureAdjustment;
    window.addRegistrationAdjustment = addRegistrationAdjustment;
    window.removeAdjustmentRow = removeAdjustmentRow;
    window.loadGrossAdjustments = loadGrossAdjustments;
    window.updateGrossMarketValueCalculation = updateGrossMarketValueCalculation;
    window.loadGrossCalculationData = loadGrossCalculationData;
    
    // FORCE MANUAL CALCULATION - Last resort function
    function forceManualCalculation() {
      console.log('ğŸ”§ === FORCE MANUAL CALCULATION ===');
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Manual gross market value calculation
      let vehicleValueGross = 0;
      const leviPriceListField = document.getElementById('leviPriceList');
      const grossPercentField = document.getElementById('grossPercent');
      const totalClaimField = document.getElementById('totalClaim');
      
      // Try to get a market value from anywhere
      if (helper.levi_report?.final_price) {
        vehicleValueGross = parseFloat(helper.levi_report.final_price);
        console.log('ğŸ”§ Using levi_report.final_price as vehicleValueGross:', vehicleValueGross);
      } else if (helper.expertise?.calculations?.market_value) {
        vehicleValueGross = parseFloat(helper.expertise.calculations.market_value);
        console.log('ğŸ”§ Using expertise.calculations.market_value as vehicleValueGross:', vehicleValueGross);
      } else if (helper.levisummary?.final_price) {
        vehicleValueGross = parseFloat(helper.levisummary.final_price);
        console.log('ğŸ”§ Using levisummary.final_price as vehicleValueGross:', vehicleValueGross);
      }
      
      // If we have a value, populate the field
      if (vehicleValueGross > 0) {
        leviPriceListField.value = `â‚ª${vehicleValueGross.toLocaleString()}`;
        
        // Update helper
        helper.calculations = helper.calculations || {};
        helper.calculations.vehicle_value_gross = vehicleValueGross;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('ğŸ”§ Manually set vehicleValueGross:', vehicleValueGross);
        
        // Now calculate percentage
        const totalClaim = parseFloat(totalClaimField?.value?.replace(/[â‚ª,]/g, '') || '0');
        if (totalClaim > 0) {
          const grossPercentage = (totalClaim / vehicleValueGross) * 100;
          const formattedPercentage = `${Math.round(grossPercentage * 100) / 100}%`;
          
          grossPercentField.value = formattedPercentage;
          
          // Update helper
          helper.claims_data = helper.claims_data || {};
          helper.claims_data.gross_percent = formattedPercentage;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          console.log('ğŸ”§ Manually calculated gross percentage:', formattedPercentage);
        }
      } else {
        console.warn('âš ï¸ No market value found for manual calculation');
      }
      
      console.log('ğŸ”§ === FORCE MANUAL CALCULATION COMPLETE ===');
    }
    
    // DEBUG HELPER FUNCTION
    function debugCalculations() {
      console.log('ğŸ” === DEBUG CALCULATIONS ===');
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('Helper data:', helper);
      console.log('Calculations:', helper.calculations);
      console.log('Levi report:', helper.levi_report);
      console.log('Expertise:', helper.expertise);
      
      // Check current field values
      const leviPriceListField = document.getElementById('leviPriceList');
      const grossPercentField = document.getElementById('grossPercent');
      const totalClaimField = document.getElementById('totalClaim');
      
      console.log('ğŸ” Current field values:', {
        leviPriceList: leviPriceListField?.value || 'NOT FOUND',
        grossPercent: grossPercentField?.value || 'NOT FOUND',
        totalClaim: totalClaimField?.value || 'NOT FOUND'
      });
      
      // Force refresh all calculations
      updateAllCostDisplays();
      updateSummaryTotalsFromDamageCenters();
      // New bulk system will handle gross calculations
      
      // Check values after refresh
      setTimeout(() => {
        console.log('ğŸ” After refresh field values:', {
          leviPriceList: leviPriceListField?.value || 'NOT FOUND',
          grossPercent: grossPercentField?.value || 'NOT FOUND',
          totalClaim: totalClaimField?.value || 'NOT FOUND'
        });
        
        // If still empty, try force manual calculation
        if (!leviPriceListField?.value || !grossPercentField?.value) {
          console.log('ğŸ”§ Fields still empty, trying force manual calculation...');
          forceManualCalculation();
        }
      }, 100);
      
      console.log('ğŸ” === DEBUG CALCULATIONS COMPLETE ===');
    }
    window.debugCalculations = debugCalculations;
    window.forceManualCalculation = forceManualCalculation;
    
    // ğŸŒ GLOBAL CALCULATION INTERFACE FOR FINAL REPORT MODULES
    window.EstimateCalculations = {
      // Main calculation functions
      updateGrossMarketValueField: updateGrossMarketValueField,
      updateGrossPercentageField: updateGrossPercentageField,
      updateSummaryTotalsFromDamageCenters: updateSummaryTotalsFromDamageCenters,
      updateAllCostDisplays: updateAllCostDisplays,
      calculateDamagePercentage: calculateDamagePercentage,
      
      // Cost calculation functions
      calculateRepairsCost: calculateRepairsCost,
      calculatePartsCost: calculatePartsCost,
      calculateWorkCost: calculateWorkCost,
      updateCostDisplay: updateCostDisplay,
      
      // Helper utilities
      updateHelperFromField: updateHelperFromField,
      loadDataFromHelper: loadDataFromHelper,
      saveDamageCenterChanges: saveDamageCenterChanges,
      debugCalculations: debugCalculations,
      
      // Get calculated values from 3-bulk system
      getGrossMarketValue: function() {
        try {
          // First try to get from the gross market value result field (Bulk 1)
          const grossMarketValueField = document.getElementById('grossMarketValueResult');
          if (grossMarketValueField && grossMarketValueField.value) {
            return parseFloat(grossMarketValueField.value.replace(/[â‚ª,]/g, '')) || 0;
          }
          
          // Fallback to helper data
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          return helper.calculations?.vehicle_value_gross || 0;
        } catch (error) {
          console.error('Error getting gross market value:', error);
          return 0;
        }
      },
      
      getFullMarketValue: function() {
        try {
          // First try to get from the full market value result field (Bulk 3)
          const fullMarketValueField = document.getElementById('fullMarketValueResult');
          if (fullMarketValueField && fullMarketValueField.value) {
            return parseFloat(fullMarketValueField.value.replace(/[â‚ª,]/g, '')) || 0;
          }
          
          // Fallback to helper data
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          return helper.calculations?.market_value || helper.calculations?.full_market_value || helper.levi_report?.final_price || 0;
        } catch (error) {
          console.error('Error getting full market value:', error);
          return 0;
        }
      },
      
      getTotalClaim: function() {
        try {
          // First try to get from the total claim field (Bulk 2)
          const totalClaimField = document.getElementById('totalClaim');
          if (totalClaimField && totalClaimField.value) {
            return parseFloat(totalClaimField.value.replace(/[â‚ª,]/g, '')) || 0;
          }
          
          // Fallback: calculate from damage centers
          const totalFromDamageCenters = calculateTotalClaimFromDamageCenters();
          if (totalFromDamageCenters > 0) {
            return totalFromDamageCenters;
          }
          
          // Final fallback to helper data
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          return parseFloat(helper.claims_data?.total_claim?.replace(/[â‚ª,]/g, '') || '0') || 
                 parseFloat(helper.calculations?.total_damage) || 0;
        } catch (error) {
          console.error('Error getting total claim:', error);
          return 0;
        }
      },
      
      getGrossPercentage: function() {
        try {
          // First try to get from the gross percentage field (Bulk 2)
          const grossPercentField = document.getElementById('grossPercent');
          if (grossPercentField && grossPercentField.value) {
            return parseFloat(grossPercentField.value.replace(/[%]/g, '')) || 0;
          }
          
          // Calculate from current values if not available
          const grossMarketValue = this.getGrossMarketValue();
          const totalClaim = this.getTotalClaim();
          if (grossMarketValue > 0 && totalClaim > 0) {
            return (totalClaim / grossMarketValue) * 100;
          }
          
          // Fallback to helper data
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          return parseFloat(helper.claims_data?.gross_percent?.replace(/[%]/g, '') || '0') || 
                 parseFloat(helper.calculations?.damage_percent) || 0;
        } catch (error) {
          console.error('Error getting gross percentage:', error);
          return 0;
        }
      },
      
      // Get damage centers data
      getDamageCentersData: function() {
        try {
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          return helper.expertise?.damage_centers || [];
        } catch (error) {
          console.error('Error getting damage centers data:', error);
          return [];
        }
      },
      
      // Calculate totals from damage centers
      calculateDamageCentersTotals: function() {
        const damageCenters = this.getDamageCentersData();
        let totalParts = 0;
        let totalWorks = 0;
        let totalRepairs = 0;
        
        damageCenters.forEach(center => {
          totalParts += this.calculatePartsCost(center.parts || []);
          totalWorks += this.calculateWorkCost(center.works || []);
          totalRepairs += this.calculateRepairsCost(center.repairs || []);
        });
        
        return {
          parts: totalParts,
          works: totalWorks,
          repairs: totalRepairs,
          total: totalParts + totalWorks + totalRepairs,
          totalWithVAT: (totalParts + totalWorks + totalRepairs) * 1.18
        };
      },
      
      // Force refresh all calculations
      refreshAllCalculations: function() {
        this.updateAllCostDisplays();
        this.updateSummaryTotalsFromDamageCenters();
        
        // Refresh all 3 bulks
        setTimeout(() => {
          try {
            // Refresh Bulk 1 (Gross Market Value)
            if (typeof updateGrossMarketValueCalculation === 'function') {
              updateGrossMarketValueCalculation();
            }
            
            // Refresh Bulk 2 (Gross Percentage)
            if (typeof refreshSecondBulkFields === 'function') {
              refreshSecondBulkFields();
            }
            
            // Refresh Bulk 3 (Full Market Value)
            if (typeof updateFullMarketValueCalculation === 'function') {
              updateFullMarketValueCalculation();
            }
            
            // Trigger floating screen refresh with updated calculations
            if (typeof triggerFloatingScreenRefresh === 'function') {
              triggerFloatingScreenRefresh();
            }
            
            console.log('âœ… All 3-bulk calculations refreshed from EstimateCalculations interface');
          } catch (error) {
            console.error('Error refreshing 3-bulk calculations:', error);
          }
        }, 100);
      }
    };
    
    // Make it also available via window for backward compatibility
    window.getEstimateCalculations = () => window.EstimateCalculations;

    // MESSAGE LISTENER FOR PARTS SEARCH RESULTS
    window.addEventListener('message', function(event) {
      if (event.data.type === 'PARTS_SELECTED') {
        try {
          const { parts, target } = event.data;
          const { centerIndex, partIndex } = target;
          
          // Find the specific part row
          const targetCard = document.querySelector(`.editable-damage-card[data-center-index="${centerIndex}"]`);
          if (targetCard) {
            const partRows = targetCard.querySelectorAll('.part-row');
            const targetRow = partRows[partIndex];
            
            if (targetRow && parts.length > 0) {
              // Fill the first selected part into the target row
              const firstPart = parts[0];
              const nameInput = targetRow.querySelector('.part-name');
              const descInput = targetRow.querySelector('.part-desc');
              const priceInput = targetRow.querySelector('.part-price');
              const sourceInput = targetRow.querySelector('.part-source');
              
              if (nameInput) nameInput.value = firstPart.name || '';
              if (descInput) descInput.value = firstPart.description || '';
              if (priceInput) priceInput.value = firstPart.price || '';
              if (sourceInput) sourceInput.value = firstPart.source || '';
              
              // Add additional parts if more than one selected
              if (parts.length > 1) {
                const partsList = targetCard.querySelector('.parts-list');
                for (let i = 1; i < parts.length; i++) {
                  const part = parts[i];
                  const newPartIndex = partsList.children.length;
                  const newPartHTML = createEditablePartRow(part, centerIndex, newPartIndex);
                  partsList.insertAdjacentHTML('beforeend', newPartHTML);
                }
              }
              
              // Save changes and update costs
              saveDamageCenterChanges();
              updateAllCostDisplays();
              
              console.log(`âœ… Added ${parts.length} parts to damage center ${centerIndex + 1}`);
            }
          }
        } catch (error) {
          console.error('Error processing parts selection:', error);
        }
      }
    });
    
    // LOAD HELPER DATA AND POPULATE FIELDS
    function loadHelperData() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        console.log('ğŸ“¥ Loading helper data:', helper);
        
        // Auto-fill basic price field from helper - ENHANCED
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField) {
          let basicPrice = 0;
          
          // Try multiple sources for BASE PRICE (not market value) - FIXED PRIORITY
          if (helper.levi_report?.base_price) {
            basicPrice = parseFloat(helper.levi_report.base_price);
            console.log('ğŸ“„ Found BASE PRICE in helper.levi_report.base_price:', basicPrice);
          } else if (helper.expertise?.levi_report?.base_price) {
            basicPrice = parseFloat(helper.expertise.levi_report.base_price);
            console.log('ğŸ“„ Found BASE PRICE in helper.expertise.levi_report.base_price:', basicPrice);
          } else if (helper.levisummary?.base_price) {
            basicPrice = parseFloat(helper.levisummary.base_price);
            console.log('ğŸ“„ Found BASE PRICE in helper.levisummary.base_price:', basicPrice);
          } else if (helper.car_details?.base_price) {
            basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[â‚ª,]/g, ''));
            console.log('ğŸ“„ Found BASE PRICE in helper.car_details.base_price:', basicPrice);
          } else {
            // REMOVED market_value fallback - we need BASE price only
            console.warn('âš ï¸ No BASE PRICE found in helper - this field requires Levi base price, not market value');
          }
          
          if (basicPrice > 0) {
            basicPriceField.value = `â‚ª${basicPrice.toLocaleString()}`;
            console.log('âœ… Auto-filled basic price field:', basicPrice);
            
            // Trigger calculation after loading
            setTimeout(() => {
              updateGrossMarketValueCalculation();
            }, 100);
          } else {
            console.warn('âš ï¸ No base price found in helper, basic price field will be empty');
            console.log('Debug helper data:', {
              levi_report: helper.levi_report,
              expertise: helper.expertise,
              levisummary: helper.levisummary,
              car_details: helper.car_details
            });
            
            // Enhanced debugging: Log full helper structure
            console.group('ğŸ” FULL HELPER STRUCTURE DEBUG');
            console.log('Complete helper object keys:', Object.keys(helper));
            console.log('Helper size:', JSON.stringify(helper).length);
            
            // Check all possible base price locations
            console.log('All possible base price locations:');
            console.log('- helper.levi_report?.base_price:', helper.levi_report?.base_price);
            console.log('- helper.expertise?.levi_report?.base_price:', helper.expertise?.levi_report?.base_price);
            console.log('- helper.levisummary?.base_price:', helper.levisummary?.base_price);
            console.log('- helper.car_details?.base_price:', helper.car_details?.base_price);
            console.log('- helper.vehicle?.base_price:', helper.vehicle?.base_price);
            console.log('- helper.calculations?.base_price:', helper.calculations?.base_price);
            console.log('- helper.expertise?.calculations?.base_price:', helper.expertise?.calculations?.base_price);
            
            // Check vehicle_value_gross locations
            console.log('All possible vehicle_value_gross locations:');
            console.log('- helper.calculations?.vehicle_value_gross:', helper.calculations?.vehicle_value_gross);
            console.log('- helper.expertise?.calculations?.vehicle_value_gross:', helper.expertise?.calculations?.vehicle_value_gross);
            
            // Check damage data locations
            console.log('All possible damage data locations:');
            console.log('- helper.expertise?.damage_blocks:', helper.expertise?.damage_blocks);
            console.log('- helper.damage_centers:', helper.damage_centers);
            console.log('- helper.damage_sections:', helper.damage_sections);
            
            // Log sessionStorage raw data
            console.log('Raw sessionStorage helper:', sessionStorage.getItem('helper'));
            console.groupEnd();
          }
        }
        
        // Auto-fill car details fields
        const carFields = {
          carPlate: helper.meta?.plate || helper.car_details?.plate || '',
          carManufacturer: helper.car_details?.manufacturer || helper.vehicle?.manufacturer || '',
          carModel: helper.car_details?.model || helper.vehicle?.model || '',
          carYear: helper.car_details?.year || helper.vehicle?.year || '',
          carModelCode: helper.car_details?.model_code || helper.vehicle?.model_code || '',
          carBasePrice: helper.levi_report?.base_price || helper.expertise?.levi_report?.base_price || '',
          carMarketValue: helper.car_details?.market_value || helper.vehicle?.market_value || helper.levi_report?.final_price || '',
          carReportDate: convertToDateInputFormat(helper.car_details?.report_date || helper.levi_report?.report_date || '')
        };
        
        Object.entries(carFields).forEach(([fieldId, value]) => {
          const field = document.getElementById(fieldId);
          if (field && !field.value && value) {
            field.value = value;
          }
        });
        
        // Load damage centers from helper
        if (helper.expertise?.damage_blocks && helper.expertise.damage_blocks.length > 0) {
          loadDamageCentersFromHelper(helper.expertise.damage_blocks);
        }
        
        console.log('âœ… Helper data loaded successfully');
        
      } catch (error) {
        console.error('Error loading helper data:', error);
      }
    }
    
    // LOAD DAMAGE CENTERS FROM HELPER
    function loadDamageCentersFromHelper(damageBlocks) {
      try {
        const damageCentersContent = document.getElementById('damageCentersContent');
        if (!damageCentersContent) return;
        
        if (damageBlocks && damageBlocks.length > 0) {
          // Build HTML with damage centers and totals
          let summaryHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters">';
          
          damageBlocks.forEach((block, index) => {
            summaryHTML += createEditableDamageCenterCard(block, index);
          });
          
          summaryHTML += '</div>';
          
          // Add damage centers totals summary container
          summaryHTML += createDamageCentersSubtotal();
          
          damageCentersContent.innerHTML = summaryHTML;
          
          // Add event listeners
          setTimeout(() => {
            addDamageCenterEventListeners();
            updateAllCostDisplays();
            updateDamageCentersSubtotal();
          }, 100);
          
          console.log('âœ… Damage centers loaded from helper with totals:', damageBlocks.length);
        } else {
          // Show empty state with add button
          const emptyStateHTML = '<div style="color: #666; text-align: center;">×œ× × ××¦××• × ×ª×•× ×™ ××•×§×“×™ × ×–×§</div>' +
                                 '<div style="text-align: center; margin-top: 15px;"><button type="button" class="btn add" onclick="addNewDamageCenter()" style="background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">×”×•×¡×£ ××•×§×“ × ×–×§ ×—×“×©</button></div>';
          damageCentersContent.innerHTML = emptyStateHTML;
        }
        
      } catch (error) {
        console.error('Error loading damage centers from helper:', error);
      }
    }
    
    // ADD FIELD CHANGE LISTENERS - CRITICAL FOR HELPER UPDATES
    function addFieldChangeListeners() {
      try {
        console.log('ğŸ”— Adding field change listeners...');
        
        // Car details fields
        const carFields = [
          'carPlate', 'carManufacturer', 'carModel', 'carYear', 'carModelCode',
          'carBasePrice', 'carMarketValue', 'carReportDate', 'carMileage'
        ];
        
        carFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
              
              // Recalculate adjustment values when base price changes
              if (fieldId === 'carBasePrice') {
                console.log('ğŸ“Š Base price changed, recalculating all adjustment values');
                setTimeout(() => {
                  recalculateAllAdjustmentValues();
                }, 100);
              }
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Contact/communication fields
        const contactFields = [
          'ownerName', 'ownerPhone', 'ownerAddress', 'ownerEmail',
          'insuranceAgent', 'agentPhone', 'agentEmail',
          'insuranceCompany', 'insuranceEmail'
        ];
        
        contactFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Claims data fields
        const claimsFields = ['totalClaim', 'authorizedClaim'];
        
        claimsFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
              
              // Update gross percentage when total claim changes
              if (fieldId === 'totalClaim') {
                updateGrossPercentageFromGrossValue();
              }
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Basic price field with special handling for 3-bulk system
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField) {
          basicPriceField.addEventListener('change', function() {
            updateHelperFromField({ target: this });
            updateGrossMarketValueCalculation();
            recalculateAllAdjustmentValues();
          });
          basicPriceField.addEventListener('blur', function() {
            updateHelperFromField({ target: this });
            updateGrossMarketValueCalculation();
          });
        }
        
        // Full basic price field
        const fullBasicPriceField = document.getElementById('fullBasicPrice');
        if (fullBasicPriceField) {
          fullBasicPriceField.addEventListener('change', function() {
            updateHelperFromField({ target: this });
            updateFullMarketValueCalculation();
          });
        }
        
        // Summary data fields
        const summaryFields = ['sumMarketValue', 'sumClaim', 'sumVAT', 'sumTotalClaim', 'depCompensation', 'salvageValue', 'garageDays'];
        
        summaryFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Legal text field
        const legalTextField = document.getElementById('legal-text-content');
        if (legalTextField) {
          legalTextField.addEventListener('change', function() {
            updateHelperFromField({ target: this });
          });
        }
        
        // Estimate type change listener
        document.querySelectorAll('input[name="estimate-type"]').forEach(radio => {
          radio.addEventListener('change', function() {
            updateReportType();
            loadLegalText().catch(console.error);
          });
        });
        
        console.log('âœ… Field change listeners added successfully');
        
      } catch (error) {
        console.error('Error adding field change listeners:', error);
      }
    }
    
    // INITIALIZE 3-BULK SYSTEM ON PAGE LOAD
    document.addEventListener('DOMContentLoaded', function() {
      console.log('ğŸš€ Initializing 3-bulk system...');
      
      // Wait for all objects to be initialized before loading data
      setTimeout(() => {
        // Load saved helper data first
        loadHelperData();
        
        // Add field change listeners - CRITICAL FOR HELPER UPDATES
        addFieldChangeListeners();
      }, 200);
      
      // Initialize gross calculation data
      setTimeout(() => {
        loadGrossCalculationData();
        console.log('âœ… Bulk 1 & 2 initialized');
        
        // REMOVED: Auto-call updateHelperFromAdjustments on page load to prevent duplication
        // updateHelperFromAdjustments should only be called when user makes actual changes
        // setTimeout(() => {
        //   updateHelperFromAdjustments();
        //   console.log('ğŸ”§ Initial helper update completed for Levi floating screen');
        // }, 500);
      }, 500);
      
      // Initialize full market value calculation
      setTimeout(() => {
        loadFullMarketValueData();
        console.log('âœ… Bulk 3 initialized');
        console.log('âœ… Complete 3-bulk system initialized');
      }, 700);
      
      // Add event listeners for damage center changes
      const damageCentersContent = document.getElementById('damageCentersContent');
      if (damageCentersContent) {
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'childList' || mutation.type === 'subtree') {
              // When damage centers change, update second bulk
              setTimeout(() => {
                refreshSecondBulkFields();
              }, 100);
            }
          });
        });
        
        observer.observe(damageCentersContent, {
          childList: true,
          subtree: true
        });
      }
    });
    
    // ENHANCED SAVE DAMAGE CENTER CHANGES TO TRIGGER BULK UPDATES
    const originalSaveDamageCenterChanges = saveDamageCenterChanges;
    saveDamageCenterChanges = function() {
      originalSaveDamageCenterChanges.call(this);
      
      // After saving damage centers, update second bulk
      setTimeout(() => {
        refreshSecondBulkFields();
      }, 100);
    };
    
    // ENHANCED UPDATE ALL COST DISPLAYS TO TRIGGER BULK UPDATES
    const originalUpdateAllCostDisplays = updateAllCostDisplays;
    updateAllCostDisplays = function() {
      originalUpdateAllCostDisplays.call(this);
      
      // After updating costs, update second bulk
      setTimeout(() => {
        refreshSecondBulkFields();
      }, 100);
    };
    
    // ENHANCED CALCULATE SUMMARY TOTALS TO TRIGGER BULK UPDATES
    const originalCalculateSummaryTotals = calculateSummaryTotals;
    calculateSummaryTotals = function() {
      originalCalculateSummaryTotals.call(this);
      
      // After calculating summary totals, update second bulk
      setTimeout(() => {
        refreshSecondBulkFields();
      }, 100);
    };
    
    // GLOBAL FUNCTIONS FOR EXTERNAL ACCESS
    window.calculateGrossMarketValue = calculateGrossMarketValue;
    window.calculateGrossPercentage = calculateGrossPercentage;
    window.calculateFullMarketValue = calculateFullMarketValue;
    window.refreshSecondBulkFields = refreshSecondBulkFields;
    window.updateGrossMarketValueCalculation = updateGrossMarketValueCalculation;
    window.updateGrossPercentageFromGrossValue = updateGrossPercentageFromGrossValue;
    window.updateFullMarketValueCalculation = updateFullMarketValueCalculation;
    window.loadFullMarketValueData = loadFullMarketValueData;
    window.addFullMarketAdjustment = addFullMarketAdjustment;
    window.debugCalculations = debugCalculations;
    
    // Global debug function for helper data structure investigation
    window.debugHelperDataStructure = function() {
      console.group('ğŸ” HELPER DATA STRUCTURE INVESTIGATION');
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      console.log('=== HELPER OVERVIEW ===');
      console.log('Helper keys:', Object.keys(helper));
      console.log('Helper size:', JSON.stringify(helper).length, 'characters');
      
      console.log('\n=== BASE PRICE INVESTIGATION ===');
      const basePriceLocations = {
        'helper.levi_report?.base_price': helper.levi_report?.base_price,
        'helper.expertise?.levi_report?.base_price': helper.expertise?.levi_report?.base_price,
        'helper.levisummary?.base_price': helper.levisummary?.base_price,
        'helper.car_details?.base_price': helper.car_details?.base_price,
        'helper.vehicle?.base_price': helper.vehicle?.base_price,
        'helper.calculations?.base_price': helper.calculations?.base_price,
        'helper.expertise?.calculations?.base_price': helper.expertise?.calculations?.base_price
      };
      
      Object.entries(basePriceLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`âœ… FOUND: ${path} = ${value}`);
        } else {
          console.log(`âŒ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== VEHICLE VALUE GROSS INVESTIGATION ===');
      const vehicleValueLocations = {
        'helper.calculations?.vehicle_value_gross': helper.calculations?.vehicle_value_gross,
        'helper.expertise?.calculations?.vehicle_value_gross': helper.expertise?.calculations?.vehicle_value_gross,
        'helper.levi_report?.final_price': helper.levi_report?.final_price,
        'helper.expertise?.levi_report?.final_price': helper.expertise?.levi_report?.final_price,
        'helper.levisummary?.final_price': helper.levisummary?.final_price
      };
      
      Object.entries(vehicleValueLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`âœ… FOUND: ${path} = ${value}`);
        } else {
          console.log(`âŒ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== DAMAGE DATA INVESTIGATION ===');
      const damageLocations = {
        'helper.expertise?.damage_blocks': helper.expertise?.damage_blocks,
        'helper.damage_centers': helper.damage_centers,
        'helper.damage_sections': helper.damage_sections,
        'helper.expertise?.damage_sections': helper.expertise?.damage_sections
      };
      
      Object.entries(damageLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`âœ… FOUND: ${path} = ${Array.isArray(value) ? value.length + ' items' : typeof value}`);
          if (Array.isArray(value) && value.length > 0) {
            console.log(`  First item keys:`, Object.keys(value[0]));
          }
        } else {
          console.log(`âŒ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== CALCULATION INVESTIGATION ===');
      const calculationLocations = {
        'helper.calculations': helper.calculations,
        'helper.expertise?.calculations': helper.expertise?.calculations
      };
      
      Object.entries(calculationLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`âœ… FOUND: ${path} =`, value);
        } else {
          console.log(`âŒ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== LEVI DATA INVESTIGATION ===');
      const leviLocations = {
        'helper.levi_report': helper.levi_report,
        'helper.expertise?.levi_report': helper.expertise?.levi_report,
        'helper.levisummary': helper.levisummary
      };
      
      Object.entries(leviLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`âœ… FOUND: ${path} =`, value);
        } else {
          console.log(`âŒ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== RAW SESSION STORAGE ===');
      console.log('sessionStorage.getItem("helper"):', sessionStorage.getItem('helper'));
      
      console.groupEnd();
      
      return helper;
    };
    
    // Manual trigger for all calculations
    window.forceCalculateAllAdjustments = function() {
      console.log('ğŸ”„ Forcing calculation of all adjustments...');
      
      // First ensure basic price is loaded
      loadHelperData();
      
      setTimeout(() => {
        // Calculate all adjustment values
        const allPercentInputs = document.querySelectorAll('#featuresAdjustmentsList input[placeholder="%"], #registrationAdjustmentsList input[placeholder="%"]');
        console.log(`Found ${allPercentInputs.length} percentage inputs`);
        
        allPercentInputs.forEach((input, index) => {
          if (input.value) {
            console.log(`Calculating adjustment ${index + 1}: ${input.value}`);
            calculateAdjustmentValue(input);
          }
        });
        
        // Update gross market value calculation
        updateGrossMarketValueCalculation();
        
        console.log('âœ… All adjustment calculations completed');
      }, 200);
    };
    
    console.log('ğŸ¯ 3-bulk system functions loaded and ready');
    
    // SECTION-SPECIFIC SAVE AND REFRESH FUNCTIONALITY
    
    // Section configuration mapping - Updated to include ALL sections with editable fields
    const sectionConfig = {
      'estimate-type': {
        helperKey: 'manual_estimate_type',
        fields: ['estimate-type'],
        loadFunction: null,
        name: '×¡×•×’ ××•××“×Ÿ'
      },
      'vehicle-data': {
        helperKey: 'manual_vehicle_data',
        fields: ['carPlate', 'carManufacturer', 'carModel', 'carYear', 'carModelCode', 'carBasePrice', 'carMarketValue', 'carReportDate'],
        loadFunction: 'loadVehicleData',
        name: '× ×ª×•× ×™ ×”×¨×›×‘'
      },
      'contact-data': {
        helperKey: 'manual_contact_data',
        fields: ['ownerName', 'ownerAddress', 'ownerPhone', 'insuranceCompany', 'insuranceEmail', 'insuranceAgent', 'insuranceAgentPhone', 'insuranceAgentEmail'],
        loadFunction: 'loadContactData',
        name: '×¤×¨×˜×™ ×§×©×¨'
      },
      'damage-centers': {
        helperKey: 'manual_damage_centers',
        fields: [],
        loadFunction: 'loadDamageCentersFromHelper',
        name: '××¨×›×–×™ × ×–×§',
        dynamicContent: true
      },
      'gross-calculation': {
        helperKey: 'manual_gross_calculation',
        fields: ['basicPrice'],
        loadFunction: 'loadGrossCalculationData',
        name: '×—×™×©×•×‘ ××—×•×– × ×–×§ ×‘×¨×•×˜×•',
        dynamicContent: true
      },
      'gross-result': {
        helperKey: 'manual_gross_result',
        fields: ['grossMarketValueResult', 'totalClaim', 'grossPercent', 'authorizedClaim'],
        loadFunction: null,
        name: '×ª×•×¦××ª ×—×™×©×•×‘ ×‘×¨×•×˜×•'
      },
      'full-market-value': {
        helperKey: 'manual_full_market_value',
        fields: ['fullBasicPrice', 'fullMarketValueResult'],
        loadFunction: 'loadFullMarketValueData',
        name: '×—×™×©×•×‘ ×¢×¨×š ×”×©×•×§ ×”××œ×',
        dynamicContent: true
      },
      'depreciation': {
        helperKey: 'manual_depreciation',
        fields: ['globalDep1', 'globalDepValue', 'garageDays'],
        loadFunction: 'loadDepreciationData',
        name: '×—×™×©×•×‘ ×™×¨×™×“×ª ×¢×¨×š',
        dynamicContent: true
      },
      'summary': {
        helperKey: 'manual_summary',
        fields: ['sumMarketValue', 'sumClaim', 'sumGrossPercent', 'sumAuthorizedClaim', 'sumTotalVat', 'sumSalvageValue', 'sumNetClaim'],
        loadFunction: 'loadSummaryData',
        name: '×¡×™×›×•× ×”××•××“×Ÿ'
      },
      'notes': {
        helperKey: 'manual_notes',
        fields: ['additional-notes'],
        loadFunction: null,
        name: '×”×¢×¨×•×ª × ×•×¡×¤×•×ª'
      },
      'legal-text': {
        helperKey: 'manual_legal_text',
        fields: ['legal-text'],
        loadFunction: 'loadLegalText',
        name: '×˜×§×¡×˜ ××©×¤×˜×™'
      }
    };
    
    // Generic save function for any section
    function saveSectionData(sectionId) {
      try {
        const config = sectionConfig[sectionId];
        if (!config) {
          console.error(`Unknown section: ${sectionId}`);
          return;
        }
        
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        const sectionData = {};
        
        // Collect data from all fields in the section
        config.fields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            if (field.type === 'radio') {
              const checked = document.querySelector(`input[name="${field.name}"]:checked`);
              sectionData[fieldId] = checked ? checked.value : '';
            } else {
              sectionData[fieldId] = field.value;
            }
          }
        });
        
        // Handle special cases for dynamic content
        if (sectionId === 'estimate-type') {
          const checkedRadio = document.querySelector('input[name="estimate-type"]:checked');
          sectionData.estimateType = checkedRadio ? checkedRadio.value : '';
        } else if (sectionId === 'damage-centers') {
          sectionData.damageCenters = collectDamageCentersData();
        } else if (sectionId === 'gross-calculation') {
          sectionData.featuresAdjustments = collectAdjustmentData('#featuresAdjustmentsList');
          sectionData.registrationAdjustments = collectAdjustmentData('#registrationAdjustmentsList');
        } else if (sectionId === 'full-market-value') {
          sectionData.allAdjustments = collectAdjustmentData('#allAdjustmentsList');
        } else if (sectionId === 'depreciation') {
          sectionData.depreciationRows = collectDepreciationData('#depreciationBulkTable');
        }
        
        // Save to helper with timestamp
        helper[config.helperKey] = {
          ...sectionData,
          lastSaved: new Date().toISOString(),
          isManualSave: true
        };
        
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Show success message
        showSectionMessage(sectionId, `âœ… ${config.name} × ×©××¨ ×‘×”×¦×œ×—×”`, 'success');
        
        // Trigger refresh for related screens
        triggerFloatingScreenRefresh();
        
        console.log(`âœ… Section ${sectionId} saved successfully`);
        
      } catch (error) {
        console.error(`Error saving section ${sectionId}:`, error);
        showSectionMessage(sectionId, `âŒ ×©×’×™××” ×‘×©××™×¨×ª ${config.name}`, 'error');
      }
    }
    
    // Update depreciation calculations for all fields
    function updateDepreciationCalculation() {
      try {
        // Trigger calculation for global depreciation
        const globalDepInput = document.getElementById('globalDep1');
        if (globalDepInput && globalDepInput.value) {
          const event = new Event('input', { bubbles: true });
          globalDepInput.dispatchEvent(event);
        }
        
        // Trigger calculation for all bulk depreciation rows
        const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
        depRows.forEach(row => {
          const percentInput = row.querySelector('input[placeholder="% ×™×¨×™×“×ª ×¢×¨×š"]');
          if (percentInput && percentInput.value) {
            const event = new Event('input', { bubbles: true });
            percentInput.dispatchEvent(event);
          }
        });
        
        console.log('ğŸ“Š Depreciation calculations updated');
      } catch (error) {
        console.error('Error updating depreciation calculations:', error);
      }
    }
    
    // Generic refresh function for any section
    function refreshSectionData(sectionId) {
      const config = sectionConfig[sectionId];
      if (!config) {
        console.error(`Unknown section: ${sectionId}`);
        return;
      }
      
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Check if we have manual save data
        const manualData = helper[config.helperKey];
        if (manualData && manualData.isManualSave) {
          // Load from manual save
          config.fields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field && manualData[fieldId] !== undefined) {
              field.value = manualData[fieldId];
            }
          });
          
          // Handle special cases for dynamic content
          if (sectionId === 'estimate-type' && manualData.estimateType) {
            const radioButton = document.querySelector(`input[name="estimate-type"][value="${manualData.estimateType}"]`);
            if (radioButton) radioButton.checked = true;
          } else if (sectionId === 'damage-centers' && manualData.damageCenters) {
            restoreDamageCentersData(manualData.damageCenters);
          } else if (sectionId === 'gross-calculation' && manualData.featuresAdjustments) {
            restoreAdjustmentData('#featuresAdjustmentsList', manualData.featuresAdjustments);
            restoreAdjustmentData('#registrationAdjustmentsList', manualData.registrationAdjustments);
          } else if (sectionId === 'full-market-value' && manualData.allAdjustments) {
            restoreAdjustmentData('#allAdjustmentsList', manualData.allAdjustments);
          } else if (sectionId === 'depreciation' && manualData.depreciationRows) {
            restoreDepreciationData('#depreciationBulkTable', manualData.depreciationRows);
          }
          
          showSectionMessage(sectionId, `â†» ${config.name} × ×˜×¢×Ÿ ××”×©××™×¨×” ×”××—×¨×•× ×”`, 'info');
        } else {
          // Load from helper data (original functionality)
          if (window[config.loadFunction]) {
            window[config.loadFunction](helper);
            showSectionMessage(sectionId, `â†» ${config.name} × ×˜×¢×Ÿ ××”××¢×¨×›×ª`, 'info');
          } else if (sectionId === 'depreciation') {
            // Special handling for depreciation section
            loadDepreciationData(helper);
            showSectionMessage(sectionId, `â†» ${config.name} × ×˜×¢×Ÿ ××”××¢×¨×›×ª`, 'info');
          }
        }
        
        // Trigger calculations if needed
        if (sectionId === 'gross-calculation') {
          updateGrossMarketValueCalculation();
        } else if (sectionId === 'full-market-value') {
          // OVERRIDE: Skip the normal function and force our correct calculation
          console.log('ğŸš¨ SECTION REFRESH: Bypassing normal calculation, forcing correct two-phase method');
          
          // Call the load function first to populate data
          loadFullMarketValueData();
          
          // Add multiple validation layers with different delays
          setTimeout(() => updateFullMarketValueCalculation(), 50);
          setTimeout(() => updateFullMarketValueCalculation(), 100);
          setTimeout(() => updateFullMarketValueCalculation(), 200);
          setTimeout(() => updateFullMarketValueCalculation(), 300);
          
          // Final validation with forced correction
          setTimeout(() => {
            const currentValue = document.getElementById('fullMarketValueResult')?.value;
            if (currentValue) {
              const numericValue = parseFloat(currentValue.replace(/[â‚ª,]/g, '')) || 0;
              console.log('ğŸ” FINAL CHECK: Current value is:', numericValue);
              // REMOVED: No hardcoded values allowed - each case must use its own data
              // All calculations must come from current case helper data only
              console.log('âœ… Using dynamic calculation from current case data only');
              updateFullMarketValueCalculation(); // Re-run with proper dynamic data
            }
          }, 500);
        } else if (sectionId === 'depreciation') {
          updateDepreciationCalculation();
        }
        
        console.log(`â†» Section ${sectionId} refreshed successfully`);
        
      } catch (error) {
        console.error(`Error refreshing section ${sectionId}:`, error);
        showSectionMessage(sectionId, `âŒ ×©×’×™××” ×‘×˜×¢×™× ×ª ${config.name}`, 'error');
      }
    }
    
    // Helper function to collect adjustment data from dynamic tables
    function collectAdjustmentData(containerSelector) {
      const container = document.querySelector(containerSelector);
      if (!container) return [];
      
      const adjustments = [];
      container.querySelectorAll('div[class*="adjustment-row"], div[id*="Adj_"]').forEach(row => {
        const inputs = row.querySelectorAll('input');
        const select = row.querySelector('select');
        
        if (inputs.length >= 2) {
          adjustments.push({
            description: inputs[0].value,
            percentage: inputs[1].value,
            value: inputs[2] ? inputs[2].value : '',
            type: select ? select.value : 'plus'
          });
        }
      });
      
      return adjustments;
    }
    
    // Helper function to collect depreciation data
    function collectDepreciationData(containerSelector) {
      const container = document.querySelector(containerSelector);
      if (!container) return [];
      
      const depreciations = [];
      container.querySelectorAll('div[class*="dep-row"], div[id*="depRow_"]').forEach(row => {
        const inputs = row.querySelectorAll('input');
        
        if (inputs.length >= 4) {
          depreciations.push({
            damagedPart: inputs[0].value,
            repairType: inputs[1].value,
            percentage: inputs[2].value,
            value: inputs[3].value
          });
        }
      });
      
      return depreciations;
    }
    
    // Helper function to collect damage centers data
    function collectDamageCentersData() {
      const container = document.getElementById('damageCentersContent');
      if (!container) return [];
      
      const damageCenters = [];
      container.querySelectorAll('div[class*="damage-center-card"], div[id*="damage-center-"]').forEach(card => {
        const nameInput = card.querySelector('input[id*="damage-center-name"]');
        const center = {
          name: nameInput ? nameInput.value : '',
          parts: [],
          works: [],
          repairs: []
        };
        
        // Collect parts
        card.querySelectorAll('div[id*="parts-"] input').forEach((input, index) => {
          if (index % 2 === 0) { // Name inputs
            const priceInput = card.querySelector(`div[id*="parts-"] input:nth-child(${index + 2})`);
            center.parts.push({
              name: input.value,
              price: priceInput ? priceInput.value : ''
            });
          }
        });
        
        // Collect works
        card.querySelectorAll('div[id*="works-"] input').forEach((input, index) => {
          if (index % 2 === 0) { // Name inputs
            const priceInput = card.querySelector(`div[id*="works-"] input:nth-child(${index + 2})`);
            center.works.push({
              name: input.value,
              price: priceInput ? priceInput.value : ''
            });
          }
        });
        
        // Collect repairs
        card.querySelectorAll('div[id*="repairs-"] input').forEach((input, index) => {
          if (index % 2 === 0) { // Name inputs
            const priceInput = card.querySelector(`div[id*="repairs-"] input:nth-child(${index + 2})`);
            center.repairs.push({
              name: input.value,
              price: priceInput ? priceInput.value : ''
            });
          }
        });
        
        damageCenters.push(center);
      });
      
      return damageCenters;
    }
    
    // Helper function to restore adjustment data to dynamic tables
    function restoreAdjustmentData(containerSelector, adjustments) {
      const container = document.querySelector(containerSelector);
      if (!container) return;
      
      // Clear existing rows
      container.innerHTML = '';
      
      // Add each adjustment
      adjustments.forEach(adj => {
        // Use existing add functions
        if (containerSelector.includes('features')) {
          addFeatureAdjustment();
        } else if (containerSelector.includes('registration')) {
          addRegistrationAdjustment();
        } else if (containerSelector.includes('allAdjustments')) {
          addFullMarketAdjustment();
        }
        
        // Fill the last added row
        const lastRow = container.querySelector('div:last-child');
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input');
          const select = lastRow.querySelector('select');
          
          if (inputs[0]) inputs[0].value = adj.description;
          if (inputs[1]) inputs[1].value = adj.percentage;
          if (inputs[2]) inputs[2].value = adj.value;
          if (select) select.value = adj.type;
        }
      });
    }
    
    // Helper function to restore depreciation data
    function restoreDepreciationData(containerSelector, depreciations) {
      const container = document.querySelector(containerSelector);
      if (!container) return;
      
      // Clear existing rows
      container.innerHTML = '';
      
      // Add each depreciation
      depreciations.forEach(dep => {
        addDepField(dep);
      });
    }
    
    // Helper function to restore damage centers data
    function restoreDamageCentersData(damageCenters) {
      const container = document.getElementById('damageCentersContent');
      if (!container || !Array.isArray(damageCenters)) return;

      // Prepare container for editable cards
      container.innerHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters"></div>';
      const wrapper = container.querySelector('#editableDamageCenters');

      damageCenters.forEach((center, index) => {
        const cardHTML = createEditableDamageCenterCard(center, index);
        wrapper.insertAdjacentHTML('beforeend', cardHTML);
      });

      addDamageCenterEventListeners();
      updateAllCostDisplays();
    }
    
    // Helper function to show section messages
    function showSectionMessage(sectionId, message, type) {
      const messageId = `section-message-${sectionId}`;
      let messageDiv = document.getElementById(messageId);
      
      if (!messageDiv) {
        messageDiv = document.createElement('div');
        messageDiv.id = messageId;
        messageDiv.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 10px 15px;
          border-radius: 5px;
          font-size: 14px;
          font-weight: bold;
          z-index: 9999;
          box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          transition: all 0.3s ease;
        `;
        document.body.appendChild(messageDiv);
      }
      
      // Set message style based on type
      const colors = {
        success: { bg: '#d4edda', text: '#155724', border: '#c3e6cb' },
        error: { bg: '#f8d7da', text: '#721c24', border: '#f5c6cb' },
        info: { bg: '#d1ecf1', text: '#0c5460', border: '#bee5eb' }
      };
      
      const color = colors[type] || colors.info;
      messageDiv.style.backgroundColor = color.bg;
      messageDiv.style.color = color.text;
      messageDiv.style.border = `1px solid ${color.border}`;
      messageDiv.textContent = message;
      
      // Auto-hide after 3 seconds
      setTimeout(() => {
        if (messageDiv.parentNode) {
          messageDiv.parentNode.removeChild(messageDiv);
        }
      }, 3000);
    }
    
    // Function to add Save and Refresh buttons to sections with editable fields
    function addSectionButtons() {
      // Define sections that should have save buttons (NO REFRESH) and collapse buttons where applicable
      const sections = [
        { id: 'vehicle-data', selector: '#carPlate', name: '× ×ª×•× ×™ ×”×¨×›×‘', collapsible: true, collapseTarget: 'vehicleData' },
        { id: 'contact-data', selector: '#contactData', name: '×¤×¨×˜×™ ×§×©×¨', collapsible: true, collapseTarget: 'contactData' },
        // REMOVED: damage-centers section - has its own buttons in the totals container
        { id: 'gross-calculation', selector: '#grossCalc', name: '×—×™×©×•×‘ ××—×•×– × ×–×§ ×‘×¨×•×˜×•', collapsible: true, collapseTarget: 'grossCalc' },
        { id: 'gross-result', selector: '#grossPercentageResult', name: '×ª×•×¦××ª ×—×™×©×•×‘ ×‘×¨×•×˜×•', collapsible: true, collapseTarget: 'grossPercentageResult' },
        { id: 'full-market-value', selector: '#fullMarketValue', name: '×—×™×©×•×‘ ×¢×¨×š ×”×©×•×§ ×”××œ×', collapsible: true, collapseTarget: 'fullMarketValue' },
        { id: 'depreciation', selector: '#globalDep1', name: '×—×™×©×•×‘ ×™×¨×™×“×ª ×¢×¨×š ×œ×¤×™ ××•×§×“×™ × ×–×§', collapsible: true, collapseTarget: 'depreciationContent' },
        { id: 'summary', selector: '#sumMarketValue', name: '×¡×™×›×•× ×”××•××“×Ÿ', collapsible: false },
        { id: 'notes', selector: '#additional-notes', name: '×”×¢×¨×•×ª × ×•×¡×¤×•×ª', collapsible: false },
        { id: 'legal-text', selector: '#legal-text-content', name: '×˜×§×¡×˜ ××©×¤×˜×™', collapsible: false }
      ];
      
      sections.forEach(section => {
        let sectionElement = null;
        
        // For collapsible sections, find the collapsible content area (where buttons should go)
        if (section.collapsible && section.collapseTarget) {
          sectionElement = document.getElementById(section.collapseTarget);
        } else if (section.collapsible) {
          sectionElement = document.getElementById(section.selector.replace('#', ''));
        } else {
          // For non-collapsible sections, find by selector and get parent form-section
          const keyElement = document.querySelector(section.selector);
          if (keyElement) {
            sectionElement = keyElement.closest('.form-section');
            if (!sectionElement) {
              sectionElement = keyElement.parentElement;
              while (sectionElement && !sectionElement.classList.contains('form-section')) {
                sectionElement = sectionElement.parentElement;
              }
            }
          }
        }
        
        if (sectionElement) {
          // Remove existing buttons first to avoid duplicates
          const existingButtons = sectionElement.querySelector('.section-save-refresh-buttons');
          if (existingButtons) {
            existingButtons.remove();
          }
          
          console.log(`âœ… Adding buttons to section: ${section.name} (${section.id}) -> Target: ${section.collapseTarget || 'main'}`);
          
          // Create button container with proper styling - LEFT ALIGNED
          const buttonContainer = document.createElement('div');
          buttonContainer.className = 'section-save-refresh-buttons';
          buttonContainer.style.cssText = `
            margin-top: 12px;
            margin-bottom: 8px;
            display: flex;
            gap: 8px;
            justify-content: flex-start;
            flex-wrap: wrap;
          `;
          
          // Create Save button matching existing style
          const saveButton = document.createElement('button');
          saveButton.className = 'btn section-save-button';
          saveButton.textContent = '×©××•×¨';
          saveButton.style.cssText = `
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            display: inline-block;
            width: auto;
            margin: 0;
            transition: background-color 0.3s;
          `;
          saveButton.onmouseover = function() { this.style.background = '#218838'; };
          saveButton.onmouseout = function() { this.style.background = '#28a745'; };
          saveButton.onclick = function() { saveSectionData(section.id); };
          
          // Create Collapse button for collapsible sections
          let collapseButton = null;
          if (section.collapsible) {
            collapseButton = document.createElement('button');
            collapseButton.className = 'btn section-collapse-button';
            collapseButton.textContent = '×›×•×•×¥';
            collapseButton.style.cssText = `
              background: #6c757d;
              color: white;
              border: none;
              padding: 8px 18px;
              border-radius: 8px;
              cursor: pointer;
              font-size: 16px;
              display: inline-block;
              width: auto;
              margin: 0;
              transition: background-color 0.3s;
            `;
            collapseButton.onmouseover = function() { this.style.background = '#5a6268'; };
            collapseButton.onmouseout = function() { this.style.background = '#6c757d'; };
            collapseButton.onclick = function() { 
              // Use the collapseTarget if specified, otherwise try to find it
              const targetId = section.collapseTarget || section.id;
              toggleSection(targetId);
            };
          }
          
          // Add buttons to container - SAVE BUTTON + COLLAPSE BUTTON (NO REFRESH)
          buttonContainer.appendChild(saveButton);
          if (collapseButton) {
            buttonContainer.appendChild(collapseButton);
          }
          
          // For collapsible sections, add at the end
          // For non-collapsible sections, add at the end of the section
          if (section.collapsible) {
            sectionElement.appendChild(buttonContainer);
          } else {
            sectionElement.appendChild(buttonContainer);
          }
          
          console.log(`âœ… Added Save/Refresh buttons to section: ${section.name} (collapsible: ${section.collapsible})`);
        }
      });
    }
    
    // Initialize section buttons when page loads
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(() => {
        addSectionButtons();
      }, 1000);
    });
    
    console.log('ğŸ“„ Section Save/Refresh functionality initialized');
    
    // =========================
    // PLATE INPUT AND DOCUMENT ACTIONS FUNCTIONALITY
    // =========================
    
    // Load existing case for builder
    window.loadExistingCaseForBuilder = async function() {
      const plateNumber = document.getElementById('builderPlateInput').value.trim();
      const password = document.getElementById('builderPasswordInput').value.trim();
      
      if (!plateNumber) {
        alert('×× × ×”×›× ×¡ ××¡×¤×¨ ×¨×›×‘');
        return;
      }
      
      // Validate password against stored login credentials if password is provided
      if (password) {
        try {
          const encryptedPassword = sessionStorage.getItem("auth");
          if (encryptedPassword) {
            const { decryptPassword } = await import('./auth.js');
            const storedPassword = await decryptPassword(encryptedPassword);
            if (password !== storedPassword) {
              alert('×¡×™×¡××” ×©×’×•×™×”');
              return;
            }
          } else {
            alert('××™×Ÿ ××™××•×ª × ×ª×•× ×™× ×–××™×Ÿ');
            return;
          }
        } catch (error) {
          console.error('Error validating password:', error);
          alert('×©×’×™××” ×‘××™××•×ª ×”×¡×™×¡××”');
          return;
        }
      }
      
      const loadBtn = document.getElementById('builderLoadCaseBtn');
      const originalText = loadBtn.textContent;
      
      try {
        loadBtn.disabled = true;
        loadBtn.textContent = '×˜×•×¢×Ÿ ×ª×™×§...';
        
        // Check if main selection page has loaded a case
        const existingHelper = sessionStorage.getItem('helper');
        const existingPlate = sessionStorage.getItem('plate');
        
        if (existingHelper && existingPlate === plateNumber) {
          // Use existing data
          const caseData = JSON.parse(existingHelper);
          
          document.getElementById('builderPlateStatus').style.display = 'block';
          document.getElementById('builderPlateStatus').textContent = 'âœ“ × ×ª×•× ×™ ×”×¨×›×‘ × ×˜×¢× ×• ×‘×”×¦×œ×—×”';
          document.getElementById('builderPlateStatus').style.color = '#059669';
          
          // Update car details from helper
          if (caseData.car_details) {
            document.getElementById('carPlate').value = caseData.car_details.plate || caseData.meta?.plate || '';
            document.getElementById('carManufacturer').value = caseData.car_details.manufacturer || '';
            document.getElementById('carModel').value = caseData.car_details.model || '';
            document.getElementById('carYear').value = caseData.car_details.year || '';
            document.getElementById('carModelCode').value = caseData.car_details.model_code || '';
            document.getElementById('carReportDate').value = convertToDateInputFormat(caseData.car_details.report_date || '');
          }
          
          // Update page title
          // Apply plate standardization (remove dashes for Israeli format XXXXXXXX)
          const standardizedPlateNumber = String(plateNumber).replace(/[-\s]/g, '');
          document.getElementById('pageTitle').textContent = `×¨×›×‘ ××¡. ${standardizedPlateNumber}`;
          
          return;
        }
        
        // Make webhook call to load case
        const payload = { plate: plateNumber };
        if (password) {
          payload.password = password;
        }
        
        // Import webhook function
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('ADMIN_FETCH_CASE', payload);
        
        if (response?.success && response?.data) {
          const caseData = response.data;
          
          // Store the data
          sessionStorage.setItem('helper', JSON.stringify(caseData));
          sessionStorage.setItem('plate', plateNumber);
          sessionStorage.setItem('caseLoaded', 'true');
          
          document.getElementById('builderPlateStatus').style.display = 'block';
          document.getElementById('builderPlateStatus').textContent = 'âœ“ × ×ª×•× ×™ ×”×¨×›×‘ × ×˜×¢× ×• ×‘×”×¦×œ×—×”';
          document.getElementById('builderPlateStatus').style.color = '#059669';
          
          // Update car details from helper
          if (caseData.car_details) {
            document.getElementById('carPlate').value = caseData.car_details.plate || caseData.meta?.plate || '';
            document.getElementById('carManufacturer').value = caseData.car_details.manufacturer || '';
            document.getElementById('carModel').value = caseData.car_details.model || '';
            document.getElementById('carYear').value = caseData.car_details.year || '';
            document.getElementById('carModelCode').value = caseData.car_details.model_code || '';
            document.getElementById('carReportDate').value = convertToDateInputFormat(caseData.car_details.report_date || '');
          }
          
          // Update page title
          // Apply plate standardization (remove dashes for Israeli format XXXXXXXX)
          const standardizedPlateNumber = String(plateNumber).replace(/[-\s]/g, '');
          document.getElementById('pageTitle').textContent = `×¨×›×‘ ××¡. ${standardizedPlateNumber}`;
          
          // Reload data from helper
          loadDataFromHelper();
          
        } else {
          document.getElementById('builderPlateStatus').style.display = 'block';
          document.getElementById('builderPlateStatus').textContent = 'âŒ ×ª×™×§ ×œ× × ××¦× ×‘××¢×¨×›×ª';
          document.getElementById('builderPlateStatus').style.color = '#dc2626';
        }
        
      } catch (error) {
        console.error('Error loading case:', error);
        document.getElementById('builderPlateStatus').style.display = 'block';
        document.getElementById('builderPlateStatus').textContent = 'âŒ ×©×’×™××” ×‘×˜×¢×™× ×ª ×”×ª×™×§';
        document.getElementById('builderPlateStatus').style.color = '#dc2626';
      } finally {
        loadBtn.disabled = false;
        loadBtn.textContent = originalText;
      }
    };
    
    // Request expertise for builder
    window.requestExpertiseForBuilder = async function() {
      const plateNumber = document.getElementById('builderPlateInput').value.trim();
      const helper = sessionStorage.getItem('helper');
      
      if (!plateNumber) {
        alert('×× × ×”×›× ×¡ ××¡×¤×¨ ×¨×›×‘');
        return;
      }
      
      if (!helper) {
        alert('× ×ª×•× ×™ ×”×ª×™×§ ×œ× × ××¦××• ×‘××¢×¨×›×ª');
        return;
      }
      
      const requestBtn = document.getElementById('builderRequestExpertiseBtn');
      const originalText = requestBtn.textContent;
      
      try {
        requestBtn.disabled = true;
        requestBtn.textContent = '××‘×§×© ××§×¡×¤×™×¨×˜×™×–×”...';
        
        const caseData = JSON.parse(helper);
        const payload = {
          plate: plateNumber,
          case_id: caseData.meta?.case_id,
          helper: caseData
        };
        
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('CALL_EXPERTISE', payload);
        
        if (response?.success) {
          const successMessage = response.message || '×”××§×¡×¤×™×¨×˜×™×–×” × ×©×œ×—×” ×‘×”×¦×œ×—×”! ×‘×“×•×§ ××ª ×”××™××™×™×œ ×©×œ×š ×œ×§×‘×œ×ª ×”×§×•×‘×¥.';
          alert(successMessage);
          
          if (response.pdf_url) {
            showFloatingPDF(response.pdf_url, '××§×¡×¤×™×¨×˜×™×–×” PDF');
            
            // Update helper with expertise data
            const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
            if (!helper.expertise) helper.expertise = {};
            helper.expertise.document_url = response.pdf_url;
            helper.expertise.requested_at = new Date().toISOString();
            sessionStorage.setItem('helper', JSON.stringify(helper));
            
            // Update button states
            initializeExpertiseButtonState();
          }
        } else {
          alert('×©×’×™××” ×‘×©×œ×™×—×ª ×‘×§×©×” ×œ××§×¡×¤×™×¨×˜×™×–×”. ×× × × ×¡×” ×©×•×‘.');
        }
        
      } catch (error) {
        console.error('Error requesting expertise:', error);
        alert('×©×’×™××” ×‘×©×œ×™×—×ª ×‘×§×©×” ×œ××§×¡×¤×™×¨×˜×™×–×”. ×× × × ×¡×” ×©×•×‘.');
      } finally {
        requestBtn.disabled = false;
        requestBtn.textContent = originalText;
      }
    };
    
    // Fetch expertise PDF for builder
    window.fetchExpertisePDFForBuilder = async function() {
      const plateNumber = document.getElementById('builderPlateInput').value.trim();
      const helper = sessionStorage.getItem('helper');
      
      if (!plateNumber) {
        alert('×× × ×”×›× ×¡ ××¡×¤×¨ ×¨×›×‘');
        return;
      }
      
      const fetchBtn = document.getElementById('builderFetchExpertiseBtn');
      const originalText = fetchBtn.textContent;
      
      try {
        fetchBtn.disabled = true;
        fetchBtn.textContent = '×˜×•×¢×Ÿ PDF...';
        
        const caseData = helper ? JSON.parse(helper) : null;
        const payload = {
          plate: plateNumber,
          case_id: caseData?.meta?.case_id,
          document_type: 'expertise'
        };
        
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('FETCH_EXPERTISE_PDF', payload);
        
        if (response?.success && response?.pdf_url) {
          showFloatingPDF(response.pdf_url, '××§×¡×¤×™×¨×˜×™×–×” PDF');
        } else {
          alert('××§×¡×¤×™×¨×˜×™×–×” ×œ× × ××¦××” ×‘××¢×¨×›×ª ××• ×œ× ×”×•×¤×§×” ×¢×“×™×™×Ÿ');
        }
        
      } catch (error) {
        console.error('Error fetching expertise PDF:', error);
        alert('×©×’×™××” ×‘×˜×¢×™× ×ª ××§×¡×¤×™×¨×˜×™×–×” PDF');
      } finally {
        fetchBtn.disabled = false;
        fetchBtn.textContent = originalText;
      }
    };
    
    // Show floating PDF display
    function showFloatingPDF(pdfUrl, title) {
      const overlay = document.getElementById('floatingPdfOverlay');
      const titleElement = document.getElementById('floatingPdfTitle');
      const iframe = document.getElementById('pdfViewer');
      
      titleElement.textContent = title;
      
      console.log(`ğŸ” Attempting to display PDF: ${pdfUrl}`);
      
      // Try to load PDF in iframe
      iframe.src = pdfUrl;
      
      // Add error handling for iframe loading
      iframe.onload = function() {
        console.log('âœ… PDF loaded successfully in iframe');
      };
      
      iframe.onerror = function() {
        console.error('âŒ Failed to load PDF in iframe');
        // Fallback: show link to open in new tab
        iframe.style.display = 'none';
        const fallbackDiv = document.createElement('div');
        fallbackDiv.style.cssText = 'padding: 20px; text-align: center; direction: rtl;';
        fallbackDiv.innerHTML = `
          <h3 style="color: #1e3a8a; margin-bottom: 15px;">×œ× × ×™×ª×Ÿ ×œ×”×¦×™×’ ××ª ×”PDF ×‘×—×œ×•×Ÿ ×–×”</h3>
          <p style="margin-bottom: 15px;">×× × ×œ×—×¥ ×¢×œ ×”×§×™×©×•×¨ ×œ×”×¦×’×ª ×”×§×•×‘×¥:</p>
          <a href="${pdfUrl}" target="_blank" style="display: inline-block; padding: 10px 20px; background: #1e3a8a; color: white; text-decoration: none; border-radius: 6px;">
            ×¤×ª×— PDF ×‘×—×œ×•×Ÿ ×—×“×©
          </a>
        `;
        iframe.parentNode.appendChild(fallbackDiv);
      };
      
      overlay.style.display = 'flex';
      
      // Setup event listeners for controls
      setupFloatingPDFControls();
    }
    
    // Setup floating PDF controls with mobile optimization
    function setupFloatingPDFControls() {
      const toggleBtn = document.getElementById('togglePdfBtn');
      const closeBtn = document.getElementById('closePdfBtn');
      const content = document.getElementById('floatingPdfContent');
      const container = document.querySelector('.floating-pdf-container');
      
      // Add touch-friendly event handlers
      function addTouchFriendlyHandler(button, callback) {
        // Handle both click and touch events
        button.addEventListener('click', callback);
        button.addEventListener('touchend', function(e) {
          e.preventDefault();
          callback();
        });
        
        // Add touch visual feedback
        button.addEventListener('touchstart', function() {
          this.style.backgroundColor = 'rgba(255, 255, 255, 0.4)';
        });
        
        button.addEventListener('touchend', function() {
          this.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
        });
      }
      
      // Toggle minimize/maximize with touch support
      addTouchFriendlyHandler(toggleBtn, function() {
        content.classList.toggle('minimized');
        container.classList.toggle('minimized');
        toggleBtn.textContent = content.classList.contains('minimized') ? 'â–¡' : '_';
      });
      
      // Close PDF display with touch support
      addTouchFriendlyHandler(closeBtn, function() {
        const overlay = document.getElementById('floatingPdfOverlay');
        const iframe = document.getElementById('pdfViewer');
        overlay.style.display = 'none';
        iframe.src = '';
        
        // Reset minimize state
        content.classList.remove('minimized');
        container.classList.remove('minimized');
        toggleBtn.textContent = '_';
      });
      
      // Close on overlay click
      document.getElementById('floatingPdfOverlay').onclick = function(e) {
        if (e.target === this) {
          closeBtn.click();
        }
      };
    }
    
    // Initialize plate input and password prefill
    document.addEventListener('DOMContentLoaded', function() {
      // Prefill plate from session storage
      const existingPlate = sessionStorage.getItem('plate');
      if (existingPlate) {
        document.getElementById('builderPlateInput').value = existingPlate;
      }
      
      // Prefill password from session storage
      const prefillPassword = sessionStorage.getItem('prefillPassword') || sessionStorage.getItem('mainGatePassword');
      if (prefillPassword) {
        document.getElementById('builderPasswordInput').value = prefillPassword;
      }
      
      // Initialize expertise button state
      initializeExpertiseButtonState();
    });

    // Initialize expertise button state based on existing data
    function initializeExpertiseButtonState() {
      const fetchBtn = document.getElementById('builderFetchExpertiseBtn');
      const requestBtn = document.getElementById('builderRequestExpertiseBtn');
      
      if (!fetchBtn || !requestBtn) return;
      
      // Check if expertise exists in helper data
      const helper = sessionStorage.getItem('helper');
      let expertiseExists = false;
      
      if (helper) {
        try {
          const helperData = JSON.parse(helper);
          expertiseExists = helperData.expertise_data?.completed || 
                           helperData.documents?.expertise_pdf || 
                           helperData.expertise?.document_url ||
                           helperData.expertise_pdf;
        } catch (error) {
          console.error('Error parsing helper data:', error);
        }
      }
      
      // Set button states based on expertise existence
      if (expertiseExists) {
        // Enable fetch button
        fetchBtn.disabled = false;
        fetchBtn.style.opacity = '1';
        fetchBtn.style.cursor = 'pointer';
        
        // Change request button to "re-request" style
        requestBtn.textContent = '×‘×§×© ××§×¡×¤×™×¨×˜×™×–×” ××—×“×©';
        requestBtn.style.background = '#f59e0b'; // Orange for re-request
      } else {
        // Disable fetch button
        fetchBtn.disabled = true;
        fetchBtn.style.opacity = '0.5';
        fetchBtn.style.cursor = 'not-allowed';
        
        // Set request button to normal style
        requestBtn.textContent = '×‘×§×© ××§×¡×¤×™×¨×˜×™×–×”';
        requestBtn.style.background = '#059669'; // Green for new request
      }
      
      console.log('ğŸ”˜ Expertise button state initialized:', { expertiseExists });
    }
    
    // âœ… BIDIRECTIONAL INTEGRATION: Builder State Management
    // This allows validation page to read current builder state instead of helper directly
    function updateBuilderCurrentState(key, value) {
      try {
        let builderState = {};
        
        // Get existing builder state
        const existingState = sessionStorage.getItem('builderCurrentState');
        if (existingState) {
          builderState = JSON.parse(existingState);
        }
        
        // Update the specific key
        builderState[key] = value;
        builderState.last_update = new Date().toISOString();
        builderState.source = 'estimate-builder';
        
        // Save updated state
        sessionStorage.setItem('builderCurrentState', JSON.stringify(builderState));
        
        console.log(`âœ… Builder state updated: ${key}`, value);
        
        // Trigger broadcast to validation pages
        if (typeof broadcastBuilderStateUpdate === 'function') {
          broadcastBuilderStateUpdate(key, value);
        }
        
      } catch (error) {
        console.error('âŒ Error updating builder state:', error);
      }
    }
    
    // Initialize builder state when page loads
    function initializeBuilderState() {
      try {
        console.log('ğŸ“ Estimate Builder: Initializing with ENHANCED helper integration...');
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // ENHANCED: Create initial builder state from proper helper paths
        const initialState = {
          // Car details - use proper vehicle section
          plate: helper.vehicle?.plate || helper.meta?.plate,
          manufacturer: helper.vehicle?.manufacturer || helper.car_details?.manufacturer,
          model: helper.vehicle?.model || helper.car_details?.model,
          year: helper.vehicle?.year || helper.car_details?.year,
          
          // Owner details - use stakeholders section
          owner_name: helper.stakeholders?.owner?.name || helper.client?.name || helper.owner,
          owner_address: helper.stakeholders?.owner?.address,
          owner_phone: helper.stakeholders?.owner?.phone,
          insurance_company: helper.stakeholders?.insurance?.company || helper.client?.insurance_company || helper.insurance_company,
          
          // Estimate data - use estimate section
          estimate_type: helper.estimate?.type || helper.estimate_type,
          estimate_notes: helper.estimate?.notes || helper.estimate_notes,
          estimate_work_days: helper.estimate?.work_days || helper.estimate_work_days,
          estimate_legal_text: helper.estimate?.legal_text || helper.estimate_legal_text,
          estimate_depreciation: helper.estimate_depreciation,
          
          // Calculations
          calculations: helper.calculations,
          claims_data: helper.claims_data,
          
          // Metadata
          initialized_at: new Date().toISOString(),
          source: 'estimate-builder',
          version: '1.0'
        };
        
        sessionStorage.setItem('builderCurrentState', JSON.stringify(initialState));
        console.log('ğŸ—ï¸ Builder state initialized from helper data');
        
      } catch (error) {
        console.error('âŒ Error initializing builder state:', error);
      }
    }
    
    // Initialize builder state when page loads
    document.addEventListener('DOMContentLoaded', initializeBuilderState);
    
    
    
    // Update helper structure from contact field changes using field mapping dictionary
    function updateHelperFromContactField(element) {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        const fieldId = element.id;
        const value = element.value;
        
        console.log(`ğŸ“ Contact field change: ${fieldId} = "${value}"`);
        
        // Set nested value helper function
        const setNestedValue = (obj, path, val) => {
          const keys = path.split('.');
          let current = obj;
          for (let i = 0; i < keys.length - 1; i++) {
            const key = keys[i];
            if (!(key in current) || typeof current[key] !== 'object') {
              current[key] = {};
            }
            current = current[key];
          }
          current[keys[keys.length - 1]] = val;
        };
        
        // Map field IDs to helper structure paths using field mapping dictionary
        const fieldMappings = {
          'ownerName': 'stakeholders.owner.name',
          'ownerAddress': 'stakeholders.owner.address', 
          'ownerPhone': 'stakeholders.owner.phone',
          'insuranceCompany': 'stakeholders.insurance.company',
          'insuranceEmail': 'stakeholders.insurance.email',
          'insuranceAgent': 'stakeholders.insurance.agent.name',
          'agentPhone': 'stakeholders.insurance.agent.phone',
          'agentEmail': 'stakeholders.insurance.agent.email',
          'carReportDate': 'case_info.issue_date'
        };
        
        // Update standardized helper structure
        if (fieldMappings[fieldId]) {
          setNestedValue(helper, fieldMappings[fieldId], value);
          console.log(`âœ… Updated ${fieldMappings[fieldId]} = "${value}"`);
        }
        
        // Also maintain legacy structure for backward compatibility
        helper.client = helper.client || {};
        helper.car_details = helper.car_details || {};
        
        const legacyMappings = {
          'ownerName': () => {
            helper.client.name = value;
            helper.car_details.owner = value;
          },
          'ownerAddress': () => {
            helper.client.address = value;
            helper.car_details.ownerAddress = value;
          },
          'ownerPhone': () => {
            helper.client.phone = value;
            helper.car_details.ownerPhone = value;
          },
          'insuranceCompany': () => {
            helper.client.insurance_company = value;
            helper.car_details.insuranceCompany = value;
          },
          'insuranceEmail': () => {
            helper.client.insurance_email = value;
          },
          'insuranceAgent': () => {
            helper.client.insurance_agent = value;
            helper.car_details.agentName = value;
          },
          'agentPhone': () => {
            helper.client.insurance_agent_phone = value;
            helper.car_details.insurance_agent_phone = value;
          },
          'agentEmail': () => {
            helper.client.insurance_agent_email = value;
            helper.car_details.insurance_agent_email = value;
          }
        };
        
        if (legacyMappings[fieldId]) {
          legacyMappings[fieldId]();
        }
        
        // ENHANCED DATA PERSISTENCE: Write to both source fields and helper.estimate for reference
        // Initialize helper.estimate if not exists
        helper.estimate = helper.estimate || {};
        
        // Write current contact data to helper.estimate for historical reference
        helper.estimate.contact_data = {
          owner_name: helper.stakeholders?.owner?.name,
          owner_address: helper.stakeholders?.owner?.address,
          owner_phone: helper.stakeholders?.owner?.phone,
          insurance_company: helper.stakeholders?.insurance?.company,
          insurance_email: helper.stakeholders?.insurance?.email,
          insurance_agent: helper.stakeholders?.insurance?.agent?.name,
          agent_phone: helper.stakeholders?.insurance?.agent?.phone,
          agent_email: helper.stakeholders?.insurance?.agent?.email,
          garage_name: helper.stakeholders?.garage?.name,
          garage_phone: helper.stakeholders?.garage?.phone,
          garage_email: helper.stakeholders?.garage?.email
        };
        
        helper.estimate.timestamp = new Date().toISOString();
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        localStorage.setItem('helper', JSON.stringify(helper));
        
        console.log(`ğŸ’¾ Helper updated for field: ${fieldId} (including estimate reference)`);
        
      } catch (error) {
        console.error('âŒ Error updating helper from contact field:', error);
      }
    }
    
    // Update helper structure from vehicle field changes using field mapping dictionary
    function updateHelperFromVehicleField(element) {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        const fieldId = element.id;
        let value = element.value;
        
        console.log(`ğŸ“ Vehicle field change: ${fieldId} = "${value}"`);
        
        // Set nested value helper function
        const setNestedValue = (obj, path, val) => {
          const keys = path.split('.');
          let current = obj;
          for (let i = 0; i < keys.length - 1; i++) {
            const key = keys[i];
            if (!(key in current) || typeof current[key] !== 'object') {
              current[key] = {};
            }
            current = current[key];
          }
          current[keys[keys.length - 1]] = val;
        };
        
        // Process price fields - remove currency symbol and commas
        if (fieldId === 'carBasePrice' || fieldId === 'carMarketValue') {
          value = value.replace(/[â‚ª,]/g, '').trim();
          if (value && !isNaN(value)) {
            value = parseInt(value);
          }
        }
        
        // Map field IDs to helper structure paths
        const fieldMappings = {
          'carBasePrice': 'valuation.base_price',
          'carMarketValue': 'vehicle.market_value', 
          'carReportDate': 'case_info.issue_date'
        };
        
        // Update standardized helper structure
        if (fieldMappings[fieldId]) {
          setNestedValue(helper, fieldMappings[fieldId], value);
          console.log(`âœ… Updated ${fieldMappings[fieldId]} = "${value}"`);
        }
        
        // Also maintain legacy structure for backward compatibility
        helper.car_details = helper.car_details || {};
        helper.levi_report = helper.levi_report || {};
        helper.expertise = helper.expertise || {};
        helper.expertise.calculations = helper.expertise.calculations || {};
        
        const legacyMappings = {
          'carBasePrice': () => {
            helper.car_details.base_price = value;
            helper.levi_report.base_price = value;
          },
          'carMarketValue': () => {
            helper.car_details.market_value = value;
            helper.expertise.calculations.market_value = value;
          },
          'carReportDate': () => {
            helper.car_details.report_date = value;
            helper.levi_report.report_date = value;
          }
        };
        
        if (legacyMappings[fieldId]) {
          legacyMappings[fieldId]();
        }
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        localStorage.setItem('helper', JSON.stringify(helper));
        
        console.log(`ğŸ’¾ Helper updated for vehicle field: ${fieldId}`);
        
      } catch (error) {
        console.error('âŒ Error updating helper from vehicle field:', error);
      }
    }
    
  </script>
  
  <!-- Floating PDF Display Component -->
  <div id="floatingPdfOverlay" class="floating-pdf-overlay" style="display: none;">
    <div class="floating-pdf-container">
      <div class="floating-pdf-header">
        <h3 id="floatingPdfTitle">××¦×™×’ PDF</h3>
        <div class="floating-pdf-controls">
          <button id="togglePdfBtn" class="toggle-btn">_</button>
          <button id="closePdfBtn" class="close-btn">Ã—</button>
        </div>
      </div>
      <div id="floatingPdfContent" class="floating-pdf-content">
        <iframe id="pdfViewer" src="" width="100%" height="100%" frameborder="0"></iframe>
      </div>
    </div>
  </div>
  
  <script type="module" src="auth.js"></script>
  <script src="helper.js" type="module"></script>
  <script src="internal-browser.js"></script>
  <script src="levi-floating.js"></script>
  <script src="car-details-floating.js"></script>
</body>
</html>