<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <title>×—×œ×§×™× × ×“×¨×©×™× - ×™×¨×•×Ÿ ×›×™×•×£</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp" type="image/webp">
  <style>
    body {
      font-family: sans-serif;
      background: #f3f6fb;
      margin: 0;
      padding: 30px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      /* âœ… FIX: Prevent page overflow and layout issues */
      overflow-x: hidden;
      box-sizing: border-box;
    }
    .container {
      max-width: 700px;
      background: #fff;
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 0 20px rgba(0,0,0,0.1);
      width: 100%;
      text-align: center;
      position: relative;
      box-sizing: border-box;
      overflow-x: auto;
    }
    .logo img {
      width: 120px;
      margin-bottom: 15px;
    }
    .title { font-size: 24px; font-weight: bold; margin-bottom: 5px; }
    .subtitle { font-size: 18px; color: #666; margin-bottom: 5px; }
    .legal-note {
      color: red;
      font-weight: bold;
      margin-bottom: 15px;
    }
    h2 {
      font-size: 20px;
      color: #007bff;
      margin-bottom: 20px;
    }
    .top-bar {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    .top-bar button {
      width: 48%;
      background-color: #6c757d;
      color: white;
      border: none;
      padding: 10px;
      border-radius: 8px;
      cursor: pointer;
    }
    .logout-btn {
      background-color: #dc3545 !important;
    }
    .footer {
      margin-top: 30px;
      font-size: 12px;
      color: #aaa;
    }
    * {
  box-sizing: border-box;
}

form button {
  width: 48%;
  margin: 5px 1%;
}

.row {
  display: flex;
  flex-wrap: nowrap;
  justify-content: space-between;
  gap: 10px;
}

    .row {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      align-items: center;
      position: relative;
      flex-wrap: wrap;
      box-sizing: border-box;
      width: 100%;
      padding: 12px;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      background: #f8fafc;
    }
    .row .input-wrap {
      flex: 2 1 160px;
      min-width: 120px;
      box-sizing: border-box;
    }
    .row input.name {
      Flex:non;
      padding: 10px;
      font-size: 14px;
      border-radius: 8px;
      border: 1px solid #ccc;
      width: 100%;
      min-width: 80px;
      box-sizing: border-box;
    }

.row input.desc {
  flex: 2 1 120px;
  min-width: 80px;
  width: 100%;
  box-sizing: border-box;
  padding: 10px;
  font-size: 14px;
  border-radius: 8px;
  border: 1px solid #ccc;
}
.row input.quantity {
  flex: 0 0 60px;
  width: 60px;
  min-width: 50px;
  max-width: 70px;
  box-sizing: border-box;
  padding: 8px;
  font-size: 14px;
  border-radius: 8px;
  border: 1px solid #ccc;
  text-align: center;
}

.row input.price {
  flex: 0 0 80px;
  width: 80px;
  min-width: 60px;
  max-width: 100px;
  box-sizing: border-box;
  padding: 10px;
  font-size: 14px;
  border-radius: 8px;
  border: 1px solid #ccc;
  text-align: left;
}

.row select.source {
  flex: 1 1 100px;
  min-width: 80px;
  width: 100%;
  box-sizing: border-box;
  padding: 10px;
  font-size: 14px;
  border-radius: 8px;
  border: 1px solid #ccc;
}

.row .suggestions {
  position: absolute;
  top: 100%;
  right: 0;
  left: 0;
  background: white;
  border: 1px solid #ccc;
  border-radius: 8px;
  text-align: right;
  z-index: 1000;
  max-height: 200px;
  overflow-y: auto;
  /* âœ… FIX: Prevent layout overflow issues */
  max-width: 100%;
  box-sizing: border-box;
  contain: layout;
}


    .suggestions div {
      padding: 8px 12px;
      cursor: pointer;
    }

    .suggestions div:hover {
      background-color: #f0f0f0;
    }
    .button-row {
  display: flex;
  justify-content: space-between;
  gap: 10px;
    }


    button {
      width: 50%;
      padding: 12px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      color: white;
      background-color: #007bff;
      margin-top: 15px;
      cursor: pointer;
    }

    .btn-secondary {
      background-color: #6c757d;
    }
   .suggestions {
  position: absolute;
  background: white;
  border: 1px solid #ccc;
  z-index: 1000;
  max-height: 200px;
  overflow-y: auto;
  right: 0;
  left: 0;
  top: 100%;
  /* âœ… FIX: Prevent layout overflow issues */
  max-width: 100%;
  box-sizing: border-box;
  contain: layout;
}
.button-vehiclePopup {
    display: flex;
    gap: 10px;
    width: 100%;
    margin-top: 10px;
    margin-bottom: 10px;
}

.suggestions div {
  padding: 10px;
  cursor: pointer;
  border-bottom: 1px solid #eee;
}

.suggestions div:hover {
  background: #f2f2f2;
}
#vehiclePopup {
      background: #f1f1f1;
      padding: 10px;
      border-radius: 10px;
      margin: 10px 0;
      display: none;
      font-size: 14px;
      text-align: right;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="logo">
      <img src="https://carmelcayouf.com/wp-content/uploads/2025/04/logo-yaron.webp" alt="Logo">
    </div>
    <div class="title">×™×¨×•×Ÿ ×›×™×•×£ ×©×××•×ª - ×¤×•×¨×˜×œ</div>
    <div class="subtitle">×©×××™ ×¨×›×‘ ×•×”×¢×¨×›×ª × ×–×§×™ ×¨×›×•×©</div>
    <h2 id="pageTitle">×¨×›×‘ ××¡. ...: ×—×œ×§×™× × ×“×¨×©×™×</h2>


    <!-- Removed navigation buttons when in wizard -->
      
    <form id="partsForm">
      <div id="carDetailsBox" style="display:none;">
        <input id="inputPlate" placeholder="××¡×¤×¨ ×¨×›×‘" type="text" />
        <input id="inputManufacturer" placeholder="×™×¦×¨×Ÿ" type="text" />
        <input id="inputModel" placeholder="×“×’×" type="text" />
        <input id="inputYear" placeholder="×©× ×”" type="number" />
      </div>
      <div id="partsList">
        <div class="row" data-row-index="0">
          <div class="input-wrap">
            <input type="text" class="name" placeholder="×©× ×”×—×œ×§" oninput="suggestPart(this)">
            <select class="suggest-dropdown" style="display:none;"></select>
          </div>
          <input type="text" class="desc" placeholder="×ª×™××•×¨" oninput="suggestPart(this)">
          <input type="text" class="code" placeholder="×§×•×“ ×—×œ×§" style="width: 80px; margin-left: 8px;">
          <input type="number" class="quantity" placeholder="×›××•×ª" value="1" min="1" style="width: 60px; margin-left: 8px;">
          <input type="text" class="price" placeholder="××—×™×¨">
          <select class="source">
            <option value="">××§×•×¨</option>
            <option value="×—×œ×™×¤×™/××§×•×¨×™">×—×œ×™×¤×™/××§×•×¨×™</option>
            <option value="×—×œ×™×¤×™/××©×•××©">×—×œ×™×¤×™/××©×•××©</option>
            <option value="×—×“×© ××§×•×¨×™">×—×“×© ××§×•×¨×™</option>
            <option value="×—×œ×™×¤×™">×—×œ×™×¤×™</option>
            <option value="××©×•××©">××©×•××©</option>
            <option value="×¨×™×§">×¨×™×§</option>
          </select>
          <div class="row-actions" style="display: flex; gap: 5px; margin-right: 8px;">
            <button type="button" class="btn-edit" onclick="editPartRow(0)" title="×¢×¨×•×š ×—×œ×§" style="
              background: #f59e0b; color: white; border: none; padding: 6px 10px; 
              border-radius: 5px; cursor: pointer; font-size: 12px; font-weight: bold;
            ">âœï¸</button>
            <button type="button" class="btn-delete" onclick="deletePartRow(0)" title="××—×§ ×—×œ×§" style="
              background: #dc3545; color: white; border: none; padding: 6px 10px; 
              border-radius: 5px; cursor: pointer; font-size: 12px; font-weight: bold;
            ">ğŸ—‘ï¸</button>
          </div>
        </div>
      </div>

      <button type="button" class="btn-secondary" onclick="addPart()">×”×•×¡×£ ×—×œ×§</button>

    </form>

    <div class="footer">All rights reserved Â© Carmel Cayouf</div>
  </div>

  <script>
    // âœ… NEW: Listen for messages from damage centers wizard
    window.addEventListener('message', function(event) {
      console.log('ğŸ“¨ Parts required received message:', event.data);
      
      switch(event.data.type) {
        case 'damageCenterContext':
          handleWizardContext(event.data);
          break;
        case 'wizardReady':
          console.log('âœ… Wizard ready signal received');
          // Send ready confirmation back
          if (window.parent && window.parent.postMessage) {
            window.parent.postMessage({
              type: 'moduleReady',
              module: 'parts',
              source: 'parts_required_iframe'
            }, '*');
          }
          break;
      }
    });
    
    // âœ… NEW: Handle wizard context
    function handleWizardContext(contextData) {
      console.log('ğŸ¯ Parts required handling wizard context:', contextData);
      
      try {
        // Update global helper with wizard data
        if (contextData.helper) {
          window.helper = contextData.helper;
          globalHelper = contextData.helper;
        }
        
        // Store search results globally for suggestions
        if (contextData.searchResults && contextData.searchResults.length > 0) {
          window.wizardSearchResults = contextData.searchResults;
          console.log(`âœ… Received ${contextData.searchResults.length} search results from wizard`);
          
          // Update helper with search results if not already present
          if (!window.helper.parts_search) {
            window.helper.parts_search = {};
          }
          if (!window.helper.parts_search.current_session) {
            window.helper.parts_search.current_session = {};
          }
          if (!window.helper.parts_search.current_session.results) {
            window.helper.parts_search.current_session.results = contextData.searchResults;
          }
        }
        
        // Pre-fill with existing selected parts for current damage center
        console.log('ğŸ” EDIT MODE DEBUG - contextData.selectedParts:', contextData.selectedParts?.length || 0);
        console.log('ğŸ” EDIT MODE DEBUG - damageCenterId:', contextData.damageCenterId);
        
        if (contextData.selectedParts && contextData.selectedParts.length > 0) {
          // Clear existing parts first to avoid duplicates
          const partsList = document.getElementById('partsList');
          partsList.innerHTML = '';
          
          contextData.selectedParts.forEach((part, index) => {
            console.log(`ğŸ” Adding part ${index} for center ${contextData.damageCenterId}:`, part);
            addPartFromData(part);
          });
          console.log(`âœ… Pre-filled ${contextData.selectedParts.length} parts for damage center ${contextData.damageCenterId}`);
        } else {
          // If no parts for this center, clear the UI and show empty state
          const partsList = document.getElementById('partsList');
          partsList.innerHTML = '';
          console.log(`ğŸ“ No existing parts found for damage center ${contextData.damageCenterId}`);
        }
        
        // Show wizard mode indicator
        showWizardModeUI(contextData);
        
      } catch (error) {
        console.error('âŒ Failed to handle wizard context:', error);
      }
    }
    
    // âœ… NEW: Show wizard-specific UI
    function showWizardModeUI(contextData) {
      const container = document.querySelector('.container');
      if (container) {
        const wizardIndicator = document.createElement('div');
        wizardIndicator.style.cssText = `
          background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
          color: white; padding: 10px; border-radius: 8px; margin-bottom: 15px;
          text-align: center; font-weight: bold;
        `;
        wizardIndicator.innerHTML = `ğŸ”§ ×‘×—×™×¨×ª ×—×œ×¤×™× - ××©×£ ××•×§×“×™ × ×–×§ (××•×§×“ ${contextData.damageCenter?.number || '×—×“×©'})`;
        
        container.insertBefore(wizardIndicator, container.firstChild);
      }
    }
    
    // Authentication check
    const auth = sessionStorage.getItem("auth");
    if (!auth) {
      alert("×”×’×™×©×” ×—×¡×•××” - ×× × ×”×ª×—×‘×¨ ×“×¨×š ×“×£ ×”×‘×™×ª");
      window.location.href = "index.html";
    }

    // Get data from helper instead of legacy storage
    let globalHelper = {};
    try { globalHelper = JSON.parse(sessionStorage.getItem("helper") || '{}'); } catch(e){}
    const plate = globalHelper.meta?.plate || globalHelper.vehicle?.plate || '';
    const manufacturer = globalHelper.vehicle?.manufacturer || '';
    const model = globalHelper.vehicle?.model || '';
    const year = globalHelper.vehicle?.year || '';

    if (!plate || !manufacturer || !model || !year) {
      alert("×©×’×™××”: ×—×¡×¨ ××™×“×¢ ×§×¨×™×˜×™.");
    }

    document.getElementById("pageTitle").innerText = `×¨×›×‘ ××¡. ${plate}: ×—×œ×§×™× × ×“×¨×©×™×`;

    function logout() {
      sessionStorage.clear();
      window.location.href = "index.html";
    }

  function addPart() {
  const partsList = document.getElementById("partsList");
  const newRowIndex = partsList.children.length;
  
  const row = document.createElement("div");
  row.className = "row";
  row.setAttribute("data-row-index", newRowIndex);
  row.innerHTML = `
    <div class="input-wrap">
          <input type="text" class="name" placeholder="×©× ×”×—×œ×§" oninput="suggestPart(this); autoSaveOnChange(this)">
          <select class="suggest-dropdown" style="display:none;"></select>
        </div>
        <input type="text" class="desc" placeholder="×ª×™××•×¨" oninput="suggestPart(this); autoSaveOnChange(this)">
        <input type="number" class="quantity" placeholder="×›××•×ª" value="1" min="1" style="width: 60px; margin-left: 8px;" onchange="autoSaveOnChange(this)">
        <input type="text" class="price" placeholder="××—×™×¨" onchange="autoSaveOnChange(this)">
        <select class="source">
          <option value="">××§×•×¨</option>
          <option value="×—×œ×™×¤×™/××§×•×¨×™">×—×œ×™×¤×™/××§×•×¨×™</option>
          <option value="×—×œ×™×¤×™/××©×•××©">×—×œ×™×¤×™/××©×•××©</option>
          <option value="×—×“×© ××§×•×¨×™">×—×“×© ××§×•×¨×™</option>
          <option value="×—×œ×™×¤×™">×—×œ×™×¤×™</option>
          <option value="××©×•××©">××©×•××©</option>
          <option value="×¨×™×§">×¨×™×§</option>
        </select>
        <div class="row-actions" style="display: flex; gap: 5px; margin-right: 8px;">
          <button type="button" class="btn-edit" onclick="editPartRow(${newRowIndex})" title="×¢×¨×•×š ×—×œ×§" style="
            background: #f59e0b; color: white; border: none; padding: 6px 10px; 
            border-radius: 5px; cursor: pointer; font-size: 12px; font-weight: bold;
          ">âœï¸</button>
          <button type="button" class="btn-delete" onclick="deletePartRow(${newRowIndex})" title="××—×§ ×—×œ×§" style="
            background: #dc3545; color: white; border: none; padding: 6px 10px; 
            border-radius: 5px; cursor: pointer; font-size: 12px; font-weight: bold;
          ">ğŸ—‘ï¸</button>
        </div>
  `;
  partsList.appendChild(row);
  
  // === PHASE 3: Update counts after adding new row ===
  updatePartCount();
  
  console.log(`â• Added new part row ${newRowIndex}`);
}

// === PHASE 2: Remove duplicate parts function ===
function removeDuplicateParts(helper, activeCenterId) {
  console.log('ğŸ§¹ PHASE 2: Starting duplicate removal for center:', activeCenterId);
  
  if (!helper.parts_search?.selected_parts) {
    console.log('âš ï¸ No selected_parts array found, skipping deduplication');
    return;
  }
  
  const seen = new Map();
  const originalCount = helper.parts_search.selected_parts.length;
  
  // Remove duplicates based on centerId + part name combination
  helper.parts_search.selected_parts = helper.parts_search.selected_parts.filter(part => {
    // Create unique key based on damage center ID and part name/number
    const partIdentifier = part.name || part.partNumber || part.part || '';
    const centerIdentifier = part.damage_center_id || part.centerId || '';
    const key = `${centerIdentifier}_${partIdentifier}`;
    
    console.log(`ğŸ” DEDUP: Checking part "${partIdentifier}" in center "${centerIdentifier}" -> key: ${key}`);
    
    if (seen.has(key)) {
      console.log(`ğŸ—‘ï¸ Removing duplicate part: ${key}`);
      return false;
    }
    
    seen.set(key, true);
    return true;
  });
  
  const newCount = helper.parts_search.selected_parts.length;
  console.log(`âœ… Deduplication complete: ${originalCount} â†’ ${newCount} parts (removed ${originalCount - newCount} duplicates)`);
  
  // Also update damage_centers_summary if exists (it's an object keyed by center ID)
  if (helper.parts_search?.damage_centers_summary && helper.parts_search.damage_centers_summary[activeCenterId]) {
    const centerSummary = helper.parts_search.damage_centers_summary[activeCenterId];
    
    if (centerSummary && centerSummary.parts_list) {
      const centerSeenMap = new Map();
      const originalCenterCount = centerSummary.parts_list.length;
      
      centerSummary.parts_list = centerSummary.parts_list.filter(part => {
        // Use part name as key since parts_list items don't have partNumber
        const key = `${part.name}`;
        if (centerSeenMap.has(key)) {
          return false;
        }
        centerSeenMap.set(key, true);
        return true;
      });
      
      console.log(`âœ… Center ${activeCenterId} summary deduplication: ${originalCenterCount} â†’ ${centerSummary.parts_list.length} parts`);
    }
  }
}

// Save parts data to helper without navigation
function savePartsData() {
  // === PHASE 0: DIAGNOSTIC LOGGING ===
  console.log('=== PARTS MODULE DIAGNOSTIC (savePartsData) ===');
  const diagnosticHelper = JSON.parse(sessionStorage.getItem('helper') || '{}');
  console.log('Current damage center:', diagnosticHelper.current_damage_center);
  console.log('Selected parts count:', diagnosticHelper.parts_search?.selected_parts?.length);
  console.log('Selected parts array:', diagnosticHelper.parts_search?.selected_parts);
  console.log('Damage centers summary:', diagnosticHelper.parts_search?.damage_centers_summary);
  console.log('Parts in UI:', document.querySelectorAll('#partsList .row').length);
  console.log('Active damage center ID from session:', sessionStorage.getItem('active_damage_center_id'));
  console.log('Damage center mode:', sessionStorage.getItem('damage_center_mode'));
  console.log('=== END DIAGNOSTIC ===');
  
  const allParts = [];

  document.querySelectorAll("#partsList .row").forEach(row => {
    const name = row.querySelector(".name").value.trim();
    const desc = row.querySelector(".desc").value.trim();
    const quantity = parseInt(row.querySelector(".quantity")?.value) || 1;
    const price = row.querySelector(".price").value.trim();
    const source = row.querySelector(".source").value;
    
    // âœ… CHANGED: Include quantity in parts data
    if (name || desc || price || source) {
      allParts.push({ 
        part: name,
        name: name,  // === PHASE 4: Ensure consistent field naming ===
        desc: desc,
        description: desc,  // === PHASE 4: Ensure description field exists ===
        quantity: quantity,
        price, 
        source 
      });
    }
  });

  // âœ… CHANGED: Enhanced part validation - allow saving with 0 parts
  const validParts = [];
  const invalidParts = [];
  
  allParts.forEach(part => {
    // âœ… REMOVED: No longer require both name and desc - be more flexible
    // Only validate price format if a price was entered
    if (part.price && isNaN(parseFloat(part.price))) {
      invalidParts.push({ part, error: '××—×™×¨ ×—×™×™×‘ ×œ×”×™×•×ª ××¡×¤×¨ ×ª×§×™×Ÿ' });
    } else {
      // Check if this part came from search results and preserve full JSON data
      let searchResultData = {};
      const storedHelper = JSON.parse(sessionStorage.getItem("helper") || '{}');
      const searchResults = storedHelper?.parts_search?.search_results || [];
      
      // Find matching search result to preserve full data
      const matchingResult = searchResults.find(result => 
        (result.name && result.name.toLowerCase().includes(part.part.toLowerCase())) ||
        (result.description && result.description.toLowerCase().includes(part.part.toLowerCase()))
      );
      
      if (matchingResult) {
        searchResultData = {
          supplier: matchingResult.supplier || '',
          location: matchingResult.location || '',
          availability: matchingResult.availability || '',
          part_number: matchingResult.part_number || '',
          brand: matchingResult.brand || '',
          condition: matchingResult.condition || '',
          warranty: matchingResult.warranty || '',
          search_metadata: {
            search_engine: matchingResult.search_engine || '',
            result_rank: matchingResult.result_rank || 0,
            confidence_score: matchingResult.confidence_score || 0,
            matched_keywords: matchingResult.matched_keywords || []
          }
        };
      }
      
      // === PHASE 4: Apply part info update to ensure description integrity ===
      // Preserve user-entered description from form, don't let search result overwrite it
      const userDescription = part.description || part.desc || '';
      const updatedPart = updatePartInfo({
        ...part,
        ...searchResultData,
        // CRITICAL FIX: Always preserve the user-entered description from form
        description: userDescription,
        desc: userDescription,
        addedAt: new Date().toISOString(),
        fromWizard: true,
        fromSearch: !!matchingResult
      });
      
      validParts.push(updatedPart);
    }
  });
  
  if (invalidParts.length > 0) {
    alert(`× ××¦××• ${invalidParts.length} ×—×œ×§×™× ×œ× ×ª×§×™× ×™×:\n` + 
          invalidParts.map(item => `${item.part.part || '×œ× ××•×’×“×¨'}: ${item.error}`).join('\n'));
    return;
  }

  console.log('ğŸ’¾ Saving parts data to helper...');
  console.log('ğŸ“Š DEBUG: validParts array:', validParts);
  console.log('ğŸ“Š DEBUG: validParts length:', validParts.length);
  
  // Send data to parent wizard if in iframe
  if (window.parent !== window) {
    const partsData = {
      type: 'moduleData',
      module: 'parts',
      data: {
        parts: validParts
      }
    };
    window.parent.postMessage(partsData, '*');
    console.log('ğŸ“¤ Parts data sent to parent wizard:', partsData);
  }
  
  try {
    // Get current helper data
    let helper = {};
    try {
      helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
    } catch (e) {
      console.warn('Failed to parse helper from sessionStorage, using empty object');
      helper = {};
    }
    
    // âœ… DUAL-PURPOSE SUPPORT: Handle both damage-center-integrated and standalone modes
    // âœ… FIX: Use the actual damage center being edited, not the "active" one for new centers
    const activeCenterId = sessionStorage.getItem('active_damage_center_id') ||
                          helper.damage_assessment?.current_center_id || 
                          helper.damage_centers?.current_center_id;
    
    console.log('ğŸ” SAVE DEBUG - Center IDs:', {
      'sessionStorage active_damage_center_id': sessionStorage.getItem('active_damage_center_id'),
      'helper.damage_assessment?.current_center_id': helper.damage_assessment?.current_center_id,
      'helper.damage_centers?.current_center_id': helper.damage_centers?.current_center_id,
      'final activeCenterId': activeCenterId
    });
    
    const isStandaloneMode = !activeCenterId;
    
    if (isStandaloneMode) {
      console.log('ğŸ” Standalone parts search mode - saving to parts_search only');
    } else {
      console.log('ğŸ¢ Damage center mode - saving to both damage center and parts_search');
    }
    
    // âœ… DAMAGE CENTER MODE: Save to specific damage center if in damage center mode
    if (!isStandaloneMode) {
      console.log('âœ… Active damage center detected:', activeCenterId);
      console.log('ğŸ’¾ Saving parts data to active damage center and parts_search');
      
      // Save parts data to specific damage center, not global assessment
      helper.damage_assessment = helper.damage_assessment || {};
      helper.damage_assessment.centers = helper.damage_assessment.centers || [];
      
      // Find the active center
      let activeCenter = helper.damage_assessment.centers.find(center => 
        center.id === activeCenterId || center.current_center_id === activeCenterId
      );
      
      if (!activeCenter) {
        console.log('âŒ Active center not found in centers array, switching to standalone mode');
        // Don't return - just treat as standalone mode
      } else {
        // Save parts items directly to the active damage center
        activeCenter.parts_items = activeCenter.parts_items || [];
        
        // Replace all parts items in this center with current data
        activeCenter.parts_items = validParts.map(part => ({
          ...part,
          center_id: activeCenterId,
          updated_at: new Date().toISOString(),
          source: 'parts_required_module'
        }));
        
        activeCenter.parts_updated_at = new Date().toISOString();
        
        console.log(`âœ… Saved ${validParts.length} parts items to damage center ${activeCenterId}`);
      }
    }
    
    // DO NOT save to global damage_assessment - this prevents orphaned data
    
    // âœ… DUAL-PURPOSE PARTS_SEARCH REGISTRATION: Works for both modes
    // Structure migration now handled in helper.js initialization
    helper.parts_search = helper.parts_search || {};
    helper.parts_search.selected_parts = helper.parts_search.selected_parts || [];
    
    // Get context for categorization
    const damageCenterMode = sessionStorage.getItem('damage_center_mode');
    
    // âœ… ENHANCED: Get damage center details from multiple sources
    let damageCenterNumber = 'unknown';
    let damageCenterName = 'unknown';
    let damageCenterLocation = '';
    
    if (!isStandaloneMode && activeCenterId) {
      // First try to find in helper.centers (most reliable)
      const centerInHelper = helper.centers?.find(center => 
        center.id === activeCenterId || center.Id === activeCenterId
      );
      
      if (centerInHelper) {
        damageCenterNumber = centerInHelper["Damage center Number"] || centerInHelper.number || 'unknown';
        damageCenterName = `××•×§×“ × ×–×§ ${damageCenterNumber}`;
        damageCenterLocation = centerInHelper.Location || centerInHelper.location || '';
        console.log('ğŸ” Found center in helper.centers:', { damageCenterNumber, damageCenterName, damageCenterLocation });
      } else {
        // Fallback to current_damage_center
        damageCenterNumber = helper.current_damage_center?.["Damage center Number"] || 
                            helper.current_damage_center?.number || 'unknown';
        damageCenterName = `××•×§×“ × ×–×§ ${damageCenterNumber}`;
        damageCenterLocation = helper.current_damage_center?.Location || 
                              helper.current_damage_center?.location || '';
        console.log('ğŸ” Using current_damage_center fallback:', { damageCenterNumber, damageCenterName, damageCenterLocation });
      }
    }
    
    // === PHASE 2: Add unique key for deduplication ===
    // Add new parts to the accumulated array with appropriate context
    const newPartsWithContext = validParts.map((part, index) => {
      // === PHASE 4: Ensure description integrity for each part ===
      const updatedPart = updatePartInfo(part);
      
      return {
        ...updatedPart,
        // === PHASE 2: Create unique key for each part ===
        unique_key: `${activeCenterId || 'standalone'}_${updatedPart.part || updatedPart.name}_${index}_${Date.now()}`,
        selected_at: new Date().toISOString(),
        selected_in_module: 'parts_required',
        // âœ… ENHANCED DAMAGE CENTER CLASSIFICATION: Complete center information
        damage_center_id: isStandaloneMode ? null : activeCenterId,
        damage_center_number: isStandaloneMode ? null : damageCenterNumber,
        damage_center_name: isStandaloneMode ? null : damageCenterName,
        damage_center_location: isStandaloneMode ? null : damageCenterLocation,
        assigned_to_center: !isStandaloneMode,
        selection_mode: isStandaloneMode ? 'standalone_search' : (damageCenterMode || 'damage_center_integrated'),
        usage_context: isStandaloneMode ? 'general_query' : 'damage_center_assignment',
        // âœ… NEW: Distinguish between manual entry and suggestion selection
        entry_type: part.fromSuggestion ? 'suggestion_selected' : 'manual_entry',
        manual_entry: !part.fromSuggestion,
        case_context: {
          plate: helper.vehicle?.plate || '',
          case_id: helper.case_info?.case_id || '',
          step: isStandaloneMode ? null : 5,
          wizard_session: new Date().toISOString()
        }
      };
    });
    
    // âœ… SMART ACCUMULATION: Remove existing parts for current damage center, then add new ones
    // This prevents overwrite of other damage centers while avoiding duplication in current center
    
    // === PHASE 0: DIAGNOSTIC - Log before accumulation ===
    console.log('=== BEFORE ACCUMULATION ===');
    console.log('Is standalone mode:', isStandaloneMode);
    console.log('Active center ID:', activeCenterId);
    console.log('Current selected_parts length:', helper.parts_search.selected_parts.length);
    console.log('New parts to add:', newPartsWithContext.length);
    
    // Show breakdown by damage center
    if (helper.parts_search.selected_parts.length > 0) {
      const centerBreakdown = {};
      helper.parts_search.selected_parts.forEach(p => {
        const centerId = p.damage_center_id || 'no_center';
        centerBreakdown[centerId] = (centerBreakdown[centerId] || 0) + 1;
      });
      console.log('ğŸ“Š Current parts breakdown by center:', centerBreakdown);
    }
    
    if (!isStandaloneMode && activeCenterId) {
      // === PHASE 2: Implement update vs create logic ===
      // Keep parts from other damage centers
      const partsFromOtherCenters = helper.parts_search.selected_parts.filter(existingPart => 
        existingPart.damage_center_id !== activeCenterId
      );
      
      console.log(`ğŸ“Š Keeping ${partsFromOtherCenters.length} parts from other damage centers`);
      
      // For current center, update existing parts or add new ones
      const updatedPartsForCurrentCenter = [];
      const existingPartsMap = new Map();
      
      // Create a map of existing parts for current center by part name/number
      helper.parts_search.selected_parts
        .filter(p => p.damage_center_id === activeCenterId)
        .forEach(p => {
          const partKey = p.name || p.partNumber || p.part || '';
          existingPartsMap.set(partKey, p);
        });
      
      console.log(`ğŸ“‹ Found ${existingPartsMap.size} existing parts for center ${activeCenterId}`);
      
      // Process each new part
      newPartsWithContext.forEach(newPart => {
        const newPartKey = newPart.name || newPart.partNumber || newPart.part || '';
        const existingPart = existingPartsMap.get(newPartKey);
        
        if (existingPart) {
          // UPDATE existing part (merge properties)
          const updatedPart = {
            ...existingPart,
            ...newPart,
            unique_key: existingPart.unique_key || newPart.unique_key, // Preserve original key
            updated_at: new Date().toISOString()
          };
          updatedPartsForCurrentCenter.push(updatedPart);
          console.log(`ğŸ”„ Updated existing part: ${newPartKey}`);
        } else {
          // CREATE new part
          updatedPartsForCurrentCenter.push(newPart);
          console.log(`â• Added new part: ${newPartKey}`);
        }
      });
      
      // Combine parts from other centers with updated/new parts for current center
      helper.parts_search.selected_parts = [
        ...partsFromOtherCenters,
        ...updatedPartsForCurrentCenter
      ];
      
      console.log(`ğŸ§¹ Final result: ${helper.parts_search.selected_parts.length} total parts`);
      
      // === PHASE 0: DIAGNOSTIC - Log after accumulation ===
      console.log('=== AFTER ACCUMULATION (damage center mode) ===');
      console.log('Final selected_parts length:', helper.parts_search.selected_parts.length);
      console.log('Parts for current center:', helper.parts_search.selected_parts.filter(p => p.damage_center_id === activeCenterId).length);
      
      // Show final breakdown by damage center
      const finalCenterBreakdown = {};
      helper.parts_search.selected_parts.forEach(p => {
        const centerId = p.damage_center_id || 'no_center';
        finalCenterBreakdown[centerId] = (finalCenterBreakdown[centerId] || 0) + 1;
      });
      console.log('ğŸ“Š FINAL parts breakdown by center:', finalCenterBreakdown);
    } else {
      // Standalone mode: just accumulate (no damage center conflicts)
      helper.parts_search.selected_parts = [
        ...helper.parts_search.selected_parts,
        ...newPartsWithContext
      ];
      
      // === PHASE 0: DIAGNOSTIC - Log after accumulation ===
      console.log('=== AFTER ACCUMULATION (standalone mode) ===');
      console.log('Final selected_parts length:', helper.parts_search.selected_parts.length);
    }
    
    // âœ… DAMAGE CENTER CLASSIFICATION: Update classification metadata
    if (!isStandaloneMode && activeCenterId) {
      // Update damage center summary in parts_search
      helper.parts_search.damage_centers_summary = helper.parts_search.damage_centers_summary || {};
      
      // Calculate totals for current damage center
      const currentCenterParts = helper.parts_search.selected_parts.filter(part => 
        part.damage_center_id === activeCenterId
      );
      
      const currentCenterTotal = currentCenterParts.reduce((sum, part) => {
        const price = parseFloat(part.price) || 0;
        const quantity = parseInt(part.quantity) || 1;
        return sum + (price * quantity);
      }, 0);
      
      // Update damage center classification with enhanced information
      helper.parts_search.damage_centers_summary[activeCenterId] = {
        damage_center_id: activeCenterId,
        damage_center_number: damageCenterNumber,
        damage_center_name: damageCenterName,
        damage_center_location: damageCenterLocation,
        parts_count: currentCenterParts.length,
        total_cost: currentCenterTotal,
        parts_list: currentCenterParts.map(part => ({
          name: part.name || part.part,
          description: part.desc || part.description,
          quantity: part.quantity,
          price: part.price,
          source: part.source,
          entry_type: part.entry_type,
          selected_at: part.selected_at
        })),
        last_updated: new Date().toISOString(),
        summary: `${damageCenterName} (${damageCenterLocation}): ${currentCenterParts.length} ×—×œ×§×™×, â‚ª${currentCenterTotal.toFixed(2)}`
      };
      
      console.log(`ğŸ“Š Updated classification for damage center ${damageCenterNumber}: ${currentCenterParts.length} parts, â‚ª${currentCenterTotal.toFixed(2)} total`);
    }
    
    // âœ… COMPREHENSIVE DATA CAPTURE: Will be called after accumulation is complete
    
    console.log(`âœ… DUAL-PURPOSE: Registered ${validParts.length} parts in parts_search.selected_parts`);
    console.log(`ğŸ“Š Mode: ${isStandaloneMode ? 'Standalone Search' : 'Damage Center Integrated'}`);
    console.log(`ğŸ“Š Total parts_search.selected_parts count: ${helper.parts_search.selected_parts.length}`);
    
    // Update meta information
    helper.meta = helper.meta || {};
    helper.meta.last_updated = new Date().toISOString();
    
    // === PHASE 5: Apply bidirectional sync before saving ===
    syncPartsBetweenModules();
    
    // Save to session storage
    sessionStorage.setItem('helper', JSON.stringify(helper));
    
    // === PHASE 2: Remove duplicates before final save ===
    removeDuplicateParts(helper, activeCenterId);
    
    // === PHASE 6: Final count update after all processing ===
    updatePartCount();
    
    // === PHASE 6: Update comprehensive data and case_summary AFTER accumulation ===
    updatePartsSearchComprehensiveData(helper, validParts, isStandaloneMode, activeCenterId);
    updateCaseSummary();
    
    
    // Show save confirmation (safely check if button exists)
    const saveBtn = document.querySelector('.save-btn') || document.getElementById('saveBtn') || document.querySelector('button[onclick*="save"]');
    if (saveBtn) {
      const originalText = saveBtn.textContent;
      saveBtn.textContent = 'âœ… × ×©××¨';
      saveBtn.style.background = '#155724';
      
      setTimeout(() => {
        saveBtn.textContent = originalText;
        saveBtn.style.background = '#28a745';
      }, 2000);
    } else {
      console.log('âœ… Parts data saved successfully (no save button found for visual feedback)');
    }
    
    // Trigger helper update broadcast if available
    if (typeof window.broadcastHelperUpdate === 'function') {
      window.broadcastHelperUpdate(['damage_assessment'], 'parts_required_module');
    }
    
  } catch (error) {
    console.error('âŒ Failed to save parts data to helper:', error);
    alert('×©×’×™××” ×‘×©××™×¨×ª ×”× ×ª×•× ×™×');
  }
}

    document.getElementById("partsForm").addEventListener("submit", function(e) {
      e.preventDefault();
      
      // âœ… FIX: Call the main savePartsData() function instead of duplicating code
      console.log('ğŸ“ Form submitted, calling savePartsData()...');
      savePartsData();
    });

    // âœ… Helper function to get car details from helper or form
    function getCarDetails() {
      const urlParams = new URLSearchParams(window.location.search);
      const isStandalone = urlParams.get('standalone') === '1';
      
      if (isStandalone) {
        return {
          plate: document.getElementById("inputPlate")?.value?.trim() || "",
          manufacturer: document.getElementById("inputManufacturer")?.value?.trim() || "",
          model: document.getElementById("inputModel")?.value?.trim() || "",
          year: document.getElementById("inputYear")?.value?.trim() || ""
        };
      } else {
        // Get from helper data
        try {
          const helperData = JSON.parse(sessionStorage.getItem("helper") || '{}');
          return {
            plate: helperData.meta?.plate || helperData.vehicle?.plate_number || helperData.car_details?.plate || "",
            manufacturer: helperData.vehicle?.manufacturer || helperData.car_details?.manufacturer || "",
            model: helperData.vehicle?.model || helperData.car_details?.model || "",
            year: helperData.vehicle?.year || helperData.car_details?.year || ""
          };
        } catch(e) {
          console.error('Error reading helper data:', e);
          return { plate: "", manufacturer: "", model: "", year: "" };
        }
      }
    }

    // --- Suggestion logic with dropdown ---
    function suggestPart(input) {
      const row = input.closest('.row');
      const nameInput = row.querySelector('.name');
      const descInput = row.querySelector('.desc');
      const priceInput = row.querySelector('.price');
      const sourceSelect = row.querySelector('.source');
      const dropdown = row.querySelector('.suggest-dropdown');

      // Use the value of the input that triggered the event
      const query = input.value.trim();
      const { plate, manufacturer, model, year } = getCarDetails();

      if (!query || query.length < 2) {
        dropdown.style.display = "none";
        return;
      }

      // Get suggestions from multiple sources
      const suggestions = [];
      
      // âœ… FIXED: Search ONLY in helper parts_search results (from parts search module)
      const searchResults = [];
      
      // âœ… ENHANCED: Multi-source search integration with cross-damage-center suggestions
      
      // 1. Get search results from helper.parts_search (populated by parts search module)
      if (window.helper?.parts_search?.all_results) {
        searchResults.push(...window.helper.parts_search.all_results);
        console.log(`ğŸ” Using ${window.helper.parts_search.all_results.length} parts from comprehensive search history`);
      }
      
      // 2. Also check results array (legacy support)
      if (window.helper?.parts_search?.results) {
        searchResults.push(...window.helper.parts_search.results);
        console.log(`ğŸ” Using ${window.helper.parts_search.results.length} parts from current search results`);
      }
      
      // 3. Include wizard search results (temporary session data from wizard)
      if (window.wizardSearchResults && window.wizardSearchResults.length > 0) {
        searchResults.push(...window.wizardSearchResults);
        console.log(`ğŸ” Using ${window.wizardSearchResults.length} parts from wizard session`);
      }
      
      // 4. âœ… NEW: Cross-damage-center suggestions (parts from other centers in this case)
      if (window.helper?.parts_search?.selected_parts) {
        const currentCenterId = sessionStorage.getItem('active_damage_center_id') || 
                               window.helper.current_damage_center?.Id;
        
        // Filter parts from other damage centers to suggest as cross-references
        const otherCenterParts = window.helper.parts_search.selected_parts.filter(part => 
          part.damage_center_id && part.damage_center_id !== currentCenterId
        );
        
        if (otherCenterParts.length > 0) {
          searchResults.push(...otherCenterParts.map(part => ({
            ...part,
            crossReference: true,
            source_damage_center: part.damage_center_number || '××•×§×“ ××—×¨',
            suggestion_type: 'cross_reference'
          })));
          console.log(`ğŸ”— Including ${otherCenterParts.length} cross-reference parts from other damage centers`);
        }
      }
      
      // 5. âœ… NEW: Include global parts bank for broader suggestions
      if (window.PARTS_BANK && query.length >= 2) {
        Object.keys(window.PARTS_BANK).forEach(category => {
          if (window.PARTS_BANK[category] && Array.isArray(window.PARTS_BANK[category])) {
            window.PARTS_BANK[category].forEach(partName => {
              if (partName.toLowerCase().includes(query.toLowerCase())) {
                searchResults.push({
                  name: partName,
                  desc: category,
                  source: '×‘× ×§ ×—×œ×§×™× ×’×œ×•×‘×œ×™',
                  category: category,
                  fromPartsBank: true,
                  suggestion_type: 'parts_bank'
                });
              }
            });
          }
        });
      }
      
      console.log(`ğŸ“‹ Total search results available for suggestions: ${searchResults.length}`);
      
      // Process search results (handle both flat and nested structures)
      searchResults.forEach(item => {
        // Handle nested structure (webhook groups with search_results)
        if (item.search_results && Array.isArray(item.search_results)) {
          item.search_results.forEach(part => {
            const partName = part.×ª×™××•×¨ || part.description || part.name || '';
            const partDesc = part.×ª×™××•×¨ || part.description || part.name || '';
            
            if (partName.toLowerCase().includes(query.toLowerCase()) ||
                partDesc.toLowerCase().includes(query.toLowerCase())) {
              suggestions.push({ 
                name: partName,
                desc: partDesc,
                source: part['×¡×•×’ ×—×œ×§'] || part.type || '×œ× ×¦×•×™×Ÿ',
                price: (part.××—×™×¨ || part.price || '').toString().replace('â‚ª', '').trim(),
                supplier: part.×¡×¤×§ || part.supplier || '',
                location: part.××™×§×•× || part.location || '',
                availability: part.×–××™× ×•×ª || part.availability || '',
                searchResult: true, // Mark as from search results
                group: item.group || '×›×œ×œ×™'
              });
            }
          });
        }
        // Handle flat structure (legacy compatibility)
        else {
          const part = item;
          if ((part.name && part.name.toLowerCase().includes(query.toLowerCase())) ||
              (part.description && part.description.toLowerCase().includes(query.toLowerCase())) ||
              (part.desc && part.desc.toLowerCase().includes(query.toLowerCase()))) {
            suggestions.push({ 
              name: part.name || part.description || part.desc, 
              desc: part.description || part.desc || part.name, 
              source: part.condition || part.source || '×œ× ×¦×•×™×Ÿ',
              price: part.price || '',
              supplier: part.supplier || '',
              location: part.location || '',
              availability: part.availability || '',
              searchResult: true // Mark as from search results
            });
          }
        }
      });
      
      // Search in stored helper results
      // REMOVED: No localStorage fallback - helper only
      let storedHelper = {};
      try {
        storedHelper = JSON.parse(sessionStorage.getItem("helper") || '{}');
      } catch (e) {
        storedHelper = {};
      }
      const allResults = storedHelper?.parts_search?.results || [];
      
      allResults.forEach(result => {
        if ((result.name || '').toLowerCase().includes(query.toLowerCase()) ||
            (result.desc || '').toLowerCase().includes(query.toLowerCase())) {
          suggestions.push({
            name: result.name || result.desc,
            desc: result.desc || result.name,
            price: result.price,
            source: result.source
          });
        }
      });

      if (suggestions.length === 0) {
        dropdown.innerHTML = '';
        dropdown.style.display = "none";
        return;
      }

      // Remove duplicates and limit to 10 results
      const uniqueSuggestions = suggestions.filter((suggestion, index, self) => 
        index === self.findIndex(s => s.name === suggestion.name)
      ).slice(0, 10);

      dropdown.innerHTML = '<option value="">×‘×—×¨ ×”×¦×¢×”...</option>' +
        uniqueSuggestions.map((s, i) => `
          <option value="${i}">${s.name}${s.category ? ` (${s.category})` : ''}${s.price ? ` - â‚ª${s.price}` : ''}</option>
        `).join('');
      dropdown.style.display = "";
      dropdown._suggestions = uniqueSuggestions;

      // âœ… ENHANCED: Comprehensive autofill functionality
      dropdown.onchange = function () {
        const idx = this.value;
        if (!this._suggestions || !this._suggestions[idx]) return;
        const suggestion = this._suggestions[idx];
        
        // Core fields autofill
        nameInput.value = suggestion.name || "";
        descInput.value = suggestion.desc || suggestion.description || "";
        
        // Enhanced autofill for all available fields
        if (suggestion.price) {
          priceInput.value = suggestion.price;
        }
        
        if (suggestion.source || suggestion.condition) {
          const sourceValue = suggestion.source || suggestion.condition;
          // Try to match source value with dropdown options
          const sourceOptions = Array.from(sourceSelect.options);
          const matchingOption = sourceOptions.find(opt => 
            opt.value.toLowerCase() === sourceValue.toLowerCase() ||
            opt.textContent.toLowerCase().includes(sourceValue.toLowerCase())
          );
          if (matchingOption) {
            sourceSelect.value = matchingOption.value;
          } else if (sourceValue) {
            // If no exact match, try common mappings
            const sourceMap = {
              'new': '×—×“×©',
              'used': '××©×•××©', 
              'oem': '××§×•×¨×™',
              'aftermarket': '×ª×—×œ×™×¤×™',
              'refurbished': '××—×•×“×©'
            };
            const hebrewSource = sourceMap[sourceValue.toLowerCase()] || sourceValue;
            const hebrewMatch = sourceOptions.find(opt => opt.textContent.includes(hebrewSource));
            if (hebrewMatch) {
              sourceSelect.value = hebrewMatch.value;
            }
          }
        }
        
        // Set quantity if available
        if (suggestion.quantity || suggestion.qty) {
          quantityInput.value = suggestion.quantity || suggestion.qty;
        }
        
        dropdown.style.display = "none";
        
        // Visual feedback for successful autofill
        [nameInput, descInput, priceInput, sourceSelect].forEach(field => {
          if (field.value) {
            field.style.backgroundColor = '#e8f5e8'; // Light green background
            setTimeout(() => {
              field.style.backgroundColor = '';
            }, 1500);
          }
        });
        
        // Trigger change events for potential additional processing
        [nameInput, descInput, priceInput, sourceSelect, quantityInput].forEach(field => {
          field.dispatchEvent(new Event('change', { bubbles: true }));
        });
        
        // âœ… NEW: Mark as suggestion-selected for proper categorization
        nameInput.dataset.fromSuggestion = 'true';
        descInput.dataset.fromSuggestion = 'true';
        priceInput.dataset.fromSuggestion = 'true';
        sourceSelect.dataset.fromSuggestion = 'true';
        
        console.log(`âœ… ENHANCED AUTOFILL: ${suggestion.name} with comprehensive field population (marked as suggestion-selected)`);
      };
    }
    // Calculate and display totals
    function calculatePartsTotals() {
      const parts = [];
      
      // âœ… FIXED: Use correct selector for rows
      document.querySelectorAll("#partsList .row").forEach(row => {
        const nameInput = row.querySelector('.name');
        const descInput = row.querySelector('.desc');
        const codeInput = row.querySelector('.code');
        const quantityInput = row.querySelector('.quantity');
        const priceInput = row.querySelector('.price');
        const sourceSelect = row.querySelector('.source');
        
        const name = nameInput ? nameInput.value.trim() : '';
        const desc = descInput ? descInput.value.trim() : '';
        const code = codeInput ? codeInput.value.trim() : '';
        const quantity = quantityInput ? parseInt(quantityInput.value) || 1 : 1;
        const price = priceInput ? parseFloat(priceInput.value) || 0 : 0;
        const source = sourceSelect ? sourceSelect.value : '';
        
        if (name || desc) {
          // âœ… ENHANCED: Track suggestion vs manual entry and format according to webhook response structure
          const fromSuggestion = nameInput?.dataset.fromSuggestion === 'true' || 
                                 descInput?.dataset.fromSuggestion === 'true';
          
          parts.push({ 
            "name": name,
            "×ª×™××•×¨": desc,
            "×›××•×ª": quantity,
            "××—×™×¨": `â‚ª${price}`,
            "×¡×•×’ ×—×œ×§": source,
            "×¡×¤×§": "", // To be filled from search results
            "fromSuggestion": fromSuggestion,
            "entry_method": fromSuggestion ? "suggestion_selected" : "manual_typed",
            "××™×§×•×": "×™×©×¨××œ", // Default
            "×–××™× ×•×ª": "×–××™×Ÿ", // Default
            "××¡×¤×¨ OEM": "", // To be filled if available
            "×”×¢×¨×•×ª": "",
            // Additional fields for helper compatibility
            "price": price, // Numeric for calculations
            "quantity": quantity,
            "source": source,
            "code": code // Add code field for parts search compatibility
          });
        }
      });
      
      const total = parts.reduce((sum, part) => sum + part.price, 0);
      
      // Display total in the page
      let totalDisplay = document.getElementById('partsTotal');
      if (!totalDisplay) {
        totalDisplay = document.createElement('div');
        totalDisplay.id = 'partsTotal';
        totalDisplay.style.cssText = 'background: #e8f5e8; padding: 15px; margin: 20px 0; border-radius: 8px; font-weight: bold; text-align: center; border: 2px solid #4caf50;';
        document.querySelector('.container').insertBefore(totalDisplay, document.querySelector('.footer'));
      }
      
      totalDisplay.innerHTML = `
        <div style="font-size: 18px; color: #2e7d32; margin-bottom: 5px;">×¡×™×›×•× ×—×œ×¤×™×</div>
        <div style="font-size: 24px; color: #1b5e20;">â‚ª${total.toLocaleString()}</div>
        <div style="font-size: 14px; color: #424242;">×›×•×œ×œ ××¢"×: â‚ª${(total * 1.17).toLocaleString()}</div>
      `;
      
      return { parts, total };
    }
    
    // âœ… NEW: Send parts selection updates to wizard
    function sendPartsUpdateToWizard() {
      if (window.parent && window.parent.postMessage && window.parent !== window) {
        try {
          const partsData = calculatePartsTotals();
          
          // Separate selected and unselected parts
          const allSearchResults = [];
          
          // Get all search results from helper - check new structure
          if (globalHelper.parts_search && globalHelper.parts_search.results) {
            // Handle new webhook structure with nested search_results
            globalHelper.parts_search.results.forEach(group => {
              if (group.search_results && Array.isArray(group.search_results)) {
                group.search_results.forEach(result => {
                  // âœ… Ensure consistent structure for all parts
                  allSearchResults.push({
                    "name": group.name || '',
                    "×ª×™××•×¨": result["×ª×™××•×¨"] || '',
                    "×›××•×ª": 1,
                    "××—×™×¨": result["××—×™×¨"] || '',
                    "×¡×•×’ ×—×œ×§": result["×¡×•×’ ×—×œ×§"] || '',
                    "×¡×¤×§": result["×¡×¤×§"] || '',
                    "××™×§×•×": result["××™×§×•×"] || '×™×©×¨××œ',
                    "×–××™× ×•×ª": result["×–××™× ×•×ª"] || '',
                    "××¡×¤×¨ OEM": result["××¡×¤×¨ OEM"] || '',
                    "×”×¢×¨×•×ª": result["×”×¢×¨×•×ª"] || '',
                    // Additional fields for calculations
                    "price": parseFloat(result["××—×™×¨"]?.replace(/[^0-9.-]/g, '')) || 0,
                    "quantity": 1,
                    "source": result["×¡×•×’ ×—×œ×§"] || ''
                  });
                });
              }
            });
          }
          
          // Identify unselected parts (from search results that weren't selected)
          const selectedPartNames = partsData.parts.map(p => p.name.toLowerCase());
          const unselectedParts = allSearchResults.filter(result => 
            !selectedPartNames.includes((result.name || '').toLowerCase())
          );
          
          // Send update to wizard
          window.parent.postMessage({
            type: 'partsSelectionUpdate',
            selectedParts: partsData.parts,
            unselectedParts: unselectedParts,
            total: partsData.total,
            source: 'parts_required_iframe'
          }, '*');
          
          console.log(`ğŸ“¤ Sent parts update to wizard: ${partsData.parts.length} selected, ${unselectedParts.length} unselected`);
          
        } catch (error) {
          console.error('âŒ Failed to send parts update to wizard:', error);
        }
      }
    }
    
    // Auto-calculate when data changes and send updates to wizard
    document.addEventListener('change', function() {
      calculatePartsTotals();
      sendPartsUpdateToWizard();
    });
    document.addEventListener('input', function() {
      calculatePartsTotals();
      sendPartsUpdateToWizard();
    });
    
    // âœ… NEW: Helper function to add part from data (for pre-filling from wizard)
    function addPartFromData(partData) {
      const partsList = document.getElementById('partsList');
      const newRow = document.createElement('div');
      newRow.className = 'row';
      
      const rowIndex = partsList.children.length;
      newRow.setAttribute('data-row-index', rowIndex);
      
      newRow.innerHTML = `
        <div class="input-wrap">
          <input type="text" class="name" placeholder="×©× ×”×—×œ×§" oninput="suggestPart(this)" value="${partData.name || partData.part || ''}">
          <select class="suggest-dropdown" style="display:none;"></select>
        </div>
        <input type="text" class="desc" placeholder="×ª×™××•×¨" oninput="suggestPart(this)" value="${partData.description || partData.desc || ''}">
        <input type="text" class="code" placeholder="×§×•×“ ×—×œ×§" style="width: 80px; margin-left: 8px;" value="${partData.code || ''}">
        <input type="number" class="quantity" placeholder="×›××•×ª" value="${partData.quantity || partData.qty || 1}" min="1" style="width: 60px; margin-left: 8px;">
        <input type="text" class="price" placeholder="××—×™×¨" value="${partData.price || ''}">
        <select class="source">
          <option value="">××§×•×¨</option>
          <option value="×—×œ×™×¤×™/××§×•×¨×™" ${partData.source === '×—×œ×™×¤×™/××§×•×¨×™' ? 'selected' : ''}>×—×œ×™×¤×™/××§×•×¨×™</option>
          <option value="×—×œ×™×¤×™/××©×•××©" ${partData.source === '×—×œ×™×¤×™/××©×•××©' ? 'selected' : ''}>×—×œ×™×¤×™/××©×•××©</option>
          <option value="×—×“×© ××§×•×¨×™" ${partData.source === '×—×“×© ××§×•×¨×™' ? 'selected' : ''}>×—×“×© ××§×•×¨×™</option>
          <option value="×—×œ×™×¤×™" ${partData.source === '×—×œ×™×¤×™' ? 'selected' : ''}>×—×œ×™×¤×™</option>
          <option value="××©×•××©" ${partData.source === '××©×•××©' ? 'selected' : ''}>××©×•××©</option>
          <option value="×¨×™×§" ${partData.source === '×¨×™×§' ? 'selected' : ''}>×¨×™×§</option>
        </select>
        <div class="row-actions" style="display: flex; gap: 5px; margin-right: 8px;">
          <button type="button" class="btn-edit" onclick="editPartRow(${rowIndex})" title="×¢×¨×•×š ×—×œ×§" style="
            background: #f59e0b; color: white; border: none; padding: 6px 10px; 
            border-radius: 5px; cursor: pointer; font-size: 12px; font-weight: bold;
          ">âœï¸</button>
          <button type="button" class="btn-delete" onclick="deletePartRow(${rowIndex})" title="××—×§ ×—×œ×§" style="
            background: #dc3545; color: white; border: none; padding: 6px 10px; 
            border-radius: 5px; cursor: pointer; font-size: 12px; font-weight: bold;
          ">ğŸ—‘ï¸</button>
        </div>
      `;
      
      partsList.appendChild(newRow);
    }
    
    // âœ… NEW: Edit/Delete functionality for individual parts
    let editingRowIndex = -1;
    
    function editPartRow(rowIndex) {
      const rows = document.querySelectorAll('#partsList .row');
      const row = rows[rowIndex];
      
      if (!row) {
        console.error('Row not found:', rowIndex);
        return;
      }
      
      if (editingRowIndex === rowIndex) {
        // Already editing this row, finish editing
        finishEditingRow(rowIndex);
        return;
      }
      
      // If editing another row, finish that first
      if (editingRowIndex >= 0) {
        finishEditingRow(editingRowIndex);
      }
      
      // Start editing this row
      editingRowIndex = rowIndex;
      const editBtn = row.querySelector('.btn-edit');
      editBtn.textContent = 'ğŸ’¾';
      editBtn.title = '×©××•×¨ ×©×™× ×•×™×™×';
      editBtn.style.background = '#10b981';
      
      // Make fields more prominent for editing
      row.style.background = '#fffbeb';
      row.style.borderColor = '#f59e0b';
      row.style.borderWidth = '2px';
      
      console.log(`ğŸ“ Started editing row ${rowIndex}`);
    }
    
    function finishEditingRow(rowIndex) {
      const rows = document.querySelectorAll('#partsList .row');
      const row = rows[rowIndex];
      
      if (!row) return;
      
      const editBtn = row.querySelector('.btn-edit');
      editBtn.textContent = 'âœï¸';
      editBtn.title = '×¢×¨×•×š ×—×œ×§';
      editBtn.style.background = '#f59e0b';
      
      // Reset row styling
      row.style.background = '#f8fafc';
      row.style.borderColor = '#e5e7eb';
      row.style.borderWidth = '1px';
      
      editingRowIndex = -1;
      console.log(`ğŸ’¾ Finished editing row ${rowIndex}`);
    }
    
    function deletePartRow(rowIndex) {
      const rows = document.querySelectorAll('#partsList .row');
      const row = rows[rowIndex];
      
      if (!row) {
        console.error('Row not found:', rowIndex);
        return;
      }
      
      // Get part info for confirmation
      const name = row.querySelector('.name').value.trim();
      const desc = row.querySelector('.desc').value.trim();
      const partInfo = name || desc || '×—×œ×§ ×œ×œ× ×©×';
      
      const confirmDelete = confirm(`×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª ×”×—×œ×§?\n\n${partInfo}`);
      
      if (!confirmDelete) {
        console.log('ğŸš« Delete cancelled by user');
        return;
      }
      
      console.log('ğŸ—‘ï¸ Starting delete process...');
      // === PHASE 0: DIAGNOSTIC - Log delete operation ===
      console.log('=== DELETE OPERATION DIAGNOSTIC ===');
      console.log('Part to delete:', { name, desc, rowIndex });
      console.log('Active damage center ID sources:');
      
      // âœ… COMPREHENSIVE DELETE: Remove from ALL 3 required locations
      try {
          let helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          
          console.log('- helper.damage_assessment?.current_center_id:', helper.damage_assessment?.current_center_id);
          console.log('- helper.damage_centers?.current_center_id:', helper.damage_centers?.current_center_id);
          console.log('- sessionStorage active_damage_center_id:', sessionStorage.getItem('active_damage_center_id'));
          console.log('Helper structure before delete:', {
            'helper.centers': helper.centers,
            'helper.current_damage_center': helper.current_damage_center,
            'parts_search.selected_parts': helper.parts_search?.selected_parts
          });
          
          const activeCenterId = helper.damage_assessment?.current_center_id || 
                                helper.damage_centers?.current_center_id ||
                                sessionStorage.getItem('active_damage_center_id');
          
          console.log(`ğŸ—‘ï¸ DELETE SYNC: Starting comprehensive delete for "${name}"/"${desc}" from center ${activeCenterId}`);
          
          // 1. Remove from parts_search.selected_parts
          if (helper.parts_search && helper.parts_search.selected_parts) {
            const beforeCount = helper.parts_search.selected_parts.length;
            console.log(`ğŸ” DELETE DEBUG: Looking for parts with name="${name}" or desc="${desc}" in center="${activeCenterId}"`);
            
            helper.parts_search.selected_parts = helper.parts_search.selected_parts.filter(part => {
              const partName = part.name || part.part || '';
              const partDesc = part.desc || part.description || '';
              const partCenter = part.damage_center_id;
              
              // Match criteria: (name OR desc) AND same damage center
              const nameMatch = partName.toLowerCase().trim() === name.toLowerCase().trim();
              const descMatch = partDesc.toLowerCase().trim() === desc.toLowerCase().trim();
              const centerMatch = activeCenterId ? (partCenter === activeCenterId) : (!partCenter);
              
              // Keep parts that DON'T match - remove parts that DO match
              const shouldRemove = (nameMatch || descMatch) && centerMatch;
              
              // Debug each part
              console.log(`ğŸ” Part check: "${partName}" (center: ${partCenter}) - nameMatch: ${nameMatch}, descMatch: ${descMatch}, centerMatch: ${centerMatch}, shouldRemove: ${shouldRemove}`);
              
              return !shouldRemove;
            });
            const afterCount = helper.parts_search.selected_parts.length;
            console.log(`ğŸ—‘ï¸ 1/3 Removed ${beforeCount - afterCount} from parts_search.selected_parts`);
          }
          
          // 2. Remove from current_damage_center.Parts.parts_required
          if (activeCenterId) {
            // Find the damage center in helper.centers
            if (helper.centers && Array.isArray(helper.centers)) {
              const currentCenter = helper.centers.find(c => c.Id === activeCenterId || c.id === activeCenterId);
              if (currentCenter && currentCenter.Parts && currentCenter.Parts.parts_required) {
                const beforeCount = currentCenter.Parts.parts_required.length;
                currentCenter.Parts.parts_required = currentCenter.Parts.parts_required.filter(part => {
                  const partName = part.name || part.part || '';
                  const partDesc = part.desc || part.description || '';
                  
                  const nameMatch = partName.toLowerCase().trim() === name.toLowerCase().trim();
                  const descMatch = partDesc.toLowerCase().trim() === desc.toLowerCase().trim();
                  
                  // Keep parts that DON'T match
                  return !(nameMatch || descMatch);
                });
                const afterCount = currentCenter.Parts.parts_required.length;
                console.log(`ğŸ—‘ï¸ 2/3 Removed ${beforeCount - afterCount} from current_damage_center.Parts.parts_required`);
              }
            }
          }
          
          // 3. Remove from parts_search.damage_centers_summary[center_id].parts_list  
          if (activeCenterId && helper.parts_search && helper.parts_search.damage_centers_summary && helper.parts_search.damage_centers_summary[activeCenterId]) {
            const centerSummary = helper.parts_search.damage_centers_summary[activeCenterId];
            if (centerSummary.parts_list && Array.isArray(centerSummary.parts_list)) {
              const beforeCount = centerSummary.parts_list.length;
              centerSummary.parts_list = centerSummary.parts_list.filter(part => {
                const partName = part.name || part.part || '';
                const partDesc = part.desc || part.description || '';
                
                const nameMatch = partName.toLowerCase().trim() === name.toLowerCase().trim();
                const descMatch = partDesc.toLowerCase().trim() === desc.toLowerCase().trim();
                
                // Keep parts that DON'T match
                return !(nameMatch || descMatch);
              });
              const afterCount = centerSummary.parts_list.length;
              console.log(`ğŸ—‘ï¸ 3/3 Removed ${beforeCount - afterCount} from parts_search.damage_centers_summary[${activeCenterId}].parts_list`);
              
              // Update center summary totals
              centerSummary.parts_count = centerSummary.parts_list.length;
              centerSummary.total_cost = centerSummary.parts_list.reduce((sum, part) => {
                const price = parseFloat(part.price) || 0;
                const quantity = parseInt(part.quantity) || 1;
                return sum + (price * quantity);
              }, 0);
              centerSummary.last_updated = new Date().toISOString();
            }
          }
          
          // Save updated helper
          sessionStorage.setItem('helper', JSON.stringify(helper));
          // === DEBUG: Check if delete worked ===
          helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          console.log('ğŸ” VERIFICATION: After delete attempt:');
          console.log('- parts_search.selected_parts count:', helper.parts_search?.selected_parts?.length || 0);
          console.log('- current_damage_center parts count:', helper.current_damage_center?.parts?.length || 0);
          
          if (helper.parts_search?.selected_parts) {
            const matchingParts = helper.parts_search.selected_parts.filter(p => 
              (p.name === name || p.desc === desc || p.description === desc));
            console.log(`- Still found ${matchingParts.length} matching parts in selected_parts:`, matchingParts);
          }
          
          console.log(`âœ… Comprehensive delete completed - removed "${partInfo}" from all 3 locations`);
          
        } catch (error) {
          console.error('âŒ Failed to sync delete with helper data:', error);
        }
        
        // Remove from UI
        row.remove();
        
        // Update row indices for remaining rows
        updateRowIndices();
        
        // === PHASE 3: Update totals after delete ===
        updateTotalCost();
        updatePartCount();
        
        // === PHASE 6: Update case_summary after delete ===
        updateCaseSummary();
        
        // === PHASE 3: Notify wizard of changes ===
        if (typeof sendPartsUpdateToWizard === 'function') {
          sendPartsUpdateToWizard();
          console.log('ğŸ“¤ Sent update to wizard after delete');
        }
        
        console.log(`ğŸ—‘ï¸ Deleted row ${rowIndex}: ${partInfo}`);
        
        // Show notification if available
        if (typeof showNotification === 'function') {
          showNotification(`× ××—×§ ×—×œ×§: ${partInfo}`, 'success');
        }
    }
    
    function updateRowIndices() {
      const rows = document.querySelectorAll('#partsList .row');
      rows.forEach((row, index) => {
        row.setAttribute('data-row-index', index);
        
        // Update button onclick handlers
        const editBtn = row.querySelector('.btn-edit');
        const deleteBtn = row.querySelector('.btn-delete');
        
        if (editBtn) editBtn.onclick = () => editPartRow(index);
        if (deleteBtn) deleteBtn.onclick = () => deletePartRow(index);
      });
      
      // Reset editing state if we were editing a deleted row
      if (editingRowIndex >= rows.length) {
        editingRowIndex = -1;
      }
    }
    
    // === PHASE 3: Update total cost function ===
    function updateTotalCost() {
      console.log('ğŸ’° Updating total cost...');
      let totalCost = 0;
      
      // Calculate from UI rows
      const rows = document.querySelectorAll('#partsList .row');
      rows.forEach(row => {
        const priceInput = row.querySelector('.price');
        const quantityInput = row.querySelector('.quantity');
        
        if (priceInput && quantityInput) {
          const price = parseFloat(priceInput.value) || 0;
          const quantity = parseInt(quantityInput.value) || 1;
          totalCost += price * quantity;
        }
      });
      
      // Update total display - use the correct ID
      let totalDisplay = document.getElementById('partsTotal');
      
      if (totalDisplay) {
        totalDisplay.innerHTML = `
          <div style="font-size: 18px; color: #2e7d32; margin-bottom: 5px;">×¡×™×›×•× ×—×œ×¤×™× (${rows.length} ×¤×¨×™×˜×™×)</div>
          <div style="font-size: 24px; color: #1b5e20;">â‚ª${totalCost.toLocaleString()}</div>
          <div style="font-size: 14px; color: #424242;">×›×•×œ×œ ××¢"×: â‚ª${(totalCost * 1.17).toLocaleString()}</div>
        `;
        console.log(`âœ… Updated total cost: â‚ª${totalCost.toFixed(2)}`);
      } else {
        // Create total display if it doesn't exist
        totalDisplay = document.createElement('div');
        totalDisplay.id = 'partsTotal';
        totalDisplay.style.cssText = 'background: #e8f5e8; padding: 15px; margin: 20px 0; border-radius: 8px; font-weight: bold; text-align: center; border: 2px solid #4caf50;';
        
        const container = document.querySelector('.container');
        const footer = document.querySelector('.footer');
        if (container) {
          if (footer) {
            container.insertBefore(totalDisplay, footer);
          } else {
            container.appendChild(totalDisplay);
          }
          
          totalDisplay.innerHTML = `
            <div style="font-size: 18px; color: #2e7d32; margin-bottom: 5px;">×¡×™×›×•× ×—×œ×¤×™× (${rows.length} ×¤×¨×™×˜×™×)</div>
            <div style="font-size: 24px; color: #1b5e20;">â‚ª${totalCost.toLocaleString()}</div>
            <div style="font-size: 14px; color: #424242;">×›×•×œ×œ ××¢"×: â‚ª${(totalCost * 1.17).toLocaleString()}</div>
          `;
          console.log(`âœ… Created and updated total cost: â‚ª${totalCost.toFixed(2)}`);
        } else {
          console.log(`âš ï¸ Container not found, calculated: â‚ª${totalCost.toFixed(2)}`);
        }
      }
      
      // Also update in helper if in damage center mode
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        const activeCenterId = helper.damage_assessment?.current_center_id || 
                              helper.damage_centers?.current_center_id ||
                              sessionStorage.getItem('active_damage_center_id');
        
        if (activeCenterId && helper.parts_search?.damage_centers_summary?.[activeCenterId]) {
          helper.parts_search.damage_centers_summary[activeCenterId].total_cost = totalCost;
          helper.parts_search.damage_centers_summary[activeCenterId].last_updated = new Date().toISOString();
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
      } catch (error) {
        console.error('Failed to update total in helper:', error);
      }
    }
    
    // === PHASE 6: Fix part count function per task document ===
    function updatePartCount() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Get actual count from helper.parts_search.selected_parts (global truth)
        const actualCount = helper.parts_search?.selected_parts?.length || 0;
        console.log(`ğŸ“Š PHASE 6: Updating part count - actual count: ${actualCount}`);
        
        // Update UI element if it exists
        const countElement = document.querySelector('.parts-total-count');
        if (countElement) {
          countElement.textContent = actualCount;
          console.log(`âœ… Updated UI count display: ${actualCount}`);
        }
        
        // Also update UI row count for consistency
        const rows = document.querySelectorAll('#partsList .row');
        const uiRowCount = rows.length;
        console.log(`ğŸ“Š UI rows count: ${uiRowCount}, Helper count: ${actualCount}`);
        
        // Update in helper if in damage center mode
        const activeCenterId = helper.damage_assessment?.current_center_id || 
                              helper.damage_centers?.current_center_id ||
                              sessionStorage.getItem('active_damage_center_id');
        
        if (activeCenterId && helper.parts_search?.damage_centers_summary?.[activeCenterId]) {
          helper.parts_search.damage_centers_summary[activeCenterId].parts_count = actualCount;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          console.log(`âœ… Updated part count in damage center summary: ${actualCount}`);
        }
        
        return actualCount;
      } catch (error) {
        console.error('Failed to update part count:', error);
        return 0;
      }
    }
    
    // === PHASE 6: Dedicated function to update case_summary aggregation ===
    function updateCaseSummary() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        if (!helper.parts_search) {
          helper.parts_search = {};
        }
        
        const allSelectedParts = helper.parts_search.selected_parts || [];
        const allSearchResults = helper.parts_search.search_results || [];
        const unselectedParts = helper.parts_search.unselected_parts || [];
        
        // Calculate accurate total cost
        const totalCost = allSelectedParts.reduce((sum, part) => {
          const price = parseFloat(part.price) || 0;
          const quantity = parseInt(part.quantity) || 1;
          return sum + (price * quantity);
        }, 0);
        
        // Update case_summary with correct aggregation
        helper.parts_search.case_summary = {
          total_searches: helper.parts_search.case_summary?.total_searches || 0,
          total_results: allSearchResults.length,
          selected_count: allSelectedParts.length,
          unselected_count: unselectedParts.length,
          last_search: new Date().toISOString(),
          estimated_total_cost: totalCost
        };
        
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        return helper.parts_search.case_summary;
        
      } catch (error) {
        console.warn('Could not update case_summary:', error);
        return null;
      }
    }
    
    // âœ… COMPREHENSIVE DATA CAPTURE FUNCTION: Updates all parts_search statistics and data
    function updatePartsSearchComprehensiveData(helper, newParts, isStandaloneMode, activeCenterId) {
      try {
        // Ensure all parts_search structures exist
        helper.parts_search = helper.parts_search || {};
        helper.parts_search.case_summary = helper.parts_search.case_summary || {};
        helper.parts_search.global_parts_bank = helper.parts_search.global_parts_bank || {
          all_parts: [], suppliers: [], price_history: [], search_patterns: [], 
          ocr_results: [], manual_additions: []
        };
        helper.parts_search.search_history = helper.parts_search.search_history || {
          by_date: [], by_vehicle: {}, by_part_name: {}, by_supplier: {},
          statistics: { total_searches: 0, unique_parts: 0, unique_suppliers: 0, average_results_per_search: 0 }
        };

        const currentTimestamp = new Date().toISOString();
        
        // === PHASE 6: Fix case_summary aggregation logic ===
        const allSelectedParts = helper.parts_search.selected_parts || [];
        const allSearchResults = helper.parts_search.search_results || [];
        const unselectedParts = helper.parts_search.unselected_parts || [];
        
        // Calculate total cost from all selected parts (across all damage centers)
        const totalCost = allSelectedParts.reduce((sum, part) => {
          const price = parseFloat(part.price) || 0;
          const quantity = parseInt(part.quantity) || 1;
          return sum + (price * quantity);
        }, 0);
        
        console.log('ğŸ“Š PHASE 6: Case Summary Calculation:', {
          allSelectedParts_count: allSelectedParts.length,
          allSearchResults_count: allSearchResults.length,
          unselectedParts_count: unselectedParts.length,
          calculatedTotalCost: totalCost
        });
        
        // === PHASE 6: Let updateCaseSummary() handle case_summary - don't overwrite it here ===
        // case_summary is now handled by the dedicated updateCaseSummary() function

        // Update global_parts_bank with manual additions
        newParts.forEach(part => {
          const partEntry = {
            id: `manual_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            name: part.name || part.part,
            description: part.desc || part.description,
            price: parseFloat(part.price) || 0,
            quantity: parseInt(part.quantity) || 1,
            source: part.source,
            supplier: part.supplier || '',
            added_date: currentTimestamp,
            added_method: 'manual_entry',
            damage_center_id: isStandaloneMode ? null : activeCenterId,
            vehicle_plate: helper.vehicle?.plate || '',
            case_id: helper.case_info?.case_id || ''
          };

          // Add to all_parts (avoid duplicates by name+price combination)
          const existsInBank = helper.parts_search.global_parts_bank.all_parts.some(existing => 
            existing.name === partEntry.name && existing.price === partEntry.price
          );
          
          if (!existsInBank) {
            helper.parts_search.global_parts_bank.all_parts.push(partEntry);
          }

          // Add to manual_additions
          helper.parts_search.global_parts_bank.manual_additions.push(partEntry);

          // Update price_history
          helper.parts_search.global_parts_bank.price_history.push({
            part_name: partEntry.name,
            price: partEntry.price,
            supplier: partEntry.supplier,
            date: currentTimestamp,
            source: 'manual_entry'
          });

          // Update suppliers list
          if (partEntry.supplier && !helper.parts_search.global_parts_bank.suppliers.find(s => s.name === partEntry.supplier)) {
            helper.parts_search.global_parts_bank.suppliers.push({
              name: partEntry.supplier,
              contact_info: {},
              parts_supplied: [partEntry.id],
              last_interaction: currentTimestamp
            });
          }
        });

        // Update search_history statistics
        const uniquePartNames = new Set(helper.parts_search.global_parts_bank.all_parts.map(p => p.name.toLowerCase()));
        const uniqueSuppliers = new Set(helper.parts_search.global_parts_bank.suppliers.map(s => s.name));
        
        helper.parts_search.search_history.statistics = {
          total_searches: helper.parts_search.case_summary?.total_searches || 0,
          unique_parts: uniquePartNames.size,
          unique_suppliers: uniqueSuppliers.size,
          average_results_per_search: helper.parts_search.case_summary?.total_searches > 0 ? 
            allSelectedParts.length / helper.parts_search.case_summary.total_searches : 0
        };

        // Add current session to search history by_date
        helper.parts_search.search_history.by_date.push({
          timestamp: currentTimestamp,
          search_type: 'manual_entry',
          parts_added: newParts.length,
          damage_center_id: isStandaloneMode ? null : activeCenterId,
          total_cost: newParts.reduce((sum, part) => sum + ((parseFloat(part.price) || 0) * (parseInt(part.quantity) || 1)), 0)
        });

        console.log('ğŸ“Š COMPREHENSIVE DATA: Updated all parts_search statistics and data');
        console.log('ğŸ“Š Case Summary:', helper.parts_search.case_summary);
        console.log('ğŸ“Š Global Bank Stats:', {
          all_parts: helper.parts_search.global_parts_bank.all_parts.length,
          manual_additions: helper.parts_search.global_parts_bank.manual_additions.length,
          suppliers: helper.parts_search.global_parts_bank.suppliers.length,
          price_history: helper.parts_search.global_parts_bank.price_history.length
        });

      } catch (error) {
        console.warn('Failed to update comprehensive parts_search data:', error);
      }
    }

    // âœ… AUTO-SAVE FUNCTION: Automatically save when parts change
    function autoSaveOnChange(element) {
      // Debounce to avoid excessive saves
      clearTimeout(window.autoSaveTimer);
      window.autoSaveTimer = setTimeout(() => {
        console.log('ğŸ”„ Auto-saving parts data after change...');
        savePartsData();
      }, 1000); // Wait 1 second after last change
    }

    // Make functions globally available
    window.editPartRow = editPartRow;
    window.deletePartRow = deletePartRow;
    window.updateRowIndices = updateRowIndices;
    window.updatePartsSearchComprehensiveData = updatePartsSearchComprehensiveData;
    window.autoSaveOnChange = autoSaveOnChange;
    window.updateTotalCost = updateTotalCost;
    window.updatePartCount = updatePartCount;
    window.loadExistingPartsIntoUI = loadExistingPartsIntoUI;
    window.debugLoadParts = function() {
      console.log('ğŸ”§ Manual debug load triggered');
      loadExistingPartsIntoUI();
      setTimeout(() => {
        updateTotalCost();
        updatePartCount();
      }, 100);
    };
    
    // === PHASE 5: Implement bidirectional sync between modules ===
    function syncPartsBetweenModules() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        const activeCenterId = sessionStorage.getItem('active_damage_center_id') ||
                              helper.damage_assessment?.current_center_id || 
                              helper.damage_centers?.current_center_id;
        
        // Only sync when in wizard context (parts search initiated from wizard)
        const isWizardContext = window.parent !== window || // iframe context
                               activeCenterId || // has damage center ID
                               helper.current_damage_center; // has current damage center
        
        if (!isWizardContext) {
          console.log('ğŸ”„ SYNC: Skipping sync - standalone parts_search.html mode');
          return;
        }
        
        console.log('ğŸ”„ SYNC: Starting bidirectional sync for wizard context, center:', activeCenterId);
        
        // Bidirectional sync: parts_search â†” current_damage_center
        if (helper.parts_search?.selected_parts && activeCenterId) {
          
          // 1. Sync FROM current_damage_center TO parts_search
          if (helper.current_damage_center?.Parts?.parts_required) {
            helper.current_damage_center.Parts.parts_required.forEach(centerPart => {
              const existingIndex = helper.parts_search.selected_parts.findIndex(p => 
                p.damage_center_id === activeCenterId && 
                (p.name || p.part) === (centerPart.name || centerPart.part)
              );
              
              if (existingIndex >= 0) {
                // Update existing part in parts_search with current_damage_center data
                helper.parts_search.selected_parts[existingIndex] = {
                  ...helper.parts_search.selected_parts[existingIndex],
                  ...centerPart,
                  damage_center_id: activeCenterId
                };
                console.log(`ğŸ”„ SYNC: Updated parts_search with "${centerPart.name}" from current_damage_center`);
              }
            });
          }
          
          // 2. Sync FROM parts_search TO current_damage_center
          const centerParts = helper.parts_search.selected_parts.filter(p => 
            p.damage_center_id === activeCenterId
          );
          
          if (centerParts.length > 0) {
            helper.current_damage_center = helper.current_damage_center || {};
            helper.current_damage_center.Parts = helper.current_damage_center.Parts || {};
            helper.current_damage_center.Parts.parts_required = centerParts.map(part => ({
              name: part.name || part.part,
              description: part.description || part.desc || part.×ª×™××•×¨ || '',
              quantity: part.quantity || part.×›××•×ª || 1,
              price: part.price || 0,
              source: part.source || 'manual'
            }));
            console.log(`ğŸ”„ SYNC: Updated current_damage_center with ${centerParts.length} parts from parts_search`);
          }
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
          console.log('âœ… SYNC: Bidirectional sync completed');
        }
        
      } catch (error) {
        console.error('âŒ SYNC: Error in bidirectional sync:', error);
      }
    }
    
    // === PHASE 4: Ensure description is separate field and not overwritten ===
    function updatePartInfo(part) {
      // Add description field if missing
      if (!part.hasOwnProperty('description')) {
        part.description = part.desc || '';
      }
      
      // Ensure both desc and description fields exist and match
      if (part.desc && !part.description) {
        part.description = part.desc;
      } else if (part.description && !part.desc) {
        part.desc = part.description;
      }
      
      // Don't overwrite description with name - ensure they stay separate
      if (part.description === part.name && part.desc && part.desc !== part.name) {
        part.description = part.desc;
      }
      
      return part;
    }
    
    // Make updatePartInfo globally available
    window.updatePartInfo = updatePartInfo;
    window.syncPartsBetweenModules = syncPartsBetweenModules;
    window.updateCaseSummary = updateCaseSummary;
    
    // === PHASE 3: Initialize totals on page load ===
    function initializeTotals() {
      console.log('ğŸš€ Initializing parts module on page load...');
      
      // Clean up existing duplicates first
      cleanupExistingDuplicates();
      
      // Load existing parts from current damage center
      loadExistingPartsIntoUI();
      
      // Update totals after parts are loaded
      setTimeout(() => {
        updateTotalCost();
        updatePartCount();
      }, 100);
    }
    
    // === FIX: Load existing parts into UI on page load ===
    function loadExistingPartsIntoUI() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        // In edit mode, use the editing center ID, otherwise use current center ID
        const editMode = sessionStorage.getItem('damage_center_mode');
        const activeCenterId = editMode === 'edit_existing' ? 
                              sessionStorage.getItem('active_damage_center_id') :
                              (helper.damage_assessment?.current_center_id || 
                               helper.damage_centers?.current_center_id ||
                               sessionStorage.getItem('active_damage_center_id'));
        
        console.log('ğŸ” LOAD DEBUG: Edit mode:', editMode);
        console.log('ğŸ” LOAD DEBUG: Active center ID:', activeCenterId);
        console.log('ğŸ” LOAD DEBUG: Helper structure:', {
          has_parts_search: !!helper.parts_search,
          has_selected_parts: !!helper.parts_search?.selected_parts,
          selected_parts_length: helper.parts_search?.selected_parts?.length || 0,
          selected_parts_sample: helper.parts_search?.selected_parts?.slice(0, 2)
        });
        
        if (!activeCenterId) {
          console.log('âš ï¸ No active damage center ID found, loading all parts');
        }
        
        // Get parts for current damage center or all parts if standalone
        let partsToLoad = [];
        
        if (helper.parts_search?.selected_parts) {
          if (activeCenterId) {
            partsToLoad = helper.parts_search.selected_parts.filter(p => {
              const matches = p.damage_center_id === activeCenterId;
              console.log(`ğŸ” FILTER DEBUG: Part "${p.name}" center "${p.damage_center_id}" matches "${activeCenterId}": ${matches}`);
              return matches;
            });
            console.log(`ğŸ“¦ Loading ${partsToLoad.length} parts for damage center ${activeCenterId}`);
          } else {
            partsToLoad = helper.parts_search.selected_parts;
            console.log(`ğŸ“¦ Loading ${partsToLoad.length} parts (standalone mode)`);
          }
        }
        
        console.log('ğŸ” LOAD DEBUG: Parts to load:', partsToLoad);
        
        if (partsToLoad.length === 0) {
          console.log('â„¹ï¸ No existing parts found to load');
          return;
        }
        
        // Clear existing UI rows first
        const partsList = document.getElementById('partsList');
        if (partsList) {
          partsList.innerHTML = '';
        }
        
        // Add each part to the UI
        partsToLoad.forEach((part, index) => {
          addPartToUI(part, index);
        });
        
        console.log(`âœ… Loaded ${partsToLoad.length} existing parts into UI`);
        
      } catch (error) {
        console.error('Failed to load existing parts:', error);
      }
    }
    
    // === Helper function to add a part to the UI ===
    function addPartToUI(part, index) {
      console.log(`â• Adding part ${index} to UI:`, part);
      const partsList = document.getElementById("partsList");
      if (!partsList) {
        console.error('âŒ partsList element not found!');
        return;
      }
      
      const row = document.createElement("div");
      row.className = "row";
      row.setAttribute("data-row-index", index);
      row.innerHTML = `
        <div class="input-wrap">
              <input type="text" class="name" placeholder="×©× ×”×—×œ×§" value="${part.name || part.part || ''}" oninput="suggestPart(this); autoSaveOnChange(this)">
              <select class="suggest-dropdown" style="display:none;"></select>
            </div>
            <input type="text" class="desc" placeholder="×ª×™××•×¨" value="${part.desc || part.description || part.×ª×™××•×¨ || ''}" oninput="suggestPart(this); autoSaveOnChange(this)">
            <input type="number" class="quantity" placeholder="×›××•×ª" value="${part.quantity || part.×›××•×ª || 1}" min="1" style="width: 60px; margin-left: 8px;" onchange="autoSaveOnChange(this)">
            <input type="text" class="price" placeholder="××—×™×¨" value="${part.price || part.××—×™×¨ || ''}" onchange="autoSaveOnChange(this)">
            <select class="source">
              <option value="">××§×•×¨</option>
              <option value="×—×œ×™×¤×™/××§×•×¨×™" ${(part.source || part['×¡×•×’ ×—×œ×§']) === '×—×œ×™×¤×™/××§×•×¨×™' ? 'selected' : ''}>×—×œ×™×¤×™/××§×•×¨×™</option>
              <option value="×—×œ×™×¤×™/××©×•××©" ${(part.source || part['×¡×•×’ ×—×œ×§']) === '×—×œ×™×¤×™/××©×•××©' ? 'selected' : ''}>×—×œ×™×¤×™/××©×•××©</option>
              <option value="×—×“×© ××§×•×¨×™" ${(part.source || part['×¡×•×’ ×—×œ×§']) === '×—×“×© ××§×•×¨×™' ? 'selected' : ''}>×—×“×© ××§×•×¨×™</option>
              <option value="×—×œ×™×¤×™" ${(part.source || part['×¡×•×’ ×—×œ×§']) === '×—×œ×™×¤×™' ? 'selected' : ''}>×—×œ×™×¤×™</option>
              <option value="××©×•××©" ${(part.source || part['×¡×•×’ ×—×œ×§']) === '××©×•××©' ? 'selected' : ''}>××©×•××©</option>
              <option value="×¨×™×§" ${(part.source || part['×¡×•×’ ×—×œ×§']) === '×¨×™×§' ? 'selected' : ''}>×¨×™×§</option>
            </select>
            <div class="row-actions" style="display: flex; gap: 5px; margin-right: 8px;">
              <button type="button" class="btn-edit" onclick="editPartRow(${index})" title="×¢×¨×•×š ×—×œ×§" style="
                background: #f59e0b; color: white; border: none; padding: 6px 10px; 
                border-radius: 5px; cursor: pointer; font-size: 12px; font-weight: bold;
              ">âœï¸</button>
              <button type="button" class="btn-delete" onclick="deletePartRow(${index})" title="××—×§ ×—×œ×§" style="
                background: #dc3545; color: white; border: none; padding: 6px 10px; 
                border-radius: 5px; cursor: pointer; font-size: 12px; font-weight: bold;
              ">ğŸ—‘ï¸</button>
            </div>
      `;
      partsList.appendChild(row);
    }
    
    // === FIX: Clean up existing duplicates on page load ===
    function cleanupExistingDuplicates() {
      try {
        let helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        if (helper.parts_search?.selected_parts && helper.parts_search.selected_parts.length > 0) {
          console.log('ğŸ§¹ Cleaning up existing duplicates on page load...');
          const beforeCount = helper.parts_search.selected_parts.length;
          
          removeDuplicateParts(helper, null); // null activeCenterId to clean all centers
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
          const afterCount = helper.parts_search.selected_parts.length;
          
          if (beforeCount !== afterCount) {
            console.log(`âœ… Cleaned up ${beforeCount - afterCount} duplicate parts on page load`);
          }
        }
      } catch (error) {
        console.error('Failed to cleanup duplicates:', error);
      }
    }
    
    // Call initialization with retry logic for timing issues
    function initializeWithRetry(attempt = 1, maxAttempts = 5) {
      console.log(`ğŸ”„ Initialization attempt ${attempt}/${maxAttempts}`);
      
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        const hasValidData = helper.parts_search || helper.damage_centers || helper.vehicle;
        
        if (hasValidData || attempt >= maxAttempts) {
          console.log('âœ… Data found or max attempts reached, proceeding with initialization');
          initializeTotals();
        } else {
          console.log(`â³ Data not ready, retrying in ${500 * attempt}ms...`);
          setTimeout(() => initializeWithRetry(attempt + 1, maxAttempts), 500 * attempt);
        }
      } catch (error) {
        console.error(`âŒ Initialization attempt ${attempt} failed:`, error);
        if (attempt < maxAttempts) {
          setTimeout(() => initializeWithRetry(attempt + 1, maxAttempts), 1000);
        }
      }
    }
    
    // Start initialization when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => initializeWithRetry());
    } else {
      // DOM is already ready
      setTimeout(() => initializeWithRetry(), 100);
    }
  </script>
  <script type="module">
    // Try to load parts bank for better suggestions
    try {
      import('./parts.js').then(module => {
        window.PARTS_BANK = module.PARTS_BANK;
        console.log('Parts bank loaded for suggestions');
      }).catch(e => console.warn('Could not load parts bank'));
    } catch (e) {
      console.warn('Module import not supported');
    }
  </script>
</body>
</html>
