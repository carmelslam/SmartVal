<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <title>××©×£ ×—×•×•×ª ×”×“×¢×ª - ×™×¨×•×Ÿ ×›×™×•×£</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp" type="image/webp">
  <style>
    body {
      font-family: sans-serif;
      background: #f3f6fb;
      margin: 0;
      min-height: 100vh;
      padding: 0;
      padding-top: 90px;
      overflow-x: hidden;
    }
    .container {
      width: 100%;
      max-width: 820px;
      min-width: 320px;
      background: #fff;
      padding: 32px 24px 24px 24px;
      border-radius: 16px;
      box-shadow: 0 0 20px rgba(0,0,0,0.08);
      margin: 32px auto 32px auto;
      box-sizing: border-box;
    }
    .logo {
      display: flex;
      justify-content: center;
      margin-bottom: 8px;
    }
    .logo img {
      width: 112px;
      height: auto;
      display: block;
    }
    .title { font-size: 27px; font-weight: bold; text-align: center; margin-bottom: 2px; font-weight: 900;}
    .subtitle { font-size: 23px; color: #666; text-align: center; margin-bottom: 10px;}
    h1, h2 { color: #1e3a8a; font-size: 25px; text-align: center; margin: 15px 0 8px 0; font-weight: 600;}
    h3 { color: #1e3a8a; font-size: 24px; margin: 22px 0 12px 0; text-align: right; font-weight: 900;}
    .form-section {
      width: 100%;
      max-width: 100%;
      margin-bottom: 20px;
      background: #fafbfe;
      border-radius: 12px;
      padding: 17px 15px 12px 15px;
      box-sizing: border-box;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      overflow: hidden;
    }
    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px 18px;
      width: 100%;
    }
    @media (max-width: 600px) {
      .form-grid { grid-template-columns: 1fr; }
      .container {
        width: 98vw;
        max-width: 98vw;
        min-width: 0;
        padding: 14px 2vw 20px 2vw;
      }
    }
    
    /* Mobile viewport fixes */
    @media (max-width: 768px) {
      body {
        width: 100vw;
        overflow-x: hidden !important;
        position: relative;
      }
      
      html {
        width: 100vw;
        overflow-x: hidden !important;
      }
      
      .container {
        width: 95vw;
        max-width: 95vw;
        margin: 32px 2.5vw 32px 2.5vw;
      }
    }
    
    /* Desktop constraint fix */
    @media (min-width: 769px) {
      .container {
        width: 100%;
        max-width: 820px !important;
        margin: 32px auto !important;
      }
    }
    
    /* Summary container constraint fix */
    .summary-container {
      max-width: 820px;
      margin: 0 auto;
      width: 100%;
      box-sizing: border-box;
    }
    
    @media (min-width: 769px) {
      .summary-container {
        max-width: 820px;
        width: 820px;
      }
    }
    
    /* Summary block styling within container */
    .summary-block {
      width: 100% !important;
      box-sizing: border-box !important;
      margin-bottom: 20px;
    }
    label {
      font-size: 18px;
      margin-bottom: 4px;
      display: block;
      text-align: right;
    }
    input, select, textarea {
      width: 100%;
      font-size: 16px;
      border-radius: 8px;
      border: 1px solid #ccc;
      margin-bottom: 0px;
      padding: 8px 9px;
      box-sizing: border-box;
      text-align: right !important;
      background: #f9f9f9;
      transition: border .15s;
      outline: none;
    }
    input:focus, select:focus, textarea:focus {
      border-color: #3b82f6;
    }
    .readonly-box {
      background: #f4f6fa;
      border-radius: 6px;
      border: 1px solid #eee;
      padding: 7px 8px;
      min-height: 20px;
      font-size: 16px;
      color: #333;
      text-align: right !important;
    }
    .btn {
      background: #007bff;
      color: white;
      border: none;
      padding: 12px 15px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      display: block;
    }
    
    /* FLOATING SCREENS STYLING - COPIED FROM DEPRECIATION */
    .floating-toggles-top {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.95);
      padding: 8px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .toggle-square {
      width: 80px;
      height: 70px;
      background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      color: white;
      text-align: center;
      border: 2px solid transparent;
    }

    .toggle-square:hover {
      background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
    }

    .toggle-square.active {
      border-color: #fbbf24;
      box-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
    }

    .toggle-icon {
      font-size: 18px;
      margin-bottom: 2px;
    }

    .toggle-text {
      font-size: 10px;
      font-weight: 600;
      line-height: 1.1;
    }
    
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .section-header h3 {
      margin: 0;
    }
    @media (max-width: 768px) {
      .floating-toggles-top {
        top: 5px;
        gap: 4px;
        padding: 6px;
      }
      .toggle-square {
        width: 65px;
        height: 60px;
      }
      .toggle-icon {
        font-size: 16px;
      }
      .toggle-text {
        font-size: 9px;
      }
      
      /* Mobile fixes for depreciation table */
      #depreciationBulkTable .dep-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #depreciationBulkTable .dep-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #depreciationBulkTable .dep-row > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(1)::before {
        content: "××¡' ××•×§×“:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(2)::before {
        content: "×”×—×œ×§ ×”× ×™×–×•×§:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(3)::before {
        content: "××”×•×ª ×”×ª×™×§×•×Ÿ:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(4)::before {
        content: "% ×™×¨×™×“×ª ×¢×¨×š:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(5)::before {
        content: "×¢×¨×š ×‘-â‚ª:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(6)::before {
        content: "×¤×¢×•×œ×•×ª:";
      }
      
      /* Hide table headers on mobile */
      #depreciationSection > div:first-child {
        display: none !important;
      }
      
      /* Mobile fixes for Full Market Adjustments table */
      #allAdjustmentsList .adjustment-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #allAdjustmentsList .adjustment-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #allAdjustmentsList .adjustment-row > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
        display: block;
        margin-bottom: 4px;
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(1)::before {
        content: "×ª×™××•×¨:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(2)::before {
        content: "×¡×•×’:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(3)::before {
        content: "××—×•×–:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(4)::before {
        content: "×¢×¨×š:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(5)::before {
        content: "×¤×¢×•×œ×•×ª:";
      }
      
      /* Hide Full Market Adjustments table headers on mobile */
      #allAdjustments > div:first-child {
        display: none !important;
      }
      
      /* Mobile fixes for damage center part rows */
      .part-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa !important;
        padding: 12px !important;
        border-radius: 8px !important;
        margin-bottom: 12px !important;
        border: 1px solid #e9ecef !important;
      }
      
      .part-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .part-row > div:nth-child(1) label::after {
        content: " (×©× ×”×—×œ×§)";
      }
      
      .part-row > div:nth-child(2) label::after {
        content: " (×ª×™××•×¨)";
      }
      
      .part-row > div:nth-child(3) label::after {
        content: " (×¢×œ×•×ª)";
      }
      
      /* Mobile fixes for damage center work rows */
      .work-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa !important;
        padding: 12px !important;
        border-radius: 8px !important;
        margin-bottom: 12px !important;
        border: 1px solid #e9ecef !important;
      }
      
      .work-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .work-row > div:nth-child(1) label::after {
        content: " (×¡×•×’ ×¢×‘×•×“×”)";
      }
      
      .work-row > div:nth-child(2) label::after {
        content: " (×”×¢×¨×•×ª)";
      }
      
      .work-row > div:nth-child(3) label::after {
        content: " (×¢×œ×•×ª)";
      }
      
      /* Mobile fixes for damage center repair rows */
      .repair-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa !important;
        padding: 12px !important;
        border-radius: 8px !important;
        margin-bottom: 12px !important;
        border: 1px solid #e9ecef !important;
      }
      
      .repair-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .repair-row > div:nth-child(1) label::after {
        content: " (×ª×™××•×¨ ×ª×™×§×•×Ÿ)";
      }
      
      .repair-row > div:nth-child(2) label::after {
        content: " (×”×¢×¨×•×ª)";
      }
      
      .repair-row > div:nth-child(3) label::after {
        content: " (×¢×œ×•×ª)";
      }
      
      /* Mobile fixes for Features Adjustments section */
      #featuresAdjustments > div:first-child {
        display: none !important;
      }
      
      #featuresAdjustmentsList > div {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #featuresAdjustmentsList > div > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #featuresAdjustmentsList > div > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
        display: block;
        margin-bottom: 4px;
      }
      
      #featuresAdjustmentsList > div > div:nth-child(1)::before {
        content: "×ª×™××•×¨:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(2)::before {
        content: "×¡×•×’:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(3)::before {
        content: "××—×•×–:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(4)::before {
        content: "×¢×¨×š:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(5)::before {
        content: "×¤×¢×•×œ×•×ª:";
      }
      
      /* Mobile fixes for Registration Adjustments section */
      #registrationAdjustments > div:first-child {
        display: none !important;
      }
      
      #registrationAdjustmentsList > div {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #registrationAdjustmentsList > div > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #registrationAdjustmentsList > div > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
        display: block;
        margin-bottom: 4px;
      }
      
      #registrationAdjustmentsList > div > div:nth-child(1)::before {
        content: "×ª×™××•×¨:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(2)::before {
        content: "×¡×•×’:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(3)::before {
        content: "××—×•×–:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(4)::before {
        content: "×¢×¨×š:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(5)::before {
        content: "×¤×¢×•×œ×•×ª:";
      }
      
      
      /* Fix button spacing on mobile */
      .btn.add {
        width: 100% !important;
        margin-top: 8px !important;
      }
      
      /* Navigation buttons mobile responsive */
      .nav-btn {
        font-size: 14px !important;
        padding: 10px 8px !important;
        min-height: 44px !important;
      }
      
      /* Damage centers mobile responsive */
      #damageCentersContent > div > div > div:nth-child(n+1) {
        grid-template-columns: 1fr 1fr !important;
        gap: 4px !important;
      }
      
      /* Levi adjustments mobile responsive */
      .levi-adjustments-grid {
        grid-template-columns: 1fr !important;
        gap: 4px !important;
      }
      
      .levi-adjustment-row {
        grid-template-columns: 1fr !important;
        gap: 4px !important;
        padding: 8px !important;
      }
      
      .levi-adjustment-row > div {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 4px 0;
      }
      
      .levi-adjustment-row > div:nth-child(1)::after {
        content: "";
      }
      
      .levi-adjustment-row > div:nth-child(2)::before {
        content: "××—×•×–: ";
        font-weight: bold;
        color: #495057;
      }
      
      .levi-adjustment-row > div:nth-child(3)::before {
        content: "×¢×¨×š: ";
        font-weight: bold;
        color: #495057;
      }
      
      /* Custom summary rows mobile responsive */
      .custom-summary-row {
        grid-template-columns: 1fr !important;
        gap: 8px !important;
      }
      
      .custom-summary-row > input {
        margin-bottom: 4px;
      }
    }
    
    .collapsible-btn {
      background: #e0e7f1;
      font-family: sans-serif;
      color: #1e3a8a;
      border: none;
      padding: 7px 18px;
      border-radius: 7px;
      margin-bottom: 8px;
      margin-top: 2px;
      cursor: pointer;
      font-weight: 600;
      font-size: 16px;
      text-align: right;
      width: auto;
      display: inline-block;
    }

    .collapsible-btn:hover {
      background: #d1d9e6;
    }

    .btn.add {
      background: #28a745;
      margin-top: 7px;
      margin-bottom: 0;
      width: auto;
      padding: 8px 18px;
      font-size: 16px;
      display: block;
    }

    /* Navigation Buttons Styling */
    .nav-btn {
      padding: 12px 16px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      min-height: 48px;
    }

    .save-btn {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
    }
    .save-btn:hover {
      background: linear-gradient(135deg, #218838 0%, #1ea085 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
    }

    .preview-btn {
      background: linear-gradient(135deg, #17a2b8 0%, #20c997 100%);
    }
    .preview-btn:hover {
      background: linear-gradient(135deg, #138496 0%, #1ea085 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(23, 162, 184, 0.3);
    }

    .generate-btn {
      background: linear-gradient(135deg, #007bff 0%, #6610f2 100%);
    }
    .generate-btn:hover {
      background: linear-gradient(135deg, #0056b3 0%, #520dc2 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
    }

    .back-btn {
      background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
    }
    .back-btn:hover {
      background: linear-gradient(135deg, #545b62 0%, #3d4142 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
    }
    
    .footer {
      margin-top: 40px;
      font-size: 12px;
      color: #aaa;
      text-align: center;
    }
    
    /* Floating PDF Display Styles */
    .floating-pdf-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 0;
      margin: 0;
      box-sizing: border-box;
    }
    
    .floating-pdf-container {
      background: white;
      border-radius: 12px;
      width: 90%;
      max-width: 900px;
      height: 90%;
      max-height: 700px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }
    
    /* Mobile optimization for floating PDF - Complete rewrite */
    @media (max-width: 768px) {
      .floating-pdf-overlay {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100% !important;
        height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        background: rgba(0, 0, 0, 0.8) !important;
        z-index: 999999 !important;
        overflow: hidden !important;
      }
      
      .floating-pdf-container {
        position: fixed !important;
        top: 20px !important;
        left: 10px !important;
        right: 10px !important;
        bottom: 20px !important;
        width: auto !important;
        height: auto !important;
        max-width: none !important;
        max-height: none !important;
        margin: 0 !important;
        border-radius: 10px !important;
        background: white !important;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5) !important;
        overflow: hidden !important;
      }
      
      .floating-pdf-header {
        position: relative !important;
        background: #1e3a8a !important;
        color: white !important;
        padding: 15px !important;
        border-radius: 10px 10px 0 0 !important;
        display: flex !important;
        justify-content: space-between !important;
        align-items: center !important;
        min-height: 60px !important;
        box-sizing: border-box !important;
      }
      
      .floating-pdf-header h3 {
        font-size: 18px !important;
        margin: 0 !important;
        flex: 1 !important;
        text-align: right !important;
      }
      
      .floating-pdf-controls {
        display: flex !important;
        gap: 10px !important;
        flex-shrink: 0 !important;
      }
      
      .toggle-btn, .close-btn {
        width: 44px !important;
        height: 44px !important;
        font-size: 22px !important;
        background: rgba(255,255,255,0.2) !important;
        border: none !important;
        color: white !important;
        border-radius: 8px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        touch-action: manipulation !important;
        -webkit-tap-highlight-color: transparent !important;
      }
      
      .floating-pdf-content {
        position: absolute !important;
        top: 60px !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        overflow: hidden !important;
      }
      
      .floating-pdf-content iframe {
        width: 100% !important;
        height: 100% !important;
        border: none !important;
      }
    }
    
    /* Extra small mobile devices */
    @media (max-width: 480px) {
      .floating-pdf-container {
        top: 10px !important;
        left: 5px !important;
        right: 5px !important;
        bottom: 10px !important;
      }
      
      .floating-pdf-header {
        padding: 12px !important;
        min-height: 50px !important;
      }
      
      .floating-pdf-header h3 {
        font-size: 16px !important;
      }
      
      .toggle-btn, .close-btn {
        width: 40px !important;
        height: 40px !important;
        font-size: 20px !important;
      }
    }
    
    .floating-pdf-header {
      background: #1e3a8a;
      color: white;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 12px 12px 0 0;
    }
    
    .floating-pdf-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    
    .floating-pdf-controls {
      display: flex;
      gap: 10px;
    }
    
    .toggle-btn, .close-btn {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 35px;
      height: 35px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.3s ease;
    }
    
    .toggle-btn:hover, .close-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }
    
    .floating-pdf-content {
      flex: 1;
      padding: 0;
      overflow: hidden;
    }
    
    .floating-pdf-content.minimized {
      display: none;
    }
    
    .floating-pdf-container.minimized {
      height: auto;
      max-height: none;
    }
    
    /* Plate and document actions section styles */
    .plate-actions-section {
      background: #f8fafc;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 25px;
    }
    
    .plate-actions-section label {
      font-size: 16px;
      font-weight: 600;
      color: #1e3a8a;
      margin-bottom: 10px;
      text-align: right;
    }
    
    .plate-actions-section input {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #cbd5e1;
      border-radius: 6px;
      text-align: center;
      box-sizing: border-box;
    }
    
    .load-case-btn {
      padding: 10px 20px;
      background: #1e3a8a;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
    }
    
    .load-case-btn:hover {
      background: #3b82f6;
    }
    
    .document-actions-section {
      margin-top: 20px;
      padding: 15px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
    }
    
    .document-actions-section .nav-btn {
      flex: 1;
      padding: 12px;
      font-size: 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      color: white;
    }
    
    /* Summary block styling to work with inline gradients */
    .summary-block {
      position: relative;
      max-width: 100% !important;
      width: 100% !important;
      box-sizing: border-box !important;
      /* Enhanced with inline gradient backgrounds */
    }
    
    .summary-block h3 {
      color: white !important;
      font-size: 26px !important;
      text-align: center !important;
      margin-bottom: 20px !important;
      font-weight: 900 !important;
    }
    
    /* Ensure all form sections stay within container bounds - merged with existing definition */
    
    /* Force container children to stay within bounds */
    .container > * {
      max-width: 100% !important;
      box-sizing: border-box !important;
    }
    
    /* Mobile fixes for summary date field */
    @media (max-width: 768px) {
      /* Reduce the overall summary block padding on mobile */
      .summary-block {
        padding: 15px 6px !important;
      }
      
      .summary-block > div {
        margin-left: 0 !important;
        margin-right: 0 !important;
        padding-left: 0 !important;
        padding-right: 0 !important;
      }
      
      /* Fix date input container specifically */
      .summary-block input[type="date"] {
        width: calc(100% - 4px) !important;
        box-sizing: border-box !important;
        max-width: calc(100% - 4px) !important;
        margin: 2px !important;
        padding: 6px 4px !important;
        font-size: 13px !important;
      }
      
      /* More specific targeting for the summary date field */
      #finalReportDateSummary {
        width: calc(100% - 10px) !important;
        box-sizing: border-box !important;
        max-width: calc(100% - 10px) !important;
        margin: 5px !important;
        padding: 4px 2px !important;
        font-size: 12px !important;
      }
      
      /* Ensure date container doesn't overflow */
      .summary-block > div[style*="text-align: center"] {
        padding: 2px !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
        box-sizing: border-box !important;
      }
    }
    
    /* Override for parts search modal width */
    #partsSearchResultsModal {
      max-width: 750px !important;
      width: 80vw !important;
    }
    
    /* Sliding Toggle Container */
    .sliding-toggle {
      position: relative;
      display: flex;
      background: rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 20px;
      padding: 3px;
      box-shadow: 0 8px 32px rgba(31, 38, 135, 0.2);
      transition: all 0.3s ease;
      width: 140px;
    }
    
    .sliding-toggle:hover {
      box-shadow: 0 12px 40px rgba(31, 38, 135, 0.3);
    }
    
    /* Toggle Options */
    .toggle-option {
      position: relative;
      z-index: 2;
      padding: 8px 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      border-radius: 17px;
      flex: 1;
      text-align: center;
      user-select: none;
    }
    
    .toggle-option span {
      font-size: 12px;
      font-weight: 500;
      color: #333;
      transition: all 0.3s ease;
      text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
    }
    
    .toggle-option.active span {
      color: #fff;
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }
    
    .toggle-option:hover:not(.active) span {
      color: #000;
      font-weight: 600;
    }
    
    /* Sliding Background */
    .toggle-slider {
      position: absolute;
      top: 3px;
      left: 3px;
      width: calc(50% - 3px);
      height: calc(100% - 6px);
      background: linear-gradient(145deg, #4CAF50, #45a049);
      border-radius: 17px;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
      z-index: 1;
    }
    
    /* Slider positions */
    .toggle-slider.wizard-active {
      transform: translateX(0);
    }
    
    .toggle-slider.invoice-active {
      transform: translateX(100%);
    }
    
    /* Private Report Mode - Invoice Only */
    .sliding-toggle.private-report-mode {
      width: 140px; /* Keep original width to not break layout */
      justify-content: center;
    }
    
    .sliding-toggle.private-report-mode .toggle-option.active {
      background: linear-gradient(145deg, #2196F3, #1976D2);
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
    }
    
    .sliding-toggle.private-report-mode .toggle-option.active span {
      color: white !important;
      font-weight: 600 !important;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important;
    }
    
    /* Other Report Mode - Wizard Only */
    .sliding-toggle.other-report-mode {
      width: 140px; /* Keep original width to not break layout */
      justify-content: center;
    }
    
    .sliding-toggle.other-report-mode .toggle-option.active {
      background: linear-gradient(145deg, #4CAF50, #45a049);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }
    
    .sliding-toggle.other-report-mode .toggle-option.active span {
      color: white !important;
      font-weight: 600 !important;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3) !important;
    }
    
    /* Invoice data mode styling */
    .invoice-data-mode {
      background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(255, 255, 255, 0.8)) !important;
      backdrop-filter: blur(8px) !important;
      -webkit-backdrop-filter: blur(8px) !important;
      border: 2px solid #4CAF50 !important;
      box-shadow: 0 4px 16px rgba(76, 175, 80, 0.2) !important;
    }
    
    /* Archive data mode styling */
    .archive-data-mode {
      background: linear-gradient(135deg, rgba(255, 149, 0, 0.1), rgba(255, 255, 255, 0.8)) !important;
      backdrop-filter: blur(8px) !important;
      -webkit-backdrop-filter: blur(8px) !important;
      border: 2px solid #ff9500 !important;
      box-shadow: 0 4px 16px rgba(255, 149, 0, 0.2) !important;
    }
    
    /* Loading spinner animation */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <!-- FLOATING SCREEN TOGGLES - TOP OF PAGE -->
  <div class="floating-toggles-top">
    <div class="toggle-square" onclick="toggleFloatingScreen('leviReport')">
      <div class="toggle-icon">ğŸ“Š</div>
      <div class="toggle-text">×“×•"×— ×œ×•×™ ×™×¦×—×§</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('carDetails')">
      <div class="toggle-icon">ğŸš—</div>
      <div class="toggle-text">×¤×¨×˜×™ ×¨×›×‘</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('invoiceDetails')">
      <div class="toggle-icon">ğŸ§¾</div>
      <div class="toggle-text">×¤×¨×˜×™ ×—×©×‘×•× ×™×•×ª</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('internalBrowser')">
      <div class="toggle-icon">ğŸŒ</div>
      <div class="toggle-text">×“×¤×“×¤×Ÿ ×¤× ×™××™</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('partsSearchResults')">
      <div class="toggle-icon">ğŸ”§</div>
      <div class="toggle-text">×ª×•×¦××•×ª ×—×œ×§×™×</div>
    </div>
  </div>

  <div class="container">
    <div class="logo"><img src="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp" alt="Logo"></div>
    <div class="title">×™×¨×•×Ÿ ×›×™×•×£ ×©×××•×ª - ×¤×•×¨×˜×œ</div>
    <div class="subtitle">×©×××•×ª ×•×”×¢×¨×›×ª × ×–×§×™ ×¨×›×‘ ×•×¨×›×•×©</div>
    
    <!-- Plate Input and Document Actions Section -->
    <div class="plate-actions-section">
      <!-- Separate the plate input from password to prevent browser interference -->
      <div style="margin-bottom: 15px;">
        <div style="display: inline-block; margin-left: 15px;">
          <label for="builderPlateInput" style="display: block; margin-bottom: 5px;">××¡×¤×¨ ×¨×›×‘:</label>
          <input type="text" id="builderPlateInput" placeholder="×”×›× ×¡ ××¡×¤×¨ ×¨×›×‘" required autocomplete="off" autocapitalize="none" spellcheck="false" inputmode="numeric" data-plate-field="true">
        </div>
      </div>
      
      <form id="builderLoadCaseForm" onsubmit="event.preventDefault(); const plateInput = document.getElementById('builderPlateInput'); if (plateInput && typeof loadExistingCaseForBuilder === 'function') { loadExistingCaseForBuilder(); }" autocomplete="off">
        
        <!-- Password field removed - using Supabase auth instead -->
        
        <div style="text-align:center; margin-bottom:15px;">
          <button type="submit" id="builderLoadCaseBtn" class="load-case-btn">
            ×˜×¢×Ÿ ×ª×™×§ ×§×™×™×
          </button>
        </div>
      </form>
      
      <div style="margin-top:10px; font-size:12px; color:#6b7280; text-align:center;">
        ğŸ’¡ ×”×–×Ÿ ××¡×¤×¨ ×¨×›×‘ - ×¡×™×¡××ª ×”×¢××•×“ ××ª××œ××ª ××•×˜×•××˜×™×ª ××”×›× ×™×¡×” ×œ××¢×¨×›×ª
      </div>
      
      <div id="builderPlateStatus" style="margin-top:10px; font-size:14px; color:#059669; display:none; text-align:right;">
        âœ“ × ×ª×•× ×™ ×”×¨×›×‘ × ×˜×¢× ×• ×‘×”×¦×œ×—×”
      </div>
      
      <!-- Document Actions Section -->
    <div id="documentActionsSection" style="margin-top: 20px; padding: 15px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
      <div style="font-size: 16px; font-weight: 600; color: #1e3a8a; margin-bottom: 15px; text-align: center;">
        ×¤×¢×•×œ×•×ª ××¡××›×™×
      </div>
      <!-- FETCH BUTTONS - View existing documents (require plate input) -->
      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 10px;">
        <button class="nav-btn" id="fetchEstimateBtn" onclick="fetchEstimatePDF()" style="background: #dc2626; color: white;">
          ×”×¦×’ ××•××“×Ÿ ×¨××©×•× ×™ PDF
        </button>
        <button class="nav-btn" id="fetchExpertiseBtn" onclick="fetchExpertisePDF()" style="background: #8b5cf6; color: white;">
          ×”×¦×’ ××§×¡×¤×™×¨×˜×™×–×” PDF
        </button>
        <button class="nav-btn" id="fetchFinalReportBtn" onclick="fetchFinalReportPDF()" style="background: #06b6d4; color: white;">
          ×”×¦×’ ×—×•×•×ª ×“×¢×ª PDF
        </button>
      </div>
      <div style="margin-top: 10px; padding: 10px; background: #e0f2fe; border-radius: 6px; font-size: 14px; text-align: center; color: #0277bd;">
        ğŸ“ ×”×›× ×¡ ××¡×¤×¨ ×¨×›×‘ ×•×˜×¢×Ÿ ×ª×™×§ ×›×“×™ ×œ×¦×¤×•×ª ×‘××¡××›×™× ×§×™×™××™×<br>
        ×›×¤×ª×•×¨×™ ×”×¤×§×” ×©×œ ××¡××›×™× ×—×“×©×™× × ××¦××™× ×‘×ª×—×ª×™×ª ×”×¢××•×“ ğŸš€
      </div>
    </div>
    
    <h1>××©×£ ×—×•×•×ª ×”×“×¢×ª - ××•×“×•×œ ×™×¨×™×“×ª ×¢×¨×š ××ª×§×“×</h1> 
    <h2 id="pageTitle">×¨×›×‘ ××¡. ...</h2>

    <!-- DEPRECIATION REPORT TYPE SELECTION -->
    <div class="form-section">
      <h3>×‘× ×™×™×ª ×—×•×•×ª ×“×¢×ª</h3>
      <div class="form-grid">
        <div>
          <label for="reportType">×‘×—×¨ ×¡×•×’ ×—×•×•×ª ×“×¢×ª:</label>
          <select id="reportType" onchange="updateSummaryVisibility(); loadLegalText(); saveLegalTextAfterChange();">
            <option>×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª</option>
            <option>×—×•×•×ª ×“×¢×ª ×’×œ×•×‘×œ×™×ª</option>
            <option>×—×•×•×ª ×“×¢×ª ××›×™×¨×” ××¦×‘×• ×”× ×™×–×•×§</option>
            <option>×—×•×•×ª ×“×¢×ª ×˜×•×˜×œ×•×¡×˜</option>
            <option>×—×•×•×ª ×“×¢×ª ××•×‘×“×Ÿ ×œ×”×œ×›×”</option>
          </select>
        </div>
        <div>
          <label for="isCompanyClient">×“×•"×— ×œ×—×‘×¨×”:</label>
          <select id="isCompanyClient" onchange="updateFinalReportField('report_for_company', this.value === 'yes')">
            <option value="no">×œ×</option>
            <option value="yes">×›×Ÿ</option>
          </select>
        </div>
        <div>
          <label for="inAgreement">×¡×˜×˜×•×¡ ×”×¡×“×¨:</label>
          <select id="inAgreement" onchange="updateFinalReportField('in_agreement', this.value === 'yes')">
            <option value="yes">×‘×”×¡×“×¨</option>
            <option value="no">×œ× ×‘×”×¡×“×¨</option>
          </select>
        </div>
        
        <div style="text-align: center; margin-top: 15px;">
          <button type="button" onclick="saveFinalReportConfiguration()" class="nav-btn" style="background: #28a745; color: white; font-size: 14px;">
            ğŸ’¾ ×©××•×¨ ×”×’×“×¨×•×ª
          </button>
        </div>
      </div>
    </div>

    <!-- VEHICLE DATA - EDITABLE FROM HELPER -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('vehicleData')">× ×ª×•× ×™ ×¨×›×‘ (×”×¦×’/×”×¡×ª×¨)</button>
      <div id="vehicleData" style="display:none;">
        <div class="form-grid">
          <div><label>××¡×¤×¨ ×¨×›×‘:</label><input type="text" id="carPlate" onchange="updateHelperFromField(event);" /></div>
          <div><label>×ª×•×¦×¨×ª:</label><input type="text" id="carManufacturer" onchange="updateHelperFromField(event);" /></div>
          <div><label>×“×’×:</label><input type="text" id="carModel" onchange="updateHelperFromField(event);" /></div>
          <div><label>×©× ×ª ×™×™×¦×•×¨:</label><input type="text" id="carYear" onchange="updateHelperFromField(event);" /></div>
          <div><label>×§×•×“ ×“×’×:</label><input type="text" id="carModelCode" onchange="updateHelperFromField(event);" /></div>
          <div><label>××—×™×¨ ×‘×¡×™×¡:</label><input type="text" id="carBasePrice" onchange="updateHelperFromVehicleField(this);" /></div>
          <div><label>×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘:</label><input type="text" id="carMarketValue" onchange="updateHelperFromVehicleField(this);" /></div>
          <div><label>×ª××¨×™×š ×—×•×•×ª ×”×“×¢×ª (×“×•×— ×¡×•×¤×™):</label><input type="date" id="finalReportDate" onchange="updateHelperFromField(event);" /></div>
        </div>
      </div>
    </div>


    <!-- COLLAPSIBLE CONTACT DATA -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('contactData')">× ×ª×•× ×™ ×”×ª×§×©×¨×•×ª (×”×¦×’/×”×¡×ª×¨)</button>
      <div id="contactData" style="display:none;">
        <div class="form-grid">
          <div><label>×©× ×‘×¢×œ ×”×¨×›×‘:</label><input type="text" id="ownerName" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>×›×ª×•×‘×ª ×‘×¢×œ ×”×¨×›×‘:</label><input type="text" id="ownerAddress" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>×˜×œ×¤×•×Ÿ ×‘×¢×œ ×”×¨×›×‘:</label><input type="text" id="ownerPhone" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>×—×‘×¨×ª ×‘×™×˜×•×—:</label><input type="text" id="insuranceCompany" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>××™××™×™×œ ×—×‘×¨×ª ×‘×™×˜×•×—:</label><input type="text" id="insuranceEmail" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>×¡×•×›×Ÿ ×‘×™×˜×•×—:</label><input type="text" id="insuranceAgent" onchange="updateHelperFromContactField(this); triggerFloatingScreenRefresh();" /></div>
          <div><label>×˜×œ×¤×•×Ÿ ×¡×•×›×Ÿ ×‘×™×˜×•×—:</label><input type="text" id="agentPhone" onchange="updateHelperFromContactField(this); triggerFloatingScreenRefresh();" /></div>
          <div><label>××™××™×™×œ ×¡×•×›×Ÿ ×‘×™×˜×•×—:</label><input type="text" id="agentEmail" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>×©× ××•×¡×š:</label><input type="text" id="garageName" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>×˜×œ×¤×•×Ÿ ××•×¡×š:</label><input type="text" id="garagePhone" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>××™××™×™×œ ××•×¡×š:</label><input type="text" id="garageEmail" onchange="updateHelperFromContactField(this);" /></div>
        </div>
      </div>
    </div>

    <!-- DAMAGE CENTERS SUMMARY SECTION - EDITABLE -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('damageCentersSummary')">×¡×™×›×•× ××•×§×“×™ × ×–×§ (×”×¦×’/×”×¡×ª×¨)</button>
      <div id="damageCentersSummary" style="display:none;">
        <h3>×¡×™×›×•× ××•×§×“×™ × ×–×§ (× ×™×ª×Ÿ ×œ×¢×¨×™×›×”) </h3>
        
        <!-- SESSION 88: Invoice Assignment Banner -->
        <div id="invoiceAssignmentBanner" style="display: none; margin-bottom: 15px;">
          <div style="
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border: 2px solid #2196f3;
            border-radius: 8px;
            padding: 15px;
            position: relative;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
          ">
            <div style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              margin-bottom: 10px;
            ">
              <div style="
                display: flex;
                align-items: center;
                gap: 10px;
              ">
                <span style="font-size: 20px;">ğŸ“„</span>
                <span style="
                  font-weight: 600;
                  color: #1565c0;
                  font-size: 16px;
                ">×–××™× ×•×ª ×—×©×‘×•× ×™×•×ª ×œ×”×§×¦××”</span>
              </div>
              <button id="dismissInvoiceBanner" onclick="dismissInvoiceAssignmentBanner()" style="
                background: none;
                border: none;
                font-size: 18px;
                cursor: pointer;
                color: #666;
                padding: 0;
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
              ">Ã—</button>
            </div>
            
            <div id="invoiceAssignmentContent" style="
              background: white;
              border-radius: 6px;
              padding: 12px;
              margin-bottom: 10px;
            ">
              <div style="color: #666; text-align: center;">
                ×˜×•×¢×Ÿ ×—×©×‘×•× ×™×•×ª ×–××™× ×•×ª...
              </div>
            </div>
            
            <div style="
              display: flex;
              gap: 10px;
              justify-content: flex-end;
            ">
              <button id="acceptInvoiceAssignment" onclick="acceptInvoiceAssignment()" style="
                background: #4caf50;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                font-weight: 500;
              ">××©×¨ ×”×§×¦××ª ×—×©×‘×•× ×™×•×ª</button>
            </div>
          </div>
        </div>
        
        <!-- Sliding Toggle between Invoice and Wizard -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin: 15px 0 10px 0;">
          <h3 style="margin: 0; color: #333; font-size: 18px; font-weight: 600;">××¨×›×–×™ × ×–×§</h3>
          <div id="dataToggleContainer" style="display: none;">
            <div class="sliding-toggle">
              <div class="toggle-option" id="wizardOption" onclick="switchToInvoice()">
                <span>×—×©×‘×•× ×™×ª</span>
              </div>
              <div class="toggle-option" id="invoiceOption" onclick="switchToWizard()">
                <span>××©×£</span>
              </div>
              <div class="toggle-slider" id="toggleSlider"></div>
            </div>
          </div>
        </div>
        
        <div style="background: #f8f9fa; border-radius: 6px; padding: 15px; min-height: 50px; transition: background-color 0.3s;" id="damageCentersContent">
          <div style="color: #666; text-align: center;">×˜×•×¢×Ÿ × ×ª×•× ×™ ××•×§×“×™ × ×–×§...</div>
        </div>
        <button type="button" class="btn add" onclick="addNewDamageCenter()" style="margin-top: 10px;">×”×•×¡×£ ××•×§×“ × ×–×§ ×—×“×©</button>
      </div>
    </div>

    <!-- GROSS DAMAGE PERCENTAGE CALCULATION -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('grossCalc')">  ×¢×¨×š ×”×¨×›×‘ ×œ× ×–×§ ×’×•×œ××™ - ×××¤×™×™× ×™× ×•×¢×œ×™×” ×œ×›×‘×™×© ×‘×œ×‘×“ (×”×¦×’/×”×¡×ª×¨)</button>
      <div id="grossCalc" style="display:none;">
        <div class="form-grid">
          <div><label>×¢×¨×š ×”×¨×›×‘ ×¢"×¤ ××—×™×¨×•×Ÿ ×›×•×œ×œ ××¢"×:</label><input type="text" id="basicPrice" placeholder="â‚ª" onchange="updateHelperFromField(event); updateGrossMarketValueCalculation(); updateHelperFromAdjustments();" /></div>
          <div></div>
        </div>
        <div style="margin-top: 10px; text-align: right;">
          <button type="button" onclick="reloadGrossAdjustments()" style="background: #ff9500; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600;">×˜×¢×Ÿ ×”×ª×××•×ª ×œ×•×™ ×™×¦×—×§</button>
        </div>
        
        <!-- Features Adjustments -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">×ª×•×¡×¤×•×ª ×××¤×™×™× ×™× (×ª×›×•× ×•×ª ×”×¨×›×‘):</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            ğŸ—ï¸ ×ª×•×¡×¤×•×ª ×”×§×©×•×¨×•×ª ×œ×ª×›×•× ×•×ª ×¤×™×–×™×•×ª ×©×œ ×”×¨×›×‘ ×¢×¦××•
          </div>
          <div id="featuresAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>×ª×™××•×¨:</label></div>
              <div><label>×¡×•×’:</label></div>
              <div><label>××—×•×–:</label></div>
              <div><label>×¢×¨×š:</label></div>
              <div><label>×¤×¢×•×œ×•×ª:</label></div>
            </div>
            <div id="featuresAdjustmentsList"></div>
            <div id="grossFeaturesCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ×¢×¨×š ×œ××—×¨ ×ª×•×¡×¤×•×ª ×××¤×™×™× ×™×: <span style="color: #28a745;">â‚ª0</span>
            </div>
            <button class="btn add" type="button" onclick="addFeatureAdjustment()">×”×•×¡×£ ×ª×•×¡×¤×ª ×××¤×™×™×Ÿ</button>
          </div>
        </div>
        
        <!-- Registration Adjustments -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">×¢×œ×™×” ×œ×›×‘×™×© (×ª××¨×™×š ×¨×™×©×•×):</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            ğŸ“… ×”×ª×××•×ª ×‘×’×™×Ÿ ×ª××¨×™×š ×¨×™×©×•× ×”×¨×›×‘ (×××¤×™×™×Ÿ ×§×‘×•×¢ ×©×œ ×”×¨×›×‘)
          </div>
          <div id="registrationAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>×ª×™××•×¨:</label></div>
              <div><label>×¡×•×’:</label></div>
              <div><label>××—×•×–:</label></div>
              <div><label>×¢×¨×š:</label></div>
              <div><label>×¤×¢×•×œ×•×ª:</label></div>
            </div>
            <div id="registrationAdjustmentsList"></div>
            <div id="grossRegistrationCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ×¢×¨×š ×œ××—×¨ ×¢×œ×™×” ×œ×›×‘×™×©: <span style="color: #28a745;">â‚ª0</span>
            </div>
            <button class="btn add" type="button" onclick="addRegistrationAdjustment()">×”×•×¡×£ ×ª×•×¡×¤×ª ×¢×œ×™×” ×œ×›×‘×™×©</button>
          </div>
        </div>
        
        <!-- Gross Market Value Result -->
        <div style="margin-top: 20px; padding: 15px; background: #f0f8ff; border-radius: 8px; border: 2px solid #4a90e2;">
          <div class="form-grid">
            <div><label><strong>×¢×¨×š ×”×¨×›×‘ ×œ× ×–×§ ×’×•×œ××™ ×›×•×œ×œ ××¢"×:</strong></label><input type="text" id="grossMarketValueResult" style="background: #f8f9fa; font-weight: bold;" readonly /></div>
            <div></div>
          </div>
        </div>
      </div>
    </div>

    <!-- FINAL REPORT ADJUSTMENTS SECTION -->

    <!-- GROSS DAMAGE PERCENTAGE RESULT -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('grossPercentageResult')">××—×•×– ×”× ×–×§ ×”×’×•×œ××™ - ×‘×¡×™×¡ ×”×¨×›×‘ ×‘×œ×‘×“ (×”×¦×’/×”×¡×ª×¨)</button>
      <div id="grossPercentageResult" style="display:none;">
        <div class="form-grid">
          <div><label>×¡×”×´×› ×¢×œ×•×ª × ×–×§×™×: <span style="color: #dc3545; font-size: 11px;">(×œ×¤×™ ×—×©×‘×•× ×™×ª/×”×¢×¨×›×”)</span></label><input type="text" id="totalClaimGross" style="background: #f8f9fa;" readonly /></div>
          <div><label>×¢×¨×š ×”×¨×›×‘ ×œ× ×–×§ ×’×•×œ××™:</label><input type="text" id="leviPriceList" style="background: #f8f9fa;" readonly /></div>
        </div>
        
        <!-- Additional Claims Data -->
        <div style="margin-top: 20px;">
          <div class="form-grid">
            <div><label>×¡×”"×› ×ª×‘×™×¢×” (×××•×©×¨):</label><input type="text" id="authorizedClaim" onchange="updateAuthorizedClaim(this); updateGrossPercentageField();" style="direction: ltr; text-align: right;" /></div>
            <div></div>
          </div>
        </div>
        
        <!-- Gross Percentage Result -->
        <div style="margin-top: 15px; padding: 15px; background: #f0f8ff; border-radius: 8px; border: 2px solid #e74c3c;">
          <div class="form-grid">
            <div><label><strong>××—×•×– ×”× ×–×§ ×”×’×•×œ××™:</strong></label><input type="text" id="grossPercent" style="background: #f8f9fa; font-weight: bold; color: #e74c3c;" readonly /></div>
            <div></div>
          </div>
          <div style="margin-top: 10px; font-size: 14px; color: #666;">
            <strong>×—×™×©×•×‘:</strong> ×¡×”×´×› ×ª×‘×™×¢×” (×××•×©×¨) Ã· ×¢×¨×š ×”×¨×›×‘ ×œ× ×–×§ ×’×•×œ××™ Ã— 100
          </div>
        </div>
      </div>
    </div>

    <!-- FULL MARKET VALUE CALCULATION -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('fullMarketValue')">×¢×¨×š ×”×©×•×§ ×”××œ× - ×›×•×œ×œ ×’×•×¨××™ ×©×™××•×© (×”×¦×’/×”×¡×ª×¨)</button>
      <div id="fullMarketValue" style="display:none;">
        <div class="form-grid">
          <div><label>×¢×¨×š ×”×¨×›×‘ ×¢"×¤ ××—×™×¨×•×Ÿ ×›×•×œ×œ ××¢"×:</label><input type="text" id="fullBasicPrice" placeholder="â‚ª" readonly style="background: #f8f9fa;" /></div>
          <div></div>
        </div>
        <div style="margin-top: 10px; text-align: right;">
          <button type="button" onclick="reloadFullMarketAdjustments()" style="background: #ff9500; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600;">×˜×¢×Ÿ ×”×ª×××•×ª ×œ×•×™ ×™×¦×—×§</button>
        </div>
        
        <!-- Features Adjustments (×ª×•×¡×¤×•×ª ×××¤×™×™× ×™×) -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">×ª×•×¡×¤×•×ª ×××¤×™×™× ×™× (×ª×›×•× ×•×ª ×”×¨×›×‘):</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            ğŸ—ï¸ ×ª×•×¡×¤×•×ª ×”×§×©×•×¨×•×ª ×œ×ª×›×•× ×•×ª ×¤×™×–×™×•×ª ×©×œ ×”×¨×›×‘ ×¢×¦××•
          </div>
          <div id="fullFeaturesAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>×ª×™××•×¨:</label></div>
              <div><label>×¡×•×’:</label></div>
              <div><label>××—×•×–:</label></div>
              <div><label>×¢×¨×š:</label></div>
              <div><label>×¤×¢×•×œ×•×ª:</label></div>
            </div>
            <div id="fullFeaturesAdjustmentsList"></div>
            <div id="featuresCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ×¢×¨×š ×œ××—×¨ ×ª×•×¡×¤×•×ª ×××¤×™×™× ×™×: <span style="color: #28a745;">â‚ª118,000</span>
            </div>
            <button class="btn add" type="button" onclick="addFullMarketFeatureAdjustment()">×”×•×¡×£ ×ª×•×¡×¤×ª ×××¤×™×™×Ÿ</button>
          </div>
        </div>
        
        <!-- Registration Adjustments (×¢×œ×™×” ×œ×›×‘×™×©) -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">×¢×œ×™×” ×œ×›×‘×™×© (×ª××¨×™×š ×¨×™×©×•×):</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            ğŸ“… ×”×ª×××•×ª ×‘×’×™×Ÿ ×ª××¨×™×š ×¨×™×©×•× ×”×¨×›×‘ (×××¤×™×™×Ÿ ×§×‘×•×¢ ×©×œ ×”×¨×›×‘)
          </div>
          <div id="fullRegistrationAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>×ª×™××•×¨:</label></div>
              <div><label>×¡×•×’:</label></div>
              <div><label>××—×•×–:</label></div>
              <div><label>×¢×¨×š:</label></div>
              <div><label>×¤×¢×•×œ×•×ª:</label></div>
            </div>
            <div id="fullRegistrationAdjustmentsList"></div>
            <div id="registrationCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ×¢×¨×š ×œ××—×¨ ×¢×œ×™×” ×œ×›×‘×™×©: <span style="color: #28a745;">â‚ª118,000</span>
            </div>
            <button class="btn add" type="button" onclick="addFullMarketRegistrationAdjustment()">×”×•×¡×£ ×ª×•×¡×¤×ª ×¢×œ×™×” ×œ×›×‘×™×©</button>
          </div>
        </div>
        
        <!-- Mileage Adjustments (××¡ ×§"×) -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">××¡ ×§"×:</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            ğŸš— ×”×ª×××•×ª ×‘×’×™×Ÿ ×§"× ×©×œ ×”×¨×›×‘
          </div>
          <div id="mileageAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>×ª×™××•×¨:</label></div>
              <div><label>×¡×•×’:</label></div>
              <div><label>××—×•×–:</label></div>
              <div><label>×¢×¨×š:</label></div>
              <div><label>×¤×¢×•×œ×•×ª:</label></div>
            </div>
            <div id="mileageAdjustmentsList"></div>
            <div id="mileageCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ×¢×¨×š ×œ××—×¨ ××¡ ×§"×: <span style="color: #dc3545;">â‚ª86,312</span>
            </div>
            <button class="btn add" type="button" onclick="addMileageAdjustment()">×”×•×¡×£ ×”×ª×××ª ××¡ ×§"×</button>
          </div>
        </div>
        
        <!-- Ownership Type Adjustments (×¡×•×’ ×‘×¢×œ×•×ª) -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">×¡×•×’ ×‘×¢×œ×•×ª:</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            ğŸ¢ ×”×ª×××•×ª ×‘×’×™×Ÿ ×¡×•×’ ×‘×¢×œ×•×ª (×¤×¨×˜×™, ×—×‘×¨×”, ×œ×™×¡×™× ×’)
          </div>
          <div id="ownershipAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>×ª×™××•×¨:</label></div>
              <div><label>×¡×•×’:</label></div>
              <div><label>××—×•×–:</label></div>
              <div><label>×¢×¨×š:</label></div>
              <div><label>×¤×¢×•×œ×•×ª:</label></div>
            </div>
            <div id="ownershipAdjustmentsList"></div>
            <div id="ownershipCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ×¢×¨×š ×œ××—×¨ ×¡×•×’ ×‘×¢×œ×•×ª: <span style="color: #dc3545;">â‚ª84,586</span>
            </div>
            <button class="btn add" type="button" onclick="addOwnershipAdjustment()">×”×•×¡×£ ×”×ª×××ª ×¡×•×’ ×‘×¢×œ×•×ª</button>
          </div>
        </div>
        
        <!-- Number of Owners Adjustments (××¡×¤×¨ ×‘×¢×œ×™×) -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">××¡×¤×¨ ×‘×¢×œ×™×:</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            ğŸ‘¥ ×”×ª×××•×ª ×‘×’×™×Ÿ ××¡×¤×¨ ×‘×¢×œ×™× ×§×•×“××™×
          </div>
          <div id="ownersAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>×ª×™××•×¨:</label></div>
              <div><label>×¡×•×’:</label></div>
              <div><label>××—×•×–:</label></div>
              <div><label>×¢×¨×š:</label></div>
              <div><label>×¤×¢×•×œ×•×ª:</label></div>
            </div>
            <div id="ownersAdjustmentsList"></div>
            <div id="ownersCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ×¢×¨×š ×œ××—×¨ ××¡×¤×¨ ×‘×¢×œ×™×: <span style="color: #dc3545;">â‚ª70,206</span>
            </div>
            <button class="btn add" type="button" onclick="addOwnersAdjustment()">×”×•×¡×£ ×”×ª×××ª ××¡×¤×¨ ×‘×¢×œ×™×</button>
          </div>
        </div>
        
        <!-- Additional Market Adjustments -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">×”×ª×××•×ª ×©×•×§ × ×•×¡×¤×•×ª:</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            ğŸ’¡ ×”×ª×××•×ª × ×•×¡×¤×•×ª ×‘×’×™×Ÿ ×©×•×•×™ ×©×•×§
          </div>
          <div id="allAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>×ª×™××•×¨:</label></div>
              <div><label>×¡×•×’:</label></div>
              <div><label>××—×•×–:</label></div>
              <div><label>×¢×¨×š:</label></div>
              <div><label>×¤×¢×•×œ×•×ª:</label></div>
            </div>
            <div id="allAdjustmentsList">
              <!-- This will be populated from helper data -->
            </div>
            <button class="btn add" type="button" onclick="addFullMarketAdjustment()">×”×•×¡×£ ×”×ª×××” × ×•×¡×¤×ª</button>
          </div>
        </div>
        
        <!-- Full Market Value Result -->
        <div style="margin-top: 20px; padding: 15px; background: #f0f8ff; border-radius: 8px; border: 2px solid #28a745;">
          <div class="form-grid">
            <div><label><strong>×¢×¨×š ×”×©×•×§ ×”××œ× ×©×œ ×”×¨×›×‘ ×›×•×œ×œ ××¢"×:</strong></label><input type="text" id="fullMarketValueResult" style="background: #f8f9fa; font-weight: bold; color: #28a745;" readonly /></div>
            <div></div>
          </div>
          <div style="margin-top: 10px; font-size: 14px; color: #666;">
            <strong>×—×™×©×•×‘:</strong> (××—×™×¨ ×‘×¡×™×¡ + ×”×ª×××•×ª ×¨×›×‘) + ×”×ª×××•×ª ×©×™××•×©
          </div>
        </div>
      </div>
    </div>


    <!-- DEPRECIATION CALCULATION SECTION -->
    <div class="form-section" id="depreciationSection">
      <button class="collapsible-btn" type="button" onclick="toggleSection('depreciationContent')">×—×™×©×•×‘ ×™×¨×™×“×ª ×¢×¨×š ×œ×¤×™ ××•×§×“×™ × ×–×§ (×”×¦×’/×”×¡×ª×¨)</button>
      <div id="depreciationContent" style="display: none;">
        <h3>×—×™×©×•×‘ ×™×¨×™×“×ª ×¢×¨×š ×œ×¤×™ ××•×§×“×™ × ×–×§</h3>
        <div style="display:grid; grid-template-columns:70px 2fr 2fr 80px 90px 80px; gap:14px; margin-bottom:10px;">
        <div><label>××¡' ××•×§×“:</label></div>
        <div><label>×”×—×œ×§ ×”× ×™×–×•×§:</label></div>
        <div><label>××”×•×ª ×”×ª×™×§×•×Ÿ:</label></div>
        <div><label>% ×™×¨×™×“×ª ×¢×¨×š:</label></div>
        <div><label>×¢×¨×š ×‘-â‚ª:</label></div>
        <div><label>×¤×¢×•×œ×•×ª:</label></div>
      </div>
      <div id="depreciationBulkTable"></div>
      <button class="btn add" type="button" onclick="addDepField()">×”×•×¡×£ ×©×“×”</button>
      <div style="margin-top:14px;">
        <label>×™×¨×™×“×ª ×¢×¨×š ×’×œ×•×‘×œ×™:</label>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:14px;">
          <input type="text" id="globalDep1" placeholder="×™×¨×™×“×ª ×¢×¨×š" style="direction: ltr; text-align: right;" />
          <input type="text" id="globalDepValue" placeholder="×¢×¨×š ×‘-â‚ª" readonly style="background:#f4f6fa;" />
        </div>
      </div>
      <div style="margin-top:14px;">
        <label>×™××™ ××•×¡×š ××©×•×¢×¨×™×:</label>
        <input type="number" id="garageDays" placeholder="××¡×¤×¨ ×™××™ ×¢×‘×•×“×”" style="width: 200px;" onchange="updateHelperDepreciationField(this, 'work_days_impact');" />
      </div>
      <br><br>
  </div>
    </div>
    </div> <!-- Close depreciationContent -->
    <br><br>

    <!-- SESSION 62: Case Reduction Section Placeholder -->
    <div id="caseReductionPlaceholder"></div>

    <!-- COLLAPSIBLE PRICE DATA -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('priceData')">× ×ª×•× ×™ ×ª×‘×™×¢×” (×”×¦×’/×”×¡×ª×¨)</button>
      <div id="priceData" style="display:none;">
        <div class="form-grid">
          <div>
            <label>×¡×”×´×› ×ª×‘×™×¢×” (×¡×›×•× ××•×§×“×™ × ×–×§):</label>
            <div class="readonly-box" id="totalClaim">0</div>
          </div>
          <div>
            <label>×—×™×©×•×‘ ×”×¢×¨×š ×œ× ×–×§ ×’×•×œ××™:</label>
            <div class="readonly-box" id="grossDamageValue">×™×—×•×©×‘ ××•×˜×•××˜×™×ª ××”×ª×××•×ª ×œ×•×™</div>
          </div>
          <div>
            <label>×—×™×©×•×‘ ×”××—×•×– ×”×’×•×œ××™:</label>
            <div class="readonly-box" id="grossPercentage">×™×—×•×©×‘ ××•×˜×•××˜×™×ª</div>
          </div>
          <div>
            <label>××—×™×¨ ×©×•×§ (×‘×¡×™×¡ + ×”×ª×××•×ª):</label>
            <div class="readonly-box" id="marketPriceCalculated">×™×—×•×©×‘ ××•×˜×•××˜×™×ª</div>
          </div>
          <div>
            <label>×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘ (×œ×¤×™ ×“×•×´×— ×œ×•×™ ×™×¦×—×§): </label>
            <div class="readonly-box" id="finalMarketValue">×™×—×•×©×‘ ××”×ª×××•×ª ×œ×•×™</div>
          </div>
          <div>
            <label>××™×©×•×¨ ×—×‘×¨×ª ×‘×™×˜×•×— (××•×¤×¦×™×•× ×œ×™):</label>
            <input type="text" id="insuranceAuthorization" placeholder="â‚ª" onchange="updateClaimsDataFromField(this, 'authorized_claim');" style="direction: ltr; text-align: right;" />
          </div>
        </div>
      </div>
    </div>

    <!-- SUMMARY SECTIONS CONTAINER -->
    <div style="text-align: center; margin: 20px 0;">
      <button onclick="location.reload()" style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 14px; cursor: pointer; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">ğŸ”„ ×¨×¢× ×Ÿ ×“×£</button>
    </div>
    <div class="summary-container">
    
    <!-- SUMMARY SECTION - PROPER FINAL REPORT VERSION -->
    <div class="form-section summary-block" id="summaryPrivate" style="background: linear-gradient(135deg, #0346a4 0%, #042676 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">×¡×™×›×•× - ×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª</h3>
      
      <!-- Final Report Date Section -->
      <div style="background: rgba(255,255,255,0.9); color: #333; border-radius: 8px; padding: 12px; margin-bottom: 15px; text-align: center;">
        <div style="margin-bottom: 8px;">
          <label style="color: #1e3a8a; font-weight: bold; font-size: 14px;">×ª××¨×™×š ×—×•×•×ª ×”×“×¢×ª:</label>
        </div>
        <div>
          <input type="date" id="finalReportDateSummary" onchange="updateHelperFromField(event);" style="background: white; color: #333; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px;" />
        </div>
      </div>
      <div style="background: rgba(255,255,255,0.95); color: #333; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
        <div class="form-grid">
        <div>
          <label style="color: #333;">×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘:</label>
          <input type="text" id="sumMarketValue" style="background: white; color: #333;" value="â‚ª158,901" />
        </div>
        <div>
          <label style="color: #333;">×¡×”×´×› ×ª×‘×™×¢×”:</label>
          <input type="text" id="sumClaim" style="background: white; color: #333;" />
        </div>
        <div>
          <label style="color: #333;">×¤×™×¦×•×™ ×‘×’×™×Ÿ ×™×¨×™×“×ª ×¢×¨×š:</label>
          <input type="text" id="depCompensation" style="background: white; color: #333;" />
        </div>
        <div>
          <label style="color: #333;">×ª×•×¡×¤×•×ª ×•×”×•×¨×“×•×ª (××™×“×¢ ×‘×œ×‘×“):</label>
          <input type="text" id="adjustmentsInfo" style="background: #f0f0f0; color: #666;" readonly />
        </div>
        </div>
      </div>
      <div style="background: rgba(255,255,255,0.95); color: #333; border-radius: 8px; padding: 15px;">
        <div class="form-grid">
          <div>
            <label style="color: #333;">×¡×”×´×› × ×›×œ×œ ×‘×—×•×•×ª ×”×“×¢×ª:</label>
            <input type="text" id="sumTotalBeforeDifferentials" style="background: white; color: #333;" />
          </div>
        </div>
      </div>
    </div>

    <div class="form-section summary-block" id="summaryGlobal" style="display:none; background: linear-gradient(135deg, #0346a4 0%, #042676 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">×¡×™×›×•× - ×—×•×•×ª ×“×¢×ª ×’×œ×•×‘×œ×™×ª</h3>
      <div class="form-grid">
        <div>
          <label>×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘:</label>
          <input type="text" id="sumMarketValueGlobal" />
        </div>
        <div>
          <label>×¡×”×´×› ×ª×‘×™×¢×”:</label>
          <input type="text" id="sumClaimGlobal" />
        </div>
        <div>
          <label>×¤×™×¦×•×™ ×‘×’×™×Ÿ ×™×¨×™×“×ª ×¢×¨×š:</label>
          <input type="text" id="depCompensationGlobal" />
        </div>
      </div>
      <div class="form-grid" style="margin-top:16px;">
        <div>
          <label>×¡×”×´×› × ×›×œ×œ ×‘×—×•×•×ª ×”×“×¢×ª:</label>
          <input type="text" id="sumTotalGlobal" />
        </div>
      </div>
    </div>

    <div class="form-section summary-block" id="summaryDamage" style="display:none; background: linear-gradient(135deg, #0346a4 0%, #042676 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">×¡×™×›×•× - ××¦×‘×• ×”× ×™×–×•×§</h3>
      <div class="form-grid">
        <div>
          <label>×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘:</label>
          <input type="text" id="sumMarketValueDamage" />
        </div>
        <div>
          <label>×¢×¨×š ×”××›×™×¨×” ×‘××¦×‘×• ×”× ×™×–×•×§:</label>
          <input type="text" id="saleValueDamage" />
        </div>
        <div>
          <label>×©×™×˜×ª ×ª×©×œ×•×:</label>
          <input type="text" id="paymentMethod" placeholder="××–×•××Ÿ, ×¦'×§, ×”×¢×‘×¨×” ×‘× ×§××™×ª..." />
        </div>
      </div>
      <div class="form-grid" style="margin-top:16px;">
        <div>
          <label>×¡×”×´×› ×œ××—×¨ ××›×™×¨×”:</label>
          <input type="text" id="afterSaleDamage" />
        </div>
      </div>
    </div>

    <div class="form-section summary-block" id="summaryTotalLoss" style="display:none; background: linear-gradient(135deg, #0346a4 0%, #042676 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">×¡×™×›×•× - ×˜×•×˜×œ×•×¡×˜</h3>
      <div class="form-grid">
        <div>
          <label>×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘:</label>
          <input type="text" id="sumMarketValueTotal" />
        </div>
        <div>
          <label>×¢×¨×š ×©×¨×™×“×™ ×”×¨×›×‘:</label>
          <input type="text" id="salvageValueTotal" />
        </div>
        <div>
          <label>×ª×•×¡×¤×ª ×’×¨×™×¨×” ×•××—×¡× ×”:</label>
          <input type="text" id="storageValueTotal" />
        </div>
      </div>
      <div class="form-grid" style="margin-top:16px;">
        <div>
          <label>×¡×”×´×› ×œ××—×¨ ××›×™×¨×ª ×©×¨×™×“×™×:</label>
          <input type="text" id="afterSaleTotal" style="background: white; color: #333;" />
        </div>
      </div>
    </div>

    <div class="form-section summary-block" id="summaryLegalLoss" style="display:none; background: linear-gradient(135deg, #0346a4 0%, #042676 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">×¡×™×›×•× - ××•×‘×“×Ÿ ×œ×”×œ×›×”</h3>
      <div class="form-grid">
        <div>
          <label>×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘:</label>
          <input type="text" id="sumMarketValueLegal" />
        </div>
        <div>
          <label>×¢×¨×š ×©×¨×™×“×™ ×”×¨×›×‘:</label>
          <input type="text" id="salvageValueLegal" />
        </div>
      </div>
      <div class="form-grid" style="margin-top:16px;">
        <div>
          <label>×¡×”×´×› ×œ××—×¨ ××›×™×¨×ª ×©×¨×™×“×™×:</label>
          <input type="text" id="afterSaleLegal" style="background: white; color: #333;" />
        </div>
      </div>
    </div>

    <!-- ADDITIONAL NOTES -->
    <div class="form-section">
      <h3>×”×¢×¨×•×ª × ×•×¡×¤×•×ª ×œ×—×•×•×ª ×“×¢×ª</h3>
      <textarea id="additional-notes" placeholder="×”×•×¡×£ ×”×¢×¨×•×ª, ×”××œ×¦×•×ª ××• ××™×“×¢ × ×•×¡×£ ×œ×—×•×•×ª ×“×¢×ª..." style="min-height: 80px; font-family: sans-serif; font-size: 16px;" onchange="updateHelperFromField(event);"></textarea>
    </div>

    <!-- LEGAL TEXT SECTION - EDITABLE (MOVED BEFORE NAVIGATION) -->
    <div class="form-section" id="legal-text">
      <h3>×˜×§×¡×˜ ××©×¤×˜×™ ×œ×—×•×•×ª ×“×¢×ª</h3>
      <div style="margin-bottom: 10px;">
        <button type="button" onclick="loadLegalTextFromVault()" style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-left: 10px;">×˜×¢×Ÿ ××”×›×¡×¤×ª</button>
        <button type="button" onclick="resetLegalText()" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">××™×¤×•×¡ ×˜×§×¡×˜</button>
      </div>
      <textarea id="legal-text-content" style="width: 100%; min-height: 200px; padding: 15px; border: 1px solid #e2e8f0; border-radius: 6px; background: #f8f9fa; line-height: 1.6; font-family: inherit; resize: vertical; box-sizing: border-box;" placeholder="×”×˜×§×¡×˜ ×”××©×¤×˜×™ ×™×˜×¢×Ÿ ×›××Ÿ ×¢× ×”× ×ª×•× ×™× ×”××¢×•×“×›× ×™×..." onchange="updateHelperFromField(event);"></textarea>
      <div style="margin-top: 8px; font-size: 14px; color: #666;">
        ğŸ’¡ ×”×˜×§×¡×˜ × ×™×ª×Ÿ ×œ×¢×¨×™×›×” ×œ×¦×•×¨×š ×”×ª×××” ×œ×“×•×— ×”×¡×¤×¦×™×¤×™. ×”×©×™× ×•×™×™× ×œ× ×™×©×¤×™×¢×• ×¢×œ ×”×›×¡×¤×ª ×”××§×•×¨×™×ª.
      </div>
    </div>

    <!-- VAT RATE SETTINGS -->
    <div class="form-section" id="vat-settings" style="background: #fff3cd; border-left: 4px solid #ffc107;">
      <h3 style="color: #856404;">ğŸ›ï¸ ×”×’×“×¨×•×ª ××¢"×</h3>
      <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px;">
        <div style="font-size: 14px; color: #495057; margin-bottom: 10px;">
          <strong>××§×•×¨ ×©×™×¢×•×¨ ××¢"× × ×•×›×—×™:</strong> <span id="vat-source-display">×˜×•×¢×Ÿ...</span><br>
          <strong>×¢×“×›×•×Ÿ ××—×¨×•×Ÿ:</strong> <span id="vat-updated-display">×˜×•×¢×Ÿ...</span>
        </div>
        <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
          <label style="font-weight: bold; color: #495057;">×©×™×¢×•×¨ ××¢"× (%):</label>
          <input type="number" id="vat-rate-input" min="0" max="100" step="0.1" 
                 style="width: 80px; padding: 6px; border: 1px solid #ced4da; border-radius: 4px;" 
                 value="" placeholder="18">
          <button type="button" onclick="updateVatRate()" 
                  style="background: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">
            ×¢×“×›×Ÿ ××¢"×
          </button>
          <button type="button" onclick="resetVatRateFromAdmin()" 
                  style="background: #6c757d; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">
            ××¤×¡ ×œ×¢×¨×š ×× ×”×œ
          </button>
        </div>
        <div style="font-size: 12px; color: #6c757d; margin-top: 8px;">
          ğŸ’¡ ×©×™× ×•×™ ×©×™×¢×•×¨ ×”××¢"× ×™×©×¤×™×¢ ×¢×œ ×›×œ ×”×—×™×©×•×‘×™× ×‘×“×•"×— ×–×”. ×”×©×™× ×•×™ ×œ× ×™×©×¤×™×¢ ×¢×œ ×”××§×¨×™× ×”××—×¨×™×.
        </div>
      </div>
    </div>

    <!-- ATTACHMENTS SECTION - EDITABLE -->
    <div class="form-section" id="attachments-section">
      <h3>×¨×©×™××ª × ×¡×¤×—×™×</h3>
      <div style="margin-bottom: 10px;">
        <button type="button" onclick="loadAttachmentsFromVault()" style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-left: 10px;">×˜×¢×Ÿ ××”×›×¡×¤×ª</button>
        <button type="button" onclick="resetAttachments()" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">××™×¤×•×¡ ×¨×©×™××”</button>
      </div>
      <textarea id="attachments-content" style="width: 100%; min-height: 120px; padding: 15px; border: 1px solid #e2e8f0; border-radius: 6px; background: #f8f9fa; line-height: 1.6; font-family: inherit; resize: vertical; box-sizing: border-box;" placeholder="×¨×©×™××ª ×”× ×¡×¤×—×™× ×ª×˜×¢×Ÿ ×›××Ÿ..."><strong>×œ×•×˜×”</strong>
×ª×¦×œ×•××™ ×”×¨×›×‘ ×”× ×™×–×•×§
×—×©×‘×•× ×™×•×ª ×ª×™×§×•×Ÿ
×¢×¨×š ×¨×›×‘ ×××•×—×©×‘
×¦×™×œ×•× ×¨×™×©×™×•×Ÿ ×”×¨×›×‘
×—×©×›"×˜</textarea>
      <div style="margin-top: 8px; font-size: 14px; color: #666;">
        ğŸ’¡ ×”×¨×©×™××” × ×™×ª× ×ª ×œ×¢×¨×™×›×” ×œ×¦×•×¨×š ×”×ª×××” ×œ×“×•×— ×”×¡×¤×¦×™×¤×™. ×”×©×™× ×•×™×™× ×œ× ×™×©×¤×™×¢×• ×¢×œ ×”×›×¡×¤×ª ×”××§×•×¨×™×ª.
      </div>
    </div>

    <!-- Navigation Buttons -->
    <div class="form-section">
      <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px;">
        <button type="button" class="nav-btn save-btn" onclick="saveDepreciationData()">×©××•×¨ × ×ª×•× ×™×</button>
        <button type="button" class="nav-btn" style="background: #1e40af;" onclick="previewFinalReport()">
          <span style="margin-left: 5px;">ğŸ‘ï¸</span>
          ×ª×¦×•×’×” ××§×“×™××” ×œ×—×•×•×´×“
        </button>
        <button type="button" class="nav-btn" style="background: #059669;" onclick="continueToValidation()">
          <span style="margin-left: 5px;">âœ…</span>
          ×”××©×š ×œ×©×›×¨ ×˜×¨×—×”
        </button>
        <button type="button" class="nav-btn back-btn" onclick="window.location.href='selection.html'">×—×–×•×¨ ×œ×“×£ ×”×‘×—×™×¨×”</button>
      </div>
    </div>

    </div> <!-- Close summary-container -->

    <div class="footer"> Carmel Cayouf 2025 Â© All rights reserved. SmartVal Pro System by Evalix. </div>
  </div>
</div>

  
  <!-- Load Legal Text Engine -->
  <script src="legal-text-engine.js"></script>
  
  <script>
    // Early function declarations to prevent ReferenceError
    window.updateHelperFromContactField = function(element) {
      console.log('Early updateHelperFromContactField called, will be replaced by full implementation');
    };

    // ğŸ”’ CRITICAL: Block any redirects to index.html IMMEDIATELY on page load
    (function() {
      console.log('ğŸ”’ Installing redirect blocker...');
      
      // Monitor for navigation attempts
      window.addEventListener('beforeunload', function(e) {
        console.error('ğŸš« PAGE UNLOAD DETECTED');
        console.trace('Unload from:');
      });
      
      // Intercept location.replace
      const originalReplace = window.location.replace;
      window.location.replace = function(url) {
        if (url && (url.includes('index.html') || url.includes('/index.html'))) {
          console.error('ğŸš« BLOCKED: location.replace() to:', url);
          console.trace('Replace blocked from:');
          return;
        }
        return originalReplace.call(window.location, url);
      };
      
      // Intercept location.assign
      const originalAssign = window.location.assign;
      window.location.assign = function(url) {
        if (url && (url.includes('index.html') || url.includes('/index.html'))) {
          console.error('ğŸš« BLOCKED: location.assign() to:', url);
          console.trace('Assign blocked from:');
          return;
        }
        return originalAssign.call(window.location, url);
      };
      
      console.log('âœ… Redirect blocker installed');
    })();

    // GROSS SECTION IMPORT STATE TRACKING
    let grossSectionImportState = {
      hasImportedOnce: false,
      userHasManagedData: false,
      featuresImported: false,
      registrationImported: false
    };

    // IMMEDIATE FUNCTION DEFINITIONS - MUST BE AVAILABLE BEFORE DOM LOADS
    
    // Helper function to safely parse amounts and prevent NaN
    function safeParseAmount(value) {
      if (!value || value === '') return 0;
      
      // Convert to string if not already
      const strValue = String(value);
      
      // Remove currency symbols (â‚ª and ×©), commas, and spaces
      const cleanedValue = strValue.replace(/[â‚ª×©,\s]/g, '');
      
      // Parse the cleaned value
      const parsed = parseFloat(cleanedValue);
      
      // Return 0 if parsing resulted in NaN, otherwise round to whole number
      return isNaN(parsed) ? 0 : Math.round(parsed);
    }
    
    // Helper function to check if a type is a reduction/minus type
    function isReductionType(type) {
      return type === 'minus' || type === '×”×¤×—×ª×”' || type === '×”×¤×—×ª×” (-)' || type === '×”×•×¨×“×”';
    }
    window.toggleFloatingScreen = function(screenType) {
      
      const screens = {
        leviReport: () => {
          if (window.toggleLeviReport) {
            window.toggleLeviReport();
          } else {
          }
        },
        carDetails: () => {
          if (window.toggleCarDetails) {
            window.toggleCarDetails();
          } else {
          }
        },
        internalBrowser: () => {
          if (window.showBrowserMenu) {
            showBrowserMenuUnderToggle();
          } else {
          }
        },
        invoiceDetails: () => {
          if (window.toggleInvoiceDetails) {
            window.toggleInvoiceDetails();
          } else {
            alert('××¡×š ×¤×¨×˜×™ ×—×©×‘×•× ×™×•×ª ×™×”×™×” ×–××™×Ÿ ×‘×§×¨×•×‘\nInvoice details screen coming soon');
          }
        },
        partsSearchResults: () => {
          if (window.togglePartsSearchResults) {
            window.togglePartsSearchResults();
          } else {
            console.log('Parts search results floating screen not available');
          }
        }
      };
      
      if (screens[screenType]) {
        screens[screenType]();
      } else {
      }
    };
    
    window.toggleSection = function(sectionId) {
      
      const section = document.getElementById(sectionId);
      if (section) {
        const isVisible = section.style.display !== 'none';
        section.style.display = isVisible ? 'none' : 'block';
      } else {
      }
    };
    // Authentication check - Supabase compatible
    const authData = sessionStorage.getItem("auth");
    if (!authData) {
      alert("×”×’×™×©×” ×—×¡×•××” - ×× × ×”×ª×—×‘×¨ ×“×¨×š ×“×£ ×”×‘×™×ª");
      window.location.href = "index.html";
    } else {
      try {
        const auth = JSON.parse(authData);
        if (auth.user && auth.session) {
          console.log('âœ… Valid Supabase session for:', auth.user.email);
          
          // CRITICAL: Prevent any unauthorized redirects after this point
          window.__finalReportBuilderAuthVerified = true;
          console.log('ğŸ”’ Page lock engaged - redirects blocked');
        } else {
          console.log('âš ï¸ Using legacy auth system');
        }
      } catch (e) {
        console.log('âš ï¸ Using legacy auth system (non-JSON)');
      }
    }
    
    // CRITICAL: Monitor for redirect attempts with beforeunload
    window.addEventListener('beforeunload', function(e) {
      if (window.__finalReportBuilderAuthVerified) {
        console.error('ğŸš« PAGE UNLOAD DETECTED - Something is trying to leave final-report-builder');
        console.trace('Unload triggered from:');
        // This won't prevent unload but will show us what's happening
      }
    });
    
    // Intercept navigation by wrapping window.location.replace and window.location.assign
    const originalReplace = window.location.replace;
    const originalAssign = window.location.assign;
    
    window.location.replace = function(url) {
      if (window.__finalReportBuilderAuthVerified && url && url.includes('index.html')) {
        console.error('ğŸš« BLOCKED: location.replace() to index.html');
        console.trace('Replace blocked from:');
        return;
      }
      return originalReplace.call(window.location, url);
    };
    
    window.location.assign = function(url) {
      if (window.__finalReportBuilderAuthVerified && url && url.includes('index.html')) {
        console.error('ğŸš« BLOCKED: location.assign() to index.html');
        console.trace('Assign blocked from:');
        return;
      }
      return originalAssign.call(window.location, url);
    };

    // FLOATING SCREENS TOGGLE FUNCTION - COPIED FROM DEPRECIATION MODULE

    // CUSTOM BROWSER MENU - COPIED FROM DEPRECIATION MODULE
    function showBrowserMenuUnderToggle() {
      const menu = document.createElement('div');
      menu.style.cssText = `
        position: fixed;
        top: 90px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 20px;
        z-index: 99999;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        font-family: sans-serif;
        direction: rtl;
        min-width: 280px;
      `;
      
      menu.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 15px; color: #2c3e50; font-size: 16px;">×‘×—×¨ ××ª×¨ ×œ×¤×ª×™×—×”:</div>
        <button onclick="window.openInternalBrowser('car-part.co.il'); this.parentElement.remove();" style="width: 100%; padding: 12px; margin-bottom: 8px; border: none; background: #28a745; color: white; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: 500;">
          ğŸ”§ Car Part - ×—×œ×§×™ ×¨×›×‘
        </button>
        <button onclick="window.openInternalBrowser('portal.levi-itzhak.co.il'); this.parentElement.remove();" style="width: 100%; padding: 12px; margin-bottom: 8px; border: none; background: #007bff; color: white; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: 500;">
          ğŸ“Š ×¤×•×¨×˜×œ ×œ×•×™ ×™×¦×—×§
        </button>
        <button onclick="this.parentElement.remove();" style="width: 100%; padding: 10px; border: 1px solid #ccc; background: white; color: #666; border-radius: 6px; cursor: pointer; font-size: 14px;">
          ×‘×™×˜×•×œ
        </button>
      `;
      
      document.body.appendChild(menu);
      
      // Remove menu when clicking outside
      setTimeout(() => {
        document.addEventListener('click', function removeMenu(e) {
          if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', removeMenu);
          }
        });
      }, 100);
    }

    // COLLAPSIBLE SECTION TOGGLE
    function toggleSection(sectionId) {
      const section = document.getElementById(sectionId);
      if (section) {
        section.style.display = section.style.display === 'none' ? 'block' : 'none';
        
        // Save state to sessionStorage
        const isVisible = section.style.display !== 'none';
        sessionStorage.setItem(`section-${sectionId}`, isVisible ? 'expanded' : 'collapsed');
      } else {
      }
    }

    // DAMAGE CENTERS SECTION TOGGLE
    function toggleDamageCentersSection() {
      const section = document.getElementById('damageCentersSummary');
      const toggleBtn = document.getElementById('damageCentersToggleBtn');
      
      if (section && toggleBtn) {
        const isVisible = section.style.display !== 'none';
        
        if (isVisible) {
          // Hide section
          section.style.display = 'none';
          toggleBtn.innerHTML = 'ğŸ”¼ ×¤×ª×—';
          toggleBtn.style.background = '#28a745';
        } else {
          // Show section
          section.style.display = 'block';
          toggleBtn.innerHTML = 'ğŸ”½ ×¡×’×•×¨';
          toggleBtn.style.background = '#6c757d';
        }
        
        // Save state to sessionStorage
        sessionStorage.setItem('damageCentersSection', isVisible ? 'collapsed' : 'expanded');
      }
    }

    
    // ADD DEPRECIATION FIELD FUNCTION
    function addDepField(data = {}) {
      const container = document.getElementById('depreciationBulkTable');
      if (!container) {
        return;
      }
      
      const rowId = 'depRow_' + Date.now();
      const newRow = `
        <div id="${rowId}" class="dep-row" style="display:grid; grid-template-columns:70px 2fr 2fr 80px 90px 80px; gap:10px; margin-bottom:8px;">
          <div><input type="text" placeholder="××¡' ××•×§×“" value="${data.center_number || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" style="text-align: center;" title="${data.center_number || ''}" /></div>
          <div><input type="text" placeholder="×”×—×œ×§ ×”× ×™×–×•×§" value="${data.damaged_part || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="${data.damaged_part || ''}" /></div>
          <div><input type="text" placeholder="××”×•×ª ×”×ª×™×§×•×Ÿ" value="${data.repair_type || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="${data.repair_type || ''}" /></div>
          <div><input type="text" placeholder="×™×¨×™×“×ª ×¢×¨×š (××¡×¤×¨)" value="${data.percent || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="${data.percent || ''}" style="direction: ltr; text-align: right;" /></div>
          <div><input type="text" placeholder="×¢×¨×š ×‘-â‚ª" value="${data.value || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="â‚ª${data.value || ''}" /></div>
          <div><button class="btn remove" onclick="removeDepField('${rowId}')">××—×§</button></div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      
      // Add auto-calculation functionality to the percentage field
      const row = document.getElementById(rowId);
      
      // Add tooltip update listeners to all input fields
      const inputs = row.querySelectorAll('input');
      inputs.forEach(input => {
        input.addEventListener('input', function() {
          this.title = this.value;
        });
      });
      const percentInput = row.querySelector('input[placeholder="×™×¨×™×“×ª ×¢×¨×š (××¡×¤×¨)"]');
      const valueInput = row.querySelector('input[placeholder="×¢×¨×š ×‘-â‚ª"]');
      
      percentInput.addEventListener('input', function() {
        // Clean the value to extract the numeric part for calculation only
        const cleanValue = this.value.replace('%', '').replace(/[^0-9.-]/g, '');
        let percent = parseFloat(cleanValue) || 0;
        
        // Don't modify the input value - keep it as the user entered it
        
        // Calculate value from market price automatically
        const marketValueField = document.getElementById('carMarketValue') || document.getElementById('sumMarketValue');
        const marketValueStr = marketValueField?.value.replace(/[â‚ª,]/g, '') || '0';
        const marketValue = parseFloat(marketValueStr) || 0;
        
        const calculatedValue = (marketValue * percent) / 100;
        valueInput.value = calculatedValue ? `â‚ª${Math.round(calculatedValue).toLocaleString()}` : '';
        
        // Save data after calculation
        saveDepreciationData();
      });
    }

    // âœ… REAL-TIME 2-WAY DATA FLOW: Update helper.depreciation immediately when UI fields change
    function updateHelperDepreciationField(element, fieldName) {
      try {
        const helper = window.helper || {};
        if (!helper.depreciation) helper.depreciation = {};
        
        let value = element.value;
        
        // Handle different field types
        switch(fieldName) {
          case 'global_percentage':
            // Clean the value: remove % sign and handle decimal values correctly
            const cleanValue = value.replace('%', '').replace(/[^0-9.-]/g, '');
            helper.depreciation.global_percentage = parseFloat(cleanValue) || 0;
            // Also trigger the calculation
            calculateGlobalDepreciationValue();
            break;
          case 'work_days_impact':
            helper.depreciation.work_days_impact = parseInt(value) || 0;
            break;
          default:
            helper.depreciation[fieldName] = value;
        }
        
        helper.depreciation.last_updated = new Date().toISOString();
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        
        // Trigger helper update broadcast
        if (typeof broadcastHelperUpdate === 'function') {
          broadcastHelperUpdate(['depreciation'], 'depreciation_field_update');
        }
      } catch (error) {
      }
    }
    
    // REMOVE DEPRECIATION FIELD FUNCTION
    function removeDepField(rowId) {
      const row = document.getElementById(rowId);
      if (row) {
        row.remove();
        // Save after removal
        saveDepreciationData();
      }
    }

    // NEW CLEAN SAVE FUNCTION - ONLY SAVES ADJUSTMENTS DATA
    function saveAdjustmentsData() {
      console.log('ğŸ’¾ SAVE ADJUSTMENTS BUTTON CLICKED!');
      const button = document.querySelector('.save-btn');
      
      // Show visual feedback
      if (button) {
        button.style.background = '#059669';
        button.innerHTML = 'â³ ×©×•××¨ ×”×ª×××•×ª...';
        button.disabled = true;
      }
      
      // Phase 6: Capture user ID for tracking
      let userId = null;
      let userName = null;
      try {
        const authData = sessionStorage.getItem('auth');
        if (authData) {
          const auth = JSON.parse(authData);
          userId = auth?.user?.id;
          userName = auth?.profile?.name;
        }
      } catch (e) {
        console.warn('Could not extract user ID:', e);
      }
      
      try {
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // CRITICAL: Only save adjustments data using syncAdjustmentToHelper pattern
        // This preserves user edits without triggering competing functions
        
        console.log('ğŸ”„ Saving adjustments data using syncAdjustmentToHelper pattern...');
        
        // FIRST: Save depreciation data (same as old button)
        const globalPercent = document.getElementById('globalDep1')?.value || '';
        const globalValue = document.getElementById('globalDepValue')?.value || '';
        
        const depreciationData = {
          global_percent: globalPercent,
          global_value: globalValue,
          bulk_items: []
        };
        
        // Collect depreciation rows
        const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
        depRows.forEach((row, index) => {
          const inputs = row.querySelectorAll('input');
          if (inputs.length >= 5) {
            depreciationData.bulk_items.push({
              center_number: inputs[0].value,
              damaged_part: inputs[1].value,
              repair_type: inputs[2].value,
              percent: inputs[3].value,
              value: inputs[4].value
            });
          }
        });
        
        // Save depreciation data to helper (same structure as old button)
        if (!helper.depreciation) helper.depreciation = {};
        helper.depreciation = {
          global_percentage: parseFloat(String(globalPercent).replace('%', '').replace(/[^0-9.-]/g, '')) || 0,
          global_amount: parseFloat(String(globalValue).replace(/[â‚ª,]/g, '')) || 0,
          work_days_impact: parseInt(document.getElementById('garageDays')?.value) || 0,
          bulk_items: depreciationData.bulk_items,
          last_updated: new Date().toISOString(),
          source: 'final_report_builder'
        };
        
        if (!helper.final_report) helper.final_report = {};
        helper.final_report.depreciation = helper.depreciation;
        
        console.log('âœ… Depreciation data saved');
        
        // SECOND: Save all adjustment categories using the proven syncAdjustmentToHelper logic
        const categories = [
          { category: 'features', containerId: 'featuresAdjustmentsList' },
          { category: 'features', containerId: 'fullFeaturesAdjustmentsList' },
          { category: 'registration', containerId: 'registrationAdjustmentsList' }, 
          { category: 'registration', containerId: 'fullRegistrationAdjustmentsList' },
          { category: 'mileage', containerId: 'mileageAdjustmentsList' },
          { category: 'ownership_type', containerId: 'ownershipAdjustmentsList' },
          { category: 'ownership_history', containerId: 'ownersAdjustmentsList' },
          { category: 'additional', containerId: 'allAdjustmentsList' }
        ];
        
        categories.forEach(({ category, containerId }) => {
          const container = document.getElementById(containerId);
          if (container && container.children.length > 0) {
            // Trigger syncAdjustmentToHelper for each category to save current UI state
            const firstInput = container.children[0].querySelector('input');
            if (firstInput) {
              console.log(`ğŸ’¾ Saving ${category} from ${containerId}`);
              syncAdjustmentToHelper(firstInput, category);
            }
          }
        });
        
        // Save updated helper to sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper; // Update window.helper too
        
        console.log('âœ… ADJUSTMENTS DATA SAVED SUCCESSFULLY!');
        
        // Show success feedback
        if (button) {
          button.style.background = '#16a34a';
          button.innerHTML = 'âœ… × ×©××¨!';
          setTimeout(() => {
            button.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
            button.innerHTML = '×©××•×¨ ×”×ª×××•×ª';
            button.disabled = false;
          }, 2000);
        }
        
      } catch (error) {
        console.error('âŒ Error saving adjustments data:', error);
        
        // Show error feedback
        if (button) {
          button.style.background = '#dc3545';
          button.innerHTML = 'âŒ ×©×’×™××”';
          setTimeout(() => {
            button.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
            button.innerHTML = '×©××•×¨ ×”×ª×××•×ª';
            button.disabled = false;
          }, 3000);
        }
      }
    }

    // OLD DEPRECIATION SAVE FUNCTION - KEEP FOR OTHER FUNCTIONALITY
    function saveDepreciationData() {
      console.log('ğŸ’¾ SAVE DATA BUTTON CLICKED!');
      const button = document.querySelector('.save-btn');
      
      // Show visual feedback
      if (button) {
        button.style.background = '#059669';
        button.innerHTML = 'â³ ×©×•××¨...';
        button.disabled = true;
      }
      
      // Phase 6: Capture user ID for tracking
      let userId = null;
      let userName = null;
      try {
        const authData = sessionStorage.getItem('auth');
        if (authData) {
          const auth = JSON.parse(authData);
          userId = auth?.user?.id;
          userName = auth?.profile?.name;
        }
      } catch (e) {
        console.warn('Could not extract user ID:', e);
      }
      
      try {
        // Get helper data from sessionStorage (single source of truth) to ensure consistency
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Get global depreciation values
        const globalPercent = document.getElementById('globalDep1')?.value || '';
        const globalValue = document.getElementById('globalDepValue')?.value || '';
        
        
        // Collect depreciation data
        const depreciationData = {
          global_percent: globalPercent,
          global_value: globalValue,
          bulk_items: []
        };
        
        // Collect data from all depreciation rows
        const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
        console.log('ğŸ’¾ Collecting data from', depRows.length, 'depreciation rows');
        
        depRows.forEach((row, index) => {
          const inputs = row.querySelectorAll('input');
          if (inputs.length >= 5) {
            const item = {
              center_number: inputs[0].value,
              damaged_part: inputs[1].value,
              repair_type: inputs[2].value,
              // Keep percent value as entered by user
              percent: inputs[3].value,
              value: inputs[4].value
            };
            console.log(`  Row ${index + 1}:`, item);
            depreciationData.bulk_items.push(item);
          }
        });
        
        // âœ… CORRECT 2-WAY DATA FLOW: Save to main helper.depreciation structure
        if (!helper.depreciation) helper.depreciation = {};
        
        
        // Save to main depreciation section (single source of truth) with COMPLETE structure
        try {
          
          helper.depreciation = {
            // Form field names (for direct loading) - keep the value as entered by user
            globalDep1: globalPercent,
            globalDepValue: globalValue,
            garageDays: document.getElementById('garageDays')?.value || '',
            
            // Processed values (for calculations)  
            global_percentage: parseFloat(String(globalPercent).replace('%', '').replace(/[^0-9.-]/g, '')) || 0,
            global_amount: parseFloat(String(globalValue).replace(/[â‚ª,]/g, '')) || 0,
            work_days_impact: parseInt(document.getElementById('garageDays')?.value) || 0,
            
            // Array data (single array, no duplication)
            bulk_items: depreciationData.bulk_items,
            
            // Metadata
            last_updated: new Date().toISOString(),
            lastSaved: new Date().toISOString(),
            source: 'final_report_builder',
            isManualSave: true
          };
          
        } catch (error) {
        }
        
        // Also maintain final_report reference for compatibility
        if (!helper.final_report) helper.final_report = {};
        helper.final_report.depreciation = helper.depreciation;
        
        // Initialize adjustments structure mirroring estimate.adjustments
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // âœ… REMOVED: No longer saving to manual_depreciation - everything is in helper.depreciation
        
        // Phase 6: Add user tracking to meta
        if (!helper.meta) helper.meta = {};
        helper.meta.updated_by = userId;
        helper.meta.updated_by_name = userName;
        helper.meta.last_updated = new Date().toISOString();
        
        // âœ… CRITICAL FIX: Update BOTH sessionStorage AND in-memory window.helper to prevent populateAllForms overwrite
        sessionStorage.setItem('helper', JSON.stringify(helper));
        if (window.helper) {
          window.helper.depreciation = helper.depreciation;
          window.helper.final_report = helper.final_report;
          window.helper.meta = helper.meta;
        }
        
        console.log('âœ… Depreciation data saved successfully:', helper.depreciation);
        console.log('âœ… Updated window.helper:', window.helper);
        
        // Trigger helper update broadcast for real-time sync
        if (typeof broadcastHelperUpdate === 'function') {
          broadcastHelperUpdate(['depreciation'], 'depreciation_update');
        }
        
        console.log('âœ… DATA SAVED SUCCESSFULLY!');
        
        // Show success message using the standard message system
        showSectionMessage('depreciation', 'âœ… × ×ª×•× ×™ ×™×¨×™×“×ª ×¢×¨×š × ×©××¨×• ×‘×”×¦×œ×—×”', 'success');
        
        // Show success feedback on button
        if (button) {
          button.style.background = '#16a34a';
          button.innerHTML = 'âœ… × ×©××¨!';
          setTimeout(() => {
            button.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
            button.innerHTML = '×©××•×¨ × ×ª×•× ×™×';
            button.disabled = false;
          }, 2000);
        }
        
      } catch (error) {
        console.error('âŒ SAVE ERROR:', error);
        
        // Show error feedback
        if (button) {
          button.style.background = '#dc2626';
          button.innerHTML = 'âŒ ×©×’×™××”';
          setTimeout(() => {
            button.style.background = '#ef4444';
            button.innerHTML = '×©××•×¨ × ×ª×•× ×™×';
            button.disabled = false;
          }, 2000);
        }
      }
    }

    // ADD AUTO-CALCULATION TO EXISTING ROWS
    function addAutoCalculationToExistingRows() {
      const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
      depRows.forEach(row => {
        const percentInput = row.querySelector('input[placeholder="×™×¨×™×“×ª ×¢×¨×š (××¡×¤×¨)"]');
        const valueInput = row.querySelector('input[placeholder="×¢×¨×š ×‘-â‚ª"]');
        
        if (percentInput && valueInput) {
          // Remove any existing event listeners first
          percentInput.removeEventListener('input', percentInput.autoCalcHandler);
          
          // Create the auto-calculation handler
          const autoCalcHandler = function() {
            // Clean the value to extract the numeric part
            const cleanValue = this.value.replace('%', '').replace(/[^0-9.-]/g, '');
            let percent = parseFloat(cleanValue) || 0;
            
            // Keep value as clean decimal number without % sign
            this.value = cleanValue;
            
            // Calculate value from market price automatically
            const marketValueField = document.getElementById('carMarketValue') || document.getElementById('sumMarketValue');
            const marketValueStr = marketValueField?.value.replace(/[â‚ª,]/g, '') || '0';
            const marketValue = parseFloat(marketValueStr) || 0;
            
            const calculatedValue = (marketValue * percent) / 100;
            valueInput.value = calculatedValue ? `â‚ª${Math.round(calculatedValue).toLocaleString()}` : '';
            
            // Save data after calculation
            saveDepreciationData();
          };
          
          // Store the handler reference for potential removal
          percentInput.autoCalcHandler = autoCalcHandler;
          
          // Add the event listener
          percentInput.addEventListener('input', autoCalcHandler);
          
          // Trigger calculation for existing values
          if (percentInput.value) {
            autoCalcHandler.call(percentInput);
          }
        }
      });
    }

    // MAKE FUNCTIONS GLOBALLY ACCESSIBLE
    window.toggleSection = toggleSection;
    window.toggleDamageCentersSection = toggleDamageCentersSection;
    window.addDepField = addDepField;
    window.removeDepField = removeDepField;
    window.saveDepreciationData = saveDepreciationData;

    // BUTTON FUNCTIONS - NO DEBUG ALERTS
    window.saveFinalReport = function() {
      const selectedTypeElement = document.querySelector('input[name="final-report-type"]:checked');
      if (!selectedTypeElement) {
        alert('×× × ×‘×—×¨ ×¡×•×’ ×—×•×•×ª ×“×¢×ª');
        return;
      }
      
      const selectedType = selectedTypeElement.value;
      const additionalNotes = document.getElementById('additional-notes')?.value || '';
      const garageDays = document.getElementById('garageDays')?.value || '';
      
      // Get summary data
      const summaryData = {
        market_value: document.getElementById('sumMarketValue')?.value || '',
        total_claim: document.getElementById('sumClaim')?.value || '',
        vat: document.getElementById('sumVAT')?.value || '',
        total_with_vat: document.getElementById('sumTotalClaim')?.value || '',
        dep_compensation: document.getElementById('depCompensation')?.value || '',
        salvage_value: document.getElementById('salvageValue')?.value || ''
      };
      
      // Get depreciation data
      const depreciationData = {
        global_percent: document.getElementById('globalDep1')?.value || '',
        global_value: document.getElementById('globalDepValue')?.value || '',
        bulk_items: []
      };
      
      // Collect depreciation bulk items
      const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
      depRows.forEach(row => {
        const inputs = row.querySelectorAll('input');
        if (inputs.length >= 5) {
          depreciationData.bulk_items.push({
            center_number: inputs[0].value,
            damaged_part: inputs[1].value,
            repair_type: inputs[2].value,
            // Clean percent value to remove % and handle decimals properly
            percent: inputs[3].value.replace('%', '').replace(/[^0-9.-]/g, ''),
            value: inputs[4].value
          });
        }
      });
      
      // Collect adjustment data and save to helper.final_report.adjustments
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Initialize final_report.adjustments if not exists
      if (!helper.final_report) helper.final_report = {};
      if (!helper.final_report.adjustments) {
        helper.final_report.adjustments = {
          features: [],
          registration: [],
          mileage: [],
          ownership_type: [],
          ownership_history: [],
          usage: [],
          additional: []
        };
      }

      // Define adjustment mapping for all categories
      const adjustmentMappings = [
        { category: 'features', containerId: 'featuresAdjustmentsList' },
        { category: 'registration', containerId: 'registrationAdjustmentsList' },
        { category: 'features', containerId: 'fullFeaturesAdjustmentsList' }, // Full market features
        { category: 'registration', containerId: 'fullRegistrationAdjustmentsList' }, // Full market registration
        { category: 'mileage', containerId: 'mileageAdjustmentsList' },
        { category: 'ownership_type', containerId: 'ownershipAdjustmentsList' },
        { category: 'ownership_history', containerId: 'ownersAdjustmentsList' },
        { category: 'usage', containerId: 'usageAdjustmentsList' },
        { category: 'additional', containerId: 'allAdjustmentsList' }
      ];

      // Clear all categories in final_report.adjustments
      Object.keys(helper.final_report.adjustments).forEach(key => {
        helper.final_report.adjustments[key] = [];
      });

      // Collect adjustments from all containers
      adjustmentMappings.forEach(({ category, containerId }) => {
        const container = document.getElementById(containerId);
        if (container) {
          // Try different row selectors based on container structure
          let rows = container.querySelectorAll('div.adjustment-row');
          if (rows.length === 0) {
            // Fallback for containers that use direct child divs
            rows = container.children;
          }
          
          Array.from(rows).forEach(row => {
            const inputs = row.querySelectorAll('input, select');
            
            if (inputs.length >= 4) {
              const adjustmentItem = {
                value: inputs[0].value || '', // Field mapping: ×ª×™××•×¨ â†’ value
                type: inputs[1].value || 'plus', // Field mapping: ×¡×•×’ â†’ type
                percent: parseFloat(inputs[2].value) || 0, // Field mapping: ××—×•×– â†’ percent
                percentage: parseFloat(inputs[2].value) || 0, // Backward compatibility
                amount: safeParseAmount(inputs[3].value),
                amount_display: inputs[3].value || '',
                source: 'final_report',
                timestamp: new Date().toISOString()
              };

              // Apply proper sign based on type
              if (adjustmentItem.type === 'minus') {
                adjustmentItem.percent = -Math.abs(adjustmentItem.percent);
                adjustmentItem.percentage = -Math.abs(adjustmentItem.percentage);
                adjustmentItem.amount = -Math.abs(adjustmentItem.amount);
              }

              helper.final_report.adjustments[category].push(adjustmentItem);
            }
          });
        }
      });

      // Update valuation.adjustments with original items only (first item of each category)
      if (!helper.valuation) helper.valuation = {};
      if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
      
      Object.keys(helper.final_report.adjustments).forEach(category => {
        const items = helper.final_report.adjustments[category];
        if (items.length > 0 && items[0].source !== 'final_report') {
          // Only update valuation if the first item is from original estimate data
          helper.valuation.adjustments[category] = items[0];
        }
      });

      // Legacy format for compatibility
      const adjustmentsData = {
        features: helper.final_report.adjustments.features,
        registration: helper.final_report.adjustments.registration,
        full_market: helper.final_report.adjustments.additional
      };
      
      // Collect legal text
      const legalText = document.getElementById('legal-text-content')?.value || '';
      
      // Save to helper using proper function
      const finalReportData = {
        type: selectedType,
        notes: additionalNotes,
        work_days: garageDays,
        summary: summaryData,
        depreciation: depreciationData,
        adjustments: adjustmentsData,
        legal_text: legalText
      };
      
      // Save the helper object with updated adjustments
      sessionStorage.setItem('helper', JSON.stringify(helper));
      if (window.helper) {
        window.helper = helper;
      }

      if (typeof updateHelper === 'function') {
        updateHelper('final_report', finalReportData, 'final_report_builder_save');
      } else {
        // Fallback for compatibility - already updated helper above
        Object.assign(helper.final_report, finalReportData);
        sessionStorage.setItem('helper', JSON.stringify(helper));
      }
      
      // âœ… BIDIRECTIONAL INTEGRATION: Update builder current state with all final report data
      updateBuilderCurrentState('final_report.type', selectedType);
      updateBuilderCurrentState('final_report.notes', additionalNotes);
      updateBuilderCurrentState('final_report.work_days', garageDays);
      updateBuilderCurrentState('final_report.summary', summaryData);
      updateBuilderCurrentState('final_report.depreciation', depreciationData);
      // Removed: updateBuilderCurrentState('final_report.adjustments', adjustmentsData); - using valuation.adjustments instead
      updateBuilderCurrentState('final_report.legal_text', legalText);
      
      alert('×—×•×•×ª ×“×¢×ª ×¡×•×¤×™×ª × ×©××¨×” ×‘×”×¦×œ×—×”');
    };

    window.previewFinalReport = function() {
      // First save all data
      window.saveFinalReport();
      
      // Set report type and navigate
      sessionStorage.setItem('selectedReportType', 'final-report');
      window.location.href = 'final-report-validation.html';
    };

    window.generateFinalReport = function() {
      // First save all data
      window.saveFinalReport();
      
      // Set report type and navigate to fee module
      sessionStorage.setItem('selectedReportType', 'final-report');
      window.location.href = 'fee-module.html';
    };

    // Convert various date formats to YYYY-MM-DD for date input
    function convertToDateInputFormat(dateString) {
      if (!dateString) return '';
      
      try {
        // Handle various date formats
        let date;
        
        // If already in YYYY-MM-DD format, return as is
        if (/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
          return dateString;
        }
        
        // Handle DD/MM/YYYY format
        if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateString)) {
          const parts = dateString.split('/');
          const day = parts[0].padStart(2, '0');
          const month = parts[1].padStart(2, '0');
          const year = parts[2];
          return `${year}-${month}-${day}`;
        }
        
        // Handle DD-MM-YYYY format
        if (/^\d{1,2}-\d{1,2}-\d{4}$/.test(dateString)) {
          const parts = dateString.split('-');
          const day = parts[0].padStart(2, '0');
          const month = parts[1].padStart(2, '0');
          const year = parts[2];
          return `${year}-${month}-${day}`;
        }
        
        // Handle DD.MM.YYYY format
        if (/^\d{1,2}\.\d{1,2}\.\d{4}$/.test(dateString)) {
          const parts = dateString.split('.');
          const day = parts[0].padStart(2, '0');
          const month = parts[1].padStart(2, '0');
          const year = parts[2];
          return `${year}-${month}-${day}`;
        }
        
        // Try to parse as a general date
        date = new Date(dateString);
        if (!isNaN(date.getTime())) {
          return date.toISOString().split('T')[0];
        }
        
        return '';
      } catch (error) {
        return '';
      }
    }

    // LOAD DATA FROM HELPER
    function loadDataFromHelper() {
      try {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Clean up redundant duplicate damage_assessment.centers section on page load
        if (helper.damage_assessment?.centers) {
          delete helper.damage_assessment.centers;
          if (Object.keys(helper.damage_assessment).length === 0) {
            delete helper.damage_assessment;
          }
          // Save cleaned helper
          sessionStorage.setItem('helper', JSON.stringify(helper));
          window.helper = helper;
        }
        
        // Helper function to get nested values
        const getNestedValue = (obj, path, defaultValue = '') => {
          const keys = path.split('.');
          let current = obj;
          for (const key of keys) {
            if (current && typeof current === 'object' && key in current) {
              current = current[key];
            } else {
              return defaultValue;
            }
          }
          return current || defaultValue;
        };
        
        // Load car details (now editable) and sync vehicle structure
        if (helper.car_details || helper.meta) {
          document.getElementById('carPlate').value = helper.meta?.plate || helper.car_details?.plate || '';
          document.getElementById('carManufacturer').value = helper.car_details?.manufacturer || '';
          document.getElementById('carModel').value = helper.car_details?.model || '';
          document.getElementById('carYear').value = helper.car_details?.year || '';
          document.getElementById('carModelCode').value = helper.car_details?.model_code || helper.vehicle?.model_code || '';
          // Base price from standardized valuation structure (with legacy fallback)
          const rawBasePrice = helper.valuation?.base_price || helper.car_details?.base_price || helper.levi_report?.base_price;
          // Clean any existing currency symbols and parse as number
          const basePrice = rawBasePrice ? parseFloat(String(rawBasePrice).replace(/[â‚ª,]/g, '')) : null;
          document.getElementById('carBasePrice').value = basePrice ? `â‚ª${basePrice.toLocaleString()}` : '';
          
          // Also populate the basicPrice field (marked price field) with levi base price
          const basicPriceField = document.getElementById('basicPrice');
          if (basicPriceField && basePrice) {
            basicPriceField.value = `â‚ª${basePrice.toLocaleString()}`;
          }
          // Market value from standardized vehicle structure (with legacy fallback) 
          const rawMarketValue = helper.calculations?.full_market_value || helper.vehicle?.market_value || helper.valuation?.market_value;
          
          // DEBUG: Track where 80487 comes from
          if (helper.vehicle?.market_value) {
          }
          if (helper.calculations?.full_market_value) {
          }
          if (helper.valuation?.market_value) {
          }
          
          // Clean any existing currency symbols and parse as number
          const marketValue = rawMarketValue ? parseFloat(String(rawMarketValue).replace(/[â‚ª,]/g, '')) : null;
          
          // Debug market value loading
          if (marketValue && marketValue > 0) {
          } else {
          }
          
          document.getElementById('carMarketValue').value = marketValue ? `â‚ª${marketValue.toLocaleString()}` : '';
          // Load finalReportDate from car_details like other fields
          const finalReportDateValue = helper.car_details?.final_report_date || new Date().toISOString().split('T')[0];
          const topDateField = document.getElementById('finalReportDate');
          const summaryDateField = document.getElementById('finalReportDateSummary');
          
          if (topDateField) topDateField.value = convertToDateInputFormat(finalReportDateValue);
          if (summaryDateField) summaryDateField.value = convertToDateInputFormat(finalReportDateValue);
          
          // Load saved full market value from helper if it exists
          const savedFullMarketValue = helper.calculations?.full_market_value;
          if (savedFullMarketValue) {
            const fullMarketValueField = document.getElementById('fullMarketValueResult');
            if (fullMarketValueField) {
              fullMarketValueField.value = `â‚ª${savedFullMarketValue.toLocaleString()}`;
            }
          }
          
          // Ensure vehicle structure is populated on load
          helper.vehicle = helper.vehicle || {};
          helper.vehicle.manufacturer = helper.car_details?.manufacturer || helper.vehicle.manufacturer || '';
          helper.vehicle.model = helper.car_details?.model || helper.vehicle.model || '';
          helper.vehicle.year = helper.car_details?.year || helper.vehicle.year || '';
          helper.vehicle.model_code = helper.car_details?.model_code || helper.vehicle.model_code || '';
          helper.vehicle.plate_number = helper.meta?.plate || helper.car_details?.plate || helper.vehicle.plate_number || '';
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        
        // Load claims data section fields - ××™×¤×•×™ × ×ª×•× ×™ ×ª×‘×™×¢×”
        const calc = helper.expertise?.calculations || {};
        const claimsData = helper.claims_data || {};
        const leviData = helper.levi_report || helper.levisummary || {};
        
        // 1. ×¡×”×´×› ×ª×‘×™×¢×” (×¡×›×•× ××•×§×“×™ × ×–×§) - Total Claim from damage centers
        const totalClaimDiv = document.getElementById('totalClaim');
        const formattedClaim = claimsData.total_claim || 
          (calc.total_damage ? `â‚ª${calc.total_damage.toLocaleString()}` : '') ||
          (helper.damage_centers_summary?.total_cost ? `â‚ª${helper.damage_centers_summary.total_cost.toLocaleString()}` : '');
        if (totalClaimDiv) {
          totalClaimDiv.innerText = formattedClaim;
        }
        
        // Load totalClaimGross field from damage_assessment.totals["Total with VAT"] 
        const totalClaimGrossField = document.getElementById('totalClaimGross');
        let totalClaimGrossValue = helper.damage_assessment?.totals?.["Total with VAT"] || 0;
        
        if (totalClaimGrossField) {
          totalClaimGrossField.value = totalClaimGrossValue ? `â‚ª${totalClaimGrossValue.toLocaleString()}` : '';
        }
        
        // Load authorizedClaim field - SAME source as totalClaimGross (NO fallback)
        const authorizedClaimField = document.getElementById('authorizedClaim');
        if (authorizedClaimField) {
          const useValue = totalClaimGrossValue ? `â‚ª${totalClaimGrossValue.toLocaleString()}` : '';
          const numericValue = totalClaimGrossValue;
          
          authorizedClaimField.value = useValue;
          
          // Ensure both storage locations are updated
          if (!helper.claims_data) helper.claims_data = {};
          if (!helper.calculations) helper.calculations = {};
          helper.claims_data.total_claim = useValue;
          helper.calculations.total_damage = numericValue;
        }
        
        
        // 2. ×—×™×©×•×‘ ×”×¢×¨×š ×œ× ×–×§ ×’×•×œ××™ - Gross damage value (from Levi adjustments)
        const grossDamageValueDiv = document.getElementById('grossDamageValue');
        const grossValue = helper.calculations?.vehicle_value_gross || 
          leviData.final_price || 
          (helper.valuation?.calculations?.gross_price?.total) || 0;
        if (grossDamageValueDiv && grossValue > 0) {
          grossDamageValueDiv.innerText = `â‚ª${grossValue.toLocaleString()}`;
        }
        
        // 3. ×—×™×©×•×‘ ×”××—×•×– ×”×’×•×œ××™ - Gross percentage calculation
        const grossPercentageDiv = document.getElementById('grossPercentage');
        const grossPercent = claimsData.gross_percent || 
          (helper.calculations?.damage_percent ? `${helper.calculations.damage_percent}%` : '') ||
          (calc.damage_percent ? `${calc.damage_percent}%` : '');
        if (grossPercentageDiv) {
          grossPercentageDiv.innerText = grossPercent;
        }
        
        // 4. ××—×™×¨ ×©×•×§ (×‘×¡×™×¡ + ×”×ª×××•×ª) - Market price CORRECTED MAPPING
        const marketPriceDiv = document.getElementById('marketPriceCalculated');
        let marketPrice = helper.calculations?.full_market_value || 
                         helper.expertise?.calculations?.market_value || 
                         helper.vehicle?.market_value || 
                         helper.valuation?.market_value || 0;
        
        // DEBUG: Check what's in helper for market value
        console.log('ğŸ” Market value debug:', {
          'helper.calculations': helper.calculations,
          'helper.calculations.full_market_value': helper.calculations?.full_market_value,
          'helper.expertise?.calculations?.market_value': helper.expertise?.calculations?.market_value,
          'helper.vehicle?.market_value': helper.vehicle?.market_value,
          'marketPrice': marketPrice
        });
        
        // Handle string values that need parsing
        if (typeof marketPrice === 'string') {
          marketPrice = parseFloat(marketPrice.replace(/[â‚ª,]/g, '')) || 0;
        }
        
        if (marketPriceDiv && marketPrice > 0) {
          marketPriceDiv.innerText = `â‚ª${marketPrice.toLocaleString()}`;
        } else if (marketPriceDiv) {
          marketPriceDiv.innerText = '×œ× ×–××™×Ÿ';
        }
        
        // 5. ×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘ (×œ×¤×™ ×“×•×´×— ×œ×•×™ ×™×¦×—×§) - Final market value from Levi report
        const finalMarketValueDiv = document.getElementById('finalMarketValue');
        let finalMarketVal = helper.levisummary?.final_price || 
                            helper.levi_report?.final_price || 
                            helper.expertise?.levi_report?.final_price || 0;
        
        // DEBUG: Check what's in helper for Levi data
        
        // Handle string values that need parsing
        if (typeof finalMarketVal === 'string') {
          finalMarketVal = parseFloat(finalMarketVal.replace(/[â‚ª,]/g, '')) || 0;
        }
        
        if (finalMarketValueDiv && finalMarketVal > 0) {
          finalMarketValueDiv.innerText = `â‚ª${finalMarketVal.toLocaleString()}`;
        } else if (finalMarketValueDiv) {
          finalMarketValueDiv.innerText = '×œ× ×–××™×Ÿ';
        }
        
        // Legacy field mappings for backward compatibility
        const leviPriceListField = document.getElementById('leviPriceList');
        if (leviPriceListField) {
          leviPriceListField.value = grossValue > 0 ? `â‚ª${grossValue.toLocaleString()}` : '';
        }
        
        const grossPercentField = document.getElementById('grossPercent');
        if (grossPercentField) {
          grossPercentField.value = grossPercent;
        }
        
          
        console.log('ğŸ’° × ×ª×•× ×™ ×ª×‘×™×¢×” mapped successfully:', { 
          totalClaim: formattedClaim,
          grossDamageValue: grossValue,
          grossPercentage: grossPercent,
          marketPrice: marketPrice,
          finalMarketValue: finalMarketVal
        });
        
        // Update gross market value field with calculated value
        updateGrossMarketValueField();
        
        // Force refresh of all cost displays and calculations
        setTimeout(() => {
          updateAllCostDisplays();
          updateSummaryTotalsFromDamageCenters();
          // loadGrossCalculationData(); // DISABLED - causes duplicate Levi data, loadGrossAdjustments() already handles this
        }, 200);
        
        // Load contact data using standardized helper structure - Populate ALL fields from standardized helper structure paths (with legacy fallback)
        document.getElementById('ownerName').value = getNestedValue(helper, 'stakeholders.owner.name') || helper.client?.name || '';
        document.getElementById('ownerAddress').value = getNestedValue(helper, 'stakeholders.owner.address') || helper.client?.address || '';  
        document.getElementById('ownerPhone').value = getNestedValue(helper, 'stakeholders.owner.phone') || helper.client?.phone || '';
        document.getElementById('insuranceCompany').value = getNestedValue(helper, 'stakeholders.insurance.company') || helper.client?.insurance_company || '';
        document.getElementById('insuranceEmail').value = getNestedValue(helper, 'stakeholders.insurance.email') || helper.client?.insurance_email || '';
        document.getElementById('insuranceAgent').value = getNestedValue(helper, 'stakeholders.insurance.agent.name') || helper.client?.insurance_agent || '';
        document.getElementById('agentPhone').value = getNestedValue(helper, 'stakeholders.insurance.agent.phone') || helper.client?.insurance_agent_phone || '';
        document.getElementById('agentEmail').value = getNestedValue(helper, 'stakeholders.insurance.agent.email') || helper.client?.insurance_agent_email || '';
        
        // Load garage data from stakeholders helper
        document.getElementById('garageName').value = getNestedValue(helper, 'stakeholders.garage.name') || helper.garage?.name || '';
        document.getElementById('garagePhone').value = getNestedValue(helper, 'stakeholders.garage.phone') || helper.garage?.phone || '';
        document.getElementById('garageEmail').value = getNestedValue(helper, 'stakeholders.garage.email') || helper.garage?.email || '';
        
          
        // Sync data to both standardized and legacy structures for compatibility
        helper.car_details = helper.car_details || {};
        helper.car_details.owner = getNestedValue(helper, 'stakeholders.owner.name') || helper.client?.name || '';
        helper.car_details.ownerAddress = getNestedValue(helper, 'stakeholders.owner.address') || helper.client?.address || '';
        helper.car_details.ownerPhone = getNestedValue(helper, 'stakeholders.owner.phone') || helper.client?.phone || '';
        helper.car_details.insuranceCompany = getNestedValue(helper, 'stakeholders.insurance.company') || helper.client?.insurance_company || '';
        helper.car_details.agentName = getNestedValue(helper, 'stakeholders.insurance.agent.name') || helper.client?.insurance_agent || '';
        helper.car_details.insurance_agent_phone = getNestedValue(helper, 'stakeholders.insurance.agent.phone') || helper.client?.insurance_agent_phone || '';
        helper.car_details.insurance_agent_email = getNestedValue(helper, 'stakeholders.insurance.agent.email') || helper.client?.insurance_agent_email || '';
          
          // Note: garageName and garagePhone are not in the builder, so they'll remain empty
          helper.car_details.garageName = helper.car_details.garageName || '';
          helper.car_details.garagePhone = helper.car_details.garagePhone || '';
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Update page title with plate
        // Standardize plate format
        const rawPlate = helper.meta?.plate || helper.car_details?.plate || '...';
        const standardizedPlate = rawPlate !== '...' ? String(rawPlate).replace(/[-\s]/g, '') : rawPlate;
        document.getElementById('pageTitle').textContent = `×¨×›×‘ ××¡. ${standardizedPlate}`;
        
        // Load summary data
        loadSummaryData(helper);
        
        // Load depreciation data
        loadDepreciationData(helper);
        
        // Load garage days data
        if (helper.final_report?.work_days || helper.expertise?.depreciation?.work_days) {
          document.getElementById('garageDays').value = helper.final_report?.work_days || helper.expertise?.depreciation?.work_days || '';
        }
        
        // Load damage centers summary
        loadDamageCentersSummary(helper);
        
        // Load features and registration adjustments for gross calculation
        loadGrossAdjustments(helper);
        
        // DISABLED: loadAllAdjustments - causes override of final_report data
        // loadAllAdjustments(helper);
        
        // Load Total Value Section adjustments from final_report.adjustments
        loadTotalValueSectionAdjustments(helper);
        
        // Set flag to prevent sync during page load before calculations
        window.pageLoadInProgress = true;
        
        // Trigger calculations after data is loaded
        setTimeout(() => {
          updateGrossMarketValueCalculation();
          
          // CRITICAL FIX: Allow more time for DOM updates before reading dropdown states
          setTimeout(() => {
            updateFullMarketValueCalculation();
            
            // CRITICAL: Save all adjustment data including added rows after calculations
            updateFullMarketValueToFinalReportAndValuation(helper);
            
            // CRITICAL: Trigger all change events to ensure formatAdjustmentDisplay runs
            triggerAllAdjustmentChangeEvents();
          }, 50);  // Additional delay to ensure dropdown states are ready
          
          // Save formatted state back to sessionStorage so refresh loads correct data  
          setTimeout(() => {
            // REMOVED: updateHelperFromAdjustments() to prevent overwriting calculated amounts on page load
            const updatedHelper = window.helper || {};
            sessionStorage.setItem('helper', JSON.stringify(updatedHelper));
            console.log('ğŸ’¾ Saved formatted helper state to sessionStorage after load with change events');
          }, 100);
        }, 150);
        
        
        // Note: addFieldChangeListeners() is called in DOMContentLoaded event
        
      } catch (error) {
        console.error('Error loading data from helper:', error);
      }
    }

    // POPULATE MARKET VALUE FOR CURRENT VARIANT - TARGETED APPROACH
    function populateMarketValueForCurrentVariant(helper, reportType) {
      try {
        // Handle different value formats (string, number, formatted)
        let marketValue = helper.calculations?.full_market_value || 0;
        
        if (typeof marketValue === 'string') {
          marketValue = parseFloat(marketValue.replace(/[â‚ª,\s]/g, '')) || 0;
        } else if (typeof marketValue === 'number') {
          marketValue = marketValue || 0;
        }
        
        console.log('ğŸ” Market value population - Type:', reportType, 'Value:', marketValue);
        
        if (marketValue <= 0) {
          console.log('âŒ No valid market value found');
          return;
        }
        
        // Target the correct field ID based on report type
        let targetFieldId = '';
        switch(reportType) {
          case '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª':
            targetFieldId = 'sumMarketValuePrivate';
            break;
          case '×—×•×•×ª ×“×¢×ª ×’×œ×•×‘×œ×™×ª':
            targetFieldId = 'sumMarketValueGlobal';
            break;
          case '×—×•×•×ª ×“×¢×ª ×˜×•×˜×œ×•×¡×˜':
            targetFieldId = 'sumMarketValueTotal';
            break;
          case '×—×•×•×ª ×“×¢×ª ××›×™×¨×” ××¦×‘×• ×”× ×™×–×•×§':
            targetFieldId = 'sumMarketValueDamage';
            break;
          case '×—×•×•×ª ×“×¢×ª ××•×‘×“×Ÿ ×œ×”×œ×›×”':
            targetFieldId = 'sumMarketValueLegal';
            break;
          default:
            targetFieldId = 'sumMarketValueDefault';
        }
        
        // Populate the target field
        const targetField = document.getElementById(targetFieldId);
        if (targetField) {
          const formattedValue = `â‚ª${marketValue.toLocaleString()}`;
          targetField.value = formattedValue;
          console.log(`âœ… Set ${targetFieldId} = ${formattedValue}`);
        } else {
          console.log(`âŒ Field ${targetFieldId} not found`);
        }
        
      } catch (error) {
        console.error('Error populating market value:', error);
      }
    }

    // LOAD SUMMARY FIELDS FROM HELPER - ENHANCED FOR ALL 5 REPORT VARIANTS
    function loadSummaryFieldsFromHelper(helper) {
      try {
        
        // ENSURE HELPER STRUCTURE EXISTS FOR ALL VARIANTS
        helper.final_report = helper.final_report || {};
        helper.final_report.summary = helper.final_report.summary || {};
        
        // AUTO-POPULATED FIELDS (COMMON ACROSS VARIANTS)
        
        // SIMPLE DIRECT MAPPING - NO COMPLICATIONS
        
        // 1. Market Value - ONLY from calculations.full_market_value
        const marketValue = helper.calculations?.full_market_value || 0;
        
        // Set market value for ALL variant fields immediately
        ['sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 'sumMarketValueTotal', 'sumMarketValueLegal', 'sumMarketValuePrivate'].forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.value = marketValue > 0 ? `â‚ª${marketValue.toLocaleString()}` : '';
          }
        });
        
        // 2. Total Claim - from helper.claims_data.total_claim
        let totalClaim = 0;
        
        // Parse from claims_data.total_claim (may be formatted string)
        if (helper.claims_data?.total_claim) {
          const claimValue = helper.claims_data.total_claim;
          if (typeof claimValue === 'string') {
            totalClaim = parseFloat(claimValue.replace(/[â‚ª,]/g, '')) || 0;
          } else {
            totalClaim = parseFloat(claimValue) || 0;
          }
        } 
        // Fallback to damage_centers_summary.total_cost
        else if (helper.damage_centers_summary?.total_cost) {
          totalClaim = parseFloat(helper.damage_centers_summary.total_cost) || 0;
        }
        
        // Populate all total claim fields across ALL variants
        const allClaimFields = ['sumClaim', 'sumClaimGlobal', 'sumClaimPrivate', 'sumClaimDefault'];
        allClaimFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            const formattedClaim = totalClaim > 0 ? `â‚ª${totalClaim.toLocaleString()}` : '';
            field.value = formattedClaim;
            helper.final_report.summary.total_claim = formattedClaim;
          }
        });
        
        // 3. Depreciation Compensation - from helper.depreciation.globalDepValue
        let depCompensation = 0;
        
        // Parse from globalDepValue (preferred)
        if (helper.depreciation?.globalDepValue) {
          const depValue = helper.depreciation.globalDepValue;
          if (typeof depValue === 'string') {
            depCompensation = parseFloat(depValue.replace(/[â‚ª,]/g, '')) || 0;
          } else {
            depCompensation = parseFloat(depValue) || 0;
          }
        }
        // Fallback to globalDep1 (may contain formatted string like "1,972â‚ª")
        else if (helper.depreciation?.globalDep1) {
          const dep1Value = helper.depreciation.globalDep1;
          if (typeof dep1Value === 'string') {
            depCompensation = parseFloat(dep1Value.replace(/[â‚ª,%]/g, '')) || 0;
          } else {
            depCompensation = parseFloat(dep1Value) || 0;
          }
        }
        // Final fallback to total_compensation
        else if (helper.depreciation?.total_compensation) {
          depCompensation = parseFloat(helper.depreciation.total_compensation) || 0;
        }
        
        // Populate all depreciation compensation fields across ALL variants
        const allDepFields = ['depCompensation', 'depCompensationGlobal', 'depCompensationPrivate', 'sumDepreciation', 'sumDepreciationDefault'];
        allDepFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            const formattedDepValue = depCompensation > 0 ? `â‚ª${depCompensation.toLocaleString()}` : '';
            field.value = formattedDepValue;
            helper.final_report.summary.dep_compensation = formattedDepValue;
          }
        });
        
        // 4. Adjustments Info - informative field only (not for calculations)
        const adjustmentsValue = helper.calculations?.final_adjustments_value || 0;
        const adjustmentsInfoField = document.getElementById('adjustmentsInfo');
        const adjustmentsInfoPrivateField = document.getElementById('adjustmentsInfoPrivate');
        
        const formattedAdjValue = adjustmentsValue !== 0 ? `â‚ª${adjustmentsValue.toLocaleString()}` : 'â‚ª0';
        
        // Populate both static and dynamic private fields
        if (adjustmentsInfoField) {
          adjustmentsInfoField.value = formattedAdjValue;
        }
        
        if (adjustmentsInfoPrivateField) {
          adjustmentsInfoPrivateField.value = formattedAdjValue;
        }
        
        if (!adjustmentsInfoField && !adjustmentsInfoPrivateField) {
        }
        helper.final_report.summary.adjustments_value = adjustmentsValue;
        
        // MANUAL INPUT FIELDS (VARIANT-SPECIFIC)
        
        // Load existing manual input values from helper structure
        const manualFields = [
          // Damaged Sale variant
          { fieldId: 'saleValueDamage', helperKey: 'sale_value_damaged' },
          { fieldId: 'paymentMethod', helperKey: 'paymentMethod' },
          { fieldId: 'afterSaleDamage', helperKey: 'total_after_sale_damage' },
          
          // Total Loss variant  
          { fieldId: 'salvageValueTotal', helperKey: 'salvage_value_total' },
          { fieldId: 'storageValueTotal', helperKey: 'storage_towing_value_total' },
          { fieldId: 'afterSaleTotal', helperKey: 'total_after_salvage_total' },
          
          // Legal Loss variant
          { fieldId: 'salvageValueLegal', helperKey: 'salvage_value_legal' },
          { fieldId: 'afterSaleLegal', helperKey: 'total_after_salvage_legal' },
          
          // Legacy fields
          { fieldId: 'salvageValue', helperKey: 'salvage_value' }
        ];
        
        // Load manual input fields and ensure they exist in helper structure
        manualFields.forEach(({ fieldId, helperKey }) => {
          const field = document.getElementById(fieldId);
          const savedValue = helper.final_report.summary[helperKey];
          
          if (field) {
            // ENHANCED PROTECTION: Don't overwrite calculated fields if they have calculated values
            const isCalculatedField = ['afterSaleDamage', 'afterSaleTotal', 'afterSaleLegal'].includes(fieldId);
            const hasValue = field.value && field.value.trim() !== '';
            const marketValue = helper.calculations?.full_market_value || 0;
            const isNotMarketValue = field.value !== `â‚ª${marketValue.toLocaleString()}`;
            
            if (isCalculatedField && hasValue && isNotMarketValue) {
              console.log(`ğŸ”’ ENHANCED PROTECTION: Preserving calculated field ${fieldId} = ${field.value} (blocked override with ${savedValue})`);
              // Also ensure the helper has the correct calculated value
              if (savedValue !== field.value) {
                helper.final_report.summary[helperKey] = field.value;
                sessionStorage.setItem('helper', JSON.stringify(helper));
                console.log(`ğŸ”„ Updated helper with preserved calculation: ${helperKey} = ${field.value}`);
              }
              return; // Skip this field to preserve calculation
            }
            // Load saved value if exists
            field.value = savedValue || '';
          }
          
          // Ensure field exists in helper structure (initialize if missing)
          if (!helper.final_report.summary.hasOwnProperty(helperKey)) {
            helper.final_report.summary[helperKey] = '';
          }
        });
        
        // Save updated helper structure
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Calculate totals based on loaded fields
        setTimeout(() => {
          calculateSummaryTotals();
        }, 100);
        
        
      } catch (error) {
        console.error('âŒ Error loading enhanced summary fields:', error);
      }
    }
    
    // CONSOLIDATED FIELD MAPPING - ELIMINATES DUPLICATES
    function getHelperMappingKey(fieldId) {
      const consolidatedMapping = {
        // UNIVERSAL FIELDS - ALL VARIANTS USE SAME KEY
        // Market Value - all variants write to same key
        'sumMarketValue': 'market_value',
        'sumMarketValueGlobal': 'market_value',
        'sumMarketValueDamage': 'market_value', 
        'sumMarketValueTotal': 'market_value',
        'sumMarketValueLegal': 'market_value',
        'sumMarketValuePrivate': 'market_value',
        
        // Total Claim - all variants write to same key
        'sumClaim': 'total_claim',
        'sumClaimPrivate': 'total_claim',
        'sumClaimGlobal': 'total_claim',
        
        // Depreciation Compensation - all variants write to same key
        'depCompensation': 'depreciation_compensation',
        'depCompensationPrivate': 'depreciation_compensation',
        'depCompensationGlobal': 'depreciation_compensation',
        'sumDepreciation': 'depreciation_compensation',
        
        // VARIANT-SPECIFIC FIELDS - UNIQUE VALUES
        // Private Report
        'sumTotalBeforeDifferentials': 'private_before_differentials',
        'sumTotalFinal': 'private_after_differentials',
        
        // Global Report  
        'sumTotalGlobal': 'global_before_differentials',
        // Damaged Sale Report
        'saleValueDamage': 'sale_value_damaged',
        'afterSaleDamage': 'damage_total_before_differentials',
        
        // Total Loss Report
        'salvageValueTotal': 'salvage_value_total_loss',
        'storageValueTotal': 'storage_towing_costs',
        'afterSaleTotal': 'total_loss_before_differentials',
        
        // Legal Loss Report
        'salvageValueLegal': 'salvage_value_legal_loss',
        'afterSaleLegal': 'legal_loss_before_differentials',
        
        // General fields
        'finalReportDateSummary': 'report_date'
      };
      return consolidatedMapping[fieldId] || null;
    }

    // LOAD ADDITIONAL NOTES FIELD
    function loadAdditionalNotesField() {
      try {
        const helper = window.helper || {};
        const additionalNotesField = document.getElementById('additional-notes');
        
        if (additionalNotesField) {
          // Check both 'notes' (from save) and 'comments' (from real-time save)
          const savedNotes = helper.final_report?.notes || helper.final_report?.comments || '';
          
          console.log('ğŸ” Loading additional notes field:', {
            fieldExists: true,
            notes: helper.final_report?.notes,
            comments: helper.final_report?.comments,
            savedNotes: savedNotes,
            currentValue: additionalNotesField.value
          });
          
          if (savedNotes) {
            additionalNotesField.value = savedNotes;
            console.log('âœ… Additional notes loaded successfully:', savedNotes.substring(0, 50) + '...');
          } else {
            console.log('âš ï¸ No saved notes found in helper');
          }
        } else {
          console.log('âŒ Additional notes field not found in DOM');
        }
      } catch (error) {
        console.error('âŒ Error loading additional notes:', error);
      }
    }

    // LOAD SUMMARY DATA AND CALCULATIONS - ENHANCED FOR AUTO-POPULATION
    function loadSummaryData(helper) {
      try {
        console.log('ğŸ“Š Loading summary data with enhanced auto-population');
        
        // DISABLED: Conflicting code that overrides saved dropdown selection
        // const selectedType = document.querySelector('input[name="final-report-type"]:checked')?.value || '××•×‘×“×Ÿ_×œ×”×œ×›×”';
        // const reportTypeText = selectedType === '××•×‘×“×Ÿ_×œ×”×œ×›×”' ? '×—×•×•×ª ×“×¢×ª ××•×‘×“×Ÿ ×œ×”×œ×›×”' : '×—×•×•×ª ×“×¢×ª ×˜×•×˜×œ×•×¡×˜';
        // document.getElementById('reportType').value = reportTypeText;
        console.log('ğŸ“‹ Skipping report type override - using saved dropdown selection');
        
        // ENHANCED AUTO-POPULATION SYSTEM
        
        // 1. Market Value Auto-Population (from mapping analysis)
        const marketValue = helper.calculations?.full_market_value || 0;
        if (marketValue > 0) {
          console.log(`ğŸ’° Auto-populating market value: â‚ª${marketValue.toLocaleString()}`);
          
          // Auto-populate all market value fields using comprehensive mapping
          const marketValueFields = ['sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 'sumMarketValueTotal', 'sumMarketValueLegal'];
          marketValueFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
              field.value = `â‚ª${marketValue.toLocaleString()}`;
              // Update helper using comprehensive mapping
              const mappingKey = getHelperMappingKey(fieldId);
              if (mappingKey) {
                helper.final_report.summary[mappingKey] = field.value;
              }
            }
          });
        }
        
        // 2. Total Claim Auto-Population (from mapping analysis)  
        const totalClaim = helper.claims_data?.total_claim || 0;
        if (totalClaim > 0) {
          console.log(`ğŸ’° Auto-populating total claim: â‚ª${totalClaim.toLocaleString()}`);
          const sumClaimField = document.getElementById('sumClaim');
          if (sumClaimField) {
            sumClaimField.value = `â‚ª${totalClaim.toLocaleString()}`;
            helper.final_report.summary.total_claim = sumClaimField.value;
          }
        }
        
        // 3. Depreciation Compensation Auto-Population (from mapping analysis)
        const depCompensation = helper.depreciation?.globalDepValue || 0;
        if (depCompensation > 0) {
          console.log(`ğŸ’° Auto-populating depreciation compensation: â‚ª${depCompensation.toLocaleString()}`);
          const depCompensationField = document.getElementById('depCompensation');
          if (depCompensationField) {
            depCompensationField.value = `â‚ª${depCompensation.toLocaleString()}`;
            helper.final_report.summary.dep_compensation = depCompensationField.value;
          }
        }
        
        // 4. Adjustments Value Auto-Population (from mapping analysis)
        const adjustmentsValue = helper.calculations?.final_adjustments_value || 0;
        if (adjustmentsValue !== 0) {
          console.log(`ğŸ’° Auto-populating adjustments value: â‚ª${adjustmentsValue.toLocaleString()}`);
          helper.final_report.summary.adjustments_value = adjustmentsValue;
        }
        
        // Load all summary fields using enhanced loader IMMEDIATELY
        loadSummaryFieldsFromHelper(helper);
        
        // Calculate VAT and totals if we have claim data
        if (totalClaim > 0) {
          const vatRate = getVatRate();
          const vat = totalClaim * vatRate;
          
          const vatField = document.getElementById('sumVAT');
          if (vatField) {
            vatField.value = `â‚ª${Math.round(vat).toLocaleString()}`;
          }
          
          const totalWithVAT = totalClaim + vat;
          const totalClaimField = document.getElementById('sumTotalClaim');
          if (totalClaimField) {
            totalClaimField.value = `â‚ª${Math.round(totalWithVAT).toLocaleString()}`;
          }
        }
        
        // Load saved final report notes if available
        // Check both 'notes' (from save) and 'comments' (from real-time save)
        const additionalNotesField = document.getElementById('additional-notes');
        if (additionalNotesField) {
          const savedNotes = helper.final_report?.notes || helper.final_report?.comments || '';
          console.log('ğŸ” Checking for additional notes:', {
            notes: helper.final_report?.notes,
            comments: helper.final_report?.comments,
            savedNotes: savedNotes
          });
          
          if (savedNotes) {
            additionalNotesField.value = savedNotes;
            console.log('âœ… Loaded additional notes from helper:', savedNotes.substring(0, 50) + '...');
          } else {
            console.log('âš ï¸ No saved notes found in helper');
          }
        } else {
          console.log('âŒ Additional notes field not found in DOM');
        }
        
        // Add event listeners for real-time calculations
        addSummaryCalculationListeners();
        
        // TRIGGER INITIAL AUTO-FILL FOR SUMMARY FIELDS
        setTimeout(() => {
          if (window.addSummaryCalculationListeners) {
            const calculateEvent = new Event('input', { bubbles: true });
            
            // Trigger auto-fill from totalClaim to sumClaim
            const totalClaimField = document.getElementById('totalClaim');
            if (totalClaimField && totalClaimField.value) {
              totalClaimField.dispatchEvent(calculateEvent);
            }
            
            // Trigger auto-fill from globalDepValue to depCompensation
            const globalDepField = document.getElementById('globalDepValue');
            if (globalDepField && globalDepField.value) {
              globalDepField.dispatchEvent(calculateEvent);
            }
          }
        }, 200);
        
      } catch (error) {
        console.error('Error loading summary data:', error);
      }
    }

    // ADD CALCULATION LISTENERS FOR SUMMARY WITH MATH.JS - CORRECTED LOGIC
    function addSummaryCalculationListeners() {
      const sumMarketValueInput = document.getElementById('sumMarketValue');
      const sumClaimInput = document.getElementById('sumClaim');
      const depCompensationInput = document.getElementById('depCompensation');
      const sumVATInput = document.getElementById('sumVAT');
      const sumTotalInput = document.getElementById('sumTotalClaim');

      function calculateSummaryTotals() {
        try {
          // Skip auto-fill for private summary - handled by refreshSummary() 
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          const helperMarketValue = helper.calculations?.full_market_value || 0;
          // Don't auto-fill private summary field - let refreshSummary() handle it
          
          // Also auto-fill global variant market value field if it exists
          const sumMarketValueGlobal = document.getElementById('sumMarketValueGlobal');
          if (helperMarketValue && helperMarketValue > 0 && sumMarketValueGlobal) {
            sumMarketValueGlobal.value = `â‚ª${helperMarketValue.toLocaleString()}`;
          }
          
          // AUTO-FILL SUMMARY CLAIM FROM CLAIMS SECTION
          const totalClaimValue = document.getElementById('totalClaim')?.value;
          if (totalClaimValue && sumClaimInput) {
            sumClaimInput.value = totalClaimValue;
          }
          
          // AUTO-FILL DEPRECIATION COMPENSATION FROM GLOBAL DEPRECIATION VALUE
          const globalDepValue = document.getElementById('globalDepValue')?.value;
          if (globalDepValue && depCompensationInput) {
            depCompensationInput.value = globalDepValue;
          }
          
          // Ensure all variant fields are populated
          const updatedHelper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
          loadSummaryFieldsFromHelper(updatedHelper);
          
          // Get values - market price + claim + compensation - salvage = total
          const marketValue = parseFloat(sumMarketValueInput?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
          const claimValue = parseFloat(sumClaimInput?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
          const depValue = parseFloat(depCompensationInput?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
          const salvageValue = parseFloat(document.getElementById('salvageValue')?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
          
          // Calculate subtotal: claim + compensation - salvage value = subtotal (market price is separate)
          const subtotal = claimValue + depValue - salvageValue;
          
          // Automatic calculation with math.js - Calculate VAT (admin rate on subtotal)
          const vatRate = (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100;
          const vat = Math.round(subtotal * vatRate);
          
          // Calculate final total (subtotal + VAT) - automatic calculation with math.js
          const total = subtotal + vat;
          
          // Update readonly fields with formatted values - auto-filled from relevant fields
          if (sumVATInput) {
            sumVATInput.value = vat ? `â‚ª${vat.toLocaleString()}` : '';
            sumVATInput.readOnly = true;
            sumVATInput.style.background = '#f4f6fa';
          }
          
          if (sumTotalInput) {
            sumTotalInput.value = total ? `â‚ª${total.toLocaleString()}` : '';
            sumTotalInput.readOnly = true;
            sumTotalInput.style.background = '#e8f5e8';
          }
          
        } catch (error) {
          console.error('Error in summary calculations:', error);
        }
      }

      // Add listeners to trigger calculations for all relevant fields
      // Disabled - private summary handled by refreshSummary()
      // if (sumMarketValueInput) {
      //   sumMarketValueInput.addEventListener('input', calculateSummaryTotals);
      // }
      if (sumClaimInput) {
        sumClaimInput.addEventListener('input', calculateSummaryTotals);
      }
      if (depCompensationInput) {
        depCompensationInput.addEventListener('input', calculateSummaryTotals);
      }
      
      // Auto-update when car market value changes
      const carMarketValueInput = document.getElementById('carMarketValue');
      if (carMarketValueInput) {
        carMarketValueInput.addEventListener('input', () => {
          calculateSummaryTotals();
          triggerGlobalDepreciationCalc(); // Recalculate global depreciation when market value changes
        });
      }
      
      // Disabled - private summary handled by refreshSummary()
      // Auto-update when summary market value changes
      // if (sumMarketValueInput) {
      //   sumMarketValueInput.addEventListener('input', () => {
      //     calculateSummaryTotals();
      //     triggerGlobalDepreciationCalc(); // Recalculate global depreciation when market value changes
      //   });
      // }
      
      // ADD EVENT LISTENERS FOR SOURCE FIELDS TO AUTO-UPDATE SUMMARY
      const totalClaimInput = document.getElementById('totalClaim');
      if (totalClaimInput) {
        totalClaimInput.addEventListener('input', calculateSummaryTotals);
      }
      
      const globalDepValueInput = document.getElementById('globalDepValue');
      if (globalDepValueInput) {
        globalDepValueInput.addEventListener('input', calculateSummaryTotals);
      }
      
      // ADD EVENT LISTENER FOR SALVAGE VALUE TO TRIGGER RECALCULATION
      const salvageValueInput = document.getElementById('salvageValue');
      if (salvageValueInput) {
        salvageValueInput.addEventListener('input', calculateSummaryTotals);
      }
      
      // ENHANCED MANUAL INPUT FIELD LISTENERS - For All 5 Report Variants
      addManualInputFieldListeners();
      
      // Add listeners for custom additions if they exist
      function addCustomFieldListeners() {
        const customFields = document.querySelectorAll('#sumAdditionsGridFinalReport input');
        customFields.forEach(field => {
          field.addEventListener('input', calculateSummaryTotals);
        });
      }
      
      // Initial calculation and setup
      calculateSummaryTotals();
      addCustomFieldListeners();
      
      // Re-add listeners when custom fields are added
      const originalAddField = window.addCustomSummaryField;
      window.addCustomSummaryField = function(summaryType) {
        originalAddField(summaryType);
        setTimeout(addCustomFieldListeners, 100);
      };
    }

    // LOAD DEPRECIATION DATA
    function loadDepreciationData(helper) {
      try {
        console.log('ğŸ”„ Loading depreciation data, helper:', helper);
        console.log('ğŸ” helper.centers:', helper.centers);
        console.log('ğŸ” helper.depreciation:', helper.depreciation);
        console.log('ğŸ” helper.final_report?.depreciation:', helper.final_report?.depreciation);
        
        // âœ… 2-WAY DATA FLOW: Check both locations for depreciation data
        // The save function writes to both helper.depreciation AND helper.final_report.depreciation
        const depreciationData = helper.final_report?.depreciation || helper.depreciation || null;
        
        console.log('ğŸ“Š Depreciation data found:', depreciationData);
        console.log('ğŸ“Š Bulk items:', depreciationData?.bulk_items);
        
        if (depreciationData) {
          
          // Load global depreciation fields from helper.depreciation (single source)
          // Format global depreciation with % symbol if numeric
          const globalPercent = depreciationData.globalDep1 || depreciationData.global_percent || '';
          // Keep the value as is - don't add % if it's already there
          document.getElementById('globalDep1').value = globalPercent;
          document.getElementById('globalDepValue').value = depreciationData.globalDepValue || 
                                                           depreciationData.global_value || '';
          document.getElementById('garageDays').value = depreciationData.garageDays || 
                                                       depreciationData.work_days_impact || '';
          
          // Load bulk depreciation table
          if (depreciationData.bulk_items && Array.isArray(depreciationData.bulk_items)) {
            // Check if we need to update the mapping
            let needsUpdate = false;
            
            // If we have damage centers, check if the saved data needs updating
            if (helper.centers && helper.centers.length > 0) {
              // Check if any saved item has old format (center_number is not just a number)
              needsUpdate = depreciationData.bulk_items.some(item => 
                item.center_number && (item.center_number.includes('××•×§×“') || isNaN(item.center_number))
              );
            }
            
            if (needsUpdate) {
              // Don't regenerate - just load the existing data even if format is old
              console.log('âš ï¸ Old format detected but preserving existing manual data');
            }
            
            // Always load existing saved data
            if (depreciationData.bulk_items.length > 0) {
              // Load existing data
              const depreciationContainer = document.getElementById('depreciationBulkTable');
              if (depreciationContainer) {
                depreciationContainer.innerHTML = '';
              }
              
              console.log('ğŸ“‹ Loading bulk items:', depreciationData.bulk_items);
              depreciationData.bulk_items.forEach((item, index) => {
                console.log(`  Item ${index + 1}:`, item);
                addDepField(item);
              });
              
              // Add auto-calculation to all existing rows after loading
              setTimeout(() => {
                addAutoCalculationToExistingRows();
              }, 100);
            }
          }
          
        }
        
        // ALWAYS check and auto-populate from damage centers if table is empty
        // BUT ONLY if there's no saved depreciation data
        if (helper.centers && helper.centers.length > 0) {
          const existingRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
          const hasDepreciationData = depreciationData && depreciationData.bulk_items && depreciationData.bulk_items.length > 0;
          
          if (existingRows.length === 0 && !hasDepreciationData) {
            console.log('ğŸ”„ Auto-populating depreciation from damage centers (no saved data found)...');
            updateDepreciationFromDamageCenters([]);
          }
        }
      } catch (error) {
        console.error('Error loading depreciation data:', error);
      }
    }

    // LOAD DAMAGE CENTERS SUMMARY - EDITABLE CARDS
    function loadDamageCentersSummary(helper) {
      try {
        console.log('ğŸ” DEBUG: loadDamageCentersSummary called with helper.centers:', helper?.centers);
        const damageCentersContent = document.getElementById('damageCentersContent');
        
        // Load from damage centers helper (primary source) with fallbacks
        // NOTE: Removed damage_assessment.centers - using only helper.centers as source of truth
        const damageCenters = helper.centers || 
                             helper.damage_centers || 
                             helper.expertise?.damage_blocks || [];
        console.log('ğŸ” DEBUG: Final damageCenters array:', damageCenters);
        
        if (damageCenters && damageCenters.length > 0) {
          let summaryHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters">';
          
          damageCenters.forEach((center, index) => {
            // Adapt centers data structure to damage block structure for compatibility
            const adaptedCenter = adaptCenterToBlock(center, index);
            summaryHTML += createEditableDamageCenterCard(adaptedCenter, index);
          });
          
          summaryHTML += '</div>';
          damageCentersContent.innerHTML = summaryHTML;
          
          // Add event listeners after HTML is created
          setTimeout(addDamageCenterEventListeners, 100);
          
          // Reposition save button if subtotal exists
          setTimeout(repositionDamageCentersSaveButton, 150);
          
        } else {
          damageCentersContent.innerHTML = '<div style="color: #666; text-align: center;">×œ× × ××¦××• × ×ª×•× ×™ ××•×§×“×™ × ×–×§ - ×œ×—×¥ "×”×•×¡×£ ××•×§×“ × ×–×§ ×—×“×©" ×›×“×™ ×œ×”×ª×—×™×œ</div>';
        }
      } catch (error) {
        console.error('Error loading damage centers summary:', error);
        document.getElementById('damageCentersContent').innerHTML = '<div style="color: #dc3545; text-align: center;">×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™ ××•×§×“×™ × ×–×§</div>';
      }
    }

    // Adapt centers data structure to damage block structure for compatibility
    function adaptCenterToBlock(center, index) {
      
      // Centers structure (from wizard) vs damage_blocks structure (from expertise)
      const adaptedBlock = {
        Id: center.Id || center.id || center.code || center.damage_center_code || '',
        damage_center_name: center.Location || center.damage_center_name || `××•×§×“ × ×–×§ ${index + 1}`,
        // Extract just the number if it contains the full text
        damage_center_number: (() => {
          const num = center["Damage center Number"] || center.damage_center_number || (index + 1);
          // If it's a string that contains "××•×§×“ × ×–×§ ××¡'", extract just the number
          if (typeof num === 'string' && num.includes('××•×§×“')) {
            const match = num.match(/\d+$/);
            return match ? match[0] : String(index + 1);
          }
          return num;
        })(),
        description: center.Description || center.description || '',
        // CORRECT MAPPING: RepairNature data from helper.centers
        RepairNature: center.RepairNature || center.repair_nature || '',
        // CORRECT MAPPING: Works data structure from helper.centers
        works: center.Works?.works || center.works || [],
        // CORRECT MAPPING: Parts data is in center.Parts.parts_required for helper.centers
        parts: center.Parts?.parts_required || center.Parts?.parts || center.parts_required || center.parts || center.Parts || [],
        // CORRECT MAPPING: Repairs data structure from helper.centers
        repairs: center.Repairs?.repairs || center.repairs || [],
        works_meta: center.Works?.works_meta || center.works_meta || { total_cost: 0 },
        parts_meta: center.Parts?.parts_meta || center.parts_meta || { total_cost: 0 },
        repairs_meta: center.Repairs?.repairs_meta || center.repairs_meta || { total_cost: 0 },
        total_cost: center.Summary?.["Total with VAT"] || center.total_cost || 0
      };
      
      // Additional normalization for different data structures
      if (Array.isArray(center.Works) && adaptedBlock.works.length === 0) {
        adaptedBlock.works = center.Works;
      }
      if (Array.isArray(center.Parts) && adaptedBlock.parts.length === 0) {
        adaptedBlock.parts = center.Parts;
      }
      if (Array.isArray(center.Repairs) && adaptedBlock.repairs.length === 0) {
        adaptedBlock.repairs = center.Repairs;
      }
      
      console.log(`âœ… SESSION 56: Adapted block ${index}:`, adaptedBlock);
      console.log(`  ğŸ“‹ Parts found: ${adaptedBlock.parts.length}, Works found: ${adaptedBlock.works.length}`);
      console.log(`  ğŸ†” ID preserved: ${adaptedBlock.Id || 'MISSING!'}`);
      
      if (!adaptedBlock.Id) {
        console.warn(`âš ï¸ SESSION 56: Center ${index} has NO ID after adaptation!`);
        console.warn('  Original center object:', center);
      }
      
      return adaptedBlock;
    }

    // CREATE EDITABLE DAMAGE CENTER CARD
    function createEditableDamageCenterCard(block, index) {
      
      const centerNum = block.damage_center_number || (index + 1);
      const centerLocation = block.damage_center_name || block.Location || `××•×§×“ × ×–×§ ${centerNum}`;
      const workCosts = block.work_cost || 0;
      const partsCosts = block.parts_cost || 0;
      const repairsCosts = workCosts + partsCosts;
      const totalWithVAT = repairsCosts * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100);
      
      const centerId = block.Id || block.id || block.code || block.damage_center_code || '';
      console.log(`ğŸ†” SESSION 56: Creating card ${index} with ID: ${centerId}`);
      
      // Get existing parts, works, repairs from block
      const parts = block.parts || [];
      const works = block.works || [];
      const repairs = block.repairs || [];
      
      console.log(`ğŸ”§ Card ${index} data - Parts: ${parts.length}, Works: ${works.length}, Repairs: ${repairs.length}`);
      console.log(`ğŸ“‹ Parts content:`, parts);
      console.log(`ğŸ”¨ Works content:`, works);
      
      return `
        <div class="editable-damage-card" data-center-index="${index}" data-center-id="${centerId}" style="background: white; border-radius: 8px; padding: 15px; border: 1px solid #e2e8f0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <!-- Card Header -->
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="font-weight: bold; color: #1e3a8a; font-size: 16px;">××•×§×“ × ×–×§ ××¡'</span>
              <input type="text" value="${centerNum}" class="damage-center-number" style="font-weight: bold; color: #1e3a8a; font-size: 16px; border: 1px solid #ddd; padding: 8px; border-radius: 4px; width: 50px; text-align: center;" />
            </div>
            <button onclick="removeDamageCenter(${index})" style="background: #dc3545; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">××—×§</button>
          </div>
          
          <!-- Damage Center Location Field -->
          <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #1e3a8a;">×©× ××•×§×“ ×”× ×–×§:</label>
            <input type="text" class="damage-center-location" style="width: 100%; border: 1px solid #ddd; padding: 8px; border-radius: 4px; font-size: 14px;" placeholder="×”×–×Ÿ ×©×/××™×–×•×¨ ××•×§×“ ×”× ×–×§ (×œ×“×•×’××”: ×¤×’×•×© ×§×“××™, ×“×œ×ª × ×”×’, ×•×›×•')" value="${centerLocation}" />
          </div>
          
          <!-- Damage Description Field -->
          <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #1e3a8a;">×ª×™××•×¨ ×”× ×–×§:</label>
            <textarea class="damage-center-description" style="width: 100%; min-height: 60px; border: 1px solid #ddd; padding: 8px; border-radius: 4px; font-size: 14px; font-family: inherit; resize: vertical;" placeholder="×”×–×Ÿ ×ª×™××•×¨ ××¤×•×¨×˜ ×©×œ ×”× ×–×§ ×‘××•×§×“ ×–×”...">${block.description || ''}</textarea>
          </div>

          <!-- RepairNature Field -->
          <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #1e3a8a;">××”×•×ª ×”×ª×™×§×•×Ÿ:</label>
            <input class="damage-center-repair-nature" style="width: 100%; border: 1px solid #ddd; padding: 8px; border-radius: 4px; font-size: 14px;" placeholder="×”×–×Ÿ ××ª ××”×•×ª ×”×ª×™×§×•×Ÿ..." value="${block.RepairNature || block.repair_nature || ''}" />
          </div>

          <!-- Parts Section (Full Width Row) -->
          <div style="border: 1px solid #e2e8f0; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
            <h4 style="margin: 0 0 10px 0; color: #1e3a8a;">×—×œ×§×™× × ×“×¨×©×™×:</h4>
            <div class="parts-list" data-center="${index}">
              ${parts.map((part, partIndex) => createEditablePartRow(part, index, partIndex)).join('')}
            </div>
            <button onclick="addPartRow(${index})" class="btn" style="background: #28a745; color: white; padding: 6px 12px; margin-top: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">×”×•×¡×£ ×—×œ×§</button>
          </div>

          <!-- Works Section (Full Width Row) -->
          <div style="border: 1px solid #e2e8f0; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
            <h4 style="margin: 0 0 10px 0; color: #1e3a8a;">×¢×‘×•×“×•×ª × ×“×¨×©×•×ª:</h4>
            <div class="works-list" data-center="${index}">
              ${works.map((work, workIndex) => createEditableWorkRow(work, index, workIndex)).join('')}
            </div>
            <button onclick="addWorkRow(${index})" class="btn" style="background: #17a2b8; color: white; padding: 6px 12px; margin-top: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">×”×•×¡×£ ×¢×‘×•×“×”</button>
          </div>

          <!-- Repairs Section (Full Width Row) -->
          <div style="border: 1px solid #e2e8f0; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
            <h4 style="margin: 0 0 10px 0; color: #1e3a8a;">×ª×™×§×•× ×™× × ×“×¨×©×™×:</h4>
            <div class="repairs-list" data-center="${index}">
              ${repairs.map((repair, repairIndex) => createEditableRepairRow(repair, index, repairIndex)).join('')}
            </div>
            <button onclick="addRepairRow(${index})" class="btn" style="background: #ffc107; color: #212529; padding: 6px 12px; margin-top: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">×”×•×¡×£ ×ª×™×§×•×Ÿ</button>
          </div>

          <!-- Cost Summary (Auto-calculated) -->
          <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; border: 1px solid #e2e8f0;">
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; font-size: 14px;">
              <div><strong>×¢×‘×•×“×•×ª:</strong> <span class="work-costs-display">â‚ª${workCosts.toLocaleString()}</span></div>
              <div><strong>×—×œ×¤×™×:</strong> <span class="parts-costs-display">â‚ª${partsCosts.toLocaleString()}</span></div>
              <div><strong>×ª×™×§×•× ×™×:</strong> <span class="repairs-costs-display">â‚ª${repairsCosts.toLocaleString()}</span></div>
              <div><strong>×›×•×œ×œ ××¢"×:</strong> <span class="total-with-vat-display">â‚ª${Math.round(totalWithVAT).toLocaleString()}</span></div>
            </div>
          </div>
        </div>
      `;
    }

    // CREATE EDITABLE PART ROW WITH SEARCH DROPDOWN - SESSION: Updated structure with 7 fields + mobile responsive
    function createEditablePartRow(part, centerIndex, partIndex) {
      // Extract data with NEW field structure (Session 40 compatibility)
      const partName = part?.name || part?.part_name || '';
      const partDesc = part?.desc || part?.description || part?.×ª×™××•×¨ || '';
      const pricePerUnit = parseFloat(part?.price_per_unit || part?.unit_price || part?.price || 0);
      const reduction = parseFloat(part?.reduction_percentage || part?.reduction || 0);
      const wear = parseFloat(part?.wear_percentage || part?.wear || 0);
      const quantity = parseInt(part?.quantity || part?.×›××•×ª || 1);
      const updatedPrice = Math.round(parseFloat(part?.updated_price || pricePerUnit));
      const totalCost = Math.round(parseFloat(part?.total_cost || (updatedPrice * quantity)));
      const partSource = part?.source || part?.××§×•×¨ || '';
      const catalogCode = part?.catalog_code || part?.pcode || part?.part_number || '';
      
      // ğŸ” SESSION 61 FIX: Generate UUID if missing - don't leave empty!
      let rowUuid = part?.row_uuid;
      if (!rowUuid || rowUuid === '') {
        rowUuid = crypto.randomUUID();
        console.warn(`âš ï¸ SESSION 61 FINAL-REPORT: Part "${partName}" has NO row_uuid! Generated new: ${rowUuid}`);
        if (part) {
          part.row_uuid = rowUuid;
        }
      } else {
        console.log(`âœ… SESSION 61 FINAL-REPORT: Part "${partName}" has row_uuid: ${rowUuid}`);
      }
      
      return `
        <div class="part-row" data-center="${centerIndex}" data-part="${partIndex}" data-row-uuid="${rowUuid}" 
             style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; padding: 12px; background: #f9f9f9; border-radius: 6px; border: 1px solid #e0e0e0;">
          
          <!-- Row 1: Catalog Number + Part Name (Responsive Grid) -->
          <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 8px;">
            <div>
              <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block; font-weight: 600;">××¡. ×§×˜×œ×•×’×™:</label>
              <input type="text" value="${catalogCode}" placeholder="××¡. ×§×˜×œ×•×’×™" class="part-catalog-code-visible" 
                     style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
                     oninput="autoSaveDamageCenterChanges()" />
            </div>
            <div style="position: relative;">
              <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block; font-weight: 600;">×©× ×”×—×œ×§:</label>
              <input type="text" value="${partName}" placeholder="×©× ×”×—×œ×§" class="part-name" 
                     style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
                     onkeyup="handlePartInput(this, ${centerIndex}, ${partIndex})" 
                     onclick="handlePartClick(this, ${centerIndex}, ${partIndex})"
                     oninput="autoSaveDamageCenterChanges()" />
              <div class="part-suggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ddd; border-top: none; border-radius: 0 0 4px 4px; display: none; z-index: 1000; max-height: 200px; overflow-y: auto;"></div>
            </div>
          </div>
          
          <!-- Row 2: Price Fields (Responsive Grid) -->
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 6px;">
            <div>
              <label style="font-size: 11px; color: #666; margin-bottom: 2px; display: block;">××—×™×¨:</label>
              <input type="number" value="${pricePerUnit}" placeholder="0" class="part-price-per-unit" 
                     style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" 
                     min="0" step="0.01" 
                     oninput="calculatePartPriceFields(this.closest('.part-row'))" />
            </div>
            <div>
              <label style="font-size: 11px; color: #666; margin-bottom: 2px; display: block;">×”× ×—×”%:</label>
              <input type="number" value="${reduction}" placeholder="0" class="part-reduction" 
                     style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" 
                     min="0" max="100" step="0.1" 
                     oninput="calculatePartPriceFields(this.closest('.part-row'))" />
            </div>
            <div>
              <label style="font-size: 11px; color: #666; margin-bottom: 2px; display: block;">×‘×œ××™%:</label>
              <input type="number" value="${wear}" placeholder="0" class="part-wear" 
                     style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" 
                     min="0" max="100" step="0.1" 
                     oninput="calculatePartPriceFields(this.closest('.part-row'))" />
            </div>
            <div>
              <label style="font-size: 11px; color: #666; margin-bottom: 2px; display: block;">×›××•×ª:</label>
              <input type="number" value="${quantity}" placeholder="1" class="part-quantity" 
                     style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; text-align: center;" 
                     min="1" step="1" 
                     oninput="calculatePartPriceFields(this.closest('.part-row'))" />
            </div>
            <div>
              <label style="font-size: 11px; color: #666; margin-bottom: 2px; display: block;">×¡×”"×›:</label>
              <input type="text" value="â‚ª${totalCost.toLocaleString()}" placeholder="â‚ª0" class="part-total-cost" 
                     style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; background: #e8f5e9; font-weight: 600;" 
                     readonly />
            </div>
          </div>
          
          <!-- Row 3: Delete Button (Bottom Right) -->
          <div style="display: flex; justify-content: flex-end; margin-top: 4px;">
            <button onclick="removePartRow(${centerIndex}, ${partIndex})" 
                    style="background: #dc3545; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">
              ××—×§
            </button>
          </div>
          
          <!-- Hidden Fields for Data Integrity -->
          <input type="hidden" value="${partSource}" class="part-source" />
          <input type="hidden" value="${partDesc}" class="part-description" />
          <input type="hidden" value="${updatedPrice}" class="part-updated-price" />
        </div>
      `;
    }

    // CREATE EDITABLE WORK ROW WITH DROPDOWN
    function createEditableWorkRow(work, centerIndex, workIndex) {
      const workTypes = [
        '×›×œ ×¢×‘×•×“×•×ª ×”×¤×—×—×•×ª ×›×•×œ×œ ×¤×™×¨×•×§×™× ×•×”×¨×›×‘×•×ª','×¢×‘×•×“×•×ª ×¦×‘×¢', '×¢×‘×•×“×•×ª ×—×©××œ', '×¢×‘×•×“×•×ª ××›×•× ××•×ª', 
        '×¢×‘×•×“×•×ª ××–×’×Ÿ', '×¢×‘×•×“×•×ª ×¨×™×¤×•×“', '×¢×‘×•×“×•×ª ×–×’×’×•×ª',
        '××™×˜×•× ×•×–×™×¤×•×ª', '×‘×“×™×§×ª ××ª×œ×”', '×”× ×–×§ ××—×™×™×‘ ×ª×§× ×” 309',
        '×›×™×•×œ ×¨×“××¨', '×”×¢×‘×¨×ª ×—×™×™×©× ×™×', '××—×¨'
      ];
      
      const workType = typeof work === 'object' ? (work.category || work.type) : work;
      const workNote = typeof work === 'object' ? (work.comments || work.note || '') : '';
      const workCost = typeof work === 'object' ? work.cost : 0;
      
      return `
        <div class="work-row" data-center="${centerIndex}" data-work="${workIndex}" style="display: grid; grid-template-columns: 2fr 2fr 1fr auto; gap: 8px; margin-bottom: 8px; padding: 8px; background: #f9f9f9; border-radius: 4px;">
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">×¡×•×’ ×¢×‘×•×“×”:</label>
            <select class="work-type" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" onchange="handleWorkTypeChange(this, ${centerIndex}, ${workIndex})" onclick="handleWorkClick(this, ${centerIndex}, ${workIndex})">
              ${workTypes.map(type => `<option value="${type}" ${type === workType ? 'selected' : ''}>${type}</option>`).join('')}
            </select>
            <input type="text" class="work-type-other" placeholder="×”×›× ×¡ ×¡×•×’ ×¢×‘×•×“×” ××—×¨" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; margin-top: 4px; display: ${workType === '××—×¨' ? 'block' : 'none'};" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">×”×¢×¨×•×ª:</label>
            <input type="text" value="${workNote}" placeholder="×”×¢×¨×•×ª × ×•×¡×¤×•×ª" class="work-note" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">×¢×œ×•×ª (â‚ª):</label>
            <input type="number" value="${workCost}" placeholder="0" class="work-cost" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" min="0" step="0.01" />
          </div>
          <button onclick="removeWorkRow(${centerIndex}, ${workIndex})" style="background: #dc3545; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; align-self: end;">××—×§</button>
        </div>
      `;
    }

    // CREATE EDITABLE REPAIR ROW
    function createEditableRepairRow(repair, centerIndex, repairIndex) {
      const repairText = typeof repair === 'object' ? repair.description : repair;
      const repairCost = typeof repair === 'object' ? repair.cost : 0;
      const repairName = typeof repair === 'object' ? repair.name || '' : '';
      const repairHours = typeof repair === 'object' ? repair.hours || 0 : 0;
      
      return `
        <div class="repair-row" data-center="${centerIndex}" data-repair="${repairIndex}" style="display: grid; grid-template-columns: 1.5fr 2fr 0.8fr 1fr auto; gap: 8px; margin-bottom: 8px; padding: 8px; background: #f9f9f9; border-radius: 4px;">
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">×©× ×”×ª×™×§×•×Ÿ:</label>
            <input type="text" value="${repairName}" placeholder="×©× ×”×ª×™×§×•×Ÿ" class="repair-name" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" onclick="handleRepairClick(this, ${centerIndex}, ${repairIndex})" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">×ª×™××•×¨ ×”×ª×™×§×•×Ÿ:</label>
            <textarea placeholder="×ª×™××•×¨ ×”×ª×™×§×•×Ÿ" class="repair-text" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; font-family: inherit; min-height: 60px; resize: vertical;">${repairText}</textarea>
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">×©×¢×•×ª:</label>
            <input type="number" value="${repairHours}" placeholder="0" class="repair-hours" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" min="0" step="0.1" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">×¢×œ×•×ª (â‚ª):</label>
            <input type="number" value="${repairCost}" placeholder="0" class="repair-cost" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" min="0" step="0.01" />
          </div>
          <button onclick="removeRepairRow(${centerIndex}, ${repairIndex})" style="background: #dc3545; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; height: 32px; margin-top: 14px;">××—×§</button>
        </div>
      `;
    }

    // LOAD LEVI ADJUSTMENTS
    // UNIFIED ADJUSTMENTS SYSTEM - Combines Levi adjustments and custom additions
    // Debounce mechanism to prevent duplicate loading
    let loadAdjustmentsTimeout;
    
    // CRITICAL FIX: Function to clean up duplicate data in helper
    function cleanupHelperDuplicates(helper) {
      try {
        // Clean up levi_report adjustments
        if (helper.levi_report?.adjustments) {
          const seenAdjustments = new Set();
          const cleanedAdjustments = [];
          
          helper.levi_report.adjustments.forEach(adj => {
            const key = `${adj.description}-${adj.value}-${adj.percent}`;
            if (!seenAdjustments.has(key)) {
              seenAdjustments.add(key);
              cleanedAdjustments.push(adj);
            }
          });
          
          const removedCount = helper.levi_report.adjustments.length - cleanedAdjustments.length;
          if (removedCount > 0) {
            console.log(`ğŸ§¹ Removed ${removedCount} duplicate levi_report adjustments`);
          }
          
          helper.levi_report.adjustments = cleanedAdjustments;
        }
        
        // Clean up custom adjustments
        if (helper.levi?.custom_adjustments) {
          const seenCustom = new Set();
          const cleanedCustom = [];
          
          helper.levi.custom_adjustments.forEach(adj => {
            const key = `${adj.description}-${adj.value}-${adj.percentage}`;
            if (!seenCustom.has(key)) {
              seenCustom.add(key);
              cleanedCustom.push(adj);
            }
          });
          
          const removedCustomCount = helper.levi.custom_adjustments.length - cleanedCustom.length;
          if (removedCustomCount > 0) {
            console.log(`ğŸ§¹ Removed ${removedCustomCount} duplicate custom adjustments`);
          }
          
          helper.levi.custom_adjustments = cleanedCustom;
        }
        
        return helper;
      } catch (error) {
        console.error('Error cleaning helper duplicates:', error);
        return helper;
      }
    }
    
    function loadAllAdjustments(helper) {
      try {
        // Get caller information for debugging
        const caller = new Error().stack.split('\n')[2].trim();
        console.log('ğŸ”„ loadAllAdjustments called (will be debounced) from:', caller);
        
        // Clear any existing timeout to prevent duplicate calls
        if (loadAdjustmentsTimeout) {
          clearTimeout(loadAdjustmentsTimeout);
          console.log('âš ï¸ Cleared previous loadAllAdjustments timeout');
        }
        
        // Debounce the loading to prevent rapid multiple calls
        // loadAdjustmentsTimeout = setTimeout(() => {
        //   loadAllAdjustmentsImmediate(helper);
        // }, 100);
        console.log('âš ï¸ loadAllAdjustmentsImmediate disabled - adjustments container was removed');
        
      } catch (error) {
        console.error('Error in loadAllAdjustments debounce:', error);
      }
    }
    
    function loadAllAdjustmentsImmediate(helper) {
      try {
        console.log('ğŸ”„ Loading all adjustments (immediate)');
        // Note: Final report adjustments section was removed - skipping that part
        
        // CRITICAL FIX: Clean up duplicate data in helper before loading
        helper = cleanupHelperDuplicates(helper);
        
        // Save the cleaned helper back to sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        console.log('ğŸ§¹ Helper cleaned up and saved, proceeding with load...');
        
        // AGGRESSIVE FIX: Clear the container completely and verify it's empty
        adjustmentsContainer.innerHTML = '';
        
        // Force a DOM update to ensure the container is truly empty
        adjustmentsContainer.offsetHeight; // Force reflow
        
        console.log('ğŸ§¹ Container cleared, current children count:', adjustmentsContainer.children.length);
        
        let adjustmentsHTML = '';
        
        // 1. Load Levi adjustments (read-only from Levi report)
        if (helper.levi_report?.adjustments && helper.levi_report.adjustments.length > 0) {
          console.log('ğŸ“„ Loading Levi adjustments:', helper.levi_report.adjustments);
          console.log('ğŸ“„ Levi adjustments count:', helper.levi_report.adjustments.length);
          helper.levi_report.adjustments.forEach((adjustment, index) => {
            console.log(`ğŸ“„ Processing Levi adjustment ${index}:`, adjustment);
            adjustmentsHTML += createAdjustmentRow({
              description: adjustment.description || '×”×ª×××” ××œ×•×™ ×™×¦×—×§',
              percentage: adjustment.percentage || adjustment.percent || 0,
              value: adjustment.value || 0,
              source: 'levi',
              index: index,
              readonly: false
            });
          });
        } else {
          console.log('ğŸ“„ No Levi adjustments found in helper.levi_report.adjustments');
        }
        
        // 2. Load custom adjustments (editable, stored in helper.levi.custom_adjustments)
        if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments.length > 0) {
          console.log('ğŸ“„ Loading custom adjustments:', helper.levi.custom_adjustments);
          console.log('ğŸ“„ Custom adjustments count:', helper.levi.custom_adjustments.length);
          helper.levi.custom_adjustments.forEach((adjustment, index) => {
            console.log(`ğŸ“„ Processing custom adjustment ${index}:`, adjustment);
            adjustmentsHTML += createAdjustmentRow({
              description: adjustment.description || '×”×ª×××” ××•×ª×××ª ××™×©×™×ª',
              percentage: adjustment.percentage || 0,
              value: adjustment.value || 0,
              source: 'custom',
              index: index,
              readonly: false,
              adjustmentType: adjustment.adjustmentType || 'addition'
            });
          });
        } else {
          console.log('ğŸ“„ No custom adjustments found in helper.levi.custom_adjustments');
        }
        
        if (!adjustmentsHTML) {
          adjustmentsHTML = '<div style="color: #666; text-align: center; padding: 10px; font-size: 13px;">×œ× × ××¦××• ×”×ª×××•×ª - ×”×©×ª××© ×‘×›×¤×ª×•×¨ "×”×•×¡×£ ×”×ª×××” × ×•×¡×¤×ª"</div>';
        }
        
        adjustmentsContainer.innerHTML = adjustmentsHTML;
        
        // Add event listeners for all adjustments
        setTimeout(() => {
          addAdjustmentEventListeners();
          
          // Trigger initial auto-calculation for existing custom adjustments
          if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments.length > 0) {
            console.log('ğŸ”„ Triggering initial calculation for existing adjustments');
            helper.levi.custom_adjustments.forEach((adjustment, index) => {
              if (adjustment.percentage && adjustment.percentage !== 0) {
                console.log(`ğŸš€ Initial calculation for adjustment ${index}: ${adjustment.percentage}%`);
                calculateAdjustmentValue('custom', index, adjustment.percentage);
              }
            });
          }
        }, 300);
        
      } catch (error) {
        console.error('Error loading all adjustments:', error);
        // Note: allAdjustmentsRows-final-report container was removed
      }
      
      // Removed: Loading adjustments from helper.final_report.adjustments
      // Now using valuation.adjustments for all adjustment data flow
      if (false) { // Disabled - keeping code for reference
        console.log('ğŸ“‹ Loading saved adjustments from Helper:', helper.final_report.adjustments);
        
        // Clear existing rows to prevent duplication
        // REMOVED: Wrong loading from final_report.adjustments
        // The correct loading is done by loadGrossAdjustments(helper) which reads from estimate.adjustments
        
      }
      
      // Load saved legal text from final_report
      if (helper.final_report?.legal_text) {
        const legalTextElement = document.getElementById('legal-text-content');
        if (legalTextElement) {
          legalTextElement.value = helper.final_report.legal_text;
        }
      }
      
      // Attachments are now loaded by dedicated loadAttachmentsData() function
    }
    
    // Create unified adjustment row HTML
    function createAdjustmentRow(params) {
      const { description, percentage, value, source, index, readonly, adjustmentType } = params;
      const rowId = `adjustment-${source}-${index}`;
      
      // Determine type and colors
      let typeLabel, typeColor;
      if (source === 'levi') {
        typeLabel = '×œ×•×™ ×™×¦×—×§';
        typeColor = '#007bff';
      } else {
        // For custom adjustments, use the explicit type or infer from values
        const currentType = adjustmentType || (percentage < 0 || value < 0 ? 'subtraction' : 'addition');
        typeLabel = currentType === 'addition' ? '×ª×•×¡×¤×ª' : '×”×¤×—×ª×”';
        typeColor = currentType === 'addition' ? '#28a745' : '#dc3545';
      }
      
      if (readonly) {
        // Read-only Levi adjustments (5-column layout)
        return `
          <div class="adjustment-row" id="${rowId}" style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr auto; gap: 8px; padding: 8px; border-bottom: 1px solid #e9ecef; background: #f8f9fa;">
            <div style="font-size: 13px;">
              <span style="background: ${typeColor}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 8px;">${typeLabel}</span>
              ${description}
            </div>
            <div style="font-size: 13px; text-align: center; color: ${typeColor}; font-weight: bold;">${typeLabel}</div>
            <div style="font-size: 13px; text-align: center;">${percentage}%</div>
            <div style="font-size: 13px; text-align: center;">â‚ª${value.toLocaleString()}</div>
            <div style="font-size: 11px; color: #666;">×§×¨×™××” ×‘×œ×‘×“</div>
          </div>
        `;
      } else {
        // Editable custom adjustments with type dropdown (5-column layout)
        const currentAdjustmentType = adjustmentType || 'addition';
        return `
          <div class="adjustment-row" id="${rowId}" style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr auto; gap: 8px; padding: 8px; border-bottom: 1px solid #e9ecef;" data-source="${source}" data-loaded-from-helper="true">
            <input type="text" value="${description}" data-field="description" data-source="${source}" data-index="${index}" 
                   style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px;" 
                   placeholder="×ª×™××•×¨ ×”×”×ª×××”" />
            <select data-field="adjustmentType" data-source="${source}" data-index="${index}"
                    style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px; background: white;">
              <option value="addition" ${currentAdjustmentType === 'addition' ? 'selected' : ''} style="color: #28a745;">×ª×•×¡×¤×ª</option>
              <option value="subtraction" ${currentAdjustmentType === 'subtraction' ? 'selected' : ''} style="color: #dc3545;">×”×¤×—×ª×”</option>
            </select>
            <input type="number" value="${Math.abs(percentage)}" data-field="percentage" data-source="${source}" data-index="${index}"
                   style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px; text-align: center;" 
                   placeholder="0" step="0.1" min="0" />
            <input type="number" value="${Math.abs(value)}" data-field="value" data-source="${source}" data-index="${index}"
                   style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px; text-align: center; background: #f8f9fa;" 
                   placeholder="××•×˜×•××˜×™" step="100" min="0" readonly title="××—×•×©×‘ ××•×˜×•××˜×™×ª: ××—×•×– Ã— ××—×™×¨ ×‘×¡×™×¡" />
            <button type="button" onclick="removeCustomAdjustment('${source}', ${index})" 
                    style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">××—×§</button>
          </div>
        `;
      }
    }

    // ADD CUSTOM ADJUSTMENT FIELD - Unified system
    function addCustomAdjustmentField() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Initialize custom adjustments array if it doesn't exist
      if (!helper.levi) helper.levi = {};
      if (!helper.levi.custom_adjustments) helper.levi.custom_adjustments = [];
      
      // Add new empty adjustment with default type
      const newAdjustment = {
        description: '',
        percentage: 0,
        value: 0,
        adjustmentType: 'addition'
      };
      
      helper.levi.custom_adjustments.push(newAdjustment);
      
      // Save to sessionStorage
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Reload all adjustments to show the new one
      loadAllAdjustments(helper);
      
      console.log('Added new custom adjustment, total custom adjustments:', helper.levi.custom_adjustments.length);
      
      // Ensure event listeners are attached to the new row
      const newIndex = helper.levi.custom_adjustments.length - 1;
      setTimeout(() => {
        console.log('ğŸ†• Setting up new adjustment row with event listeners');
        addAdjustmentEventListeners();
        
        // Focus on the new row's description field
        const newDescriptionInput = document.querySelector(`input[data-field="description"][data-source="custom"][data-index="${newIndex}"]`);
        if (newDescriptionInput) {
          newDescriptionInput.focus();
        }
        
        // Trigger initial calculation if it has a percentage
        const newAdjustment = helper.levi.custom_adjustments[newIndex];
        if (newAdjustment && newAdjustment.percentage !== 0) {
          calculateAdjustmentValue('custom', newIndex, newAdjustment.percentage);
        }
      }, 150);
    }
    
    // REMOVE CUSTOM ADJUSTMENT
    function removeCustomAdjustment(source, index) {
      if (source !== 'custom') return; // Only allow removing custom adjustments
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments[index]) {
        helper.levi.custom_adjustments.splice(index, 1);
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Reload all adjustments
        loadAllAdjustments(helper);
        
        // Re-attach event listeners after removal
        setTimeout(() => {
          addAdjustmentEventListeners();
        }, 100);
        
        console.log('Removed custom adjustment at index:', index);
      }
    }
    
    // ADD EVENT LISTENERS FOR ADJUSTMENT FIELDS
    function addAdjustmentEventListeners() {
      // Remove existing event listeners to prevent duplicates
      // Final report container removed - will return empty NodeList
      const existingInputs = document.querySelectorAll('#allAdjustmentsRows-final-report input[data-source], #allAdjustmentsRows-final-report select[data-source]');
      existingInputs.forEach(element => {
        // Clone element to remove all event listeners
        const newElement = element.cloneNode(true);
        element.parentNode.replaceChild(newElement, element);
      });
      
      // Add fresh event listeners to all adjustment inputs (both custom and levi)
      // Final report container removed - will return empty NodeList  
      const adjustmentInputs = document.querySelectorAll('#allAdjustmentsRows-final-report input[data-source], #allAdjustmentsRows-final-report select[data-source]');
      
      console.log(`ğŸ”— Adding event listeners to ${adjustmentInputs.length} adjustment inputs`);
      
      adjustmentInputs.forEach(element => {
        // Input event for real-time updates
        element.addEventListener('input', function() {
          const source = this.dataset.source;
          const index = parseInt(this.dataset.index);
          const field = this.dataset.field;
          
          console.log(`ğŸ“ Input changed: ${field} for ${source}[${index}] = ${this.value}`);
          
          let value;
          if (field === 'description') {
            value = this.value;
          } else if (field === 'adjustmentType') {
            value = this.value;
          } else {
            value = parseFloat(this.value) || 0;
          }
          
          // Update helper based on source type
          if (source === 'custom') {
            updateCustomAdjustmentInHelper(source, index, field, value);
          } else if (source === 'levi') {
            updateLeviAdjustmentInHelper(source, index, field, value);
          }
          
          // Auto-calculate value when percentage changes
          if (field === 'percentage') {
            console.log(`ğŸ”¢ Triggering auto-calculation for percentage: ${value}%`);
            calculateAdjustmentValue(source, index, value);
          }
          
          // Debug: Check if helper is updated
          const currentHelper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          console.log(`ğŸ” DEBUG: Helper after adjustment update:`, currentHelper.levi?.custom_adjustments);
          console.log(`ğŸ” DEBUG: Helper expertise.levi_report:`, currentHelper.expertise?.levi_report);
          
          // Trigger floating screen refresh when adjustments change
          triggerFloatingScreenRefresh();
        });
        
        // Change event for final updates
        element.addEventListener('change', function() {
          // Trigger calculation update on change
          calculateSummaryTotals();
          
          // Trigger floating screen refresh when adjustments change
          triggerFloatingScreenRefresh();
          
          // If adjustment type changed, reload to update display
          if (this.dataset.field === 'adjustmentType') {
            // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
            setTimeout(() => loadAllAdjustments(helper), 50);
          }
        });
        
        // For percentage fields, trigger auto-calculation on focus out
        if (element.dataset.field === 'percentage') {
          element.addEventListener('blur', function() {
            const value = parseFloat(this.value) || 0;
            if (value !== 0) {
              console.log(`ğŸ¯ Blur event: Recalculating for percentage ${value}%`);
              calculateAdjustmentValue(this.dataset.source, parseInt(this.dataset.index), value);
            }
          });
        }
      });
    }
    
    // AUTO-CALCULATE ADJUSTMENT VALUE FROM PERCENTAGE
    function calculateAdjustmentValue(source, index, percentage) {
      // Get base price from car details
      const basePrice = getBasePriceForCalculation();
      
      if (basePrice > 0 && percentage !== 0) {
        const calculatedValue = Math.round((basePrice * Math.abs(percentage)) / 100);
        
        console.log(`Auto-calculating adjustment value: ${percentage}% Ã— â‚ª${basePrice.toLocaleString()} = â‚ª${calculatedValue.toLocaleString()}`);
        
        // Update the value field in DOM
        const valueInput = document.querySelector(`input[data-field="value"][data-source="${source}"][data-index="${index}"]`);
        if (valueInput) {
          valueInput.value = calculatedValue;
        }
        
        // Update helper with calculated value (works for both custom and levi)
        if (source === 'custom') {
          updateCustomAdjustmentInHelper(source, index, 'value', calculatedValue);
        } else if (source === 'levi') {
          updateLeviAdjustmentInHelper(source, index, 'value', calculatedValue);
        }
      }
    }
    
    // UPDATE LEVI ADJUSTMENT IN HELPER
    function updateLeviAdjustmentInHelper(source, index, field, value) {
      try {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Ensure Levi report structure exists
        if (!helper.levi_report) helper.levi_report = {};
        if (!helper.levi_report.adjustments) helper.levi_report.adjustments = [];
        
        // Update the specific adjustment
        if (helper.levi_report.adjustments[index]) {
          helper.levi_report.adjustments[index][field] = value;
          
          // Save back to helper
          sessionStorage.setItem('helper', JSON.stringify(helper));
          console.log(`âœ… Updated Levi adjustment ${index}.${field} = ${value}`);
        }
      } catch (error) {
        console.error('Error updating Levi adjustment in helper:', error);
      }
    }
    
    // GET BASE PRICE FOR CALCULATION
    function getBasePriceForCalculation() {
      // Try multiple sources for base price
      let basePrice = 0;
      
      // Priority 1: Car base price field
      const carBasePriceField = document.getElementById('carBasePrice');
      if (carBasePriceField && carBasePriceField.value) {
        const carBasePriceStr = carBasePriceField.value.replace(/[â‚ª,]/g, '') || '0';
        basePrice = parseFloat(carBasePriceStr) || 0;
      }
      
      // Priority 2: Helper data
      if (basePrice === 0) {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        basePrice = helper?.vehicle_value_base || 
                   helper?.car_details?.base_price || 
                   helper?.levi?.base_price || 
                   helper?.levi_report?.base_price || 0;
      }
      
      return basePrice;
    }
    
    // RECALCULATE ALL ADJUSTMENT VALUES (when base price changes)
    function recalculateAllAdjustmentValues() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments.length > 0) {
        console.log('ğŸ”„ Recalculating all adjustment values due to base price change');
        
        helper.levi.custom_adjustments.forEach((adjustment, index) => {
          if (adjustment.percentage && adjustment.percentage !== 0) {
            calculateAdjustmentValue('custom', index, adjustment.percentage);
          }
        });
      }
    }
    
    // UPDATE CUSTOM ADJUSTMENT IN HELPER
    function updateCustomAdjustmentInHelper(source, index, field, value) {
      if (source !== 'custom') return;
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments[index]) {
        const adjustment = helper.levi.custom_adjustments[index];
        
        // Update the field
        adjustment[field] = value;
        
        // Apply proper signs based on adjustment type when updating numeric fields
        if (field === 'percentage' || field === 'value') {
          const adjustmentType = adjustment.adjustmentType || 'addition';
          const absoluteValue = Math.abs(value);
          
          if (adjustmentType === 'subtraction') {
            adjustment[field] = -absoluteValue;
          } else {
            adjustment[field] = absoluteValue;
          }
        }
        
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log(`Updated custom adjustment ${index}.${field} to:`, adjustment[field]);
        console.log('Full adjustment object:', adjustment);
        
        // Update the structured Levi data for floating screen compatibility
        updateLeviDataStructure(helper);
        
        // Helper is already updated above with sessionStorage.setItem
        console.log('âœ… Helper updated with adjustment data');
      }
    }
    
    // UPDATE LEVI DATA STRUCTURE FOR FLOATING SCREEN COMPATIBILITY
    function updateLeviDataStructure(helper) {
      try {
        // Ensure expertise.levi_report exists
        if (!helper.expertise) helper.expertise = {};
        if (!helper.expertise.levi_report) helper.expertise.levi_report = {};
        
        // Map basic vehicle info from other helper sections
        if (helper.car_details) {
          helper.expertise.levi_report.manufacturer = helper.car_details.manufacturer || helper.vehicle?.manufacturer;
          helper.expertise.levi_report.year = helper.car_details.year || helper.vehicle?.year;
          helper.expertise.levi_report.base_price = helper.car_details.base_price;
          helper.expertise.levi_report.final_price = helper.car_details.market_value;
          helper.expertise.levi_report.vehicle_type = helper.vehicle?.vehicle_type || '';
          helper.expertise.levi_report.model_code = helper.vehicle?.model_code || '';
          helper.expertise.levi_report.category = helper.vehicle?.category || '';
          helper.expertise.levi_report.full_model = helper.vehicle?.model || helper.car_details.model;
        }
        
        // Process custom adjustments into the structure expected by Levi floating screen
        if (helper.levi?.custom_adjustments) {
          // Initialize all adjustment fields to ensure they exist
          helper.expertise.levi_report.registration = '';
          helper.expertise.levi_report.registration_percent = '';
          helper.expertise.levi_report.registration_value = '';
          helper.expertise.levi_report.registration_total = '';
          helper.expertise.levi_report.ownership = '';
          helper.expertise.levi_report.ownership_percent = '';
          helper.expertise.levi_report.ownership_value = '';
          helper.expertise.levi_report.ownership_total = '';
          helper.expertise.levi_report.km = '';
          helper.expertise.levi_report.km_percent = '';
          helper.expertise.levi_report.km_value = '';
          helper.expertise.levi_report.km_total = '';
          helper.expertise.levi_report.owners = '';
          helper.expertise.levi_report.owners_percent = '';
          helper.expertise.levi_report.owners_value = '';
          helper.expertise.levi_report.owners_total = '';
          helper.expertise.levi_report.features = '';
          helper.expertise.levi_report.features_percent = '';
          helper.expertise.levi_report.features_value = '';
          helper.expertise.levi_report.features_total = '';
          
          helper.levi.custom_adjustments.forEach((adjustment, index) => {
            const desc = adjustment.description ? adjustment.description.toLowerCase() : '';
            
            console.log(`ğŸ” Mapping adjustment ${index}: "${adjustment.description}" (${adjustment.percentage}%, â‚ª${adjustment.value})`);
            
            // Map based on description keywords ONLY (check specific terms first to avoid conflicts)
            if (desc.includes('×¢×œ×™×” ×œ×›×‘×™×©') || desc.includes('registration') || desc.includes('×¨×™×©×•×™')) {
              helper.expertise.levi_report.registration = adjustment.description || '×¢×œ×™×” ×œ×›×‘×™×©';
              helper.expertise.levi_report.registration_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.registration_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.registration_total = Math.abs(adjustment.value || 0);
              console.log(`âœ… Mapped to registration: ${adjustment.description}`);
            } else if (desc.includes('××¡×¤×¨ ×‘×¢×œ×™×') || desc.includes('owners')) {
              helper.expertise.levi_report.owners = adjustment.description || '××¡×¤×¨ ×‘×¢×œ×™×';
              helper.expertise.levi_report.owners_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.owners_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.owners_total = Math.abs(adjustment.value || 0);
              console.log(`âœ… Mapped to owners: ${adjustment.description}`);
            } else if (desc.includes('×‘×¢×œ×•×ª') || desc.includes('ownership')) {
              helper.expertise.levi_report.ownership = adjustment.description || '×‘×¢×œ×•×ª';
              helper.expertise.levi_report.ownership_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.ownership_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.ownership_total = Math.abs(adjustment.value || 0);
              console.log(`âœ… Mapped to ownership: ${adjustment.description}`);
            } else if (desc.includes('×§×´×') || desc.includes('km') || desc.includes('×§×™×œ×•××˜×¨×™×')) {
              helper.expertise.levi_report.km = adjustment.description || '××¡ ×§×´×';
              helper.expertise.levi_report.km_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.km_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.km_total = Math.abs(adjustment.value || 0);
              console.log(`âœ… Mapped to km: ${adjustment.description}`);
            } else if (desc.includes('×××¤×™×™× ×™×') || desc.includes('features')) {
              helper.expertise.levi_report.features = adjustment.description || '×××¤×™×™× ×™×';
              helper.expertise.levi_report.features_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.features_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.features_total = Math.abs(adjustment.value || 0);
              console.log(`âœ… Mapped to features: ${adjustment.description}`);
            } else {
              console.log(`âš ï¸ No mapping found for: "${adjustment.description}" - will be stored in helper for validation/report`);
            }
          });
        }
        
        // Update helper in sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('ğŸ“Š Updated Levi data structure for floating screen compatibility');
        
      } catch (error) {
        console.error('Error updating Levi data structure:', error);
      }
    }
    
    // CALCULATE SUMMARY TOTALS - Updates helper with calculated totals
    function calculateSummaryTotals() {
      try {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Calculate Levi adjustment totals
        let leviTotal = 0;
        if (helper.levi?.adjustments) {
          leviTotal = helper.levi.adjustments.reduce((sum, adj) => sum + (parseFloat(adj.value) || 0), 0);
        }
        if (helper.levi?.custom_adjustments) {
          leviTotal += helper.levi.custom_adjustments.reduce((sum, adj) => sum + (parseFloat(adj.value) || 0), 0);
        }
        
        // Calculate damage center totals
        let damageTotal = 0;
        if (helper.expertise?.damage_blocks) {
          helper.expertise.damage_blocks.forEach(block => {
            damageTotal += (parseFloat(block.parts_cost) || 0) + (parseFloat(block.work_cost) || 0) + (parseFloat(block.repairs_cost) || 0);
          });
        }
        
        // Update helper with calculated totals
        helper.summary_totals = {
          levi_total: leviTotal,
          damage_total: damageTotal,
          total_before_vat: leviTotal + damageTotal,
          total_with_vat: Math.round((leviTotal + damageTotal) * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100)),
          calculated_at: new Date().toISOString()
        };
        
        sessionStorage.setItem('helper', JSON.stringify(helper));
        console.log('âœ… Summary totals calculated and updated in helper:', helper.summary_totals);
        
        // Trigger floating screen updates when helper changes
        triggerFloatingScreenRefresh();
        
      } catch (error) {
        console.error('Error calculating summary totals:', error);
      }
    }

    // TRIGGER FLOATING SCREEN REFRESH - Updates all helper-dependent floating screens
    function triggerFloatingScreenRefresh() {
      try {
        console.log('ğŸ”„ Triggering floating screen refresh after helper update');
        
        // Update helper with current 3-bulk calculations
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Ensure calculations structure exists
        helper.calculations = helper.calculations || {};
        helper.expertise = helper.expertise || {};
        helper.expertise.calculations = helper.expertise.calculations || {};
        
        // Update with current bulk calculations - with safety checks
        let grossMarketValue = 0;
        let fullMarketValue = 0;
        let totalClaim = 0;
        let grossPercentage = 0;
        
        if (window.FinalReportCalculations && typeof window.FinalReportCalculations === 'object') {
          grossMarketValue = window.FinalReportCalculations.getGrossMarketValue();
          fullMarketValue = window.FinalReportCalculations.getFullMarketValue();
          totalClaim = window.FinalReportCalculations.getTotalClaim();
          grossPercentage = window.FinalReportCalculations.getGrossPercentage();
        } else {
          console.warn('FinalReportCalculations not yet initialized, using fallback values');
          // Try to get values from DOM or helper as fallback
          grossMarketValue = parseFloat(document.getElementById('grossMarketValueResult')?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
          fullMarketValue = parseFloat(document.getElementById('fullMarketValueResult')?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
          totalClaim = parseFloat(document.getElementById('totalClaim')?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
          grossPercentage = parseFloat(document.getElementById('grossPercent')?.value.replace(/[%]/g, '') || '0') || 0;
        }
        
        // âœ… FIX: Check for manual authorizedClaim value and use that instead of calculated totalClaim
        const authorizedClaimField = document.getElementById('authorizedClaim');
        if (authorizedClaimField && authorizedClaimField.value && authorizedClaimField.value !== '') {
          const manualTotalClaim = parseFloat(authorizedClaimField.value.replace(/[â‚ª,]/g, '')) || 0;
          if (manualTotalClaim > 0) {
            totalClaim = manualTotalClaim;
            console.log(`ğŸ”§ Using manual authorizedClaim value: ${totalClaim} instead of calculated value`);
          }
        }
        
        // Get original base price from valuation (preserve webhook data)
        const rawBasePrice = helper.valuation?.base_price || 
                             helper.car_details?.base_price || 
                             helper.levi_report?.base_price || 0;
        const originalBasePrice = parseFloat(String(rawBasePrice).replace(/[â‚ª,]/g, '')) || 0;
        
        helper.calculations.vehicle_value_gross = grossMarketValue;
        helper.calculations.market_value = fullMarketValue;
        helper.calculations.full_market_value = fullMarketValue;
        helper.calculations.total_damage = totalClaim;
        helper.calculations.damage_percent = grossPercentage;
        
        // Add new bridge fields between webhook and user modifications
        helper.calculations.base_price = originalBasePrice;
        helper.calculations.final_adjustments_value = Math.round(fullMarketValue - originalBasePrice);
        
        // Debug logging to verify correct calculation
        console.log(`ğŸ” Bridge Field Debug: fullMarketValue=${fullMarketValue}, originalBasePrice=${originalBasePrice}, final_adjustments_value=${Math.round(fullMarketValue - originalBasePrice)}`);
        
        // Update expertise calculations for compatibility
        helper.expertise.calculations.vehicle_value_gross = grossMarketValue;
        helper.expertise.calculations.market_value = fullMarketValue;
        helper.expertise.calculations.total_damage = totalClaim;
        helper.expertise.calculations.damage_percent = grossPercentage;
        
        // Update claims_data for UI consistency
        helper.claims_data = helper.claims_data || {};
        
        helper.claims_data.gross_percent = `${grossPercentage.toFixed(2)}%`;
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Debug: Check which refresh functions are available
        console.log('Debug: Available refresh functions:', {
          refreshLeviData: typeof window.refreshLeviData,
          refreshCarData: typeof window.refreshCarData, 
          refreshInvoiceData: typeof window.refreshInvoiceData,
          refreshPartsResults: typeof window.refreshPartsResults
        });
        
        // Refresh Levi floating screen if open
        if (window.refreshLeviData && typeof window.refreshLeviData === 'function') {
          console.log('ğŸ”„ Refreshing Levi floating screen');
          window.refreshLeviData();
        }
        
        // Refresh Car Details floating screen if open
        if (window.refreshCarData && typeof window.refreshCarData === 'function') {
          console.log('ğŸ”„ Refreshing Car Details floating screen');
          window.refreshCarData();
        }
        
        // Refresh Invoice floating screen if open
        if (window.refreshInvoiceData && typeof window.refreshInvoiceData === 'function') {
          console.log('ğŸ”„ Refreshing Invoice floating screen');
          window.refreshInvoiceData();
        }
        
        // Refresh Parts Search floating screen
        if (window.refreshPartsResults && typeof window.refreshPartsResults === 'function') {
          console.log('ğŸ”„ Refreshing Parts Search floating screen');
          window.refreshPartsResults();
        }
        
        // Alternative: Try to reload data directly from iframe/floating screens
        setTimeout(() => {
          // Try to refresh via postMessage to floating screens
          const floatingScreens = document.querySelectorAll('.floating-screen[style*="block"]');
          floatingScreens.forEach(screen => {
            console.log('ğŸ”„ Found open floating screen:', screen.id);
            const iframe = screen.querySelector('iframe');
            if (iframe && iframe.contentWindow) {
              try {
                iframe.contentWindow.postMessage({
                  type: 'refreshData',
                  source: 'final-report-builder',
                  calculations: helper.calculations,
                  timestamp: new Date().toISOString()
                }, '*');
              } catch (e) {
                console.log('Could not post message to iframe:', e);
              }
            }
          });
        }, 100);
        
        // Dispatch custom event for any other modules listening
        window.dispatchEvent(new CustomEvent('helperDataUpdated', {
          detail: { 
            timestamp: new Date().toISOString(),
            source: 'final-report-builder',
            calculations: helper.calculations
          }
        }));
        
        
        console.log('âœ… Helper updated with 3-bulk calculations:', {
          grossMarketValue,
          fullMarketValue,
          totalClaim,
          grossPercentage
        });
        
      } catch (error) {
        console.error('Error triggering floating screen refresh:', error);
      }
    }

    // LEGACY FUNCTION - Keep for compatibility but redirect to unified system
    function addCustomSummaryField(summaryType) {
      // Redirect to new unified system
      addCustomAdjustmentField();
    }
    
    // DEBUG FUNCTION - Test the complete data flow chain
    window.testDataFlow = function() {
      console.log('ğŸ§ª TESTING DATA FLOW CHAIN');
      
      // 1. Check if helper exists
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('1ï¸âƒ£ Helper exists:', !!helper);
      console.log('   Helper keys:', Object.keys(helper));
      
      // 2. Test manual helper update
      console.log('2ï¸âƒ£ Testing manual helper update...');
      helper.test_field = 'test_value_' + Date.now();
      helper.car_details = helper.car_details || {};
      helper.car_details.manufacturer = 'TEST_MANUFACTURER';
      sessionStorage.setItem('helper', JSON.stringify(helper));
      console.log('   Helper updated with test data');
      
      // 3. Test floating screen refresh
      console.log('3ï¸âƒ£ Testing floating screen refresh...');
      triggerFloatingScreenRefresh();
      
      // 4. Check if refresh functions are available
      console.log('4ï¸âƒ£ Checking refresh function availability:');
      console.log('   refreshLeviData:', typeof window.refreshLeviData);
      console.log('   refreshCarData:', typeof window.refreshCarData);
      console.log('   refreshInvoiceData:', typeof window.refreshInvoiceData);
      console.log('   refreshPartsResults:', typeof window.refreshPartsResults);
      
      // 5. Test manual adjustment input
      console.log('5ï¸âƒ£ Testing manual adjustment input...');
      // Final report container removed - will return empty NodeList
      const adjustmentInputs = document.querySelectorAll('#allAdjustmentsRows-final-report input[data-source="custom"]');
      console.log('   Found adjustment inputs:', adjustmentInputs.length);
      
      if (adjustmentInputs.length > 0) {
        const firstInput = adjustmentInputs[0];
        console.log('   First input element:', firstInput);
        console.log('   First input data attributes:', {
          source: firstInput.dataset.source,
          index: firstInput.dataset.index,
          field: firstInput.dataset.field
        });
        
        // Simulate input change
        firstInput.value = 'TEST_ADJUSTMENT_' + Date.now();
        firstInput.dispatchEvent(new Event('input', { bubbles: true }));
        console.log('   Simulated input change');
      }
      
      console.log('ğŸ§ª DATA FLOW TEST COMPLETE');
    };

    // REMOVED DUPLICATE FUNCTION - Using the enhanced version above

    // UPDATE HELPER FROM FIELD
    function updateHelperFromField(event) {
      try {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        const fieldId = event.target.id;
        const value = event.target.value;
        
        console.log(`ğŸ“ Field change detected: ${fieldId} = "${value}"`);
        
        // Update the appropriate helper section based on field
        if (['carPlate', 'carManufacturer', 'carModel', 'carYear', 'carModelCode', 'carBasePrice', 'carMarketValue', 'carReportDate', 'basicPrice', 'finalReportDate', 'finalReportDateSummary'].includes(fieldId)) {
          helper.car_details = helper.car_details || {};
          helper.vehicle = helper.vehicle || {};
          
          const mapping = {
            'carPlate': 'plate',
            'carManufacturer': 'manufacturer',
            'carModel': 'model',
            'carYear': 'year',
            'carModelCode': 'model_code',
            'carBasePrice': 'base_price',
            'carMarketValue': 'market_value',
            'carReportDate': 'report_date',
            'basicPrice': 'basic_price',
            'finalReportDate': 'final_report_date',
            'finalReportDateSummary': 'final_report_date'
          };
          
          // Update car_details (builder format)
          helper.car_details[mapping[fieldId]] = value;
          
          // Special handling for final report date - also save to final_report.report_date
          if (fieldId === 'finalReportDate' || fieldId === 'finalReportDateSummary') {
            helper.final_report = helper.final_report || {};
            helper.final_report.report_date = value;
            console.log('ğŸ“… Also saved to final_report.report_date:', value);
          }
          
          // Also update vehicle structure (floating screen format)
          if (fieldId === 'carManufacturer') {
            helper.vehicle.manufacturer = value;
            console.log('ğŸš— Updated vehicle manufacturer:', value);
          } else if (fieldId === 'carModel') {
            helper.vehicle.model = value;
            console.log('ğŸš— Updated vehicle model:', value);
          } else if (fieldId === 'carYear') {
            helper.vehicle.year = value;
            console.log('ğŸš— Updated vehicle year:', value);
          } else if (fieldId === 'carModelCode') {
            helper.vehicle.model_code = value;
            console.log('ğŸš— Updated vehicle model code:', value);
          } else if (fieldId === 'carPlate') {
            // CRITICAL FIX: Use centralized plate standardization function
            if (window.setPlateNumber) {
              window.setPlateNumber(value, 'final-report-builder');
            } else {
              // Fallback: standardize manually
              const standardizedPlate = value ? String(value).replace(/[-\s]/g, '') : '';
              helper.vehicle.plate_number = standardizedPlate;
              helper.meta = helper.meta || {};
              helper.meta.plate = standardizedPlate;
            }
            console.log('ğŸš— Updated vehicle plate:', value);
          } else if (fieldId === 'basicPrice') {
            // Update levi_report structure for basic price
            helper.levi_report = helper.levi_report || {};
            helper.levi_report.base_price = value.replace(/[â‚ª,]/g, '');
            helper.expertise = helper.expertise || {};
            helper.expertise.levi_report = helper.expertise.levi_report || {};
            helper.expertise.levi_report.base_price = value.replace(/[â‚ª,]/g, '');
            console.log('ğŸš— Updated basic price:', value);
          }
          
          // Plate update is now handled above with centralized function
        } else if (['ownerName', 'ownerAddress', 'ownerPhone', 'insuranceCompany', 'insuranceEmail', 'insuranceAgent', 'agentPhone', 'agentEmail'].includes(fieldId)) {
          helper.client = helper.client || {};
          helper.car_details = helper.car_details || {};
          
          const mapping = {
            'ownerName': 'name',
            'ownerAddress': 'address',
            'ownerPhone': 'phone',
            'insuranceCompany': 'insurance_company',
            'insuranceEmail': 'insurance_email',
            'insuranceAgent': 'insurance_agent',
            'agentPhone': 'insurance_agent_phone',
            'agentEmail': 'insurance_agent_email'
          };
          
          // Update client structure (main format)
          helper.client[mapping[fieldId]] = value;
          
          // Also update car_details structure (floating screen format)
          if (fieldId === 'ownerName') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.name = value;
            helper.car_details.owner = value;
          } else if (fieldId === 'ownerAddress') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.address = value;
            helper.car_details.ownerAddress = value;
          } else if (fieldId === 'ownerPhone') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.phone_number = value;
            helper.car_details.ownerPhone = value;
          } else if (fieldId === 'insuranceCompany') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_company = value;
            helper.car_details.insuranceCompany = value;
          } else if (fieldId === 'insuranceAgent') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_agent = value;
            helper.car_details.agentName = value;
          } else if (fieldId === 'agentPhone') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_agent_phone = value;
            helper.car_details.insurance_agent_phone = value;
          } else if (fieldId === 'agentEmail') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_agent_email = value;
            helper.car_details.insurance_agent_email = value;
          }
        } else if (fieldId === 'totalClaim') {
          // Claims data mapping
          helper.claims_data = helper.claims_data || {};
          helper.claims_data.total_claim = value;
          console.log(`ğŸ’° Updated claims_data.total_claim from ${fieldId}: ${value}`);
          
          // âœ… ENSURE: Update window.helper immediately
          window.helper = helper;
          
          // Also update expertise.calculations for compatibility
          helper.expertise = helper.expertise || {};
          helper.expertise.calculations = helper.expertise.calculations || {};
          if (fieldId === 'totalClaim') {
            // Remove currency formatting and parse number
            const numericValue = parseFloat(value.replace(/[â‚ª,]/g, '')) || 0;
            helper.expertise.calculations.total_damage = numericValue;
          }
          
          console.log(`ğŸ’° Updated claims data: ${fieldId} = "${value}"`);
        } else if (['sumMarketValue', 'sumClaim', 'sumVAT', 'sumTotalClaim', 'depCompensation', 'salvageValue', 'garageDays', 
                   'sumMarketValueGlobal', 'sumMarketValueDamage', 'sumMarketValueTotal', 'sumMarketValueLegal',
                   'saleValueDamage', 'afterSaleDamage', 'salvageValueTotal', 'storageValueTotal', 'afterSaleTotal',
                   'salvageValueLegal', 'afterSaleLegal'].includes(fieldId)) {
          
          // COMPREHENSIVE SUMMARY FIELD MAPPING FOR ALL 5 REPORT VARIANTS
          
          // Handle garage days separately
          if (fieldId === 'garageDays') {
            helper.final_report.work_days = value;
          } else {
            helper.final_report.summary = helper.final_report.summary || {};
            
            // COMPREHENSIVE FIELD MAPPING DICTIONARY FOR ALL VARIANTS
            const comprehensiveMapping = {
              // COMMON FIELDS (used across multiple variants)
              'sumMarketValue': 'market_value',           // Private report market value
              'sumMarketValueGlobal': 'market_value_global',     // Global report market value  
              'sumMarketValueDamage': 'market_value_damage',     // Damage sale report market value
              'sumMarketValueTotal': 'market_value_total',       // Total loss report market value
              'sumMarketValueLegal': 'market_value_legal',       // Legal loss report market value
              
              // PRIVATE REPORT SPECIFIC FIELDS  
              'sumClaim': 'total_claim',
              'sumVAT': 'vat',
              'sumTotalClaim': 'total_with_vat',
              'depCompensation': 'dep_compensation',
              
              // DAMAGED SALE VARIANT SPECIFIC FIELDS
              'saleValueDamage': 'sale_value_damaged',           // Manual input: sale value in damaged state
              'paymentMethod': 'paymentMethod',                  // Manual input: payment method for damaged sale
              'afterSaleDamage': 'total_after_sale_damage',      // Calculated: market value - sale value
              
              // TOTAL LOSS VARIANT SPECIFIC FIELDS  
              'salvageValueTotal': 'salvage_value_total',        // Manual input: salvage value for total loss
              'storageValueTotal': 'storage_towing_value_total', // Manual input: storage/towing costs
              'afterSaleTotal': 'total_after_salvage_total',     // Calculated: market value - salvage + storage
              
              // LEGAL LOSS VARIANT SPECIFIC FIELDS
              'salvageValueLegal': 'salvage_value_legal',        // Manual input: salvage value for legal loss
              'afterSaleLegal': 'total_after_salvage_legal',     // Calculated: market value - salvage
              
              // LEGACY FIELDS (maintain compatibility)
              'salvageValue': 'salvage_value'                    // General salvage value field
            };
            
            // Map field to helper structure
            const mappedKey = comprehensiveMapping[fieldId];
            if (mappedKey) {
              helper.final_report.summary[mappedKey] = value;
              console.log(`ğŸ“Š Updated summary field: ${fieldId} -> ${mappedKey} = "${value}"`);
            } else {
              console.warn(`âš ï¸ No mapping found for field: ${fieldId}`);
            }
          }
        }
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Trigger floating screen updates when helper changes
        triggerFloatingScreenRefresh();
        
        // Update page title if plate changed
        if (fieldId === 'carPlate') {
          // Standardize plate format
          const standardizedValue = value && value !== '...' ? String(value).replace(/[-\s]/g, '') : (value || '...');
          document.getElementById('pageTitle').textContent = `×¨×›×‘ ××¡. ${standardizedValue}`;
        }
        
        // Update legal text with new data
        loadLegalText().catch(console.error);
        
        // Special handling for salvage value changes
        if (fieldId === 'salvageValue') {
          console.log('Salvage value updated:', value);
        }
        
        // Trigger calculations if field affects calculations
        const calculationFields = ['basicPrice', 'carBasePrice', 'carMarketValue', 'totalClaim'];
        if (calculationFields.includes(fieldId)) {
          setTimeout(() => {
            if (window.FinalReportCalculations && typeof window.FinalReportCalculations.refresh3BulkCalculations === 'function') {
              window.FinalReportCalculations.refresh3BulkCalculations();
            }
          }, 100);
        }
        
      } catch (error) {
        console.error('Error updating helper from field:', error);
      }
    }

    // âœ… STANDARDIZED CLAIMS DATA MAPPING FUNCTION
    function updateClaimsDataFromField(element, claimsKey) {
      try {
        const helper = window.helper || {};
        if (!helper.claims_data) helper.claims_data = {};
        
        let value = element.value;
        const fieldId = element.id;
        
        console.log(`ğŸ’° Claims data field change: ${fieldId} -> claims_data.${claimsKey} = "${value}"`);
        
        // Format currency fields
        if (claimsKey === 'authorized_claim' && value) {
          // Remove existing currency symbols and format properly
          value = value.replace(/[â‚ª,]/g, '').trim();
          if (value && !isNaN(value)) {
            const numericValue = parseInt(value);
            value = `â‚ª${numericValue.toLocaleString()}`;
          }
        }
        
        // Update claims_data
        helper.claims_data[claimsKey] = value;
        
        // Also update calculations.authorized_claim when authorized_claim is updated
        if (claimsKey === 'authorized_claim') {
          if (!helper.calculations) helper.calculations = {};
          helper.calculations.authorized_claim = value;
        }
        
        // Save to helper
        window.helper = helper;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log(`âœ… Updated claims_data.${claimsKey} = "${value}"`);
        
        // Trigger floating screen refresh
        if (typeof triggerFloatingScreenRefresh === 'function') {
          triggerFloatingScreenRefresh();
        }
        
      } catch (error) {
        console.error('Error updating claims data:', error);
      }
    }

    // Update helper from contact field - delegates to updateHelperFromField
    function updateHelperFromContactField(element) {
      const event = { target: element };
      updateHelperFromField(event);
    }

    // Copied from estimator-builder.html - dynamic sign handling
    function getDropdownTypeFromValues(percentValue, amountValue, currentType) {
      // Priority: Check percent first, then amount
      let numericValue = null;
      
      if (percentValue !== null && percentValue !== undefined && percentValue !== '' && !isNaN(percentValue)) {
        numericValue = parseFloat(percentValue);
      } else if (amountValue !== null && amountValue !== undefined && amountValue !== '' && !isNaN(amountValue)) {
        numericValue = parseFloat(amountValue);
      }
      
      // If we have a numeric value, determine type based on sign
      if (numericValue !== null && numericValue !== 0) {
        return numericValue < 0 ? 'minus' : 'plus';
      }
      
      // Fall back to current type or default to 'plus'
      return currentType || 'plus';
    }

    // âœ… STANDARDIZED CLAIMS DATA MAPPING - Load from helper to UI
    function loadClaimsDataToUI() {
      try {
        const helper = window.helper || {};
        const claimsData = helper.claims_data || {};
        
        // Insurance authorization field
        const insuranceField = document.getElementById('insuranceAuthorization');
        if (insuranceField && claimsData.authorized_claim) {
          insuranceField.value = claimsData.authorized_claim;
        }
        
        console.log('âœ… Claims data loaded to UI fields');
        
      } catch (error) {
        console.error('Error loading claims data to UI:', error);
      }
    }

    // UPDATE REPORT TYPE
    function updateReportType() {
      const reportTypeSelect = document.getElementById('reportType');
      const selectedType = reportTypeSelect?.value || '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª';
      
      console.log('ğŸ”„ Updating report type to:', selectedType);
      
      // Hide all summary sections first
      const summaryBlocks = document.querySelectorAll('.summary-block');
      summaryBlocks.forEach(block => block.style.display = 'none');
      
      // Show the correct summary section based on selected type
      let summaryId = '';
      switch(selectedType) {
        case '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª':
          summaryId = 'summaryPrivate';
          break;
        case '×—×•×•×ª ×“×¢×ª ×’×œ×•×‘×œ×™×ª':
          summaryId = 'summaryGlobal';
          break;
        case '×—×•×•×ª ×“×¢×ª ××›×™×¨×” ××¦×‘×• ×”× ×™×–×•×§':
          summaryId = 'summaryDamage';
          break;
        case '×—×•×•×ª ×“×¢×ª ×˜×•×˜×œ×•×¡×˜':
          summaryId = 'summaryTotalLoss';
          break;
        case '×—×•×•×ª ×“×¢×ª ××•×‘×“×Ÿ ×œ×”×œ×›×”':
          summaryId = 'summaryLegalLoss';
          break;
        default:
          summaryId = 'summaryPrivate';
      }
      
      // Show the selected summary section
      const selectedSummary = document.getElementById(summaryId);
      if (selectedSummary) {
        selectedSummary.style.display = 'block';
        console.log('âœ… Showing summary section:', summaryId);
        
        // ğŸ”§ FIX: Refresh summary content after changing report type
        refreshSummary();
        console.log('ğŸ”„ Summary content refreshed for report type:', selectedType);
      } else {
        console.warn('âš ï¸ Summary section not found:', summaryId);
      }
    }


    // LOAD LEGAL TEXT USING CENTRALIZED ENGINE
    async function loadLegalText() {
      const reportTypeSelect = document.getElementById('reportType');
      const reportType = reportTypeSelect?.value || '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª';
      
      console.log('ğŸ”„ Loading legal text for report type:', reportType);
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Collect values for placeholder replacement
      const placeholderValues = {
        plate: document.getElementById('carPlate')?.value || helper.meta?.plate,
        manufacturer: document.getElementById('carManufacturer')?.value || helper.car_details?.manufacturer,
        model: document.getElementById('carModel')?.value || helper.car_details?.model,
        year: document.getElementById('carYear')?.value || helper.car_details?.year,
        ownerName: document.getElementById('ownerName')?.value || helper.client?.name,
        modelCode: document.getElementById('carModelCode')?.value || helper.car_details?.model_code || helper.levi_report?.model_code,
        damagePercent: document.getElementById('grossPercent')?.value || helper.claims_data?.gross_percent || calculateDamagePercentage() || helper.expertise?.calculations?.damage_percent,
        depreciation: document.getElementById('globalDep1')?.value || helper.final_report?.depreciation?.global_percent,
        damageCenters: (() => {
          // Primary source: damage_assessment.total_centers
          if (helper.damage_assessment?.total_centers) {
            return helper.damage_assessment.total_centers.toString();
          }
          
          // Fallback: Try multiple sources for damage centers count
          if (helper.damage_centers_summary && typeof helper.damage_centers_summary === 'object') {
            return Object.keys(helper.damage_centers_summary).filter(key => key.startsWith('Damage center')).length || 
                   Object.keys(helper.damage_centers_summary).length;
          }
          if (helper.damage_assessment?.comprehensive?.centers && typeof helper.damage_assessment.comprehensive.centers === 'object') {
            return Object.keys(helper.damage_assessment.comprehensive.centers).length;
          }
          if (helper.expertise?.damage_blocks?.length) {
            return helper.expertise.damage_blocks.length;
          }
          return '1'; // Default fallback
        })(),
        garageDays: document.getElementById('garageDays')?.value || helper.final_report?.work_days || helper.expertise?.depreciation?.work_days,
        carValue: document.getElementById('carMarketValue')?.value || document.getElementById('sumMarketValue')?.value || (helper.calculations?.full_market_value ? `â‚ª${helper.calculations.full_market_value.toLocaleString()}` : undefined),
        salvageValue: (() => {
          // Check report type to determine correct salvage field
          const reportType = reportTypeSelect?.value || '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª';
          let salvageInput;
          
          if (reportType === '×—×•×•×ª ×“×¢×ª ×˜×•×˜×œ×•×¡×˜') {
            // Total Loss variant uses salvageValueTotal
            salvageInput = document.getElementById('salvageValueTotal')?.value;
          } else if (reportType === '×—×•×•×ª ×“×¢×ª ××•×‘×“×Ÿ ×œ×”×œ×›×”') {
            // Legal Loss variant uses salvageValueLegal  
            salvageInput = document.getElementById('salvageValueLegal')?.value;
          } else {
            // Other variants use general salvageValue
            salvageInput = document.getElementById('salvageValue')?.value;
          }
          
          // Enhanced helper data fallback for variant-specific salvage values
          let helperSalvage = '';
          if (reportType === '×—×•×•×ª ×“×¢×ª ×˜×•×˜×œ×•×¡×˜') {
            helperSalvage = helper.final_report?.summary?.salvage_value_total ||
                           helper.final_report?.summary?.salvageValueTotal ||
                           helper.salvage_value_total_loss ||
                           helper.salvageValueTotal;
          } else if (reportType === '×—×•×•×ª ×“×¢×ª ××•×‘×“×Ÿ ×œ×”×œ×›×”') {
            helperSalvage = helper.final_report?.summary?.salvage_value_legal ||
                           helper.final_report?.summary?.salvageValueLegal ||
                           helper.salvage_value_legal_loss ||
                           helper.salvageValueLegal;
          } else {
            helperSalvage = helper.final_report?.summary?.salvage_value || 
                           helper.final_report?.salvage_value ||
                           helper.salvage_value;
          }
          
          let rawValue = '';
          if (salvageInput && salvageInput.trim() !== '' && salvageInput !== 'â‚ª0') {
            rawValue = salvageInput;
          } else if (helperSalvage && helperSalvage !== 'â‚ª0') {
            rawValue = helperSalvage;
          }
          
          // Remove existing currency symbols to prevent doubling
          if (rawValue) {
            rawValue = rawValue.replace(/â‚ª|×©\"×—|×©×´×—/g, '').trim();
            // Add clean currency formatting
            const numericValue = rawValue.replace(/[^\d.-]/g, '');
            if (numericValue) {
              return `â‚ª${Number(numericValue).toLocaleString()}`;
            }
          }
          return undefined;
        })(),
        compensation: (() => {
          // For Global variant - prioritize final_report.summary.global_before_differentials
          const globalSummary = helper.final_report?.summary?.global_before_differentials;
          const depCompField = document.getElementById('depCompensation')?.value;
          const helperComp = helper.final_report?.summary?.dep_compensation;
          const globalDepValue = helper.depreciation?.globalDepValue;
          
          let rawValue = '';
          if (globalSummary && globalSummary !== 'â‚ª0') {
            rawValue = globalSummary;
          } else if (depCompField && depCompField.trim() !== '' && depCompField !== 'â‚ª0') {
            rawValue = depCompField;
          } else if (helperComp && helperComp !== 'â‚ª0') {
            rawValue = helperComp;
          } else if (globalDepValue) {
            rawValue = `â‚ª${globalDepValue.toLocaleString()}`;
          }
          
          // Remove existing currency symbols to prevent doubling
          if (rawValue) {
            rawValue = rawValue.replace(/â‚ª|×©\"×—|×©×´×—/g, '').trim();
            // Add clean currency formatting
            const numericValue = rawValue.replace(/[^\d.-]/g, '');
            if (numericValue) {
              return `â‚ª${Number(numericValue).toLocaleString()}`;
            }
          }
          return undefined;
        })(),
        salePrice: (() => {
          // For Damaged Sale variant - use saleValueDamage field
          const saleField = document.getElementById('saleValueDamage')?.value;
          const helperSale = helper.final_report?.summary?.sale_value_damaged;
          
          let rawValue = '';
          if (saleField && saleField.trim() !== '' && saleField !== 'â‚ª0') {
            rawValue = saleField;
          } else if (helperSale && helperSale !== 'â‚ª0') {
            rawValue = helperSale;
          }
          
          // Remove existing currency symbols to prevent doubling
          if (rawValue) {
            rawValue = rawValue.replace(/â‚ª|×©\"×—|×©×´×—/g, '').trim();
            // Add clean currency formatting
            const numericValue = rawValue.replace(/[^\d.-]/g, '');
            if (numericValue) {
              return `â‚ª${Number(numericValue).toLocaleString()}`;
            }
          }
          return undefined;
        })(),
        paymentMethod: (() => {
          // For Damaged Sale variant - payment method from UI field
          const paymentField = document.getElementById('paymentMethod')?.value;
          const helperPayment = helper.final_report?.summary?.paymentMethod;
          
          if (paymentField && paymentField.trim() !== '') {
            return paymentField.trim();
          } else if (helperPayment && helperPayment.trim() !== '') {
            return helperPayment;
          }
          return undefined;
        })()
      };
      
      try {
        // Use the centralized legal text engine
        const legalText = await window.LegalTextEngine.getProcessedText(
          reportType, 
          placeholderValues, 
          'final_report'
        );
        
        const legalTextElement = document.getElementById('legal-text-content');
        if (legalTextElement) {
          legalTextElement.value = legalText;
          console.log('âœ… Legal text loaded successfully from vault for:', reportType);
        } else {
          console.error('âŒ Legal text element not found: legal-text-content');
        }
        
      } catch (error) {
        console.error('âŒ Error loading legal text:', error);
        const legalTextElement = document.getElementById('legal-text-content');
        if (legalTextElement) {
          legalTextElement.value = '×©×’×™××” ×‘×˜×¢×™× ×ª ×˜×§×¡×˜ ××©×¤×˜×™ ××”×›×¡×¤×ª - ×× × ×‘×“×•×§ ××ª ×”×—×™×‘×•×¨';
        }
      }
    }

    // LOAD LEGAL TEXT FROM VAULT - SEPARATE FUNCTION FOR BUTTON
    function loadLegalTextFromVault() {
      try {
        loadLegalText().then(() => {
          // Save the legal text to helper after it's been loaded
          setTimeout(() => {
            try {
              const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
              
              // Initialize final_report object if it doesn't exist
              if (!helper.final_report) {
                helper.final_report = {};
              }
              
              const legalTextElement = document.getElementById('legal-text-content');
              if (legalTextElement && legalTextElement.value) {
                helper.final_report.legal_text = legalTextElement.value;
                sessionStorage.setItem('helper', JSON.stringify(helper));
                console.log('âœ… Legal text loaded from vault and saved to final report');
              } else {
                console.error('âŒ Legal text element not found or empty');
              }
            } catch (error) {
              console.error('âŒ Error saving legal text to helper:', error);
            }
          }, 100);
        }).catch(error => {
          console.error('âŒ Error loading legal text from vault:', error);
        });
      } catch (error) {
        console.error('âŒ Error in loadLegalTextFromVault:', error);
      }
    }

    // Save legal text after report type or other changes
    function saveLegalTextAfterChange() {
      // Wait for legal text to be loaded, then save to helper
      setTimeout(() => {
        const legalTextArea = document.getElementById('legal-text-content');
        if (legalTextArea && legalTextArea.value && legalTextArea.value.trim() !== '') {
          const helper = window.helper || {};
          
          // Initialize final_report object if it doesn't exist
          if (!helper.final_report) {
            helper.final_report = {};
          }
          helper.final_report.legal_text = legalTextArea.value;
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
          updateBuilderCurrentState('final_report.legal_text', legalTextArea.value);
          
          console.log('âœ… Legal text updated and saved to helper after report type change');
        }
      }, 1500); // Wait longer for legal text engine to load new content
    }

    // RESET LEGAL TEXT
    function resetLegalText() {
      const reportTypeSelect = document.getElementById('reportType');
      const reportType = reportTypeSelect?.value || '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª';
      // Map report type to display text
      let typeText = '×¤×¨×˜×™×ª';
      switch(reportType) {
        case '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª':
          typeText = '×¤×¨×˜×™×ª';
          break;
        case '×—×•×•×ª ×“×¢×ª ×’×œ×•×‘×œ×™×ª':
          typeText = '×’×œ×•×‘×œ×™×ª';
          break;
        case '×—×•×•×ª ×“×¢×ª ××›×™×¨×” ××¦×‘×• ×”× ×™×–×•×§':
          typeText = '××›×™×¨×” ××¦×‘×• ×”× ×™×–×•×§';
          break;
        case '×—×•×•×ª ×“×¢×ª ×˜×•×˜×œ×•×¡×˜':
          typeText = '×˜×•×˜×œ×•×¡×ª';
          break;
        case '×—×•×•×ª ×“×¢×ª ××•×‘×“×Ÿ ×œ×”×œ×›×”':
          typeText = '××•×‘×“×Ÿ ×œ×”×œ×›×”';
          break;
      }
      
      document.getElementById('legal-text-content').value = `×˜×§×¡×˜ ××©×¤×˜×™ ×œ×—×•×•×ª ×“×¢×ª ×¡×•×¤×™×ª ${typeText} - ××•×›×Ÿ ×œ×¢×¨×™×›×”`;
      
      // Clear saved legal text from helper
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (helper.final_report) {
        delete helper.final_report.legal_text;
      }
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      console.log('Legal text reset');
    }

    // LOAD ATTACHMENTS FROM VAULT
    async function loadAttachmentsFromVault() {
      console.log('ğŸ”µ loadAttachmentsFromVault function called');
      
      try {
        // Get selected type from dropdown
        const reportTypeSelect = document.getElementById('reportType');
        console.log('ğŸ”µ reportTypeSelect element:', reportTypeSelect);
        
        const reportType = reportTypeSelect?.value || '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª';
        console.log('ğŸ“ Loading attachments from vault for type:', reportType);
        
        // Use the legal text engine to get attachments from the actual vault
        if (window.LegalTextEngine) {
          console.log('ğŸ”µ LegalTextEngine is available');
          const attachmentsText = await window.LegalTextEngine.getAttachments(reportType);
          
          const attachmentsElement = document.getElementById('attachments-content');
          console.log('ğŸ”µ attachments-content element:', attachmentsElement);
          
          if (attachmentsElement) {
            attachmentsElement.value = attachmentsText;
            console.log('ğŸ”µ Attachments text set to textarea');
          } else {
            console.error('âŒ attachments-content element not found');
          }
          
          // Save to helper and LOCK the selection
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          if (!helper.final_report) helper.final_report = {};
          helper.final_report.attachments = attachmentsText;
          helper.final_report.attachments_locked = true; // Lock the selection
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          console.log('âœ… Attachments loaded from vault using LegalTextEngine and LOCKED');
        } else {
          console.error('âŒ LegalTextEngine not available');
          // Fallback to hardcoded with ×—×©×›"×˜
          const fallbackText = '**×œ×•×˜×”**\n×ª×¦×œ×•××™ ×”×¨×›×‘ ×”× ×™×–×•×§\n×—×©×‘×•× ×™×•×ª ×ª×™×§×•×Ÿ\n×¢×¨×š ×¨×›×‘ ×××•×—×©×‘\n×¦×™×œ×•× ×¨×™×©×™×•×Ÿ ×”×¨×›×‘\n×—×©×›"×˜';
          document.getElementById('attachments-content').value = fallbackText;
        }
      } catch (error) {
        console.error('âŒ Error loading attachments from vault:', error);
        // Fallback to default with ×—×©×›"×˜
        const fallbackText = '**×œ×•×˜×”**\n×ª×¦×œ×•××™ ×”×¨×›×‘ ×”× ×™×–×•×§\n×—×©×‘×•× ×™×•×ª ×ª×™×§×•×Ÿ\n×¢×¨×š ×¨×›×‘ ×××•×—×©×‘\n×¦×™×œ×•× ×¨×™×©×™×•×Ÿ ×”×¨×›×‘\n×—×©×›"×˜';
        document.getElementById('attachments-content').value = fallbackText;
      }
    }

    // RESET ATTACHMENTS
    function resetAttachments() {
      try {
        // Reset to default attachments
        const defaultAttachments = '**×œ×•×˜×”**\n×ª×¦×œ×•××™ ×”×¨×›×‘ ×”× ×™×–×•×§\n×—×©×‘×•× ×™×•×ª ×ª×™×§×•×Ÿ\n×¢×¨×š ×¨×›×‘ ×××•×—×©×‘\n×¦×™×œ×•× ×¨×™×©×™×•×Ÿ ×”×¨×›×‘\n×—×©×›"×˜';
        document.getElementById('attachments-content').value = defaultAttachments;
        
        // Clear from helper safely
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (!helper.final_report) helper.final_report = {};
        delete helper.final_report.attachments;
        delete helper.final_report.attachments_locked;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('âœ… Attachments reset to default list');
      } catch (error) {
        console.error('âŒ Error resetting attachments:', error);
      }
    }

    // LOAD ATTACHMENTS DATA FROM HELPER
    function loadAttachmentsData() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Load saved attachments if they exist and are locked
      if (helper.final_report?.attachments && helper.final_report?.attachments_locked) {
        const attachmentsElement = document.getElementById('attachments-content');
        if (attachmentsElement) {
          attachmentsElement.value = helper.final_report.attachments;
          console.log('ğŸ“ Loaded LOCKED attachments from helper - will not revert to default');
        }
      } else if (helper.final_report?.attachments) {
        const attachmentsElement = document.getElementById('attachments-content');
        if (attachmentsElement) {
          attachmentsElement.value = helper.final_report.attachments;
          console.log('ğŸ“ Loaded saved attachments from helper (not locked)');
        }
      } else {
        console.log('ğŸ“ No saved attachments found, keeping default');
      }
    }

    // ADD GLOBAL DEPRECIATION CALCULATION
    function updateGlobalDepreciationCalculation() {
      const globalDepInput = document.getElementById('globalDep1');
      const globalDepValueInput = document.getElementById('globalDepValue');
      
      if (globalDepInput && globalDepValueInput) {
        globalDepInput.addEventListener('input', function() {
          // Clean the value to extract the numeric part
          const cleanValue = this.value.replace('%', '').replace(/[^0-9.-]/g, '');
          let percent = parseFloat(cleanValue) || 0;
          
          // Keep value as clean decimal number without % sign
          this.value = cleanValue;
          
          // Calculate value from market price automatically - try multiple sources
          let marketValue = 0;
          
          // First try summary market value (priority)
          const sumMarketValueField = document.getElementById('sumMarketValue');
          if (sumMarketValueField && sumMarketValueField.value) {
            const sumMarketStr = sumMarketValueField.value.replace(/[â‚ª,]/g, '') || '0';
            marketValue = parseFloat(sumMarketStr) || 0;
          }
          
          // If no summary value, try car details market value
          if (marketValue === 0) {
            const carMarketValueField = document.getElementById('carMarketValue');
            if (carMarketValueField && carMarketValueField.value) {
              const carMarketStr = carMarketValueField.value.replace(/[â‚ª,]/g, '') || '0';
              marketValue = parseFloat(carMarketStr) || 0;
            }
          }
          
          console.log('Global depreciation calculation:', {
            percent,
            marketValue,
            calculation: (marketValue * percent) / 100
          });
          
          const calculatedValue = (marketValue * percent) / 100;
          globalDepValueInput.value = calculatedValue ? `â‚ª${Math.round(calculatedValue).toLocaleString()}` : '';
          
          // TRIGGER SUMMARY UPDATE when global depreciation value changes
          if (window.addSummaryCalculationListeners) {
            const sumCalculate = document.querySelector('[data-summary-calculate]');
            if (sumCalculate) {
              sumCalculate.click();
            }
          }
          
          // Direct trigger for summary calculations
          setTimeout(() => {
            const event = new Event('input', { bubbles: true });
            globalDepValueInput.dispatchEvent(event);
          }, 100);
        });
      }
    }
    
    // CALCULATE DAMAGE PERCENTAGE
    function calculateDamagePercentage() {
      try {
        const totalClaim = parseFloat(document.getElementById('sumClaim')?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
        
        // Try to get vehicle_value_gross from helper first (gross market value for damage calculation)
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        const vehicleValueGross = helper.calculations?.vehicle_value_gross || 0;
        
        // Fallback to market value if vehicle_value_gross not available
        const marketValue = parseFloat(document.getElementById('sumMarketValue')?.value.replace(/[â‚ª,]/g, '') || '0') || 0;
        const calculationBase = vehicleValueGross > 0 ? vehicleValueGross : marketValue;
        
        if (calculationBase > 0 && totalClaim > 0) {
          const percentage = (totalClaim / calculationBase) * 100;
          console.log(`ğŸ“Š Damage percentage calculation: ${totalClaim.toLocaleString()} Ã· ${calculationBase.toLocaleString()} = ${Math.round(percentage)}%`);
          return Math.round(percentage) + '%';
        }
        return '[××—×•×– × ×–×§]';
      } catch (error) {
        return '[××—×•×– × ×–×§]';
      }
    }

    // UPDATE GROSS MARKET VALUE FIELD
    function updateGrossMarketValueField() {
      try {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        let vehicleValueGross = helper.calculations?.vehicle_value_gross;
        
        console.log('ğŸ” Checking vehicle_value_gross:', {
          helper_calculations: helper.calculations,
          vehicle_value_gross: vehicleValueGross,
          levi_report_final_price: helper.levi_report?.final_price,
          expertise_calculations: helper.expertise?.calculations
        });
        
        // If vehicle_value_gross is missing, try to calculate it from Levi data
        if (!vehicleValueGross && helper.levi_report) {
          const leviReport = helper.levi_report;
          const basePrice = parseFloat(leviReport.base_price || 0);
          const featuresValue = parseFloat(leviReport.features_value || 0);
          const registrationValue = parseFloat(leviReport.registration_value || 0);
          
          if (basePrice > 0) {
            vehicleValueGross = basePrice + featuresValue + registrationValue;
            console.log(`ğŸ”§ Calculated vehicle_value_gross from Levi data: ${basePrice} + ${featuresValue} + ${registrationValue} = ${vehicleValueGross}`);
            
            // Update helper with calculated value
            helper.calculations = helper.calculations || {};
            helper.calculations.vehicle_value_gross = vehicleValueGross;
            sessionStorage.setItem('helper', JSON.stringify(helper));
          }
        }
        
        // If still no value, try other fallbacks
        if (!vehicleValueGross) {
          const fallbackSources = [
            helper.levi_report?.final_price,
            helper.expertise?.calculations?.market_value,
            helper.expertise?.calculations?.vehicle_value_gross,
            helper.levisummary?.final_price
          ];
          
          for (const fallback of fallbackSources) {
            if (fallback && fallback > 0) {
              vehicleValueGross = fallback;
              console.log(`ğŸ”§ Using fallback for vehicle_value_gross: ${vehicleValueGross}`);
              break;
            }
          }
        }
        
        // Update the field if we have a value
        if (vehicleValueGross && vehicleValueGross > 0) {
          const leviPriceListField = document.getElementById('leviPriceList');
          if (leviPriceListField) {
            leviPriceListField.value = `â‚ª${vehicleValueGross.toLocaleString()}`;
            
            // Update helper claims data to maintain consistency
            helper.claims_data = helper.claims_data || {};
            helper.claims_data.gross_value = `â‚ª${vehicleValueGross.toLocaleString()}`;
            sessionStorage.setItem('helper', JSON.stringify(helper));
            
            console.log(`ğŸ’° Updated gross market value field: â‚ª${vehicleValueGross.toLocaleString()}`);
          }
        } else {
          console.log('â„¹ï¸ vehicle_value_gross not found - will be calculated when needed');
        }
        
        // Do NOT call updateGrossPercentageField here to avoid infinite loop
      } catch (error) {
        console.error('Error updating gross market value field:', error);
      }
    }

    // LOAD GROSS ADJUSTMENTS FROM helper.estimate.adjustments
    function loadGrossAdjustments(helper, forceReload = false) {
      try {

        const featuresContainer = document.getElementById('featuresAdjustmentsList');
        const registrationContainer = document.getElementById('registrationAdjustmentsList');

        if (featuresContainer) featuresContainer.innerHTML = '';
        if (registrationContainer) registrationContainer.innerHTML = '';

        // Use SINGLE CLEAN SOURCE like reloadGrossAdjustments: estimate.adjustments || valuation.adjustments
        const adjustments = helper.estimate?.adjustments || helper.valuation?.adjustments || {};
        
        console.log('ğŸ“ Loading from: estimate.adjustments â†’ valuation.adjustments (clean single source)');
        console.log('ğŸ” Available adjustments data:', adjustments);
        
        // Load features and registration only (matching reloadGrossAdjustments)
        const categories = [
          { key: 'features', addFunction: addFeatureAdjustment, container: featuresContainer },
          { key: 'registration', addFunction: addRegistrationAdjustment, container: registrationContainer }
        ];
        
        categories.forEach(({ key, addFunction, container }) => {
          const finalReportData = helper.final_report?.adjustments?.[key] || [];
          const estimateData = adjustments[key];
          const deletedItems = helper.grossSectionDeletedItems?.[key] || [];
          
          let categoryData;
          // Always use final_report if it has data (preserves user changes)
          if (Array.isArray(finalReportData) && finalReportData.length > 0) {
            console.log(`ğŸ“ Loading ${key} from final_report (has ${finalReportData.length} items)`);
            categoryData = finalReportData;
          } else if (estimateData && !forceReload) {
            // Filter out deleted items from estimate data
            const filteredData = Array.isArray(estimateData) ? estimateData : [estimateData];
            categoryData = filteredData.filter(item => {
              const isDeleted = deletedItems.some(deleted => 
                deleted.value === item.value || deleted.description === item.description
              );
              return !isDeleted;
            });
            console.log(`ğŸ“ Loading ${key} from estimate (${categoryData.length} items after filtering deleted)`);
          } else {
            console.log(`ğŸ“ Loading ${key} from estimate.adjustments (full reload)`);
            categoryData = estimateData;
          }
          
          if (categoryData && container) {
            console.log(`ğŸ“ Loading ${key} adjustments:`, categoryData);
            
            // Handle both array and single object data
            const items = Array.isArray(categoryData) ? categoryData : (categoryData && (categoryData.percent || categoryData.percentage || categoryData.amount) ? [categoryData] : []);
            
            items.forEach((item, index) => {
              if (item && (item.percent || item.percentage || item.amount || item.value)) {
                // Add new row
                addFunction();
                
                // Fill the data
                const rows = container.querySelectorAll('div[id*="Adj_"]');
                const lastRow = rows[rows.length - 1];
                
                if (lastRow) {
                  const inputs = lastRow.querySelectorAll('input, select');
                  if (inputs.length >= 4) {
                    // Field mapping: value â†’ ×ª×™××•×¨ (description) - PRESERVE FULL TEXT
                    inputs[0].value = item.value || '';
                    
                    // Type dropdown - use stored type directly
                    const itemPercent = item.percentage || item.percent;
                    const itemAmount = item.amount;
                    const storedType = item.type || 'plus';
                    if (storedType === 'minus' || storedType === '×”×¤×—×ª×”' || storedType === '×”×¤×—×ª×” (-)') {
                      inputs[1].value = 'minus';
                    } else if (storedType === 'plus' || storedType === '×ª×•×¡×¤×ª' || storedType === '×ª×•×¡×¤×ª (+)') {
                      inputs[1].value = 'plus';
                    } else {
                      inputs[1].value = storedType; // For % or â‚ª types
                    }
                    
                    // Percent and amount - preserve sign based on type
                    inputs[2].value = itemPercent ? Math.abs(itemPercent) : '';
                    
                    // FIXED: Preserve amount display properly
                    if (item.amount_display) {
                      inputs[3].value = item.amount_display;
                    } else if (item.amount !== undefined && item.amount !== 0) {
                      const absAmount = Math.abs(item.amount);
                      inputs[3].value = `â‚ª${absAmount.toLocaleString()}`;
                    } else {
                      inputs[3].value = '';
                    }
                    
                    // Trigger change events
                    inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
                    if (inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
                    if (inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
                    
                    // Call formatAdjustmentDisplay to ensure proper sign display
                    formatAdjustmentDisplay(lastRow, inputs[1].value, itemPercent, itemAmount);
                    
                    // Mark source as original for page refresh loads
                    lastRow.setAttribute('data-source', 'original');
                    
                    console.log(`âœ… Loaded ${key} item ${index}:`, {
                      description: inputs[0].value,
                      type: inputs[1].value,
                      percent: itemPercent,
                      amount: itemAmount
                    });
                  }
                }
              }
            });
          }
        });
        
        // Trigger calculations after loading
        setTimeout(() => {
          updateGrossMarketValueCalculation();
          console.log('âœ… Gross adjustments loaded from clean single source');
        }, 100);
        
      } catch (error) {
        console.error('âŒ Error loading gross adjustments:', error);
      }
    }
    
    // LOAD TOTAL VALUE SECTION ADJUSTMENTS FROM final_report.adjustments
    function loadTotalValueSectionAdjustments(helper) {
      try {
        console.log('ğŸ”„ Auto-loading Total Value Section with mixed data sources');
        
        // Mixed data sources (EXACT same as reload button):
        // - Features & Registration: from final_report.adjustments (sync with Gross section)  
        // - Others (KM, Ownership, Owners, Additional): from estimate.adjustments with valuation fallback
        const estimateAdjustments = helper.estimate?.adjustments || helper.valuation?.adjustments || {};
        const finalReportAdjustments = helper.final_report?.adjustments || {};
        
        console.log('ğŸ“¦ estimate.adjustments:', estimateAdjustments);
        console.log('ğŸ“¦ final_report.adjustments:', finalReportAdjustments);
        console.log('ğŸ“¦ helper.valuation.adjustments:', helper.valuation?.adjustments);
        console.log('ğŸ“¦ helper.valuation.adjustments keys:', Object.keys(helper.valuation?.adjustments || {}));
        
        // Helper function to create adjustment row
        function createTotalValueRow(adj, category, source) {
          const rowId = category === 'additional' ? `fullAdj_${Date.now()}` : `totalValue_${category}_${Date.now()}_${Math.random()}`;
          
          // DEBUG: Log the actual adjustment data being processed
          console.log(`ğŸ” DEBUG createTotalValueRow for ${category} from ${source}:`, {
            fullAdjustment: adj,
            type: adj.type,
            percent: adj.percent,
            percentage: adj.percentage,
            amount: adj.amount,
            value: adj.value
          });
          
          // Determine the type based on adjustment data
          let selectedType = '%'; // default
          
          // Get values for analysis
          const percentValue = adj.percent || adj.percentage || 0;
          const amountValue = adj.amount || 0;
          
          // First, determine if it's plus or minus based on values
          const isNegative = percentValue < 0 || amountValue < 0;
          
          // FIX: Use stored type directly, don't detect from values
          const itemPercent = adj.percentage || adj.percent;
          const itemAmount = adj.amount;
          const storedType = adj.type || 'plus';
          
          // DEBUG: Log type loading for ownership_history
          if (category === 'ownership_history') {
            console.log(`ğŸ” OWNERSHIP_HISTORY TYPE LOADING:`, {
              category,
              source,
              storedType,
              fullAdjustment: adj
            });
          }
          
          // Map stored type to dropdown value
          if (storedType === 'minus' || storedType === '×”×¤×—×ª×”' || storedType === '×”×¤×—×ª×” (-)') {
            selectedType = 'minus';
          } else if (storedType === 'plus' || storedType === '×ª×•×¡×¤×ª' || storedType === '×ª×•×¡×¤×ª (+)') {
            selectedType = 'plus';
          } else {
            // Default to plus if type is unclear
            selectedType = 'plus';
          }
          
          // DEBUG: Log final type selection for ownership_history
          if (category === 'ownership_history') {
            console.log(`ğŸ¯ OWNERSHIP_HISTORY FINAL TYPE: ${storedType} â†’ ${selectedType}`);
          }
          
          
          const description = adj.value || adj.description || '';
          // Escape HTML entities to preserve special characters
          const escapedDescription = description
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
          // Populate percentage and amount from adjustment data (handle negative values properly)
          let percentage = '';
          let amount = '';
          
          // CRITICAL FIX: Percentage should always show positive in UI, type dropdown controls sign
          if (itemPercent !== undefined && itemPercent !== null && itemPercent !== '') {
            let cleanPercent = itemPercent;
            if (typeof itemPercent === 'string') {
              cleanPercent = itemPercent.replace('%', '');
            }
            const parsedPercent = parseFloat(cleanPercent);
            // ALWAYS show positive percentage - type dropdown controls the actual sign
            percentage = !isNaN(parsedPercent) ? Math.abs(parsedPercent) : '';
            console.log(`ğŸ”§ PERCENTAGE FIX: original=${parsedPercent}, displayed=${percentage}, type=${selectedType}`);
          } else {
            percentage = '';
          }
          
          // PRESERVE SIGN - don't use Math.abs() 
          if (adj.amount_display) {
            amount = adj.amount_display;
          } else if (adj.amount) {
            const amountValue = parseFloat(adj.amount);
            if (amountValue < 0) {
              amount = `-â‚ª${Math.abs(amountValue).toLocaleString()}`;
            } else {
              amount = `â‚ª${amountValue.toLocaleString()}`;
            }
          } else {
            amount = '';
          }
          
          // Make features and registration read-only in Total Market Value section
          const isReadOnlyCategory = (category === 'features' || category === 'registration');
          const readOnlyAttr = isReadOnlyCategory ? 'readonly' : '';
          const readOnlyStyle = isReadOnlyCategory ? ' background: #f8f9fa; color: #6c757d;' : '';
          const disabledAttr = isReadOnlyCategory ? 'disabled' : '';
          
          console.log(`ğŸ”’ Making ${category} read-only in Total Market Value: ${isReadOnlyCategory}`);
          
          const html = `
            <div id="${rowId}" class="adjustment-row" data-source="${source}">
              <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
                <div><input type="text" placeholder="×ª×™××•×¨ ×”×ª×××”" value="${escapedDescription}" ${readOnlyAttr} style="${readOnlyStyle}" ${isReadOnlyCategory ? '' : `onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, '${category}');"`} /></div>
                <div>
                  ${category === 'additional' ? 
                    `<select ${disabledAttr} style="${readOnlyStyle}" ${isReadOnlyCategory ? '' : `onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, '${category}');"`}>
                      <option value="plus" ${adj.type === 'plus' || selectedType === '×ª×•×¡×¤×ª (+)' ? 'selected' : ''}>×ª×•×¡×¤×ª (+)</option>
                      <option value="minus" ${adj.type === 'minus' || selectedType === '×”×¤×—×ª×” (-)' ? 'selected' : ''}>×”×¤×—×ª×” (-)</option>
                    </select>` :
                    `<select ${disabledAttr} style="${readOnlyStyle}" ${isReadOnlyCategory ? '' : `onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, '${category}');"`}>
                      <option value="plus" ${selectedType === 'plus' ? 'selected' : ''}>×ª×•×¡×¤×ª (+)</option>
                      <option value="minus" ${selectedType === 'minus' ? 'selected' : ''}>×”×¤×—×ª×” (-)</option>
                    </select>`
                  }
                </div>
                <div><input type="text" placeholder="××—×•×–" value="${percentage}" ${readOnlyAttr} style="direction: ltr; text-align: right;${readOnlyStyle}" ${isReadOnlyCategory ? '' : `onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, '${category}');"`} /></div>
                <div><input type="text" placeholder="×¢×¨×š" value="${amount}" ${readOnlyAttr} style="direction: ltr; text-align: right;${readOnlyStyle}" ${isReadOnlyCategory ? '' : `onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, '${category}');"`} /></div>
                <div>
                  ${isReadOnlyCategory ? 
                    '<span style="color: #6c757d; font-size: 12px;">×§×¨×™××” ×‘×œ×‘×“</span>' : 
                    `<button class="btn remove" type="button" onclick="removeAdjustmentRow('${rowId}')">×”×¡×¨</button>`
                  }
                </div>
              </div>
              <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
                ×¢×¨×š ××¦×˜×‘×¨: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">${adj.cumulative ? `â‚ª${adj.cumulative.toLocaleString()}` : 'â‚ª0'}</span>
              </div>
            </div>
          `;
          
          // Apply formatting after row is created AND trigger change events for consistency
          setTimeout(() => {
            const row = document.getElementById(rowId);
            if (row) {
              const inputs = row.querySelectorAll('input, select');
              if (inputs.length >= 4) {
                // Trigger change events (CRITICAL FOR MINUS SIGN DETECTION)
                inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
                if (inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
                if (inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
                
                // Also call formatAdjustmentDisplay directly as backup
                const itemPercent = adj.percentage || adj.percent;
                const itemAmount = adj.amount;
                formatAdjustmentDisplay(row, selectedType, itemPercent, itemAmount);
              }
            }
          }, 150);
          
          return html;
        }
        
        // 1. Load features from final_report.adjustments into fullFeaturesAdjustmentsList
        const featuresContainer = document.getElementById('fullFeaturesAdjustmentsList');
        if (featuresContainer) {
          featuresContainer.innerHTML = '';
          const features = finalReportAdjustments.features || [];
          console.log('ğŸ“¦ Loading features from final_report.adjustments:', features);
          if (Array.isArray(features)) {
            features.forEach((adj, index) => {
              console.log(`ğŸ” Processing features[${index}]:`, adj);
              // Load all non-empty items (check for any content)
              if (adj && (adj.value || adj.description || adj.percentage || adj.percent || adj.amount)) {
                const rowHtml = createTotalValueRow(adj, 'features', 'final_report');
                featuresContainer.insertAdjacentHTML('beforeend', rowHtml);
                
                // Update row cumulative if available from helper
                if (adj.cumulative !== undefined) {
                  setTimeout(() => {
                    const rows = featuresContainer.querySelectorAll('.adjustment-row');
                    const lastRow = rows[rows.length - 1];
                    const cumulativeSpan = lastRow?.querySelector('.row-cumulative');
                    if (cumulativeSpan) {
                      cumulativeSpan.textContent = `â‚ª${Math.round(adj.cumulative).toLocaleString()}`;
                    }
                  }, 10);
                }
                console.log(`âœ… Added features[${index}] to Total Value Section`);
              } else {
                console.log(`âš ï¸ Skipped features[${index}] - no content`);
              }
            });
          }
          console.log(`âœ… Loaded ${features.length} total features, filtered and added to Total Value Section`);
        }
        
        // 2. Load registration from final_report.adjustments into fullRegistrationAdjustmentsList
        const registrationContainer = document.getElementById('fullRegistrationAdjustmentsList');
        if (registrationContainer) {
          registrationContainer.innerHTML = '';
          const registration = finalReportAdjustments.registration || [];
          console.log('ğŸ“¦ Loading registration from final_report.adjustments:', registration);
          if (Array.isArray(registration)) {
            registration.forEach((adj, index) => {
              console.log(`ğŸ” Processing registration[${index}]:`, adj);
              // Load all non-empty items (check for any content)
              if (adj && (adj.value || adj.description || adj.percentage || adj.percent || adj.amount)) {
                const rowHtml = createTotalValueRow(adj, 'registration', 'final_report');
                registrationContainer.insertAdjacentHTML('beforeend', rowHtml);
                
                // Update row cumulative if available from helper
                if (adj.cumulative !== undefined) {
                  setTimeout(() => {
                    const rows = registrationContainer.querySelectorAll('.adjustment-row');
                    const lastRow = rows[rows.length - 1];
                    const cumulativeSpan = lastRow?.querySelector('.row-cumulative');
                    if (cumulativeSpan) {
                      cumulativeSpan.textContent = `â‚ª${Math.round(adj.cumulative).toLocaleString()}`;
                    }
                  }, 10);
                }
                console.log(`âœ… Added registration[${index}] to Total Value Section`);
              } else {
                console.log(`âš ï¸ Skipped registration[${index}] - no content`);
              }
            });
          }
          console.log(`âœ… Loaded ${registration.length} total registration, filtered and added to Total Value Section`);
        }
        
        // 3. Load KM from final_report.adjustments (priority) with fallback to estimate/valuation
        const mileageContainer = document.getElementById('mileageAdjustmentsList');
        if (mileageContainer) {
          mileageContainer.innerHTML = '';
          
          // FIXED: Load from final_report.adjustments FIRST (preserves manual additions)
          let mileage = finalReportAdjustments.mileage || [];
          let source = 'final_report';
          
          // Only fall back to estimate/valuation if final_report is empty
          if (!Array.isArray(mileage) || mileage.length === 0) {
            // Fallback to estimate.adjustments.mileage
            mileage = estimateAdjustments.mileage || [];
            source = 'estimate';
            
            if (!Array.isArray(mileage) || mileage.length === 0) {
              // Final fallback to valuation.adjustments.mileage
              console.log(`ğŸ” DEBUG: Checking valuation fallback for mileage`, helper.valuation?.adjustments);
              const valuationMileage = helper.valuation?.adjustments?.mileage;
              if (valuationMileage) {
                mileage = Array.isArray(valuationMileage) ? valuationMileage : [valuationMileage];
                source = 'original';
                console.log(`ğŸ“¦ Fallback: Loading mileage from valuation.adjustments:`, {
                  originalData: valuationMileage,
                  processedArray: mileage
                });
              } else {
                console.log(`ğŸ“¦ No mileage data in any source`);
              }
            } else {
              console.log(`ğŸ“¦ Loading mileage from estimate.adjustments:`, mileage);
            }
          } else {
            console.log(`ğŸ“¦ Loading mileage from final_report.adjustments (preserving manual additions):`, mileage);
          }
          
          if (Array.isArray(mileage)) {
            mileage.forEach((adj, index) => {
              if (adj && (adj.value || adj.percentage || adj.percent || adj.amount)) {
                const rowHtml = createTotalValueRow(adj, 'mileage', source);
                mileageContainer.insertAdjacentHTML('beforeend', rowHtml);
                
                // Update row cumulative if available from helper
                if (adj.cumulative !== undefined) {
                  setTimeout(() => {
                    const rows = mileageContainer.querySelectorAll('.adjustment-row');
                    const lastRow = rows[rows.length - 1];
                    const cumulativeSpan = lastRow?.querySelector('.row-cumulative');
                    if (cumulativeSpan) {
                      cumulativeSpan.textContent = `â‚ª${Math.round(adj.cumulative).toLocaleString()}`;
                    }
                  }, 10);
                }
                console.log(`âœ… Added mileage adjustment from ${source}:`, adj.value || 'no description');
              }
            });
          }
          console.log(`âœ… Loaded ${mileage.length} mileage adjustments to Total Value Section from ${source}`);
        }
        
        // 4. Load ownership_type from final_report.adjustments (priority) with fallback to estimate/valuation
        const ownershipContainer = document.getElementById('ownershipAdjustmentsList');
        if (ownershipContainer) {
          ownershipContainer.innerHTML = '';
          
          // FIXED: Load from final_report.adjustments FIRST (preserves manual additions)
          let ownership = finalReportAdjustments.ownership_type || [];
          let source = 'final_report';
          
          // Only fall back to estimate/valuation if final_report is empty
          if (!Array.isArray(ownership) || ownership.length === 0) {
            // Fallback to estimate.adjustments.ownership_type
            ownership = estimateAdjustments.ownership_type || estimateAdjustments.ownership || [];
            source = 'estimate';
            
            if (!Array.isArray(ownership) || ownership.length === 0) {
              // Final fallback to valuation.adjustments.ownership_type
              console.log(`ğŸ” DEBUG: Checking valuation fallback for ownership_type`, helper.valuation?.adjustments);
              const valuationOwnership = helper.valuation?.adjustments?.ownership_type;
              if (valuationOwnership) {
                ownership = Array.isArray(valuationOwnership) ? valuationOwnership : [valuationOwnership];
                source = 'original';
                console.log(`ğŸ“¦ Fallback: Loading ownership from valuation.adjustments:`, {
                  originalData: valuationOwnership,
                  processedArray: ownership
                });
              } else {
                console.log(`ğŸ“¦ No ownership data in any source`);
              }
            } else {
              console.log(`ğŸ“¦ Loading ownership from estimate.adjustments:`, ownership);
            }
          } else {
            console.log(`ğŸ“¦ Loading ownership from final_report.adjustments (preserving manual additions):`, ownership);
          }
          
          if (Array.isArray(ownership)) {
            ownership.forEach((adj, index) => {
              if (adj && (adj.value || adj.percentage || adj.percent || adj.amount)) {
                const rowHtml = createTotalValueRow(adj, 'ownership_type', source);
                ownershipContainer.insertAdjacentHTML('beforeend', rowHtml);
                
                // Update row cumulative if available from helper
                if (adj.cumulative !== undefined) {
                  setTimeout(() => {
                    const rows = ownershipContainer.querySelectorAll('.adjustment-row');
                    const lastRow = rows[rows.length - 1];
                    const cumulativeSpan = lastRow?.querySelector('.row-cumulative');
                    if (cumulativeSpan) {
                      cumulativeSpan.textContent = `â‚ª${Math.round(adj.cumulative).toLocaleString()}`;
                    }
                  }, 10);
                }
                console.log(`âœ… Added ownership adjustment from ${source}:`, adj.value || 'no description');
              }
            });
          }
          console.log(`âœ… Loaded ${ownership.length} ownership adjustments to Total Value Section from ${source}`);
        }
        
        // 5. Load ownership_history from final_report.adjustments (priority) with fallback to estimate/valuation
        const ownersContainer = document.getElementById('ownersAdjustmentsList');
        if (ownersContainer) {
          ownersContainer.innerHTML = '';
          
          // FIXED: Load from final_report.adjustments FIRST (preserves manual additions)
          let owners = finalReportAdjustments.ownership_history || [];
          let source = 'final_report';
          
          // DEBUG: Log ownership_history data source decision
          console.log(`ğŸ” OWNERSHIP_HISTORY DATA SOURCE CHECK:`, {
            finalReportOwners: finalReportAdjustments.ownership_history,
            ownersFallback: owners,
            estimateOwners: estimateAdjustments.owners,
            estimateOwnershipHistory: estimateAdjustments.ownership_history,
            willFallback: !Array.isArray(owners) || owners.length === 0
          });
          
          // CRITICAL FIX: Only fall back if final_report is truly empty AND not during save operations
          // This prevents overriding user edits during save process
          const shouldFallback = (!Array.isArray(owners) || owners.length === 0);
          
          if (shouldFallback) {
            console.log(`âš ï¸ OWNERSHIP_HISTORY: final_report is empty, falling back to estimate/valuation data`);
          } else {
            console.log(`âœ… OWNERSHIP_HISTORY: Using final_report data (preserving user edits)`);
          }
          
          if (shouldFallback) {
            // Fallback to estimate.adjustments.ownership_history
            owners = estimateAdjustments.ownership_history || estimateAdjustments.owners || [];
            source = 'estimate';
            
            if (!Array.isArray(owners) || owners.length === 0) {
              // Final fallback to valuation.adjustments.ownership_history
              console.log(`ğŸ” DEBUG: Checking valuation fallback for ownership_history`, helper.valuation?.adjustments);
              const valuationOwners = helper.valuation?.adjustments?.ownership_history;
              if (valuationOwners) {
                owners = Array.isArray(valuationOwners) ? valuationOwners : [valuationOwners];
                source = 'original';
                console.log(`ğŸ“¦ Fallback: Loading owners from valuation.adjustments:`, {
                  originalData: valuationOwners,
                  processedArray: owners
                });
              } else {
                console.log(`ğŸ“¦ No owners data in any source`);
              }
            } else {
              console.log(`ğŸ“¦ Loading owners from estimate.adjustments:`, owners);
            }
          } else {
            console.log(`ğŸ“¦ Loading owners from final_report.adjustments (preserving manual additions):`, owners);
          }
          
          if (Array.isArray(owners)) {
            owners.forEach((adj, index) => {
              if (adj && (adj.value || adj.percentage || adj.percent || adj.amount)) {
                const rowHtml = createTotalValueRow(adj, 'ownership_history', source);
                ownersContainer.insertAdjacentHTML('beforeend', rowHtml);
                
                // Update row cumulative if available from helper
                if (adj.cumulative !== undefined) {
                  setTimeout(() => {
                    const rows = ownersContainer.querySelectorAll('.adjustment-row');
                    const lastRow = rows[rows.length - 1];
                    const cumulativeSpan = lastRow?.querySelector('.row-cumulative');
                    if (cumulativeSpan) {
                      cumulativeSpan.textContent = `â‚ª${Math.round(adj.cumulative).toLocaleString()}`;
                    }
                  }, 10);
                }
                console.log(`âœ… Added owners adjustment from ${source}:`, adj.value || 'no description');
              }
            });
          }
          console.log(`âœ… Loaded ${owners.length} owners adjustments to Total Value Section from ${source}`);
        }
        
        // 6. Load additional from final_report.adjustments (priority) with fallback to estimate/valuation
        const additionalContainer = document.getElementById('allAdjustmentsList');
        if (additionalContainer) {
          additionalContainer.innerHTML = '';
          
          // FIXED: Load from final_report.adjustments FIRST (preserves manual additions)
          let additional = finalReportAdjustments.additional || [];
          let source = 'final_report';
          
          // Only fall back to estimate/valuation if final_report is empty
          if (!Array.isArray(additional) || additional.length === 0) {
            // Fallback to estimate.adjustments.additional
            additional = estimateAdjustments.additional || [];
            source = 'estimate';
            
            if (!Array.isArray(additional) || additional.length === 0) {
              // Final fallback to valuation.adjustments.additional
              const valuationAdditional = helper.valuation?.adjustments?.additional;
              if (valuationAdditional) {
                additional = Array.isArray(valuationAdditional) ? valuationAdditional : [valuationAdditional];
                source = 'original';
                console.log(`ğŸ“¦ Fallback: Loading additional from valuation.adjustments:`, additional);
              } else {
                console.log(`ğŸ“¦ No additional data in any source`);
              }
            } else {
              console.log(`ğŸ“¦ Loading additional from estimate.adjustments:`, additional);
            }
          } else {
            console.log(`ğŸ“¦ Loading additional from final_report.adjustments (preserving manual additions):`, additional);
          }
          
          if (Array.isArray(additional)) {
            additional.forEach((adj, index) => {
              if (adj && (adj.value || adj.percentage || adj.percent || adj.amount)) {
                // Create row with proper handlers for additional adjustments
                const rowId = 'fullAdj_' + Date.now() + '_' + Math.random();
                const newRow = `
                  <div id="${rowId}" class="adjustment-row" data-source="${source}">
                    <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
                      <div><input type="text" placeholder="×ª×™××•×¨ ×”×ª×××” × ×•×¡×¤×ª" value="${adj.value || ''}" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional');" /></div>
                      <div><select onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));">
                        <option value="plus" ${adj.type === 'plus' ? 'selected' : ''}>×ª×•×¡×¤×ª (+)</option>
                        <option value="minus" ${adj.type === 'minus' ? 'selected' : ''}>×”×¤×—×ª×” (-)</option>
                      </select></div>
                      <div><input type="text" placeholder="××—×•×–" value="${adj.percentage || adj.percent || ''}" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(this.value) || 0), safeParseAmount(inputs[3].value));" /></div>
                      <div><input type="text" placeholder="â‚ª" value="${adj.amount_display || (adj.amount ? (adj.amount < 0 ? '-â‚ª' + Math.abs(adj.amount).toLocaleString() : 'â‚ª' + Math.abs(adj.amount).toLocaleString()) : '')}" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(this.value));" /></div>
                      <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">××—×§</button></div>
                    </div>
                    <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
                      ×¢×¨×š ××¦×˜×‘×¨: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">â‚ª0</span>
                    </div>
                  </div>
                `;
                additionalContainer.insertAdjacentHTML('beforeend', newRow);
                
                // Trigger formatAdjustmentDisplay for proper minus sign display and update cumulative
                setTimeout(() => {
                  const row = document.getElementById(rowId);
                  if (row) {
                    formatAdjustmentDisplay(row, adj.type, adj.percentage || adj.percent, adj.amount);
                    
                    // Update row cumulative if available from helper
                    if (adj.cumulative !== undefined) {
                      const cumulativeSpan = row.querySelector('.row-cumulative');
                      if (cumulativeSpan) {
                        cumulativeSpan.textContent = `â‚ª${Math.round(adj.cumulative).toLocaleString()}`;
                      }
                    }
                  }
                }, 10);
                
                console.log(`âœ… Added additional adjustment from ${source}:`, adj.value || 'no description');
              }
            });
          }
          
          console.log(`âœ… Loaded ${additional.length} additional adjustments to Total Value Section from ${source}`);
        }
        
        console.log('âœ… Completed loading Total Value Section adjustments');
        
      } catch (error) {
        console.error('Error loading Total Value Section adjustments:', error);
      }
    }
    
    // RELOAD GROSS ADJUSTMENTS - triggered by reload button
    function reloadGrossAdjustments() {
      try {
        console.log('ğŸ”„ Reloading gross adjustments from estimate.adjustments with fallback to valuation.adjustments');
        
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Clear deleted items list to allow full reload
        if (helper.grossSectionDeletedItems) {
          delete helper.grossSectionDeletedItems;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          window.helper = helper;
        }
        
        // FIXED: Only clear Gross section data (features and registration), preserve Total section data
        if (helper.final_report && helper.final_report.adjustments) {
          // Preserve Total section data before clearing
          const preservedData = {
            mileage: helper.final_report.adjustments.mileage || [],
            ownership_type: helper.final_report.adjustments.ownership_type || [],
            ownership_history: helper.final_report.adjustments.ownership_history || [],
            usage: helper.final_report.adjustments.usage || [],
            additional: helper.final_report.adjustments.additional || []
          };
          
          // Clear only features and registration (Gross section data)
          helper.final_report.adjustments.features = [];
          helper.final_report.adjustments.registration = [];
          
          // Restore preserved Total section data
          Object.assign(helper.final_report.adjustments, preservedData);
          
          console.log('ğŸ§¹ Cleared only Gross section data (features & registration), preserved Total section data');
          console.log('ğŸ“¦ Preserved Total section data:', preservedData);
        }
        
        // Clear existing rows
        const featuresContainer = document.getElementById('featuresAdjustmentsList');
        const registrationContainer = document.getElementById('registrationAdjustmentsList');
        
        if (featuresContainer) featuresContainer.innerHTML = '';
        if (registrationContainer) registrationContainer.innerHTML = '';
        
        // FORCE reload from estimate.adjustments (button overrides user changes)
        const adjustments = helper.estimate?.adjustments || helper.valuation?.adjustments || {};
        
        console.log('ğŸ“ Force loading from: estimate.adjustments â†’ valuation.adjustments (button override)');
        console.log('ğŸ” Available adjustments data:', adjustments);
        
        // Load features and registration only (for gross section)
        const categories = [
          { key: 'features', addFunction: addFeatureAdjustment, container: featuresContainer },
          { key: 'registration', addFunction: addRegistrationAdjustment, container: registrationContainer }
        ];
        
        categories.forEach(({ key, addFunction, container }) => {
          const categoryData = adjustments[key];
          if (categoryData && container) {
            console.log(`ğŸ“ Loading ${key} adjustments:`, categoryData);
            
            // Handle both array and single object data
            const items = Array.isArray(categoryData) ? categoryData : (categoryData && (categoryData.percent || categoryData.percentage || categoryData.amount) ? [categoryData] : []);
            
            items.forEach((item, index) => {
              if (item && (item.percent || item.percentage || item.amount)) {
                // Add new row
                addFunction();
                
                // Fill the data
                const rows = container.querySelectorAll('div[id*="Adj_"]');
                const lastRow = rows[rows.length - 1];
                
                if (lastRow) {
                  const inputs = lastRow.querySelectorAll('input, select');
                  if (inputs.length >= 4) {
                    // Field mapping: value â†’ ×ª×™××•×¨ (description)
                    inputs[0].value = item.value || '';
                    
                    // Type dropdown - use stored type directly
                    const itemPercent = item.percentage || item.percent;
                    const itemAmount = item.amount;
                    // FIX: Trust the stored type instead of detecting from values
                    const storedType = item.type || 'plus';
                    // Handle Hebrew type values
                    if (storedType === '×”×¤×—×ª×”' || storedType === '×”×¤×—×ª×” (-)' || storedType === '×”×•×¨×“×”' || storedType === 'minus') {
                      inputs[1].value = 'minus';
                    } else if (storedType === '×ª×•×¡×¤×ª' || storedType === '×ª×•×¡×¤×ª (+)' || storedType === 'plus') {
                      inputs[1].value = 'plus';
                    } else if (storedType === '%' || storedType === 'â‚ª') {
                      inputs[1].value = storedType;
                    } else {
                      // Default to plus if type is unclear
                      inputs[1].value = 'plus';
                    }
                    
                    // Percent and amount - preserve sign based on type
                    inputs[2].value = itemPercent ? Math.abs(itemPercent) : '';
                    
                    // FIXED: Preserve amount display properly
                    if (item.amount_display) {
                      inputs[3].value = item.amount_display;
                    } else if (item.amount !== undefined && item.amount !== 0) {
                      const absAmount = Math.abs(item.amount);
                      inputs[3].value = `â‚ª${absAmount.toLocaleString()}`;
                    } else {
                      inputs[3].value = '';
                    }
                    
                    // Trigger change events
                    inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
                    if (inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
                    if (inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
                    
                    // Mark source based on data origin
                    const dataSource = item.source || 'estimate'; // Use original source if available
                    lastRow.setAttribute('data-source', dataSource);
                    
                    if (dataSource === 'manual') {
                      lastRow.style.background = '#fff8e1';
                      lastRow.style.border = '1px solid #ff9800';
                    } else {
                      lastRow.style.background = '#e8f5e8';
                      lastRow.style.border = '1px solid #28a745';
                    }
                    
                    console.log(`âœ… Reloaded ${key} item ${index}:`, {
                      description: inputs[0].value,
                      type: inputs[1].value,
                      percent: inputs[2].value,
                      amount: inputs[3].value
                    });
                  }
                }
              }
            });
          }
        });
        
        // No need to load manual entries separately - final_report.adjustments already contains all data
        
        // Trigger calculation after reloading
        updateGrossMarketValueCalculation();
        
        // DELAY before updating helper to ensure UI is fully loaded
        setTimeout(() => {
          // REMOVED: updateHelperFromAdjustments() to prevent overwriting calculated amounts on page load
          
          // CRITICAL: Save current state to sessionStorage so refresh loads correct data
          const updatedHelper = window.helper || {};
          sessionStorage.setItem('helper', JSON.stringify(updatedHelper));
          console.log('ğŸ’¾ Saved updated helper to sessionStorage after reload with delay');
        }, 300);
        
        console.log('âœ… Gross adjustments reload completed');
        
      } catch (error) {
        console.error('âŒ Error reloading gross adjustments:', error);
      }
    }
    
    // GROSS DAMAGE PERCENTAGE CALCULATION FUNCTIONS
    
    // Add feature adjustment row
    function addFeatureAdjustment() {
      const container = document.getElementById('featuresAdjustmentsList');
      const rowId = 'featureAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="×ª×™××•×¨ ×”×××¤×™×™×Ÿ" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'features');" /></div>
            <div><select onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));">
              <option value="plus">×ª×•×¡×¤×ª (+)</option>
              <option value="minus">×”×¤×—×ª×” (-)</option>
            </select></div>
            <div><input type="text" placeholder="××—×•×–" oninput="calculateAdjustmentValueSimple(this);" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(this.value) || 0), safeParseAmount(inputs[3].value));" /></div>
            <div><input type="text" placeholder="â‚ª" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(this.value));" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">××—×§</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ×¢×¨×š ××¦×˜×‘×¨: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">â‚ª0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      updateGrossMarketValueCalculation();
    }
    
    // Add registration adjustment row
    function addRegistrationAdjustment() {
      const container = document.getElementById('registrationAdjustmentsList');
      const rowId = 'regAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="×ª×™××•×¨ ×¢×œ×™×” ×œ×›×‘×™×©" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');" /></div>
            <div><select onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));">
              <option value="plus">×ª×•×¡×¤×ª (+)</option>
              <option value="minus">×”×¤×—×ª×” (-)</option>
            </select></div>
            <div><input type="text" placeholder="××—×•×–" oninput="calculateAdjustmentValueSimple(this);" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(this.value) || 0), safeParseAmount(inputs[3].value));" /></div>
            <div><input type="text" placeholder="â‚ª" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(this.value));" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">××—×§</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ×¢×¨×š ××¦×˜×‘×¨: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">â‚ª0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      updateGrossMarketValueCalculation();
    }
    
    // ============================================================================
    // AUTO-POPULATION FROM LEVI SUMMARY
    // ============================================================================
    
    // Flag to prevent multiple executions
    let autoPopulationInProgress = false;
    let autoPopulationCompleted = sessionStorage.getItem('autoPopulationCompleted') === 'true';
    
    /**
     * Auto-populate features and registration adjustments from Levi summary data
     */
    function autoPopulateFromLeviSummary() {
      if (autoPopulationInProgress) {
        console.log('âš ï¸ Auto-population already in progress, skipping...');
        return;
      }
      
      if (autoPopulationCompleted) {
        console.log('âš ï¸ Auto-population already completed, skipping...');
        return;
      }
      
      // NEW: Don't auto-populate if final_report.adjustments already has user data
      const helper = window.helper || {};
      if (helper.final_report?.adjustments?.features?.length > 0 || helper.final_report?.adjustments?.registration?.length > 0) {
        console.log('âš ï¸ User data exists in final_report.adjustments, skipping auto-population');
        autoPopulationCompleted = true;
        sessionStorage.setItem('autoPopulationCompleted', 'true');
        return;
      }
      
      autoPopulationInProgress = true;
      console.log('ğŸš€ Starting auto-population from Levi summary...');
      
      // ENHANCED: Ensure FinalReportCalculations is ready before proceeding
      if (!window.FinalReportCalculations) {
        console.log('â³ FinalReportCalculations not ready, waiting...');
        setTimeout(() => {
          autoPopulationInProgress = false;
          autoPopulateFromLeviSummary();
        }, 200);
        return;
      }
      
      // Use the helper already declared above
      // const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Check for valuation adjustments (primary source) and fallback sources
      if (!helper.valuation?.adjustments && !helper.levisummary && !helper.levi_report && !helper.expertise?.levi_report) {
        autoPopulationInProgress = false;
        return;
      }
      
      clearLeviAdjustments();
      
      // Get Levi data from valuation adjustments (primary) or fallback sources
      const leviData = helper.valuation?.adjustments || helper.levisummary || helper.levi_report || helper.expertise?.levi_report || {};
      const featuresData = leviData.features || {};
      const registrationData = leviData.registration || {};
      
      // Auto-populate features adjustments (×××¤×™×™× ×™×) - GROSS section only
      // ENHANCED: Try multiple possible field locations for better data capture
      const featuresPercent = featuresData.percent || featuresData.percentage || 
                             leviData['××—×™×¨ ×××¤×™×™× ×™× %'] || leviData['×××¤×™×™× ×™× %'] || 
                             helper['××—×™×¨ ×××¤×™×™× ×™× %'] || helper['×××¤×™×™× ×™× %'] ||
                             helper.levi?.['××—×™×¨ ×××¤×™×™× ×™× %'] ||
                             helper.expertise?.levi_report?.['××—×™×¨ ×××¤×™×™× ×™× %'] || '';
      const featuresAmount = featuresData.amount || featuresData.value || 
                            leviData['×¢×¨×š ×©"×— ×××¤×™×™× ×™×'] || leviData['×¢×¨×š ×××¤×™×™× ×™×'] || 
                            helper['×¢×¨×š ×©"×— ×××¤×™×™× ×™×'] || helper['×¢×¨×š ×××¤×™×™× ×™×'] ||
                            helper.levi?.['×¢×¨×š ×©"×— ×××¤×™×™× ×™×'] ||
                            helper.expertise?.levi_report?.['×¢×¨×š ×©"×— ×××¤×™×™× ×™×'] || '';
      const featuresDescription = featuresData.description || featuresData.reason || '×ª×•×¡×¤×•×ª ×××¤×™×™× ×™×';
      
      if (featuresPercent || featuresAmount) {
        if (typeof addFeatureAdjustment === 'function') {
          addFeatureAdjustment();
        }
        
        const rows = document.querySelectorAll('#featuresAdjustmentsList > div');
        const lastRow = rows[rows.length - 1];
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            inputs[0].value = featuresDescription || '×ª×•×¡×¤×•×ª ×××¤×™×™× ×™× (××œ×•×™ ×™×¦×—×§)';
            inputs[1].value = String(featuresPercent).includes('-') ? 'minus' : 'plus';
            // CRITICAL FIX: Display minus sign for negative values
            const featuresPercentValue = parseFloat(String(featuresPercent).replace(/[%\s+]/g, '')) || 0;
            const displayFeaturesPercent = String(featuresPercent).includes('-') ? `-${Math.abs(featuresPercentValue)}` : Math.abs(featuresPercentValue);
            inputs[2].value = displayFeaturesPercent || '';
            // CRITICAL FIX: Display minus sign for amount values too
            const featuresAmountValue = parseFloat(String(featuresAmount).replace(/[â‚ª,\s]/g, '')) || 0;
            const displayFeaturesAmount = String(featuresPercent).includes('-') ? `-${Math.abs(featuresAmountValue)}` : Math.abs(featuresAmountValue);
            inputs[3].value = featuresAmount ? `â‚ª${displayFeaturesAmount.toLocaleString()}` : '';
            
            lastRow.setAttribute('data-source', 'levi');
            lastRow.style.background = '#f0f8ff';
          }
        }
      }
      
      // Auto-populate registration adjustments (×¢×œ×™×” ×œ×›×‘×™×©) - GROSS section only  
      // ENHANCED: Try multiple possible field locations for better data capture
      const registrationPercent = registrationData.percent || registrationData.percentage || 
                                 leviData['×¢×œ×™×” ×œ×›×‘×™×© %'] || 
                                 helper['×¢×œ×™×” ×œ×›×‘×™×© %'] ||
                                 helper.levi?.['×¢×œ×™×” ×œ×›×‘×™×© %'] ||
                                 helper.expertise?.levi_report?.['×¢×œ×™×” ×œ×›×‘×™×© %'] || '';
      const registrationAmount = registrationData.amount || registrationData.value ||
                                leviData['×¢×¨×š ×©"×— ×¢×œ×™×” ×œ×›×‘×™×©'] || leviData['×¢×¨×š ×¢×œ×™×” ×œ×›×‘×™×©'] ||
                                helper['×¢×¨×š ×©"×— ×¢×œ×™×” ×œ×›×‘×™×©'] || helper['×¢×¨×š ×¢×œ×™×” ×œ×›×‘×™×©'] ||
                                helper.levi?.['×¢×¨×š ×©"×— ×¢×œ×™×” ×œ×›×‘×™×©'] ||
                                helper.expertise?.levi_report?.['×¢×¨×š ×©"×— ×¢×œ×™×” ×œ×›×‘×™×©'] || '';
      const registrationDescription = registrationData.description || registrationData.reason || '×¢×œ×™×” ×œ×›×‘×™×©';
      
      if (registrationPercent || registrationAmount) {
        if (typeof addRegistrationAdjustment === 'function') {
          addRegistrationAdjustment();
        }
        
        const rows = document.querySelectorAll('#registrationAdjustmentsList > div');
        const lastRow = rows[rows.length - 1];
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            inputs[0].value = registrationDescription || '×¢×œ×™×” ×œ×›×‘×™×© (××œ×•×™ ×™×¦×—×§)';
            inputs[1].value = String(registrationPercent).includes('-') ? 'minus' : 'plus';
            // CRITICAL FIX: Display minus sign for negative values
            const registrationPercentValue = parseFloat(String(registrationPercent).replace(/[%\s+]/g, '')) || 0;
            const displayRegistrationPercent = String(registrationPercent).includes('-') ? `-${Math.abs(registrationPercentValue)}` : Math.abs(registrationPercentValue);
            inputs[2].value = displayRegistrationPercent || '';
            
            // CRITICAL FIX: Display minus sign for amount values too
            const registrationAmountValue = parseFloat(String(registrationAmount).replace(/[â‚ª,\s]/g, '')) || 0;
            const displayRegistrationAmount = String(registrationPercent).includes('-') ? `-${Math.abs(registrationAmountValue)}` : Math.abs(registrationAmountValue);
            inputs[3].value = registrationAmount ? `â‚ª${displayRegistrationAmount.toLocaleString()}` : '';
            
            lastRow.setAttribute('data-source', 'levi');
            lastRow.style.background = '#f0f8ff';
          }
        }
      }
      
      // ===== END OF GROSS ADJUSTMENTS =====
      // Note: Market adjustments (mileage, ownership, owners) belong in "Full Market Value" section,
      // not in the gross value section which is only for car properties (features + registration)
      
      // Trigger calculations after auto-population
      setTimeout(() => {
        if (typeof updateGrossMarketValueCalculation === 'function') {
          updateGrossMarketValueCalculation();
        }
        // REMOVED: updateHelperFromAdjustments() to prevent overwriting calculated amounts on page load
        if (window.FinalReportCalculations && typeof window.FinalReportCalculations.refresh3BulkCalculations === 'function') {
          window.FinalReportCalculations.refresh3BulkCalculations();
        }
      }, 100);
      
      autoPopulationInProgress = false;
      autoPopulationCompleted = true;
      sessionStorage.setItem('autoPopulationCompleted', 'true');
    }
    
    /**
     * Auto-populate market adjustments (mileage, ownership) for Full Market Value section
     */
    function autoPopulateMarketAdjustments() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const adjustments = helper.estimate?.adjustments || {};
      
      console.log('ğŸª Auto-populating market adjustments from helper.estimate.adjustments');
      console.log('ğŸ” Available adjustments:', adjustments);
      
      // Get base price for calculations
      let basePrice = 0;
      const basicPriceField = document.getElementById('basicPrice');
      if (basicPriceField && basicPriceField.value) {
        basePrice = parseFloat(basicPriceField.value.replace(/[â‚ª,]/g, '')) || 0;
      }
      console.log('ğŸ“Š Base price for calculations:', basePrice);
      
      // Clear existing auto-populated adjustments from ALL containers
      const containers = [
        'fullFeaturesAdjustmentsList',
        'fullRegistrationAdjustmentsList', 
        'mileageAdjustmentsList',
        'ownershipAdjustmentsList',
        'ownersAdjustmentsList'
      ];
      
      containers.forEach(containerId => {
        const container = document.getElementById(containerId);
        if (container) {
          const leviRows = container.querySelectorAll('div[data-source="levi"]');
          leviRows.forEach(row => row.remove());
          console.log(`ğŸ§¹ Cleared ${leviRows.length} Levi rows from ${containerId}`);
        }
      });
      
      // Auto-populate adjustments in CORRECT ORDER as per user requirements:
      // 1. Features â†’ 2. Registration â†’ 3. Mileage â†’ 4. Ownership â†’ 5. Owners
      // FIXED: Use correct keys from helper data structure
      const adjustmentMapping = [
        { key: 'features', label: '×ª×•×¡×¤×•×ª ×××¤×™×™× ×™×', containerId: 'fullFeaturesAdjustmentsList', addFunction: addFullFeaturesAdjustment },
        { key: 'registration', label: '×¢×œ×™×” ×œ×›×‘×™×©', containerId: 'fullRegistrationAdjustmentsList', addFunction: addFullRegistrationAdjustment },
        { key: 'mileage', label: '××¡ ×§"×', containerId: 'mileageAdjustmentsList', addFunction: addMileageAdjustment },
        { key: 'ownership_type', label: '×¡×•×’ ×‘×¢×œ×•×ª', containerId: 'ownershipAdjustmentsList', addFunction: addOwnershipAdjustment },
        { key: 'ownership_history', label: '××¡×¤×¨ ×‘×¢×œ×™×', containerId: 'ownersAdjustmentsList', addFunction: addOwnersAdjustment }
      ];
      
      adjustmentMapping.forEach(({ key, label, containerId, addFunction }) => {
        const adjData = adjustments[key] || [];
        console.log(`ğŸ” Processing ${key}:`, adjData);
        
        // Handle both array and single object data from estimate.adjustments
        const items = Array.isArray(adjData) ? adjData : (adjData && (adjData.percent || adjData.percentage || adjData.amount) ? [adjData] : []);
        
        items.forEach((item, index) => {
          if (item && (item.percent || item.percentage || item.amount)) {
            // Extract percentage - handle negative values  
            let percent = parseFloat(item.percent || item.percentage) || 0;
            
            // Extract amount
            let amount = parseFloat(item.amount) || 0;
            
            // Field mapping: value â†’ ×ª×™××•×¨
            const description = item.value || item.description || label;
          
            
            console.log(`ğŸ“ Importing ${key} item ${index}:`, {
              description,
              percent,
              amount,
              type: item.type
            });
            
            // Add the adjustment row
            addFunction();
            
            const container = document.getElementById(containerId);
            const rows = container.querySelectorAll('div.adjustment-row');
            const lastRow = rows[rows.length - 1];
            
            if (lastRow) {
              const inputs = lastRow.querySelectorAll('input, select');
              if (inputs.length >= 4) {
                // Use exact estimator builder logic for field assignment
                inputs[0].value = item.value || '';
                const itemPercent = item.percentage || item.percent;
                const itemAmount = item.amount;
                // FIX: Use stored type directly instead of detection
                const storedType = item.type || 'plus';
                if (storedType === '×”×¤×—×ª×”' || storedType === '×”×¤×—×ª×” (-)' || storedType === '×”×•×¨×“×”' || storedType === 'minus') {
                  inputs[1].value = 'minus';
                } else if (storedType === '×ª×•×¡×¤×ª' || storedType === '×ª×•×¡×¤×ª (+)' || storedType === 'plus') {
                  inputs[1].value = 'plus';
                } else {
                  inputs[1].value = storedType; // Use as-is for %, â‚ª etc
                }
                // CRITICAL FIX: Display minus sign for negative values
                const displayPercent = isReductionType(item.type) && itemPercent > 0 ? `-${Math.abs(itemPercent)}` : Math.abs(itemPercent || 0);
                const displayAmount = isReductionType(item.type) && item.amount > 0 ? `-${Math.abs(item.amount)}` : Math.abs(item.amount || 0);
                
                inputs[2].value = itemPercent ? displayPercent : '';
                inputs[3].value = item.amount_display || (item.amount ? `â‚ª${displayAmount.toLocaleString()}` : '');
              
              // Trigger onchange events to ensure handlers are active
              inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
              if (inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
              if (inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
              
              // Mark as Levi data
              lastRow.setAttribute('data-source', 'levi');
              lastRow.style.background = '#f0f8ff';
              lastRow.style.border = '1px solid #4a90e2';
              
              console.log(`âœ… Populated ${key}:`, {
                description: inputs[0].value,
                type: inputs[1].value,
                percent: inputs[2].value,
                amount: inputs[3].value
              });
            }
          }
          }
        });
        
        if (items.length === 0) {
          console.log(`âš ï¸ No valid data for ${key}:`, adjData);
        }
      });
      
      // Trigger calculation after populating all adjustments
      if (typeof updateFullMarketValueCalculation === 'function') {
        setTimeout(() => {
          updateFullMarketValueCalculation();
          console.log('âœ… Full market value calculation triggered after auto-population');
        }, 100);
      }
      
      console.log('âœ… Market adjustments auto-population completed from helper.valuation.adjustments');
    }
    
    // RELOAD FULL MARKET ADJUSTMENTS - triggered by reload button
    function reloadFullMarketAdjustments() {
      try {
        console.log('ğŸ”„ Reloading Total Value adjustments with mixed sources: Features/Registration from final_report, Others from estimate');
        
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Mixed data sources for Total Value section reload:
        // - Features & Registration: from final_report.adjustments (sync with Gross section)
        // - Others (KM, Ownership, Owners, Additional): from estimate.adjustments (original Levi data)
        const estimateAdjustments = helper.estimate?.adjustments || helper.valuation?.adjustments || {};
        const finalReportAdjustments = helper.final_report?.adjustments || {};
        
        console.log('ğŸ” estimate.adjustments:', estimateAdjustments);
        console.log('ğŸ” final_report.adjustments:', finalReportAdjustments);
        
        // Clear existing rows from NON-SYNCED containers only (preserve features/registration)
        const containersToReload = [
          'mileageAdjustmentsList',
          'ownershipAdjustmentsList', 
          'ownersAdjustmentsList',
          'allAdjustmentsList'
        ];
        
        containersToReload.forEach(containerId => {
          const container = document.getElementById(containerId);
          if (container) {
            container.innerHTML = '';
            console.log(`ğŸ§¹ Cleared container: ${containerId}`);
          }
        });
        
        console.log('âš ï¸ SKIPPING features/registration reload to preserve Total Value manual additions');
        
        // Load ONLY non-synced categories (skip features/registration to preserve manual additions)
        const adjustmentMapping = [
          // SKIPPED: features and registration to preserve Total Value manual additions
          { key: 'mileage', label: '××¡ ×§"×', containerId: 'mileageAdjustmentsList', addFunction: addMileageAdjustment },
          { key: 'ownership_type', label: '×¡×•×’ ×‘×¢×œ×•×ª', containerId: 'ownershipAdjustmentsList', addFunction: addOwnershipAdjustment },
          { key: 'ownership_history', label: '××¡×¤×¨ ×‘×¢×œ×™×', containerId: 'ownersAdjustmentsList', addFunction: addOwnersAdjustment }
          // REMOVED: additional - it's handled separately in loadFullMarketValueData to avoid duplicates
        ];
        
        adjustmentMapping.forEach(({ key, label, containerId, addFunction }) => {
          // All categories now load from estimate.adjustments (no features/registration)
          const categoryData = estimateAdjustments[key];
          console.log(`ğŸ“¦ Loading ${key} from estimate.adjustments:`, categoryData);
          if (categoryData) {
            console.log(`ğŸ“ Loading ${key} adjustments:`, categoryData);
            
            const container = document.getElementById(containerId);
            if (container) {
              // Handle both array and single object data
              const items = Array.isArray(categoryData) ? categoryData : (categoryData && (categoryData.percent || categoryData.percentage || categoryData.amount) ? [categoryData] : []);
              
              items.forEach((item, index) => {
                if (item && (item.percent || item.percentage || item.amount)) {
                  // Add new row
                  addFunction();
                  
                  // Fill the data
                  const rows = container.querySelectorAll('div[id*="Adj_"]');
                  const lastRow = rows[rows.length - 1];
                  
                  if (lastRow) {
                    const inputs = lastRow.querySelectorAll('input, select');
                    if (inputs.length >= 4) {
                      // Field mapping: value â†’ ×ª×™××•×¨ (description)
                      inputs[0].value = item.value || '';
                      
                      // Type dropdown - use stored type directly  
                      const itemPercent = item.percentage || item.percent;
                      const itemAmount = item.amount;
                      const storedType = item.type || 'plus';
                      if (storedType === 'minus' || storedType === '×”×¤×—×ª×”' || storedType === '×”×¤×—×ª×” (-)') {
                        inputs[1].value = 'minus';
                      } else if (storedType === 'plus' || storedType === '×ª×•×¡×¤×ª' || storedType === '×ª×•×¡×¤×ª (+)') {
                        inputs[1].value = 'plus';
                      } else {
                        inputs[1].value = storedType; // For % or â‚ª types
                      }
                      
                      // Percent and amount - preserve sign based on type
                      inputs[2].value = itemPercent ? Math.abs(itemPercent) : '';
                      // Check if it's a reduction type to preserve minus sign
                      const isReduction = isReductionType(item.type);
                      let displayAmount = Math.abs(item.amount || 0);
                      if (isReduction && displayAmount > 0) {
                        displayAmount = -displayAmount;
                      }
                      inputs[3].value = item.amount_display || (item.amount ? `â‚ª${displayAmount.toLocaleString()}` : '');
                      
                      // Trigger change events
                      inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
                      if (inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
                      if (inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
                      
                      // Mark as loaded data
                      lastRow.setAttribute('data-source', 'estimate');
                      lastRow.style.background = '#e8f5e8';
                      lastRow.style.border = '1px solid #28a745';
                      
                      console.log(`âœ… Reloaded ${key} item ${index}:`, {
                        description: inputs[0].value,
                        type: inputs[1].value,
                        percent: inputs[2].value,
                        amount: inputs[3].value
                      });
                      
                      // Apply unified formatting to ensure proper minus signs
                      setTimeout(() => {
                        formatAdjustmentDisplay(lastRow, inputs[1].value, itemPercent, itemAmount);
                      }, 10);
                    }
                  }
                }
              });
            }
          }
        });
        
        // Trigger calculation after reloading
        if (typeof updateFullMarketValueCalculation === 'function') {
          setTimeout(() => {
            updateFullMarketValueCalculation();
            console.log('âœ… Full market value calculation triggered after reload');
          }, 100);
        }
        
        // REMOVED: updateHelperFromAdjustments() to prevent overwriting calculated amounts on page load
        
        // CRITICAL: Save Total Value sections to helper after reload
        updateFullMarketValueToFinalReportAndValuation(helper);
        
        // Save updated helper to storage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        console.log('ğŸ’¾ Saved updated helper to storage after reload');
        
        console.log('âœ… Full market adjustments reload completed');
        
      } catch (error) {
        console.error('âŒ Error reloading full market adjustments:', error);
      }
    }
    
    /**
     * Clear existing auto-populated Levi adjustments before re-populating
     */
    function clearLeviAdjustments() {
      // Clear features adjustments marked as Levi data
      const featureRows = document.querySelectorAll('#featuresAdjustmentsList div[data-source="levi"]');
      console.log(`ğŸ§¹ Clearing ${featureRows.length} Levi feature rows`);
      featureRows.forEach(row => row.remove());
      
      // Clear registration adjustments marked as Levi data
      const registrationRows = document.querySelectorAll('#registrationAdjustmentsList div[data-source="levi"]');
      console.log(`ğŸ§¹ Clearing ${registrationRows.length} Levi registration rows`);
      registrationRows.forEach(row => row.remove());
      
      // Clear market adjustments marked as Levi data 
      const marketRows = document.querySelectorAll('#allAdjustmentsList div[data-source="levi"]');
      console.log(`ğŸ§¹ Clearing ${marketRows.length} Levi market rows`);
      marketRows.forEach(row => row.remove());
      
      console.log('âœ… Cleared all existing Levi adjustments');
    }
    
    /**
     * Enhanced two-way data binding: sync individual adjustment changes to helper
     */
    // UNIFIED DISPLAY FORMATTING FOR FEATURES AND REGISTRATION
    function formatAdjustmentDisplay(row, type, percent, amount) {
      try {
        const inputs = row.querySelectorAll('input, select');
        if (inputs.length < 4) return;
        
        const percentInput = inputs[2];
        const amountInput = inputs[3];
        
        
        // Determine if it's a reduction/subtraction
        const isReduction = isReductionType(type);
        
        
        // Determine field type based on category and data source
        // Features, KM, Ownership are typically percentage-based
        // Registration is typically amount-based
        const containerId = percentInput.closest('[id$="AdjustmentsList"]')?.id || '';
        
        // Simple logic: if we have percent data, show percentage mode; if we have amount data, show amount mode
        const hasPercent = (percent !== null && percent !== undefined && percent !== 0);
        const hasAmount = (amount !== null && amount !== undefined && amount !== 0);
        
        if (hasPercent && !hasAmount) {
          // Percentage mode: show percent value, make both editable
          percentInput.value = isReduction ? `-${Math.abs(percent)}` : Math.abs(percent);
          percentInput.readOnly = false;
          percentInput.style.background = '';
          amountInput.value = '';
          amountInput.readOnly = false;
          amountInput.style.background = '';
        } else if (hasAmount && !hasPercent) {
          // Amount mode: show amount value, make both editable
          const validAmount = safeParseAmount(amount);
          amountInput.value = validAmount === 0 ? '' : (isReduction ? `-â‚ª${Math.abs(validAmount).toLocaleString()}` : `â‚ª${Math.abs(validAmount).toLocaleString()}`);
          amountInput.readOnly = false;
          amountInput.style.background = '';
          percentInput.value = '';
          percentInput.readOnly = false;
          percentInput.style.background = '';
        } else {
          // Default: make both fields editable
          const validAmount = safeParseAmount(amount);
          percentInput.value = isReduction && percent ? `-${Math.abs(percent)}` : Math.abs(percent || 0);
          amountInput.value = validAmount === 0 ? '' : (isReduction ? `-â‚ª${Math.abs(validAmount).toLocaleString()}` : `â‚ª${Math.abs(validAmount).toLocaleString()}`);
          percentInput.readOnly = false;
          amountInput.readOnly = false;
          percentInput.style.background = '';
          amountInput.style.background = '';
        }
        
        
      } catch (error) {
        console.error('Error in formatAdjustmentDisplay:', error);
      }
    }

    // Save adjustment amount immediately without waiting for field change
    function saveAdjustmentAmount(category, amount, cumulativeValue) {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Ensure structures exist
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // Round amount to whole number
        const roundedAmount = Math.round(amount);
        const roundedCumulative = cumulativeValue !== undefined ? Math.round(cumulativeValue) : undefined;
        
        // Format amount display with rounded value
        const amountDisplay = roundedAmount !== 0 ? `â‚ª${Math.abs(roundedAmount).toLocaleString()}` : '';
        
        // Update valuation.adjustments
        if (!helper.valuation.adjustments[category]) {
          helper.valuation.adjustments[category] = {};
        }
        helper.valuation.adjustments[category].amount = roundedAmount;
        helper.valuation.adjustments[category].amount_display = amountDisplay;
        if (roundedCumulative !== undefined) {
          helper.valuation.adjustments[category].cumulative = roundedCumulative;
        }
        
        // Update final_report.adjustments (ensure array exists and update first item)
        if (!helper.final_report.adjustments[category]) {
          helper.final_report.adjustments[category] = [];
        }
        if (helper.final_report.adjustments[category].length === 0) {
          helper.final_report.adjustments[category].push({});
        }
        helper.final_report.adjustments[category][0].amount = roundedAmount;
        helper.final_report.adjustments[category][0].amount_display = amountDisplay;
        if (roundedCumulative !== undefined) {
          helper.final_report.adjustments[category][0].cumulative = roundedCumulative;
        }
        
        // Save to storage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        console.log(`ğŸ’¾ Saved amount for ${category}: ${roundedAmount} (cumulative: ${roundedCumulative})`);
      } catch (error) {
        console.error('Error saving adjustment amount:', error);
      }
    }

    // Restore adjustment amounts from helper data on page load
    function restoreAdjustmentAmounts() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        console.log('ğŸ”„ Restoring adjustment amounts from helper...');
        console.log('ğŸ” DEBUG: helper.valuation.adjustments:', helper.valuation?.adjustments);
        
        // Restore amounts for our three categories plus additional
        const categories = ['mileage', 'ownership_type', 'ownership_history', 'additional'];
        
        categories.forEach(category => {
          // Check both locations for amount data
          const valuationAmount = helper.valuation?.adjustments?.[category]?.amount;
          const finalReportAmount = helper.final_report?.adjustments?.[category]?.[0]?.amount;
          
          console.log(`ğŸ” DEBUG ${category}: valuationAmount=${valuationAmount}, finalReportAmount=${finalReportAmount}`);
          
          // Use valuation amount if available, otherwise final_report
          const amount = valuationAmount !== undefined ? valuationAmount : finalReportAmount;
          
          if (amount !== undefined && amount !== 0) {
            // Round the amount to ensure no fractions
            const roundedAmount = Math.round(amount);
            console.log(`ğŸ“– Found saved amount for ${category}: ${roundedAmount}`);
            
            // Find the corresponding container
            let containerId = '';
            if (category === 'mileage') containerId = 'mileageAdjustmentsList';
            else if (category === 'ownership_type') containerId = 'ownershipAdjustmentsList';
            else if (category === 'ownership_history') containerId = 'ownersAdjustmentsList';
            else if (category === 'additional') containerId = 'allAdjustmentsList';
            
            const container = document.getElementById(containerId);
            if (container) {
              const rows = container.querySelectorAll('div[id*="Adj_"]');
              if (rows.length > 0) {
                // Update the first row's amount field (original working logic)
                const firstRow = rows[0];
                const inputs = firstRow.querySelectorAll('input[type="text"]');
                if (inputs.length >= 3) {
                  const valueInput = inputs[2]; // Amount field
                  if (valueInput) {
                    valueInput.value = roundedAmount < 0 ? `-â‚ª${Math.abs(roundedAmount).toLocaleString()}` : `â‚ª${Math.abs(roundedAmount).toLocaleString()}`;
                    console.log(`âœ… Restored amount for ${category} first row in UI`);
                  }
                }
              }
              
              // EXTEND: Also restore added rows (index > 0) from final_report.adjustments
              const finalReportAdjustments = helper.final_report?.adjustments?.[category];
              if (finalReportAdjustments && finalReportAdjustments.length > 1) {
                for (let i = 1; i < finalReportAdjustments.length; i++) {
                  const savedAdjustment = finalReportAdjustments[i];
                  if (savedAdjustment && savedAdjustment.amount !== undefined && rows[i]) {
                    const addedRow = rows[i];
                    const addedInputs = addedRow.querySelectorAll('input[type="text"]');
                    if (addedInputs.length >= 3) {
                      const addedValueInput = addedInputs[2]; // Amount field
                      if (addedValueInput) {
                        const savedAmount = Math.round(savedAdjustment.amount);
                        addedValueInput.value = savedAmount < 0 ? `-â‚ª${Math.abs(savedAmount).toLocaleString()}` : `â‚ª${Math.abs(savedAmount).toLocaleString()}`;
                        console.log(`âœ… Restored amount for ${category} added row ${i}: ${savedAmount}`);
                        console.log(`ğŸ” Input value after restore: "${addedValueInput.value}"`);
                      }
                    }
                  }
                }
              }
            }
          }
        });
        
        // Trigger calculation update to refresh cumulative displays
        setTimeout(() => {
          updateFullMarketValueCalculation();
          
          // IMPORTANT: Restore added rows amounts AFTER calculation to prevent clearing
          setTimeout(() => {
            restoreAddedRowsAmounts();
          }, 200);
        }, 100);
        
      } catch (error) {
        console.error('Error restoring adjustment amounts:', error);
      }
    }

    // Separate function to restore added rows amounts after calculations
    function restoreAddedRowsAmounts() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        console.log('ğŸ”„ Restoring added rows amounts after calculations...');
        
        const categories = ['mileage', 'ownership_type', 'ownership_history', 'additional', 'features', 'registration'];
        
        categories.forEach(category => {
          let containerId = '';
          if (category === 'mileage') containerId = 'mileageAdjustmentsList';
          else if (category === 'ownership_type') containerId = 'ownershipAdjustmentsList';
          else if (category === 'ownership_history') containerId = 'ownersAdjustmentsList';
          else if (category === 'additional') containerId = 'allAdjustmentsList';
          else if (category === 'features') {
            // Check both gross and full market sections
            const grossContainer = document.getElementById('featuresAdjustmentsList');
            const fullContainer = document.getElementById('fullFeaturesAdjustmentsList');
            if (grossContainer && grossContainer.children.length > 0) containerId = 'featuresAdjustmentsList';
            else if (fullContainer && fullContainer.children.length > 0) containerId = 'fullFeaturesAdjustmentsList';
          }
          else if (category === 'registration') {
            // Check both gross and full market sections  
            const grossContainer = document.getElementById('registrationAdjustmentsList');
            const fullContainer = document.getElementById('fullRegistrationAdjustmentsList');
            if (grossContainer && grossContainer.children.length > 0) containerId = 'registrationAdjustmentsList';
            else if (fullContainer && fullContainer.children.length > 0) containerId = 'fullRegistrationAdjustmentsList';
          }
          
          if (!containerId) return;
          
          const container = document.getElementById(containerId);
          if (!container) return;
          
          const rows = container.querySelectorAll('div[id*="Adj_"]');
          const finalReportAdjustments = helper.final_report?.adjustments?.[category];
          
          if (finalReportAdjustments && finalReportAdjustments.length > 1) {
            for (let i = 1; i < finalReportAdjustments.length; i++) {
              const savedAdjustment = finalReportAdjustments[i];
              if (savedAdjustment && savedAdjustment.amount !== undefined && rows[i]) {
                const addedRow = rows[i];
                const addedInputs = addedRow.querySelectorAll('input[type="text"]');
                if (addedInputs.length >= 3) {
                  const addedValueInput = addedInputs[2]; // Amount field
                  if (addedValueInput) {
                    const savedAmount = Math.round(savedAdjustment.amount);
                    addedValueInput.value = savedAmount < 0 ? `-â‚ª${Math.abs(savedAmount).toLocaleString()}` : `â‚ª${Math.abs(savedAmount).toLocaleString()}`;
                    console.log(`âœ… FINAL restore: ${category} added row ${i}: ${savedAmount}`);
                  }
                }
              }
            }
          }
        });
        
      } catch (error) {
        console.error('Error in restoreAddedRowsAmounts:', error);
      }
    }

    // Load additional adjustments from helper to UI
    function loadAdditionalAdjustments() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        console.log('ğŸ”„ Loading additional adjustments from helper...');
        
        // Check for additional adjustments in final_report
        const additionalAdjustments = helper.final_report?.adjustments?.additional || [];
        
        if (additionalAdjustments.length > 0) {
          const container = document.getElementById('allAdjustmentsList');
          if (!container) return;
          
          // Clear existing rows first
          container.innerHTML = '';
          
          // Create rows for each saved adjustment
          additionalAdjustments.forEach((adjustment, index) => {
            const rowId = 'fullAdj_' + Date.now() + '_' + index;
            const type = adjustment.type || 'plus';
            const description = adjustment.value || '';
            const percentage = adjustment.percentage || adjustment.percent || 0;
            const amount = adjustment.amount || 0;
            const amountDisplay = adjustment.amount_display || (amount !== 0 ? `â‚ª${Math.abs(amount).toLocaleString()}` : '');
            
            const newRow = `
              <div id="${rowId}" class="adjustment-row" data-source="restored" style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
                <div><input type="text" placeholder="×ª×™××•×¨ ×”×ª×××” × ×•×¡×¤×ª" value="${description}" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(inputs[2].value) || 0, safeParseAmount(inputs[3].value));" /></div>
                <div><select onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, parseFloat(inputs[2].value) || 0, safeParseAmount(inputs[3].value));">
                  <option value="plus" ${type === 'plus' ? 'selected' : ''}>×ª×•×¡×¤×ª (+)</option>
                  <option value="minus" ${type === 'minus' ? 'selected' : ''}>×”×¤×—×ª×” (-)</option>
                </select></div>
                <div><input type="text" placeholder="××—×•×–" value="${Math.abs(percentage)}" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(this.value) || 0, safeParseAmount(inputs[3].value));" /></div>
                <div><input type="text" placeholder="â‚ª" value="${amountDisplay}" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(inputs[2].value) || 0, safeParseAmount(this.value));" /></div>
                <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">××—×§</button></div>
              </div>
            `;
            
            container.insertAdjacentHTML('beforeend', newRow);
          });
          
          console.log(`âœ… Loaded ${additionalAdjustments.length} additional adjustments to UI`);
        }
        
      } catch (error) {
        console.error('Error loading additional adjustments:', error);
      }
    }

    // Save only cumulative value for an adjustment category (without other fields)
    function saveAdjustmentCumulativeOnly(category, cumulativeValue) {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Ensure structures exist
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // Round cumulative value
        const roundedCumulative = Math.round(cumulativeValue);
        
        // Update valuation.adjustments cumulative
        if (!helper.valuation.adjustments[category]) {
          helper.valuation.adjustments[category] = {};
        }
        helper.valuation.adjustments[category].cumulative = roundedCumulative;
        
        // Update final_report.adjustments cumulative for all items in array
        if (helper.final_report.adjustments[category] && Array.isArray(helper.final_report.adjustments[category])) {
          helper.final_report.adjustments[category].forEach(item => {
            item.cumulative = roundedCumulative;
          });
        }
        
        // Save to storage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        console.log(`ğŸ’¾ Saved cumulative for ${category}: ${roundedCumulative}`);
      } catch (error) {
        console.error('Error saving adjustment cumulative:', error);
      }
    }

    // Sync cumulative values for gross section categories after calculations
    function syncGrossCumulativeValues() {
      try {
        console.log('ğŸ”„ Syncing gross section cumulative values...');
        
        // For features
        const featuresContainer = document.getElementById('featuresAdjustmentsList');
        if (featuresContainer && featuresContainer.children.length > 0) {
          const firstInput = featuresContainer.children[0].querySelector('input');
          if (firstInput) {
            syncAdjustmentToHelper(firstInput, 'features');
          }
        }
        
        // For registration
        const registrationContainer = document.getElementById('registrationAdjustmentsList');
        if (registrationContainer && registrationContainer.children.length > 0) {
          const firstInput = registrationContainer.children[0].querySelector('input');
          if (firstInput) {
            syncAdjustmentToHelper(firstInput, 'registration');
          }
        }
        
        console.log('âœ… Gross cumulative values synced');
      } catch (error) {
        console.error('Error syncing gross cumulative values:', error);
      }
    }

    function syncAdjustmentToHelper(element, category) {
      try {
        console.log(`ğŸ”¥ syncAdjustmentToHelper called for category: ${category}, element:`, element);
        
        // Skip sync during page load to prevent clearing saved data
        if (window.pageLoadInProgress) {
          console.log('â¸ï¸ Skipping sync during page load to preserve data');
          return;
        }
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Ensure structures exist
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.estimate) helper.estimate = {};
        if (!helper.estimate.adjustments) helper.estimate.adjustments = {};
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // Map category to container ID - Check both full market and gross containers
        let containerId = '';
        if (category === 'features') {
          // Check if element is from gross section or full market section
          const row = element.closest('div');
          const grossContainer = document.getElementById('featuresAdjustmentsList');
          const fullContainer = document.getElementById('fullFeaturesAdjustmentsList');
          
          if (grossContainer && grossContainer.contains(row)) {
            containerId = 'featuresAdjustmentsList'; // Gross section
            console.log(`ğŸ¯ Detected GROSS features section for ${category}`);
          } else {
            containerId = 'fullFeaturesAdjustmentsList'; // Full market section
            console.log(`ğŸ¯ Detected FULL MARKET features section for ${category}`);
          }
        }
        else if (category === 'registration') {
          // Check if element is from gross section or full market section  
          const row = element.closest('div');
          const grossContainer = document.getElementById('registrationAdjustmentsList');
          const fullContainer = document.getElementById('fullRegistrationAdjustmentsList');
          
          if (grossContainer && grossContainer.contains(row)) {
            containerId = 'registrationAdjustmentsList'; // Gross section
            console.log(`ğŸ¯ Detected GROSS registration section for ${category}`);
          } else {
            containerId = 'fullRegistrationAdjustmentsList'; // Full market section
            console.log(`ğŸ¯ Detected FULL MARKET registration section for ${category}`);
          }
        }
        else if (category === 'mileage') containerId = 'mileageAdjustmentsList';
        else if (category === 'ownership_type') containerId = 'ownershipAdjustmentsList';
        else if (category === 'ownership_history') containerId = 'ownersAdjustmentsList';
        else if (category === 'additional') containerId = 'allAdjustmentsList';
        
        if (!containerId) {
          console.error('âŒ Unknown category:', category);
          return;
        }
        
        const container = document.getElementById(containerId);
        if (!container) {
          console.error('âŒ Container not found:', containerId);
          return;
        }
        
        console.log(`ğŸ”„ Rebuilding ${category} from all UI rows in ${containerId}`);
        
        // FINAL REPORT PATTERN: Rebuild entire category array from ALL visible UI rows
        // DO NOT WRITE TO estimate.adjustments - it should be READ-ONLY!
        const allRows = Array.from(container.children);
        
        // PRESERVE EXISTING DATA: Don't clear the entire array, preserve entries beyond UI rows
        const existingAdjustments = helper.final_report.adjustments[category] || [];
        helper.final_report.adjustments[category] = [];
        
        allRows.forEach((row, index) => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            // Start with existing data if available
            const existingData = existingAdjustments[index] || {};
            
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percentage: parseFloat(inputs[2].value) || 0,
              percent: parseFloat(inputs[2].value) || 0, // Backward compatibility
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value) || existingData.amount || 0, // PRESERVE existing amount if UI is empty
              source: 'manual',
              timestamp: new Date().toISOString()
            };
            
            // DEBUG: Log type saving for ownership_history
            if (category === 'ownership_history') {
              console.log(`ğŸ’¾ OWNERSHIP_HISTORY TYPE SAVING [${index}]:`, {
                category,
                inputType: inputs[1].value,
                finalType: adjustmentData.type,
                allInputs: Array.from(inputs).map(i => i.value)
              });
            }
            
            
            // Calculate amount from percentage if needed (BEFORE applying signs)
            // FIXED: Only calculate if BOTH conditions are met:
            // 1. Percentage exists and is non-zero
            // 2. Amount is truly empty (not manually entered)
            const amountFromUI = safeParseAmount(inputs[3].value);
            const hasManualAmount = amountFromUI !== 0 || inputs[3].value.trim() !== '';
            
            if (adjustmentData.percentage && !hasManualAmount) {
              const baseValue = parseFloat(helper.estimate?.market_value_base) || 0;
              if (baseValue > 0) {
                const amount = Math.round((baseValue * Math.abs(adjustmentData.percentage)) / 100);
                adjustmentData.amount = amount; // Set as positive first
                adjustmentData.isCalculatedAmount = true; // Flag for calculated amounts
              }
            } else if (hasManualAmount) {
              adjustmentData.amount = amountFromUI;
              adjustmentData.isManualAmount = true; // Flag for manual amounts
            }
            
            // Round the amount to ensure no fractions
            adjustmentData.amount = Math.round(adjustmentData.amount);
            
            // Apply sign based on type (CRITICAL FOR MINUS SIGNS) - AFTER amount calculation
            if (adjustmentData.type === 'minus') {
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
            }
            
            // Add cumulative tracking for all adjustment categories
            if (category === 'mileage' || category === 'ownership_type' || category === 'ownership_history' || 
                category === 'features' || category === 'registration' || category === 'additional') {
              // FIXED: Get cumulative from the row itself, not the category total
              const rowCumulativeSpan = row.querySelector('.row-cumulative');
              if (rowCumulativeSpan) {
                const cumulativeText = rowCumulativeSpan.textContent.replace(/[â‚ª,]/g, '');
                const cumulativeValue = parseFloat(cumulativeText) || 0;
                // Round cumulative value to ensure no fractions
                adjustmentData.cumulative = Math.round(cumulativeValue);
                console.log(`ğŸ“Š Captured row cumulative for ${category}[${index}]: ${adjustmentData.cumulative}`);
              } else {
                // Fallback to category cumulative for backward compatibility
                let cumulativeId = '';
                
                // For features and registration, determine if it's gross or full market section
                if (category === 'features') {
                  // Check if it's gross section or full market section based on container
                  if (containerId === 'featuresAdjustmentsList') {
                    cumulativeId = 'grossFeaturesCumulative'; // Gross section
                  } else {
                    cumulativeId = 'featuresCumulative'; // Full market section
                  }
                }
                else if (category === 'registration') {
                  // Check if it's gross section or full market section based on container
                  if (containerId === 'registrationAdjustmentsList') {
                    cumulativeId = 'grossRegistrationCumulative'; // Gross section
                  } else {
                    cumulativeId = 'registrationCumulative'; // Full market section
                  }
                }
                else if (category === 'mileage') cumulativeId = 'mileageCumulative';
                else if (category === 'ownership_type') cumulativeId = 'ownershipCumulative';
                else if (category === 'ownership_history') cumulativeId = 'ownersCumulative';
                
                const cumulativeElement = document.getElementById(cumulativeId);
                if (cumulativeElement) {
                  const cumulativeSpan = cumulativeElement.querySelector('span');
                  if (cumulativeSpan) {
                    const cumulativeText = cumulativeSpan.textContent.replace(/[â‚ª,]/g, '');
                    const cumulativeValue = parseFloat(cumulativeText) || 0;
                    // Round cumulative value to ensure no fractions
                    adjustmentData.cumulative = Math.round(cumulativeValue);
                    console.log(`ğŸ“Š Captured category cumulative for ${category}: ${adjustmentData.cumulative}`);
                  }
                }
              }
            }
            
            // ONLY write to final_report - estimate should remain READ-ONLY
            helper.final_report.adjustments[category].push(adjustmentData);
            console.log(`ğŸ“ Added row ${index} to final_report.${category}:`, adjustmentData.value);
          }
        });
        
        console.log(`âœ… Rebuilt ${category}: ${helper.final_report.adjustments[category].length} items total`);
        console.log(`ğŸ“Š Final final_report.adjustments.${category}:`, helper.final_report.adjustments[category]);
        
        // FINAL REPORT PATTERN: Update valuation.adjustments with first item (for backward compatibility)
        if (helper.final_report.adjustments[category].length > 0) {
          helper.valuation.adjustments[category] = helper.final_report.adjustments[category][0];
          
          // Ensure cumulative is also copied to valuation for all categories with cumulative tracking
          if ((category === 'mileage' || category === 'ownership_type' || category === 'ownership_history' || 
               category === 'features' || category === 'registration') && 
              helper.final_report.adjustments[category][0].cumulative !== undefined) {
            helper.valuation.adjustments[category].cumulative = helper.final_report.adjustments[category][0].cumulative;
          }
        } else {
          // Clear valuation if no items remain
          if (helper.valuation.adjustments[category]) {
            delete helper.valuation.adjustments[category];
          }
        }
        
        // Save to storage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper; // Update window.helper
        
      } catch (error) {
        console.error('Error in syncAdjustmentToHelper:', error);
      }
    }
    
    // Sync UI section with data array (for bidirectional sync)
    function syncUISection(containerId, dataArray) {
      try {
        const container = document.getElementById(containerId);
        if (!container) {
          console.log(`Container ${containerId} not found`);
          return;
        }
        
        console.log(`ğŸ”„ Syncing ${dataArray.length} items to ${containerId}`);
        
        // Get existing rows
        const existingRows = container.querySelectorAll('div[id^="featureAdj_"], div[id^="regAdj_"], div[id^="fullFeatureAdj_"], div[id^="fullRegAdj_"]');
        
        // Try to preserve existing rows where possible
        dataArray.forEach((item, index) => {
          if (index < existingRows.length) {
            // Update existing row
            const row = existingRows[index];
            const inputs = row.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              inputs[0].value = item.value || '';
              inputs[1].value = item.type || '%';
              inputs[2].value = item.percentage || '';
              inputs[3].value = item.amount || '';
              
              // Update readonly states based on type - ONLY for Full Market sections with %/â‚ª dropdowns
              if (containerId.includes('full') || containerId.includes('all')) {
                // Full Market sections use %/â‚ª type dropdowns
                if (inputs[1].value === '%') {
                  inputs[2].removeAttribute('readonly');
                  inputs[2].style.background = '';
                  inputs[3].setAttribute('readonly', 'readonly');
                  inputs[3].style.background = '#f0f0f0';
                } else {
                  inputs[2].setAttribute('readonly', 'readonly');
                  inputs[2].style.background = '#f0f0f0';
                  inputs[3].removeAttribute('readonly');
                  inputs[3].style.background = '';
                }
              } else {
                // Gross sections use plus/minus dropdowns - both percent and amount should be editable
                inputs[2].removeAttribute('readonly');
                inputs[2].style.background = '';
                inputs[3].removeAttribute('readonly');
                inputs[3].style.background = '';
              }
            }
          } else {
            // Add new row
            if (containerId === 'featuresAdjustmentsList') {
              addFeatureAdjustment();
            } else if (containerId === 'registrationAdjustmentsList') {
              addRegistrationAdjustment();
            } else if (containerId === 'fullFeaturesAdjustmentsList') {
              addFullFeaturesAdjustment();
            } else if (containerId === 'fullRegistrationAdjustmentsList') {
              addFullRegistrationAdjustment();
            }
            
            // Get the newly added row and populate it
            const newRows = container.querySelectorAll('div[id^="featureAdj_"], div[id^="regAdj_"], div[id^="fullFeatureAdj_"], div[id^="fullRegAdj_"]');
            const newRow = newRows[newRows.length - 1];
            if (newRow) {
              const inputs = newRow.querySelectorAll('input, select');
              if (inputs.length >= 4) {
                inputs[0].value = item.value || '';
                inputs[1].value = item.type || '%';
                inputs[2].value = item.percentage || '';
                inputs[3].value = item.amount || '';
                
                // Update readonly states - ONLY for Full Market sections with %/â‚ª dropdowns
                if (containerId.includes('full') || containerId.includes('all')) {
                  // Full Market sections use %/â‚ª type dropdowns
                  if (inputs[1].value === '%') {
                    inputs[2].removeAttribute('readonly');
                    inputs[2].style.background = '';
                    inputs[3].setAttribute('readonly', 'readonly');
                    inputs[3].style.background = '#f0f0f0';
                  } else {
                    inputs[2].setAttribute('readonly', 'readonly');
                    inputs[2].style.background = '#f0f0f0';
                    inputs[3].removeAttribute('readonly');
                    inputs[3].style.background = '';
                  }
                } else {
                  // Gross sections use plus/minus dropdowns - both percent and amount should be editable
                  inputs[2].removeAttribute('readonly');
                  inputs[2].style.background = '';
                  inputs[3].removeAttribute('readonly');
                  inputs[3].style.background = '';
                }
              }
            }
          }
        });
        
        // Remove extra rows
        for (let i = dataArray.length; i < existingRows.length; i++) {
          existingRows[i].remove();
        }
        
        console.log(`âœ… Synced ${containerId}`);
        
      } catch (error) {
        console.error(`Error syncing UI section ${containerId}:`, error);
      }
    }
    
    // Remove adjustment row
    function removeAdjustmentRow(rowId) {
      const row = document.getElementById(rowId);
      if (row) {
        // Determine which section this row belongs to
        const isGrossFeatures = row.closest('#featuresAdjustmentsList');
        const isGrossRegistration = row.closest('#registrationAdjustmentsList');
        const isFullSection = row.closest('#fullFeaturesAdjustmentsList, #fullRegistrationAdjustmentsList, #mileageAdjustmentsList, #ownershipAdjustmentsList, #ownersAdjustmentsList, #allAdjustmentsList');
        
        // Track deleted items for gross section rows
        if (isGrossFeatures || isGrossRegistration) {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const deletedItem = {
              value: inputs[0]?.value || '',
              description: inputs[0]?.value || '',
              type: inputs[1]?.value || '',
              percent: inputs[2]?.value || '',
              amount: inputs[3]?.value || ''
            };
            
            const category = isGrossFeatures ? 'features' : 'registration';
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            
            if (!helper.grossSectionDeletedItems) helper.grossSectionDeletedItems = {};
            if (!helper.grossSectionDeletedItems[category]) helper.grossSectionDeletedItems[category] = [];
            
            helper.grossSectionDeletedItems[category].push(deletedItem);
            sessionStorage.setItem('helper', JSON.stringify(helper));
            window.helper = helper;
            
            console.log(`ğŸ—‘ï¸ Tracked deleted ${category} item:`, deletedItem);
          }
        }
        
        // Check if this is an additional adjustment row
        const isAdditionalAdjustment = row.closest('#allAdjustmentsList');
        
        // CRITICAL FIX: Get the description BEFORE removing the row
        let description = '';
        let category = '';
        if (isAdditionalAdjustment) {
          const inputs = row.querySelectorAll('input');
          description = inputs[0]?.value || '';
          category = 'additional';
          console.log(`ğŸ—‘ï¸ Preparing to remove additional adjustment: "${description}"`);
        } else {
          // Determine category for other sections
          if (row.closest('#featuresAdjustmentsList') || row.closest('#fullFeaturesAdjustmentsList')) category = 'features';
          else if (row.closest('#registrationAdjustmentsList') || row.closest('#fullRegistrationAdjustmentsList')) category = 'registration';
          else if (row.closest('#mileageAdjustmentsList')) category = 'mileage';
          else if (row.closest('#ownershipAdjustmentsList')) category = 'ownership_type';
          else if (row.closest('#ownersAdjustmentsList')) category = 'ownership_history';
        }
        
        // Remove the row from UI
        row.remove();
        
        // For any category, trigger the sync function to rebuild arrays properly
        if (category) {
          console.log(`ğŸ”„ Triggering sync for category: ${category} after row deletion`);
          
          // Find the container and trigger sync with remaining rows
          let containerId = '';
          if (category === 'features') {
            containerId = isGrossFeatures ? 'featuresAdjustmentsList' : 'fullFeaturesAdjustmentsList';
          } else if (category === 'registration') {
            containerId = isGrossRegistration ? 'registrationAdjustmentsList' : 'fullRegistrationAdjustmentsList';
          } else if (category === 'mileage') containerId = 'mileageAdjustmentsList';
          else if (category === 'ownership_type') containerId = 'ownershipAdjustmentsList';
          else if (category === 'ownership_history') containerId = 'ownersAdjustmentsList';
          else if (category === 'additional') containerId = 'allAdjustmentsList';
          
          const container = document.getElementById(containerId);
          if (container && container.children.length > 0) {
            // Use first remaining input to trigger sync
            const firstInput = container.children[0].querySelector('input');
            if (firstInput) {
              syncAdjustmentToHelper(firstInput, category);
            }
          } else {
            // No rows left, manually clear the category
            const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
            
            // Clear from all locations
            if (helper.estimate?.adjustments?.[category]) {
              helper.estimate.adjustments[category] = [];
            }
            if (helper.final_report?.adjustments?.[category]) {
              helper.final_report.adjustments[category] = [];
            }
            if (helper.valuation?.adjustments?.[category]) {
              delete helper.valuation.adjustments[category];
            }
            
            sessionStorage.setItem('helper', JSON.stringify(helper));
            window.helper = helper;
            
            console.log(`ğŸ§¹ Cleared all data for category: ${category}`);
          }
        }
        
        // Call appropriate calculation function based on section
        if (isGrossFeatures || isGrossRegistration) {
          console.log('ğŸ”„ Updating GROSS calculation after row removal');
          updateGrossMarketValueCalculation();
        }
        if (isFullSection) {
          console.log('ğŸ”„ Updating FULL calculation after row removal');
          updateFullMarketValueCalculation();
        }
        
        // OLD BROKEN CODE - KEEPING FOR REFERENCE BUT IT'S NOT NEEDED WITH SYNC PATTERN
        /*
        // For additional adjustments, we need to remove from helper arrays before updating
        if (isAdditionalAdjustment) {
          console.log('ğŸ—‘ï¸ Removing additional adjustment from helper arrays');
          
          // Get the description/value from the row to identify which item to remove
          const inputs = row.querySelectorAll('input');
          const description = inputs[0]?.value || '';
        */
        
        console.log(`âœ… Successfully removed row and synced data using new estimator pattern`);
      }
    }
    
    // Get cumulative value from previous category for correct percentage base calculation
    function getPreviousCategoryCumulative(categoryContainer) {
      let cumulativeValue = 0;
      
      if (categoryContainer === 'mileageAdjustmentsList') {
        // Mileage should use cumulative after Features + Registration
        const registrationCumulative = document.getElementById('registrationCumulative');
        if (registrationCumulative) {
          const span = registrationCumulative.querySelector('span');
          if (span) {
            const text = span.textContent.replace(/[â‚ª,]/g, '');
            cumulativeValue = parseFloat(text) || 0;
          }
        }
      } else if (categoryContainer === 'ownershipAdjustmentsList') {
        // Ownership Type should use cumulative after Mileage
        const mileageCumulative = document.getElementById('mileageCumulative');
        if (mileageCumulative) {
          const span = mileageCumulative.querySelector('span');
          if (span) {
            const text = span.textContent.replace(/[â‚ª,]/g, '');
            cumulativeValue = parseFloat(text) || 0;
          }
        }
      } else if (categoryContainer === 'ownersAdjustmentsList') {
        // Ownership History should use cumulative after Ownership Type
        const ownershipCumulative = document.getElementById('ownershipCumulative');
        if (ownershipCumulative) {
          const span = ownershipCumulative.querySelector('span');
          if (span) {
            const text = span.textContent.replace(/[â‚ª,]/g, '');
            cumulativeValue = parseFloat(text) || 0;
          }
        }
      } else if (categoryContainer === 'allAdjustmentsList') {
        // Additional should use cumulative after Ownership History
        const ownersCumulative = document.getElementById('ownersCumulative');
        if (ownersCumulative) {
          const span = ownersCumulative.querySelector('span');
          if (span) {
            const text = span.textContent.replace(/[â‚ª,]/g, '');
            cumulativeValue = parseFloat(text) || 0;
          }
        }
      }
      
      return cumulativeValue;
    }
    
    // Get basic price fallback for Gross section or when cumulative is not available
    function getBasicPriceFallback() {
      let basicPrice = 0;
      const basicPriceField = document.getElementById('basicPrice');
      if (basicPriceField?.value) {
        basicPrice = parseFloat(basicPriceField.value.replace(/[â‚ª,]/g, '')) || 0;
      }
      
      // Fallback to helper data if needed
      if (basicPrice === 0) {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        basicPrice = helper.estimate?.market_value_base || helper.levisummary?.base_price || 118000;
      }
      
      return basicPrice;
    }

    // Calculate adjustment value for simple percentage input
    function calculateAdjustmentValueSimple(percentInput) {
      const row = percentInput.closest('div[id*="Adj_"]');
      if (!row) return;
      
      const inputs = row.querySelectorAll('input, select');
      if (inputs.length < 4) return;
      
      const percent = parseFloat(percentInput.value) || 0;
      if (percent === 0) return;
      
      // CRITICAL: First ensure cumulative displays are updated by running calculation
      setTimeout(() => {
        if (typeof updateFullMarketValueCalculation === 'function') {
          updateFullMarketValueCalculation();
        }
        
        // Then proceed with the calculation using updated cumulatives
        setTimeout(() => {
          performManualRowCalculation(percentInput, row, inputs, percent);
        }, 50);
      }, 10);
    }
    
    // Separated calculation logic to run after cumulative updates
    function performManualRowCalculation(percentInput, row, inputs, percent) {
      // CRITICAL FIX: Determine which category this row belongs to and get correct base value
      let baseValue = 0;
      const isMileage = row.closest('#mileageAdjustmentsList');
      const isOwnership = row.closest('#ownershipAdjustmentsList'); 
      const isOwners = row.closest('#ownersAdjustmentsList');
      const isAdditional = row.closest('#allAdjustmentsList');
      const isGrossFeatures = row.closest('#featuresAdjustmentsList');
      const isGrossRegistration = row.closest('#registrationAdjustmentsList');
      const isFullFeatures = row.closest('#fullFeaturesAdjustmentsList');
      const isFullRegistration = row.closest('#fullRegistrationAdjustmentsList');
      
      if (isMileage) {
        // Mileage manual rows should use cumulative from Features+Registration
        baseValue = getPreviousCategoryCumulative('mileageAdjustmentsList');
        console.log(`ğŸ”§ MILEAGE manual row: Using Features+Registration cumulative base: â‚ª${baseValue.toLocaleString()}`);
      } else if (isOwnership) {
        // Ownership Type manual rows should use cumulative from Mileage
        baseValue = getPreviousCategoryCumulative('ownershipAdjustmentsList');
        console.log(`ğŸ”§ OWNERSHIP TYPE manual row: Using Mileage cumulative base: â‚ª${baseValue.toLocaleString()}`);
      } else if (isOwners) {
        // Ownership History manual rows should use cumulative from Ownership Type
        baseValue = getPreviousCategoryCumulative('ownersAdjustmentsList');
        console.log(`ğŸ”§ OWNERSHIP HISTORY manual row: Using Ownership Type cumulative base: â‚ª${baseValue.toLocaleString()}`);
      } else if (isAdditional) {
        // Additional manual rows should use cumulative from Ownership History
        baseValue = getPreviousCategoryCumulative('allAdjustmentsList');
        console.log(`ğŸ”§ ADDITIONAL manual row: Using Ownership History cumulative base: â‚ª${baseValue.toLocaleString()}`);
      } else if (isGrossFeatures || isGrossRegistration || isFullFeatures || isFullRegistration) {
        // Gross section OR Full Market Features/Registration continue using basicPrice
        baseValue = getBasicPriceFallback();
        const sectionType = (isGrossFeatures || isGrossRegistration) ? 'GROSS' : 'FULL MARKET';
        console.log(`ğŸ”§ ${sectionType} Features/Registration manual row: Using basic price base: â‚ª${baseValue.toLocaleString()}`);
      } else {
        // Default fallback to basicPrice for unknown categories
        baseValue = getBasicPriceFallback();
        console.log(`ğŸ”§ UNKNOWN category manual row: Using basic price fallback: â‚ª${baseValue.toLocaleString()}`);
      }
      
      // If no cumulative found, fallback to basic price
      if (baseValue === 0) {
        baseValue = getBasicPriceFallback();
        console.log(`ğŸ”§ No cumulative found, using basic price fallback: â‚ª${baseValue.toLocaleString()}`);
      }
      
      const calculatedValue = (baseValue * percent) / 100;
      const type = inputs[1].value;
      
      console.log(`ğŸ’° Manual row calculation: ${percent}% Ã— â‚ª${baseValue.toLocaleString()} = â‚ª${Math.round(calculatedValue).toLocaleString()}`);
      
      // Apply sign based on type
      if (type === 'minus' || type === '×”×¤×—×ª×”' || type === '×”×¤×—×ª×” (-)') {
        inputs[3].value = `-â‚ª${Math.round(calculatedValue).toLocaleString()}`;
      } else {
        inputs[3].value = `â‚ª${Math.round(calculatedValue).toLocaleString()}`;
      }
    }
    
    // ============================================================================
    // END OF AUTO-POPULATION FUNCTIONS
    // ============================================================================
    
    // Update helper from adjustments - IMPROVED VERSION with proper save pattern
    function updateHelperFromAdjustments() {
      try {
        console.log('ğŸ”„ updateHelperFromAdjustments called');
        
        const helper = window.helper || {};
        
        // Call the new dedicated save functions for each section
        updateGrossValueToFinalReportAndValuation(helper);
        updateFullMarketValueToFinalReportAndValuation(helper);
        
        // Save to sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper; // Update window.helper too
        
        console.log('âœ… updateHelperFromAdjustments completed - used dedicated save functions');
        
      } catch (error) {
        console.error('âŒ Error in updateHelperFromAdjustments:', error);
      }
    }

    /**
     * Trigger change events on all adjustment fields to ensure formatAdjustmentDisplay runs
     * Critical for minus sign detection on page refresh
     */
    function triggerAllAdjustmentChangeEvents() {
      try {
        console.log('ğŸ”„ Triggering all adjustment change events for proper formatting');
        
        // Find all adjustment containers
        const containers = [
          'grossFeaturesAdjustmentsList',
          'grossRegistrationAdjustmentsList', 
          'fullFeaturesAdjustmentsList',
          'fullRegistrationAdjustmentsList',
          'mileageAdjustmentsList',
          'ownershipAdjustmentsList',
          'ownersAdjustmentsList',
          'allAdjustmentsList'
        ];
        
        containers.forEach(containerId => {
          const container = document.getElementById(containerId);
          if (container) {
            const rows = container.querySelectorAll('div[id*="Adj_"]');
            rows.forEach(row => {
              const inputs = row.querySelectorAll('input, select');
              if (inputs.length >= 4) {
                // Get current values for formatAdjustmentDisplay
                const type = inputs[1].value;
                const percent = parseFloat(inputs[2].value) || 0;
                const amountText = inputs[3].value || '';
                const amount = parseFloat(amountText.replace(/[â‚ª,-]/g, '')) || 0;
                
                // Call formatAdjustmentDisplay directly to ensure proper formatting
                formatAdjustmentDisplay(row, type, percent, amount);
                
                // Also trigger change events
                if (inputs[1]) inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
                if (inputs[2] && inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
                if (inputs[3] && inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
              }
            });
            console.log(`âœ… Triggered change events for ${rows.length} rows in ${containerId}`);
          }
        });
        
        console.log('âœ… Completed triggering all adjustment change events');
        
      } catch (error) {
        console.error('âŒ Error triggering adjustment change events:', error);
      }
    }

    /**
     * Update gross value adjustments to BOTH final_report.adjustments AND valuation.adjustments
     * Based on working pattern from estimator-builder.html
     */
    function updateGrossValueToFinalReportAndValuation(helper) {
      try {
        // Initialize structures
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // 1. FEATURES - Copy EXACT estimator pattern
        const featuresRows = document.querySelectorAll('#featuresAdjustmentsList > div');
        helper.final_report.adjustments.features = [];
        
        featuresRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value),
              source: row.getAttribute('data-source') || 'manual'
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.final_report.adjustments.features.push(adjustmentData);
          }
        });
        
        // Update valuation.adjustments ONLY with ORIGINAL rows (not additional manual rows)
        if (helper.estimate?.adjustments?.features && Array.isArray(helper.estimate.adjustments.features) && helper.estimate.adjustments.features.length > 0) {
          helper.valuation.adjustments.features = helper.estimate.adjustments.features[0];
          console.log('ğŸ’¾ Updated valuation.adjustments.features from estimate (Levi data)');
        } else {
          // Look for ORIGINAL rows only (not manual additions)
          const originalRow = [...featuresRows].find(row => {
            const dataSource = row.getAttribute('data-source');
            return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
          });
          
          if (originalRow) {
            const inputs = originalRow.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              const adjustmentData = {
                value: inputs[0].value || '',
                type: inputs[1].value || 'plus',
                percent: parseFloat(inputs[2].value) || 0,
                percentage: parseFloat(inputs[2].value) || 0,
                amount_display: inputs[3].value || '',
                amount: safeParseAmount(inputs[3].value),
                source: originalRow.getAttribute('data-source') || 'original'
              };
              
              // Apply sign based on type
              if (inputs[1].value === 'minus') {
                adjustmentData.amount = -Math.abs(adjustmentData.amount);
                adjustmentData.percent = -Math.abs(adjustmentData.percent);
                adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
              }
              
              helper.valuation.adjustments.features = adjustmentData;
              console.log('ğŸ’¾ Updated valuation.adjustments.features from ORIGINAL row');
            }
          } else {
            // Only delete if we're certain there's no original data
            if (!helper.valuation?.adjustments?.features?.value && !helper.valuation?.adjustments?.features?.percent) {
              delete helper.valuation.adjustments.features;
              console.log('ğŸ—‘ï¸ Cleared valuation.adjustments.features (no original data)');
            }
          }
        }
        
        // 2. REGISTRATION - Copy EXACT estimator pattern
        const registrationRows = document.querySelectorAll('#registrationAdjustmentsList > div');
        helper.final_report.adjustments.registration = [];
        
        registrationRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value),
              source: row.getAttribute('data-source') || 'manual'
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.final_report.adjustments.registration.push(adjustmentData);
          }
        });
        
        // Update valuation.adjustments ONLY with ORIGINAL rows (not additional manual rows)
        if (helper.estimate?.adjustments?.registration && Array.isArray(helper.estimate.adjustments.registration) && helper.estimate.adjustments.registration.length > 0) {
          helper.valuation.adjustments.registration = helper.estimate.adjustments.registration[0];
          console.log('ğŸ’¾ Updated valuation.adjustments.registration from estimate (Levi data)');
        } else {
          // Look for ORIGINAL rows only (not manual additions)
          const originalRow = [...registrationRows].find(row => {
            const dataSource = row.getAttribute('data-source');
            return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
          });
          
          if (originalRow) {
            const inputs = originalRow.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              const adjustmentData = {
                value: inputs[0].value || '',
                type: inputs[1].value || 'plus',
                percent: parseFloat(inputs[2].value) || 0,
                percentage: parseFloat(inputs[2].value) || 0,
                amount_display: inputs[3].value || '',
                amount: safeParseAmount(inputs[3].value),
                source: originalRow.getAttribute('data-source') || 'original'
              };
              
              // Apply sign based on type
              if (inputs[1].value === 'minus') {
                adjustmentData.amount = -Math.abs(adjustmentData.amount);
                adjustmentData.percent = -Math.abs(adjustmentData.percent);
                adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
              }
              
              helper.valuation.adjustments.registration = adjustmentData;
              console.log('ğŸ’¾ Updated valuation.adjustments.registration from ORIGINAL row');
            }
          } else {
            // Only delete if we're certain there's no original data
            if (!helper.valuation?.adjustments?.registration?.value && !helper.valuation?.adjustments?.registration?.percent) {
              delete helper.valuation.adjustments.registration;
              console.log('ğŸ—‘ï¸ Cleared valuation.adjustments.registration (no original data)');
            }
          }
        }
        
        console.log('âœ… Updated gross value adjustments to BOTH final_report.adjustments AND valuation.adjustments');
        
        // DISABLED: Auto-populate that clears Total Value manual additions
        // if (helper.final_report.adjustments.features) {
        //   syncFullMarketFeaturesWithGross(helper.final_report.adjustments.features);
        // }
        // if (helper.final_report.adjustments.registration) {
        //   syncFullMarketRegistrationWithGross(helper.final_report.adjustments.registration);
        // }
        
      } catch (error) {
        console.error('âŒ Error updating gross value to final_report and valuation adjustments:', error);
      }
    }

    /**
     * Update FULL MARKET VALUE categories to BOTH final_report.adjustments AND valuation.adjustments
     * Based on working pattern from estimator-builder.html
     */
    function updateFullMarketValueToFinalReportAndValuation(helper) {
      try {
        // CRITICAL FIX: Skip during page load to prevent overriding saved dropdown states
        if (window.pageLoadInProgress) {
          console.log('â¸ï¸ Skipping updateFullMarketValueToFinalReportAndValuation during page load to preserve saved types');
          return;
        }
        
        // Initialize structures
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // 1. FEATURES - Only sync ORIGINAL rows to valuation (not additional manual rows)
        const fullFeaturesRows = document.querySelectorAll('#fullFeaturesAdjustmentsList > div');
        const originalFeatureRow = [...fullFeaturesRows].find(row => {
          const dataSource = row.getAttribute('data-source');
          return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
        });
        
        if (originalFeatureRow) {
          const inputs = originalFeatureRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            helper.valuation.adjustments.features = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value)
            };
            console.log('ğŸ’¾ Updated valuation.adjustments.features from ORIGINAL Total Market Value row');
          }
        }
        
        // 2. REGISTRATION - Only sync ORIGINAL rows to valuation (not additional manual rows)
        const fullRegistrationRows = document.querySelectorAll('#fullRegistrationAdjustmentsList > div');
        const originalRegistrationRow = [...fullRegistrationRows].find(row => {
          const dataSource = row.getAttribute('data-source');
          return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
        });
        
        if (originalRegistrationRow) {
          const inputs = originalRegistrationRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            helper.valuation.adjustments.registration = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value)
            };
            console.log('ğŸ’¾ Updated valuation.adjustments.registration from ORIGINAL Total Market Value row');
          }
        }
        
        // 3. MILEAGE (KM) - Save ALL rows to final_report, ONLY ORIGINAL rows to valuation
        const mileageRows = document.querySelectorAll('#mileageAdjustmentsList > div');
        helper.final_report.adjustments.mileage = [];
        
        // Save ALL mileage rows to final_report.adjustments
        mileageRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value),
              source: row.getAttribute('data-source') || 'manual'
            };
            
            // Apply sign based on type - CRITICAL FOR MINUS VALUES
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.final_report.adjustments.mileage.push(adjustmentData);
          }
        });
        
        // Save ONLY ORIGINAL row to valuation.adjustments
        const originalMileageRow = [...mileageRows].find(row => {
          const dataSource = row.getAttribute('data-source');
          return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
        });
        
        if (originalMileageRow) {
          const inputs = originalMileageRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value)
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.valuation.adjustments.mileage = adjustmentData;
            console.log('ğŸ’¾ Updated valuation.adjustments.mileage from ORIGINAL row');
          }
        }
        
        // 4. OWNERSHIP TYPE - Save ALL rows to final_report, ONLY ORIGINAL rows to valuation
        const ownershipRows = document.querySelectorAll('#ownershipAdjustmentsList > div');
        helper.final_report.adjustments.ownership_type = [];
        
        // Save ALL ownership rows to final_report.adjustments
        ownershipRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value),
              source: row.getAttribute('data-source') || 'manual'
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.final_report.adjustments.ownership_type.push(adjustmentData);
          }
        });
        
        // Save ONLY ORIGINAL row to valuation.adjustments
        const originalOwnershipRow = [...ownershipRows].find(row => {
          const dataSource = row.getAttribute('data-source');
          return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
        });
        
        if (originalOwnershipRow) {
          const inputs = originalOwnershipRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value)
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.valuation.adjustments.ownership_type = adjustmentData;
            console.log('ğŸ’¾ Updated valuation.adjustments.ownership_type from ORIGINAL row');
          }
        }
        
        // 5. OWNERSHIP HISTORY - Save ALL rows to final_report, ONLY ORIGINAL rows to valuation
        const ownersRows = document.querySelectorAll('#ownersAdjustmentsList > div');
        helper.final_report.adjustments.ownership_history = [];
        
        // DEBUG: Log when this function clears and rebuilds ownership_history
        console.log(`ğŸš¨ updateFullMarketValueToFinalReportAndValuation CLEARING ownership_history and rebuilding from UI`, {
          pageLoadInProgress: window.pageLoadInProgress,
          ownersRowsCount: ownersRows.length
        });
        
        // Save ALL ownership history rows to final_report.adjustments
        ownersRows.forEach((row, index) => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            // DEBUG: Log what type is being read from dropdown
            console.log(`ğŸ” REBUILDING owners[${index}] type from dropdown: ${inputs[1].value}`, {
              dropdown: inputs[1],
              selectedValue: inputs[1].value,
              selectedIndex: inputs[1].selectedIndex,
              options: Array.from(inputs[1].options).map(o => ({value: o.value, selected: o.selected}))
            });
            
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value),
              source: row.getAttribute('data-source') || 'manual'
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.final_report.adjustments.ownership_history.push(adjustmentData);
          }
        });
        
        // Save ONLY ORIGINAL row to valuation.adjustments
        const originalOwnersRow = [...ownersRows].find(row => {
          const dataSource = row.getAttribute('data-source');
          return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
        });
        
        if (originalOwnersRow) {
          const inputs = originalOwnersRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value)
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.valuation.adjustments.ownership_history = adjustmentData;
            console.log('ğŸ’¾ Updated valuation.adjustments.ownership_history from ORIGINAL row');
          }
        }
        
        // 6. ADDITIONAL - Only in Full Market Value
        const additionalRows = document.querySelectorAll('#allAdjustmentsList > div');
        if (additionalRows.length > 0) {
          helper.final_report.adjustments.additional = [];
          additionalRows.forEach(row => {
            const inputs = row.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              const adjustmentData = {
                value: inputs[0].value || '',
                type: inputs[1].value || 'plus',
                percent: parseFloat(inputs[2].value) || 0,
                percentage: parseFloat(inputs[2].value) || 0,
                amount_display: inputs[3].value || '',
                amount: safeParseAmount(inputs[3].value),
                source: row.getAttribute('data-source') || 'manual'
              };
              
              // Apply sign based on type - CRITICAL FOR MINUS VALUES
              if (inputs[1].value === 'minus') {
                adjustmentData.amount = -Math.abs(adjustmentData.amount);
                adjustmentData.percent = -Math.abs(adjustmentData.percent);
                adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
              }
              
              helper.final_report.adjustments.additional.push(adjustmentData);
            }
          });
          
          // CRITICAL: DO NOT write additional categories to valuation.adjustments
          // Additional adjustments should ONLY exist in final_report.adjustments
        } else {
          helper.final_report.adjustments.additional = [];
          // Don't touch valuation.adjustments for additional categories
        }
        
        console.log('âœ… Updated full market value adjustments to BOTH final_report.adjustments AND valuation.adjustments');
        
      } catch (error) {
        console.error('âŒ Error updating full market value to final_report and valuation adjustments:', error);
      }
    }
    
    /**
     * Sync Full Market Value Registration with Gross Value Section
     * CRITICAL for Issue 5: Data Sync Between Sections
     */
    function syncFullMarketRegistrationWithGross(grossRegistrations) {
      try {
        const container = document.getElementById('fullRegistrationAdjustmentsList');
        if (!container || !grossRegistrations || grossRegistrations.length === 0) return;
        
        // Clear existing Full Market registration
        container.innerHTML = '';
        
        // Add each gross registration to Full Market section
        grossRegistrations.forEach(registration => {
          addFullMarketRegistrationAdjustment();
          const lastRow = container.querySelector('div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              inputs[0].value = registration.value || '';
              inputs[1].value = registration.type || 'plus';
              
              // CRITICAL FIX: Display minus sign for negative values
              const displayPercent = isReductionType(registration.type) && registration.percent > 0 ? 
                `-${Math.abs(registration.percent)}` : Math.abs(registration.percent || 0);
              const displayAmount = isReductionType(registration.type) && registration.amount > 0 ? 
                `-${Math.abs(registration.amount)}` : Math.abs(registration.amount || 0);
              
              inputs[2].value = displayPercent || '';
              inputs[3].value = registration.amount_display || (registration.amount ? `â‚ª${displayAmount.toLocaleString()}` : '');
              lastRow.setAttribute('data-source', registration.source || 'gross_sync');
            }
          }
        });
        
        console.log('âœ… Synced Full Market Registration with Gross Value section');
        
      } catch (error) {
        console.error('âŒ Error syncing Full Market Registration with Gross Value:', error);
      }
    }

    /**
     * Sync Full Market Value Features with Gross Value Section
     * CRITICAL for Issue 5: Data Sync Between Sections
     */
    function syncFullMarketFeaturesWithGross(grossFeatures) {
      try {
        const container = document.getElementById('fullFeaturesAdjustmentsList');
        if (!container || !grossFeatures || grossFeatures.length === 0) return;
        
        // Clear existing Full Market features
        container.innerHTML = '';
        
        // Add each gross feature to Full Market section
        grossFeatures.forEach(feature => {
          addFullMarketFeatureAdjustment();
          const lastRow = container.querySelector('div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              inputs[0].value = feature.value || '';
              inputs[1].value = feature.type || 'plus';
              
              // CRITICAL FIX: Display minus sign for negative values
              const displayPercent = isReductionType(feature.type) && feature.percent > 0 ? 
                `-${Math.abs(feature.percent)}` : Math.abs(feature.percent || 0);
              const displayAmount = isReductionType(feature.type) && feature.amount > 0 ? 
                `-${Math.abs(feature.amount)}` : Math.abs(feature.amount || 0);
              
              inputs[2].value = displayPercent || '';
              inputs[3].value = feature.amount_display || (feature.amount ? `â‚ª${displayAmount.toLocaleString()}` : '');
              lastRow.setAttribute('data-source', feature.source || 'gross_sync');
            }
          }
        });
        
        console.log('âœ… Synced Full Market features with Gross Value section');
        
      } catch (error) {
        console.error('âŒ Error syncing Full Market features:', error);
      }
    }

    /**
     * Sync Full Market Value Registration with Gross Value Section
     * CRITICAL for Issue 5: Data Sync Between Sections
     */
    function syncFullMarketRegistrationWithGross(grossRegistration) {
      try {
        const container = document.getElementById('fullRegistrationAdjustmentsList');
        if (!container || !grossRegistration || grossRegistration.length === 0) return;
        
        // Clear existing Full Market registration
        container.innerHTML = '';
        
        // Add each gross registration to Full Market section
        grossRegistration.forEach(registration => {
          addFullMarketRegistrationAdjustment();
          const lastRow = container.querySelector('div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              inputs[0].value = registration.value || '';
              inputs[1].value = registration.type || 'plus';
              
              // CRITICAL FIX: Display minus sign for negative values
              const displayPercent = isReductionType(registration.type) && registration.percent > 0 ? 
                `-${Math.abs(registration.percent)}` : Math.abs(registration.percent || 0);
              const displayAmount = isReductionType(registration.type) && registration.amount > 0 ? 
                `-${Math.abs(registration.amount)}` : Math.abs(registration.amount || 0);
              
              inputs[2].value = displayPercent || '';
              inputs[3].value = registration.amount_display || (registration.amount ? `â‚ª${displayAmount.toLocaleString()}` : '');
              lastRow.setAttribute('data-source', registration.source || 'gross_sync');
            }
          }
        });
        
        console.log('âœ… Synced Full Market registration with Gross Value section');
        
      } catch (error) {
        console.error('âŒ Error syncing Full Market registration:', error);
      }
    }

    /**
     * Add Full Market Feature Adjustment (for sync with Gross Value)
     */
    function addFullMarketFeatureAdjustment() {
      const container = document.getElementById('fullFeaturesAdjustmentsList');
      const rowId = 'fullFeatureAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
          <div><input type="text" placeholder="×ª×™××•×¨ ×”×××¤×™×™×Ÿ" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features');" /></div>
          <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features');">
            <option value="plus">×ª×•×¡×¤×ª (+)</option>
            <option value="minus">×”×¤×—×ª×” (-)</option>
          </select></div>
          <div><input type="text" placeholder="××—×•×–" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features');" /></div>
          <div><input type="text" placeholder="â‚ª" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features');" /></div>
          <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">××—×§</button></div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
    }

    /**
     * Add Full Market Registration Adjustment (for sync with Gross Value)
     */
    function addFullMarketRegistrationAdjustment() {
      const container = document.getElementById('fullRegistrationAdjustmentsList');
      const rowId = 'fullRegAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
          <div><input type="text" placeholder="×ª×™××•×¨ ×¢×œ×™×” ×œ×›×‘×™×©" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');" /></div>
          <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');">
            <option value="plus">×ª×•×¡×¤×ª (+)</option>
            <option value="minus">×”×¤×—×ª×” (-)</option>
          </select></div>
          <div><input type="text" placeholder="××—×•×–" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');" /></div>
          <div><input type="text" placeholder="â‚ª" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');" /></div>
          <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">××—×§</button></div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
    }

    // NOTE: Duplicate function removed - using the updated version with dedicated save functions
    
    /**
     * Listen for helper updates to trigger re-population when Levi data changes
     */
    let lastLeviDataHash = null;
    function setupLeviDataListener() {
      // Calculate initial Levi data hash to detect real changes
      function getLeviDataHash(helperData) {
        if (!helperData) return null;
        const leviData = {
          summary: helperData.levisummary,
          report: helperData.levi_report
        };
        return JSON.stringify(leviData);
      }
      
      // Set initial hash
      lastLeviDataHash = getLeviDataHash(helper);
      
      // Listen for storage events (when helper data changes)
      window.addEventListener('storage', (event) => {
        if (event.key === 'helper' && event.newValue) {
          try {
            const newHelper = JSON.parse(event.newValue);
            const newLeviDataHash = getLeviDataHash(newHelper);
            
            // Only clear and re-populate if Levi data actually changed
            if (newLeviDataHash !== lastLeviDataHash && (newHelper.levisummary || newHelper.levi_report)) {
              console.log('ğŸ“¡ Detected Levi data update, re-populating adjustments...');
              lastLeviDataHash = newLeviDataHash;
              clearLeviAdjustments();
              helper = newHelper; // Update global helper
              autoPopulateFromLeviSummary();
            } else {
              // Just update the helper reference without clearing user input
              helper = newHelper;
            }
          } catch (error) {
            console.error('âŒ Error processing helper update:', error);
          }
        }
      });
      
      // Also listen for custom events
      document.addEventListener('helperUpdate', (event) => {
        if (event.detail && (event.detail.section === 'levisummary' || event.detail.section === 'levi_report')) {
          console.log('ğŸ“¡ Detected Levi data event, re-populating adjustments...');
          clearLeviAdjustments();
          autoPopulateFromLeviSummary();
        }
      });
      
      console.log('ğŸ“¡ Levi data listener setup completed');
    }
    
    // Calculate adjustment value from percentage - ENHANCED
    function calculateAdjustmentValue(percentInput) {
      const row = percentInput.closest('div[id^="featureAdj_"], div[id^="regAdj_"]');
      if (!row) {
        console.warn('âš ï¸ Cannot find adjustment row for calculation');
        return;
      }
      
      const percent = parseFloat(percentInput.value.replace('%', '')) || 0;
      let basicPrice = parseFloat(document.getElementById('basicPrice')?.value.replace(/[â‚ª,]/g, '')) || 0;
      
      // Try alternative price sources if basicPrice is empty
      if (basicPrice === 0) {
        // Try grossMarketValue first (from calculations)
        const grossMarketValue = parseFloat(document.getElementById('grossMarketValue')?.value.replace(/[â‚ª,]/g, '')) || 0;
        if (grossMarketValue > 0) {
          basicPrice = grossMarketValue;
          console.log('ğŸ“Š Using grossMarketValue for calculation:', basicPrice);
        }
      }
      
      // If still no price, try to get BASE PRICE from helper
      if (basicPrice === 0) {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        if (helper.levi_report?.base_price) {
          basicPrice = parseFloat(helper.levi_report.base_price);
        } else if (helper.expertise?.levi_report?.base_price) {
          basicPrice = parseFloat(helper.expertise.levi_report.base_price);
        } else if (helper.levisummary?.base_price) {
          basicPrice = parseFloat(helper.levisummary.base_price);
        } else if (helper.car_details?.base_price) {
          basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[â‚ª,]/g, ''));
        } else {
          // REMOVED market_value fallback - we need BASE price only for calculations
          console.warn('âš ï¸ No Levi BASE PRICE found for adjustment calculation');
        }
        
        // If we found a basic price, update the field
        if (basicPrice > 0) {
          const basicPriceField = document.getElementById('basicPrice');
          if (basicPriceField) {
            basicPriceField.value = `â‚ª${basicPrice.toLocaleString()}`;
          }
        }
      }
      
      const valueInput = row.querySelector('input[placeholder="â‚ª"]');
      
      if (!valueInput) {
        console.error('âš ï¸ Cannot find value input field in adjustment row');
        return;
      }
      
      if (basicPrice > 0 && percent !== 0) {
        const calculatedValue = (basicPrice * percent) / 100;
        valueInput.value = `â‚ª${Math.round(calculatedValue).toLocaleString()}`;
        console.log(`ğŸ’° Calculated adjustment value: ${percent}% Ã— â‚ª${basicPrice.toLocaleString()} = â‚ª${Math.round(calculatedValue).toLocaleString()}`);
        
        // Trigger change event to update other calculations
        valueInput.dispatchEvent(new Event('change', { bubbles: true }));
      } else {
        console.warn(`âš ï¸ Cannot calculate adjustment value - basicPrice: ${basicPrice}, percent: ${percent}`);
        if (basicPrice === 0) {
          console.warn('âš ï¸ No car price found. Please set the basic price first.');
        }
      }
    }
    
    // SIMPLE ADJUSTMENT CALCULATION - COPIED FROM WORKING DEPRECIATION
    // Duplicate function - removing to avoid conflicts
    // (Already defined above with proper implementation)

    // SIMPLE FINAL REPORTADJUSTMENT CALCULATION - COPIED FROM WORKING DEPRECIATION
    function calculateFinalReportAdjustmentValueSimple(percentInput) {
      const percent = parseFloat(percentInput.value) || 0;
      const row = percentInput.closest('div');
      
      if (!row) return;
      
      // Get helper data like the working depreciation does
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const marketValue = parseFloat(helper.expertise?.levi_report?.final_price) || 0;
      
      // Calculate value exactly like working depreciation
      const calculatedValue = Math.round((marketValue * percent) / 100);
      
      // Find value input (third input in row)
      const inputs = row.querySelectorAll('input');
      if (inputs.length > 2) {
        const valueInput = inputs[2];
        valueInput.value = calculatedValue || '';
      }
    }

    // Test function to manually add adjustment data for debugging
    function addTestAdjustments() {
      console.log('ğŸ§ª Adding test adjustments for debugging');
      
      // Add test features adjustment
      addFeatureAdjustment();
      const featuresContainer = document.getElementById('featuresAdjustmentsList');
      const lastFeaturesRow = featuresContainer.querySelector('div:last-child');
      if (lastFeaturesRow) {
        const inputs = lastFeaturesRow.querySelectorAll('input[type="text"]');
        inputs[0].value = '×××¤×™×™×Ÿ ×‘×“×™×§×”';
        inputs[1].value = '5%';
        inputs[2].value = 'â‚ª1000';
        lastFeaturesRow.querySelector('select').value = 'plus';
      }
      
      // Add test registration adjustment
      addRegistrationAdjustment();
      const registrationContainer = document.getElementById('registrationAdjustmentsList');
      const lastRegistrationRow = registrationContainer.querySelector('div:last-child');
      if (lastRegistrationRow) {
        const inputs = lastRegistrationRow.querySelectorAll('input[type="text"]');
        inputs[0].value = '×¢×œ×™×” ×œ×›×‘×™×© ×‘×“×™×§×”';
        inputs[1].value = '10%';
        inputs[2].value = 'â‚ª2000';
        lastRegistrationRow.querySelector('select').value = 'plus';
      }
      
      // Trigger the update
      updateHelperFromAdjustments();
    }
    
    // Expose test function globally
    window.addTestAdjustments = addTestAdjustments;
    
    // CRITICAL FIX: Add function to completely reset adjustment data
    function resetAdjustmentData() {
      console.log('ğŸ§¹ RESET: Completely clearing all adjustment data');
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Clear all adjustment data
      if (helper.levi_report) {
        helper.levi_report.adjustments = [];
      }
      if (helper.levi) {
        helper.levi.custom_adjustments = [];
      }
      
      // Clear DOM
      // Final report adjustments container was removed - no action needed
      
      // Save cleaned helper
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      console.log('âœ… RESET: All adjustment data cleared');
    }
    
    // Expose reset function globally for testing
    window.resetAdjustmentData = resetAdjustmentData;
    
    
    // Calculate and update GROSS PRICE (car properties only: base + features + registration)
    function updateGrossMarketValueCalculation() {
      try {
        // Get base price from the visible field that shows â‚ª118,000
        let basicPrice = 0;
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Priority 1: Direct from the basicPrice field that shows â‚ª118,000
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField?.value) {
          basicPrice = parseFloat(basicPriceField.value.replace(/[â‚ª,]/g, '')) || 0;
          console.log('ğŸ” Using basicPrice field:', basicPrice);
        }
        // Priority 2: Try the visible field in the ×¢×¨×š ×”×¨×›×‘ ×¢"×¤ ××—×™×¨×•×Ÿ section
        else {
          const allInputs = document.querySelectorAll('input[type="text"]');
          for (let input of allInputs) {
            const numericValue = parseFloat(input.value.replace(/[â‚ª,]/g, ''));
            if (numericValue > 0) {
              basicPrice = numericValue;
              console.log('ğŸ” Found price in field:', input.id || 'unknown', 'value:', basicPrice);
              break;
            }
          }
        }
        
        // Fallback: Use helper base price or market value if available, otherwise 0
        if (basicPrice === 0) {
          basicPrice = helper.calculations?.base_market_value || helper.levisummary?.base_price || helper.valuation?.base_price || 0;
          console.log('ğŸ” FALLBACK: Using helper base price:', basicPrice);
        }
        
        console.log('ğŸ” DEBUG: Final basic price for calculation:', basicPrice);
        
        // Collect features adjustments (car properties)
        const featuresAdjustments = [];
        const featuresRows = document.querySelectorAll('#featuresAdjustmentsList > div');
        featuresRows.forEach(row => {
          const type = row.querySelector('select').value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const description = inputs[0]?.value || '';
          const percent = parseFloat(inputs[1]?.value) || 0;
          const rawValue = parseFloat(inputs[2]?.value.replace(/[â‚ª,]/g, '')) || 0;
          // SIMPLE FIX: Treat values exactly as they are - if minus then minus, if without then positive
          const hasMinusSign = inputs[2]?.value.includes('-');
          const signedValue = (type === 'minus' || hasMinusSign) ? -Math.abs(rawValue) : Math.abs(rawValue);

          if (signedValue !== 0) {
            featuresAdjustments.push({
              description,
              type,
              percent,
              value: signedValue,
              category: 'features'
            });
          }
        });
        
        // Collect registration adjustments (car properties)
        const registrationAdjustments = [];
        const registrationRows = document.querySelectorAll('#registrationAdjustmentsList > div');
        registrationRows.forEach(row => {
          const type = row.querySelector('select').value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const description = inputs[0]?.value || '';
          const percent = parseFloat(inputs[1]?.value) || 0;
          const rawValue = parseFloat(inputs[2]?.value.replace(/[â‚ª,]/g, '')) || 0;
          // SIMPLE FIX: Treat values exactly as they are - if minus then minus, if without then positive
          const hasMinusSign = inputs[2]?.value.includes('-');
          const signedValue = (type === 'minus' || hasMinusSign) ? -Math.abs(rawValue) : Math.abs(rawValue);

          if (signedValue !== 0) {
            registrationAdjustments.push({
              description,
              type,
              percent,
              value: signedValue,
              category: 'registration'
            });
          }
        });
        
        // USE EXACT SAME LOGIC AS WORKING updateFullMarketValueCalculation
        let currentValue = basicPrice;
        
        // Process features section - CORRECTED CALCULATION LOGIC
        const grossFeaturesRows = document.querySelectorAll('#featuresAdjustmentsList > div');
        grossFeaturesRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            // FIXED: Parse amount preserving sign, then apply dropdown type logic
            const amountText = (inputs[3].value || '').trim();
            let amount = parseFloat(amountText.replace(/[â‚ª,\s]/g, '')) || 0;
            const type = inputs[1].value;
            
            // Apply type logic: if type is minus and amount is positive, make negative
            // If type is plus and amount is negative, use absolute value
            if (isReductionType(type) && amount > 0) {
              amount = -amount;
            } else if (!isReductionType(type) && amount < 0) {
              amount = Math.abs(amount);
            }
            
            currentValue += amount;
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `â‚ª${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update features cumulative
        const grossFeaturesCumulativeEl = document.getElementById('grossFeaturesCumulative');
        if (grossFeaturesCumulativeEl) {
          const span = grossFeaturesCumulativeEl.querySelector('span');
          if (span) {
            span.textContent = `â‚ª${Math.round(currentValue).toLocaleString()}`;
            span.style.color = currentValue >= basicPrice ? '#28a745' : '#dc3545';
          }
        }
        
        // Save features cumulative value
        const featuresCumulativeValue = Math.round(currentValue);
        saveAdjustmentCumulativeOnly('features', featuresCumulativeValue);
        
        // Process registration section - Add fixed values to cumulative
        const grossRegistrationRows = document.querySelectorAll('#registrationAdjustmentsList > div');
        grossRegistrationRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const type = inputs[1]?.value || 'plus';
            const valueInput = inputs[3]; // ×¢×¨×š field
            if (valueInput && valueInput.value) {
              const value = parseFloat(valueInput.value.replace(/[â‚ª,\s-]/g, '')) || 0;
              const signedValue = isReductionType(type) ? -value : value;
              currentValue += signedValue;
            }
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `â‚ª${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update registration cumulative
        const grossRegistrationCumulativeEl = document.getElementById('grossRegistrationCumulative');
        if (grossRegistrationCumulativeEl) {
          const span = grossRegistrationCumulativeEl.querySelector('span');
          if (span) {
            span.textContent = `â‚ª${Math.round(currentValue).toLocaleString()}`;
            span.style.color = currentValue >= basicPrice ? '#28a745' : '#dc3545';
          }
        }
        
        // Save registration cumulative value
        const registrationCumulativeValue = Math.round(currentValue);
        saveAdjustmentCumulativeOnly('registration', registrationCumulativeValue);
        
        // Update result field
        const resultField = document.getElementById('grossMarketValueResult');
        if (resultField) {
          resultField.value = `â‚ª${Math.round(currentValue).toLocaleString()}`;
        }
        
        const grossPrice = currentValue;
        
        console.log(`ğŸ  GROSS PRICE CALCULATION: Base â‚ª${basicPrice.toLocaleString()} â†’ Final â‚ª${grossPrice.toLocaleString()}`);
        console.log('âœ… Corrected calculation: Base + (Base Ã— Features%) + Registration = Final');
        console.log('ğŸ“‹ Features adjustments:', featuresAdjustments);
        console.log('ğŸ“‹ Registration adjustments:', registrationAdjustments);
        
        // Save to helper.calculations.vehicle_value_gross
        if (!helper.calculations) helper.calculations = {};
        helper.calculations.vehicle_value_gross = grossPrice;
        
        // PHASE 6: Add totals structure to final_report.adjustments
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) helper.final_report.adjustments = {};
        if (!helper.final_report.adjustments.totals) {
          helper.final_report.adjustments.totals = {};
        }
        
        // Calculate and save features total
        let featuresTotalValue = 0;
        let featuresTotalPercent = 0;
        featuresAdjustments.forEach(adj => {
          featuresTotalValue += adj.value;
          if (adj.percent) {
            featuresTotalPercent += (adj.type === 'minus' ? -adj.percent : adj.percent);
          }
        });
        
        // Calculate and save registration total
        let registrationTotalValue = 0;
        let registrationTotalPercent = 0;
        registrationAdjustments.forEach(adj => {
          registrationTotalValue += adj.value;
          if (adj.percent) {
            registrationTotalPercent += (adj.type === 'minus' ? -adj.percent : adj.percent);
          }
        });
        
        // Save totals
        helper.final_report.adjustments.totals.features = {
          value: featuresTotalValue,
          percent: featuresTotalPercent,
          count: featuresAdjustments.length
        };
        
        helper.final_report.adjustments.totals.registration = {
          value: registrationTotalValue,
          percent: registrationTotalPercent,
          count: registrationAdjustments.length
        };
        
        helper.final_report.adjustments.totals.gross_total = {
          value: featuresTotalValue + registrationTotalValue,
          percent: featuresTotalPercent + registrationTotalPercent,
          final_value: grossPrice
        };
        
        // Update helper in window and session storage
        window.helper = helper;
        if (typeof updateHelper === 'function') {
          updateHelper('calculations', helper.calculations);
          updateHelper('final_report', helper.final_report);
        }
        // Calculate and restore adjustments_value
        if (typeof window.calculateValuationAdjustments === 'function') {
          window.calculateValuationAdjustments();
        }
        
        if (typeof saveHelperToStorage === 'function') {
          saveHelperToStorage();
        }
        
        console.log('âœ… Saved gross value to helper.calculations.vehicle_value_gross:', grossPrice);
        
        // Update bridge fields in helper.calculations for consistency (base_price only)
        const rawBasePrice = helper.valuation?.base_price || 
                             helper.car_details?.base_price || 
                             helper.levi_report?.base_price || 0;
        const originalBasePrice = parseFloat(String(rawBasePrice).replace(/[â‚ª,]/g, '')) || 0;
        helper.calculations.base_price = originalBasePrice;
        // Note: final_adjustments_value should only be updated by the final market value calculation
        
        // Update gross percentage calculation immediately
        setTimeout(() => {
          updateGrossPercentageFromGrossValue();
        }, 100);
        
        // Sync cumulative values to ensure they persist
        setTimeout(() => {
          syncGrossCumulativeValues();
        }, 200);
        
      } catch (error) {
        console.error('Error calculating gross price:', error);
      }
    }
    
    // Load data from helper for gross calculation
    function loadGrossCalculationData() {
      try {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Load basic price from multiple sources
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField) {
          let basicPrice = 0;
          
          // Priority 1: Check carBasePrice field first
          const carBasePriceField = document.getElementById('carBasePrice');
          if (carBasePriceField && carBasePriceField.value) {
            const carBasePriceStr = carBasePriceField.value.replace(/[â‚ª,]/g, '') || '0';
            basicPrice = parseFloat(carBasePriceStr) || 0;
          }
          
          // Priority 2: Try helper data sources if field is empty
          if (basicPrice === 0) {
            if (helper.valuation?.base_price) {
              basicPrice = parseFloat(helper.valuation.base_price.toString().replace(/[â‚ª,]/g, ''));
            } else if (helper.levi_report?.base_price) {
              basicPrice = parseFloat(helper.levi_report.base_price);
            } else if (helper.expertise?.levi_report?.base_price) {
              basicPrice = parseFloat(helper.expertise.levi_report.base_price);
            } else if (helper.levisummary?.base_price) {
              basicPrice = parseFloat(helper.levisummary.base_price);
            } else if (helper.car_details?.base_price) {
              basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[â‚ª,]/g, ''));
            }
          }
          
          if (basicPrice > 0) {
            basicPriceField.value = `â‚ª${basicPrice.toLocaleString()}`;
          }
        }
        
        // DON'T clear containers or load Levi data here - loadGrossAdjustments() already handles that
        // This function now only handles manual entries to avoid duplication
        
        // Skip Levi data loading - already handled by loadGrossAdjustments()
        // Jump directly to manual entries
        if (featuresData && (featuresData.percent || featuresData.percentage || featuresData.amount)) {
          let percent = 0;
          if (featuresData.percent) {
            const percentStr = String(featuresData.percent).replace(/[%\s]/g, '');
            percent = parseFloat(percentStr) || 0;
          } else if (featuresData.percentage) {
            const percentStr = String(featuresData.percentage).replace(/[%\s]/g, '');
            percent = parseFloat(percentStr) || 0;
          }
          
          let amount = 0;
          if (featuresData.amount) {
            const amountStr = String(featuresData.amount).replace(/[â‚ª,\s×©]/g, '');
            amount = parseFloat(amountStr) || 0;
          }
          
          const description = featuresData.value || featuresData.description || '×ª×•×¡×¤×•×ª ×××¤×™×™× ×™×';
          const isReduction = percent < 0 || amount < 0;
          
          addFeatureAdjustment();
          const lastRow = document.querySelector('#featuresAdjustmentsList > div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input[type="text"]');
            inputs[0].value = description;
            lastRow.querySelector('select').value = isReduction ? 'minus' : 'plus';
            
            // CRITICAL FIX: Display minus sign for negative values
            const displayPercent = isReduction ? `-${Math.abs(percent)}` : Math.abs(percent);
            const displayAmount = isReduction ? `-${Math.abs(amount)}` : Math.abs(amount);
            
            inputs[1].value = percent ? `${displayPercent}%` : '';
            inputs[2].value = amount ? `â‚ª${displayAmount.toLocaleString()}` : '';
          }
        }
        
        // Load registration adjustments using EXACT working logic
        const registrationData = adjustments['registration'];
        if (registrationData && (registrationData.percent || registrationData.percentage || registrationData.amount)) {
          let percent = 0;
          if (registrationData.percent) {
            const percentStr = String(registrationData.percent).replace(/[%\s]/g, '');
            percent = parseFloat(percentStr) || 0;
          } else if (registrationData.percentage) {
            const percentStr = String(registrationData.percentage).replace(/[%\s]/g, '');
            percent = parseFloat(percentStr) || 0;
          }
          
          let amount = 0;
          if (registrationData.amount) {
            const amountStr = String(registrationData.amount).replace(/[â‚ª,\s×©]/g, '');
            amount = parseFloat(amountStr) || 0;
          }
          
          const description = registrationData.value || registrationData.description || '×¢×œ×™×” ×œ×›×‘×™×©';
          const isReduction = percent < 0 || amount < 0;
          
          addRegistrationAdjustment();
          const lastRow = document.querySelector('#registrationAdjustmentsList > div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input[type="text"]');
            inputs[0].value = description;
            lastRow.querySelector('select').value = isReduction ? 'minus' : 'plus';
            
            // CRITICAL FIX: Display minus sign for negative values
            const displayPercent = isReduction ? `-${Math.abs(percent)}` : Math.abs(percent);
            const displayAmount = isReduction ? `-${Math.abs(amount)}` : Math.abs(amount);
            
            inputs[1].value = percent ? `${displayPercent}%` : '';
            inputs[2].value = amount ? `â‚ª${displayAmount.toLocaleString()}` : '';
          }
        }
        
        // Also check for direct registration fields in levi_report (structured data)
        if (helper.expertise?.levi_report?.adjustments?.registration) {
          const regAdj = helper.expertise.levi_report.adjustments.registration;
          const registrationValue = parseFloat(regAdj.value || regAdj.total || 0);
          
          if (registrationValue !== 0) {
            console.log('ğŸ”§ Loading registration from expertise.levi_report.adjustments:', regAdj);
            addRegistrationAdjustment();
            const lastRow = document.querySelector('#registrationAdjustmentsList > div:last-child');
            if (lastRow) {
              lastRow.querySelector('input[type="text"]:first-of-type').value = '×¢×œ×™×” ×œ×›×‘×™×©';
              lastRow.querySelector('select').value = registrationValue >= 0 ? 'plus' : 'minus';
              // CRITICAL FIX: Display minus sign for negative values
              const displayRegValue = registrationValue >= 0 ? Math.abs(registrationValue) : `-${Math.abs(registrationValue)}`;
              lastRow.querySelector('input[type="text"]:last-of-type').value = `â‚ª${displayRegValue.toLocaleString()}`;
            }
          }
        }
        
        // Also check for features in structured data
        if (helper.expertise?.levi_report?.adjustments?.features) {
          const featAdj = helper.expertise.levi_report.adjustments.features;
          const featuresValue = parseFloat(featAdj.value || featAdj.total || 0);
          
          if (featuresValue !== 0) {
            console.log('ğŸ”§ Loading features from expertise.levi_report.adjustments:', featAdj);
            addFeatureAdjustment();
            const lastRow = document.querySelector('#featuresAdjustmentsList > div:last-child');
            if (lastRow) {
              lastRow.querySelector('input[type="text"]:first-of-type').value = '×××¤×™×™× ×™×';
              lastRow.querySelector('select').value = featuresValue >= 0 ? 'plus' : 'minus';
              // CRITICAL FIX: Display minus sign for negative values
              const displayFeatValue = featuresValue >= 0 ? Math.abs(featuresValue) : `-${Math.abs(featuresValue)}`;
              lastRow.querySelector('input[type="text"]:last-of-type').value = `â‚ª${displayFeatValue.toLocaleString()}`;
            }
          }
        }
        
        // Check for additional adjustments from levisummary (backup structure) - Handle object or array
        if (helper.levisummary?.adjustments) {
          const adjustments = Array.isArray(helper.levisummary.adjustments) ? helper.levisummary.adjustments : Object.values(helper.levisummary.adjustments);
          adjustments.forEach(adj => {
            const desc = adj.description?.toLowerCase() || '';
            const value = parseFloat(adj.value || 0);
            
            if (value !== 0) {
              if (desc.includes('×¢×œ×™×” ×œ×›×‘×™×©') || desc.includes('registration')) {
                console.log('ğŸ”§ Loading registration from levisummary:', adj);
                addRegistrationAdjustment();
                const lastRow = document.querySelector('#registrationAdjustmentsList > div:last-child');
                if (lastRow) {
                  lastRow.querySelector('input[type="text"]:first-of-type').value = adj.description || '×¢×œ×™×” ×œ×›×‘×™×©';
                  lastRow.querySelector('select').value = value >= 0 ? 'plus' : 'minus';
                  // CRITICAL FIX: Display minus sign for negative values
                  const displayValue = value >= 0 ? Math.abs(value) : `-${Math.abs(value)}`;
                  lastRow.querySelector('input[type="text"]:last-of-type').value = `â‚ª${displayValue.toLocaleString()}`;
                }
              } else if (desc.includes('×××¤×™×™× ×™×') || desc.includes('features')) {
                console.log('ğŸ”§ Loading features from levisummary:', adj);
                addFeatureAdjustment();
                const lastRow = document.querySelector('#featuresAdjustmentsList > div:last-child');
                if (lastRow) {
                  lastRow.querySelector('input[type="text"]:first-of-type').value = adj.description || '×××¤×™×™× ×™×';
                  lastRow.querySelector('select').value = value >= 0 ? 'plus' : 'minus';
                  // CRITICAL FIX: Display minus sign for negative values
                  const displayValue = value >= 0 ? Math.abs(value) : `-${Math.abs(value)}`;
                  lastRow.querySelector('input[type="text"]:last-of-type').value = `â‚ª${displayValue.toLocaleString()}`;
                }
              }
            }
          });
        }
        
        // LOAD MANUAL ENTRIES from final_report.adjustments (after Levi data)
        if (helper.final_report?.adjustments) {
          const finalReportAdjustments = helper.final_report.adjustments;
          
          // Load manual features
          const manualFeatures = finalReportAdjustments.features?.filter(item => item.source === 'manual') || [];
          if (manualFeatures.length > 0) {
            console.log(`ğŸ“ Loading ${manualFeatures.length} manual features adjustments`);
            manualFeatures.forEach((item, index) => {
              addFeatureAdjustment();
              const rows = document.querySelectorAll('#featuresAdjustmentsList > div');
              const lastRow = rows[rows.length - 1];
              
              if (lastRow) {
                const inputs = lastRow.querySelectorAll('input, select');
                if (inputs.length >= 4) {
                  inputs[0].value = item.value || '';
                  inputs[1].value = item.type || 'plus';
                  inputs[2].value = item.percentage || item.percent || '';
                  // Check if it's a reduction type to preserve minus sign
                  const isReduction = item.type === 'minus' || item.type === '×”×¤×—×ª×”' || 
                                     item.type === '×”×¤×—×ª×” (-)' || item.type === '×”×•×¨×“×”';
                  let displayAmount = Math.abs(item.amount || 0);
                  if (isReduction && displayAmount > 0) {
                    displayAmount = -displayAmount;
                  }
                  inputs[3].value = item.amount_display || (item.amount ? `â‚ª${displayAmount.toLocaleString()}` : '');
                  
                  // Keep as manual source
                  lastRow.setAttribute('data-source', 'manual');
                  
                  console.log(`âœ… Loaded manual features item ${index}:`, {
                    description: inputs[0].value,
                    type: inputs[1].value,
                    percent: inputs[2].value,
                    amount: inputs[3].value
                  });
                }
              }
            });
          }
          
          // Load manual registration
          const manualRegistration = finalReportAdjustments.registration?.filter(item => item.source === 'manual') || [];
          if (manualRegistration.length > 0) {
            console.log(`ğŸ“ Loading ${manualRegistration.length} manual registration adjustments`);
            manualRegistration.forEach((item, index) => {
              addRegistrationAdjustment();
              const rows = document.querySelectorAll('#registrationAdjustmentsList > div');
              const lastRow = rows[rows.length - 1];
              
              if (lastRow) {
                const inputs = lastRow.querySelectorAll('input, select');
                if (inputs.length >= 4) {
                  inputs[0].value = item.value || '';
                  inputs[1].value = item.type || 'plus';
                  inputs[2].value = item.percentage || item.percent || '';
                  // Check if it's a reduction type to preserve minus sign
                  const isReduction = item.type === 'minus' || item.type === '×”×¤×—×ª×”' || 
                                     item.type === '×”×¤×—×ª×” (-)' || item.type === '×”×•×¨×“×”';
                  let displayAmount = Math.abs(item.amount || 0);
                  if (isReduction && displayAmount > 0) {
                    displayAmount = -displayAmount;
                  }
                  inputs[3].value = item.amount_display || (item.amount ? `â‚ª${displayAmount.toLocaleString()}` : '');
                  
                  // Keep as manual source
                  lastRow.setAttribute('data-source', 'manual');
                  
                  console.log(`âœ… Loaded manual registration item ${index}:`, {
                    description: inputs[0].value,
                    type: inputs[1].value,
                    percent: inputs[2].value,
                    amount: inputs[3].value
                  });
                }
              }
            });
          }
        }
        
        // Calculate initial gross market value
        updateGrossMarketValueCalculation();
        
        // Trigger calculation for all existing adjustment rows
        setTimeout(() => {
          const allPercentInputs = document.querySelectorAll('#featuresAdjustmentsList input[placeholder="××—×•×–"], #registrationAdjustmentsList input[placeholder="××—×•×–"]');
          allPercentInputs.forEach(input => {
            if (input.value) {
              calculateAdjustmentValue(input);
            }
          });
          
          // Recalculate final values
          updateGrossMarketValueCalculation();
        }, 300);
        
        // Load second bulk data if available
        setTimeout(() => {
          loadSecondBulkData();
        }, 500);
        
      } catch (error) {
        console.error('Error loading gross calculation data:', error);
      }
    }
    
    // Load data for second bulk (gross percentage)
    function loadSecondBulkData() {
      try {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Load claims data if available
        if (helper.claims_data) {
          const totalClaimField = document.getElementById('totalClaim');
          const leviPriceListField = document.getElementById('leviPriceList');
          const grossPercentField = document.getElementById('grossPercent');
          
          if (totalClaimField && helper.claims_data.total_claim) {
            totalClaimField.value = helper.claims_data.total_claim;
          }
          
          
          if (leviPriceListField && helper.claims_data.gross_value) {
            leviPriceListField.value = helper.claims_data.gross_value;
          }
          
          if (grossPercentField && helper.claims_data.gross_percent) {
            grossPercentField.value = helper.claims_data.gross_percent;
          }
        }
        
        // If no saved data, calculate from current state
        if (!helper.claims_data?.total_claim) {
          updateGrossPercentageFromGrossValue();
        }
        
      } catch (error) {
        console.error('Error loading second bulk data:', error);
      }
    }
    
    // Update gross percentage when gross market value changes
    function updateGrossPercentageFromGrossValue() {
      // Get GROSS price (car properties only)
      let grossPrice = 0;
      
      if (window.CalculationInterface && typeof window.CalculationInterface.getGrossMarketValue === 'function') {
        grossPrice = window.CalculationInterface.getGrossMarketValue();
      } else {
        // Fallback: calculate gross price directly from fields
        const grossResultField = document.getElementById('grossMarketValueResult');
        if (grossResultField && grossResultField.value) {
          grossPrice = parseFloat(grossResultField.value.replace(/[â‚ª,]/g, '')) || 0;
        } else {
          // Further fallback: use basic price
          const basicPriceField = document.getElementById('basicPrice');
          if (basicPriceField && basicPriceField.value) {
            grossPrice = parseFloat(basicPriceField.value.replace(/[â‚ª,]/g, '')) || 0;
          }
        }
      }
      
      // Get total claim from damage centers calculation
      const totalClaim = calculateTotalClaimFromDamageCenters();
      
      console.log('ğŸ” Updating GROSS DAMAGE PERCENTAGE (using gross price, not market price):', {
        grossPrice,
        totalClaim
      });
      
      // Update the display fields
      const totalClaimField = document.getElementById('totalClaim');
      const leviPriceListField = document.getElementById('leviPriceList');
      
      if (totalClaimField && totalClaim > 0) {
        totalClaimField.value = `â‚ª${totalClaim.toLocaleString()}`;
      }
      
      if (leviPriceListField && grossPrice > 0) {
        leviPriceListField.value = `â‚ª${grossPrice.toLocaleString()}`;
      }
      
      // Get authorized claim instead of total claim
      const authorizedClaimField = document.getElementById('authorizedClaim');
      const authorizedClaimValue = authorizedClaimField?.value || '';
      const authorizedClaim = parseFloat(authorizedClaimValue.replace(/[â‚ª,]/g, '')) || totalClaim; // fallback to totalClaim if no authorized claim
      
      // Calculate and update GROSS DAMAGE PERCENTAGE (authorized claim Ã· gross price)
      if (grossPrice > 0 && authorizedClaim > 0) {
        const grossDamagePercentage = (authorizedClaim / grossPrice) * 100;
        const grossPercentField = document.getElementById('grossPercent');
        if (grossPercentField) {
          const formattedPercentage = `${Math.round(grossDamagePercentage * 100) / 100}%`;
          grossPercentField.value = formattedPercentage;
          
          // Update helper with GROSS damage percentage (separate from market damage percentage)
          // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          helper.calculations = helper.calculations || {};
          helper.calculations.damage_percent_gross = grossDamagePercentage;
          helper.calculations.total_damage = totalClaim;
          
          // Update claims data for backward compatibility
          helper.claims_data = helper.claims_data || {};
          helper.claims_data.gross_percent = formattedPercentage;
          
          
          helper.claims_data.gross_value = `â‚ª${grossPrice.toLocaleString()}`;
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          console.log(`ğŸ“Š GROSS DAMAGE %: ${authorizedClaim.toLocaleString()} Ã· ${grossPrice.toLocaleString()} = ${formattedPercentage}`);
          console.log(`ğŸ  This uses GROSS PRICE (car properties only), not market price`);
        }
      }
    }
    
    // CALCULATE TOTAL CLAIM FROM DAMAGE CENTERS
    function calculateTotalClaimFromDamageCenters() {
      try {
        let totalClaim = 0;
        
        // Get damage centers from the summary or helper
        const damageCentersContent = document.getElementById('damageCentersContent');
        if (damageCentersContent) {
          const damageRows = damageCentersContent.querySelectorAll('.damage-center-row');
          damageRows.forEach(row => {
            const totalField = row.querySelector('.total-field');
            if (totalField && totalField.value) {
              const total = parseFloat(totalField.value.replace(/[â‚ª,]/g, '')) || 0;
              totalClaim += total;
            }
          });
        }
        
        // Fallback: try to get from summary section
        if (totalClaim === 0) {
          const sumClaimField = document.getElementById('sumClaim');
          if (sumClaimField && sumClaimField.value) {
            totalClaim = parseFloat(sumClaimField.value.replace(/[â‚ª,]/g, '')) || 0;
          }
        }
        
        // Fallback: try to get from helper
        if (totalClaim === 0) {
          // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          if (helper.expertise?.damage_blocks) {
            helper.expertise.damage_blocks.forEach(block => {
              totalClaim += (parseFloat(block.parts_cost) || 0) + 
                           (parseFloat(block.work_cost) || 0) + 
                           (parseFloat(block.repairs_cost) || 0);
            });
          }
        }
        
        console.log('ğŸ’° Total claim from damage centers:', totalClaim);
        return totalClaim;
      } catch (error) {
        console.error('Error calculating total claim from damage centers:', error);
        return 0;
      }
    }
    
    // SIMPLE CALCULATION FUNCTIONS FOR NEW SYSTEM
    /**
     * Calculate the final appraised vehicle value based on adjustments.
     * Implements the correct calculation order from todo.md lines 337-391
     */
    function calculateVehicleValue(basePrice, adjustments) {
      if (typeof basePrice !== 'number' || isNaN(basePrice)) {
        throw new Error('Invalid base price');
      }

      const safeAdj = (adj, current) => {
        if (!adj) return 0;
        if (adj.percent && typeof adj.percent === 'number') {
          return current * (adj.percent / 100);
        }
        if (adj.fixed && typeof adj.fixed === 'number') {
          return adj.fixed;
        }
        return 0;
      };

      // Step 1: Independent adjustments (Features + Registration) using Base Price
      const featuresAdj = safeAdj(adjustments.features, basePrice);
      const registrationAdj = safeAdj(adjustments.registration, basePrice);

      const grossValue = basePrice + featuresAdj + registrationAdj;

      // Step 2: Sequential adjustments (Ownership â†’ Mileage â†’ Number of Owners)
      let currentValue = grossValue;

      for (const key of ['ownershipType', 'mileage', 'numOwners']) {
        const adj = adjustments[key];
        if (!adj) continue; // skip if missing or zero
        const adjAmount = safeAdj(adj, currentValue);
        currentValue += adjAmount; // apply sequentially
      }

      return Math.round(currentValue); // round to nearest whole currency unit
    }

    function calculateGrossMarketValue() {
      updateGrossMarketValueCalculation();
    }
    
    function calculateGrossPercentage() {
      updateGrossPercentageFromGrossValue();
    }
    
    function calculateFullMarketValue() {
      // updateFullMarketValueCalculation() removed
    }
    
    // FULL MARKET VALUE CALCULATION FUNCTIONS
    
    // Add full market adjustment row
    // Add Full Features Adjustment
    function addFullFeaturesAdjustment() {
      const container = document.getElementById('fullFeaturesAdjustmentsList');
      const rowId = 'fullFeaturesAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="×ª×™××•×¨ ×ª×•×¡×¤×ª ×××¤×™×™×Ÿ" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));" title="">
              <option value="plus">×ª×•×¡×¤×ª (+)</option>
              <option value="minus">×”×¤×—×ª×” (-)</option>
            </select></div>
            <div><input type="text" placeholder="××—×•×–" title="" oninput="calculateAdjustmentValueSimple(this); this.title = this.value;" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(this.value) || 0), safeParseAmount(inputs[3].value)); this.title = this.value;" /></div>
            <div><input type="text" placeholder="â‚ª" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(this.value)); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">××—×§</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ×¢×¨×š ××¦×˜×‘×¨: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">â‚ª0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Add Full Registration Adjustment
    function addFullRegistrationAdjustment() {
      const container = document.getElementById('fullRegistrationAdjustmentsList');
      const rowId = 'fullRegistrationAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="×ª×™××•×¨ ×¢×œ×™×” ×œ×›×‘×™×©" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');" /></div>
            <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));">
              <option value="plus">×ª×•×¡×¤×ª (+)</option>
              <option value="minus">×”×¤×—×ª×” (-)</option>
            </select></div>
            <div><input type="text" placeholder="××—×•×–" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(this.value) || 0), safeParseAmount(inputs[3].value));" /></div>
            <div><input type="text" placeholder="â‚ª" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(this.value));" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">××—×§</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ×¢×¨×š ××¦×˜×‘×¨: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">â‚ª0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Add Mileage Adjustment
    function addMileageAdjustment() {
      const container = document.getElementById('mileageAdjustmentsList');
      const rowId = 'mileageAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="×ª×™××•×¨ ××¡ ×§"×" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'mileage'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'mileage'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));" title="">
              <option value="plus">×ª×•×¡×¤×ª (+)</option>
              <option value="minus">×”×¤×—×ª×” (-)</option>
            </select></div>
            <div><input type="text" placeholder="××—×•×–" title="" oninput="calculateAdjustmentValueSimple(this); this.title = this.value;" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'mileage'); this.title = this.value;" /></div>
            <div><input type="text" placeholder="â‚ª" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'mileage'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">××—×§</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ×¢×¨×š ××¦×˜×‘×¨: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">â‚ª0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Add Ownership Type Adjustment
    function addOwnershipAdjustment() {
      const container = document.getElementById('ownershipAdjustmentsList');
      const rowId = 'ownershipAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="×ª×™××•×¨ ×¡×•×’ ×‘×¢×œ×•×ª" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_type'); this.title = this.value;" oninput="this.title = this.value;" /></div>
          <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_type'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));" title="">
            <option value="plus">×ª×•×¡×¤×ª (+)</option>
            <option value="minus">×”×¤×—×ª×” (-)</option>
          </select></div>
            <div><input type="text" placeholder="××—×•×–" title="" oninput="calculateAdjustmentValueSimple(this); this.title = this.value;" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_type'); this.title = this.value;" /></div>
            <div><input type="text" placeholder="â‚ª" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_type'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">××—×§</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ×¢×¨×š ××¦×˜×‘×¨: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">â‚ª0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Add Number of Owners Adjustment
    function addOwnersAdjustment() {
      const container = document.getElementById('ownersAdjustmentsList');
      const rowId = 'ownersAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="×ª×™××•×¨ ××¡×¤×¨ ×‘×¢×œ×™×" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_history'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_history'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));" title="">
              <option value="plus">×ª×•×¡×¤×ª (+)</option>
              <option value="minus">×”×¤×—×ª×” (-)</option>
            </select></div>
            <div><input type="text" placeholder="××—×•×–" title="" oninput="calculateAdjustmentValueSimple(this); this.title = this.value;" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_history'); this.title = this.value;" /></div>
            <div><input type="text" placeholder="â‚ª" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_history'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">××—×§</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ×¢×¨×š ××¦×˜×‘×¨: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">â‚ª0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Add General Full Market Adjustment (additional)
    function addFullMarketAdjustment() {
      const container = document.getElementById('allAdjustmentsList');
      const rowId = 'fullAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="×ª×™××•×¨ ×”×ª×××” × ×•×¡×¤×ª" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(inputs[2].value) || 0, safeParseAmount(inputs[3].value));" /></div>
            <div><select onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, parseFloat(inputs[2].value) || 0, safeParseAmount(inputs[3].value));">
              <option value="plus">×ª×•×¡×¤×ª (+)</option>
              <option value="minus">×”×¤×—×ª×” (-)</option>
            </select></div>
            <div><input type="text" placeholder="××—×•×–" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(this.value) || 0, safeParseAmount(inputs[3].value));" /></div>
            <div><input type="text" placeholder="â‚ª" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(inputs[2].value) || 0, safeParseAmount(this.value));" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">××—×§</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ×¢×¨×š ××¦×˜×‘×¨: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">â‚ª0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Remove full market adjustment row
    function removeFullMarketAdjustmentRow(rowId) {
      const row = document.getElementById(rowId);
      if (row) {
        row.remove();
        // updateFullMarketValueCalculation() removed
      }
    }
    
    // DELETED: updateFullMarketValueCalculation() function removed
    // Full market value now comes only from UI input, not automatic calculations
    
    // Update cumulative display for each section
    function updateCumulativeDisplay(sectionName, currentValue) {
      const nameMapping = {
        '×ª×•×¡×¤×•×ª ×××¤×™×™× ×™×': 'featuresCumulative',
        '×¢×œ×™×” ×œ×›×‘×™×©': 'registrationCumulative', 
        '××¡ ×§"×': 'mileageCumulative',
        '×¡×•×’ ×‘×¢×œ×•×ª': 'ownershipCumulative',
        '××¡×¤×¨ ×‘×¢×œ×™×': 'ownersCumulative'
      };
      
      const cumulativeId = nameMapping[sectionName];
      if (cumulativeId) {
        const cumulativeElement = document.getElementById(cumulativeId);
        if (cumulativeElement) {
          const span = cumulativeElement.querySelector('span');
          if (span) {
            span.textContent = `â‚ª${Math.round(currentValue).toLocaleString()}`;
            const minExpectedValue = helper.calculations?.base_market_value || helper.levisummary?.base_price || 100000;
            span.style.color = currentValue >= minExpectedValue ? '#28a745' : '#dc3545';
          }
        }
      }
    }
    
    // Calculate full market value with cumulative updates
    function updateFullMarketValueCalculation() {
      try {
        // Get helper object first
        const helper = window.helper || {};
        
        // Get base price from fullBasicPrice field
        let basicPrice = 0;
        const fullBasicPriceField = document.getElementById('fullBasicPrice');
        if (fullBasicPriceField?.value) {
          basicPrice = parseFloat(fullBasicPriceField.value.replace(/[â‚ª,]/g, '')) || 0;
        }
        
        // Fallback: Use helper base price if field is empty
        if (basicPrice === 0) {
          basicPrice = helper.calculations?.base_market_value || helper.levisummary?.base_price || helper.valuation?.base_price || 0;
        }
        let currentValue = basicPrice;
        
        // 1. Process Features Adjustments
        const fullFeaturesRows = document.querySelectorAll('#fullFeaturesAdjustmentsList > div');
        fullFeaturesRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            // FIXED: Parse amount preserving sign, then apply dropdown type logic
            const amountText = (inputs[3].value || '').trim();
            let amount = parseFloat(amountText.replace(/[â‚ª,\s]/g, '')) || 0;
            const type = inputs[1].value;
            
            // Apply type logic: if type is minus and amount is positive, make negative
            // If type is plus and amount is negative, use absolute value
            if (isReductionType(type) && amount > 0) {
              amount = -amount;
            } else if (!isReductionType(type) && amount < 0) {
              amount = Math.abs(amount);
            }
            
            currentValue += amount;
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `â‚ª${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update features cumulative - this shows currentValue after features
        updateCumulativeDisplay('×ª×•×¡×¤×•×ª ×××¤×™×™× ×™×', currentValue);
        const afterFeatures = currentValue; // Store value after features
        
        // 2. Process Registration Adjustments
        const fullRegistrationRows = document.querySelectorAll('#fullRegistrationAdjustmentsList > div');
        fullRegistrationRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            // FIXED: Parse amount preserving sign, then apply dropdown type logic
            const amountText = (inputs[3].value || '').trim();
            let amount = parseFloat(amountText.replace(/[â‚ª,\s]/g, '')) || 0;
            const type = inputs[1].value;
            
            // Apply type logic: if type is minus and amount is positive, make negative
            // If type is plus and amount is negative, use absolute value
            if (isReductionType(type) && amount > 0) {
              amount = -amount;
            } else if (!isReductionType(type) && amount < 0) {
              amount = Math.abs(amount);
            }
            
            currentValue += amount;
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `â‚ª${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update registration cumulative - this shows currentValue after features + registration
        updateCumulativeDisplay('×¢×œ×™×” ×œ×›×‘×™×©', currentValue);
        const afterRegistration = currentValue; // This is the GROSS price that subsequent calculations use
        
        // 3. Process Mileage Adjustments
        const mileageRows = document.querySelectorAll('#mileageAdjustmentsList > div');
        mileageRows.forEach((row, index) => {
          const select = row.querySelector('select');
          const type = select?.value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const percentInput = inputs[1]; // Percentage field
          const valueInput = inputs[2];   // Value field
          
          // Conditional logic: percentage vs direct value
          if (percentInput && percentInput.value && parseFloat(percentInput.value) !== 0) {
            // HAS PERCENTAGE: Calculate SPECIFIC result from PREVIOUS CATEGORY CUMULATIVE
            const percent = parseFloat(percentInput.value);
            // For manual rows (index > 0), use previous category cumulative, not running cumulative
            let previousCumulative;
            if (index > 0) {
              // Manual row: use registration cumulative (previous category)
              previousCumulative = afterRegistration;
            } else {
              // First row: use current running cumulative
              previousCumulative = currentValue;
            }
            const specificResult = previousCumulative * (Math.abs(percent) / 100); // Calculate from correct base
            
            // Apply dropdown selection to get final cumulative
            if (type === 'minus') {
              currentValue = currentValue - specificResult;
            } else {
              currentValue = currentValue + specificResult;
            }
            
            // UPDATE THE UI: Set the correct specific value in the value field
            // Skip updating during page load to preserve manual amounts
            if (valueInput && !window.pageLoadInProgress) {
              const roundedResult = Math.round(specificResult);
              const displayAmount = roundedResult.toLocaleString();
              valueInput.value = (type === 'minus') ? `-â‚ª${displayAmount}` : `â‚ª${displayAmount}`;
            }
          } else if (valueInput && valueInput.value) {
            // FIXED: Parse amount considering it might already have a minus sign
            const amountText = (valueInput.value || '').trim();
            const hasMinusSign = amountText.includes('-');
            const value = Math.abs(parseFloat(amountText.replace(/[â‚ª,\s-]/g, '')) || 0);
            const signedValue = (type === 'minus') ? -value : value;
            currentValue += signedValue;
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `â‚ª${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update mileage cumulative - this shows currentValue after mileage
        updateCumulativeDisplay('××¡ ×§"×', currentValue);
        const afterMileage = currentValue; // Store value after mileage
        
        // Removed saveAdjustmentAmount - syncAdjustmentToHelper handles row-level cumulative properly
        
        // 4. Process Ownership Adjustments
        const ownershipRows = document.querySelectorAll('#ownershipAdjustmentsList > div');
        ownershipRows.forEach((row, index) => {
          const select = row.querySelector('select');
          const type = select?.value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const percentInput = inputs[1]; // Percentage field
          const valueInput = inputs[2];   // Value field
          
          // Conditional logic: percentage vs direct value
          if (percentInput && percentInput.value && parseFloat(percentInput.value) !== 0) {
            // HAS PERCENTAGE: Calculate SPECIFIC result from PREVIOUS CATEGORY CUMULATIVE
            const percent = parseFloat(percentInput.value);
            // For manual rows (index > 0), use previous category cumulative, not running cumulative
            let previousCumulative;
            if (index > 0) {
              // Manual row: use mileage cumulative (previous category)
              previousCumulative = afterMileage;
            } else {
              // First row: use current running cumulative
              previousCumulative = currentValue;
            }
            const specificResult = previousCumulative * (Math.abs(percent) / 100); // Calculate from correct base
            
            // Apply dropdown selection to get final cumulative
            if (type === 'minus') {
              currentValue = currentValue - specificResult;
            } else {
              currentValue = currentValue + specificResult;
            }
            
            // UPDATE THE UI: Set the correct specific value in the value field
            // Skip updating during page load to preserve manual amounts
            if (valueInput && !window.pageLoadInProgress) {
              const roundedResult = Math.round(specificResult);
              const displayAmount = roundedResult.toLocaleString();
              valueInput.value = (type === 'minus') ? `-â‚ª${displayAmount}` : `â‚ª${displayAmount}`;
            }
          } else if (valueInput && valueInput.value) {
            // FIXED: Parse amount considering it might already have a minus sign
            const amountText = (valueInput.value || '').trim();
            const hasMinusSign = amountText.includes('-');
            const value = Math.abs(parseFloat(amountText.replace(/[â‚ª,\s-]/g, '')) || 0);
            if (type === 'minus') {
              currentValue = currentValue - value;
            } else {
              currentValue = currentValue + value;
            }
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `â‚ª${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update ownership cumulative - this shows currentValue after ownership
        updateCumulativeDisplay('×¡×•×’ ×‘×¢×œ×•×ª', currentValue);
        const afterOwnership = currentValue; // Store value after ownership
        
        // Removed saveAdjustmentAmount - syncAdjustmentToHelper handles row-level cumulative properly
        
        // 5. Process Owners Adjustments
        const ownersRows = document.querySelectorAll('#ownersAdjustmentsList > div');
        ownersRows.forEach((row, index) => {
          const select = row.querySelector('select');
          const type = select?.value;
          
          // DEBUG: Log ownership_history type reading during calculation
          console.log(`ğŸ” updateFullMarketValueCalculation owners[${index}] type: ${type}, pageLoadInProgress: ${window.pageLoadInProgress}`);
          const inputs = row.querySelectorAll('input[type="text"]');
          const percentInput = inputs[1]; // Percentage field
          const valueInput = inputs[2];   // Value field
          
          // Conditional logic: percentage vs direct value
          if (percentInput && percentInput.value && parseFloat(percentInput.value) !== 0) {
            // HAS PERCENTAGE: Calculate SPECIFIC result from PREVIOUS CATEGORY CUMULATIVE
            const percent = parseFloat(percentInput.value);
            // For manual rows (index > 0), use previous category cumulative, not running cumulative
            let previousCumulative;
            if (index > 0) {
              // Manual row: use ownership cumulative (previous category)
              previousCumulative = afterOwnership;
            } else {
              // First row: use current running cumulative
              previousCumulative = currentValue;
            }
            const specificResult = previousCumulative * (Math.abs(percent) / 100); // Calculate from correct base
            
            // Apply dropdown selection to get final cumulative
            if (type === 'minus') {
              currentValue = currentValue - specificResult;
            } else {
              currentValue = currentValue + specificResult;
            }
            
            // UPDATE THE UI: Set the correct specific value in the value field
            // Skip updating during page load to preserve manual amounts
            if (valueInput && !window.pageLoadInProgress) {
              const roundedResult = Math.round(specificResult);
              const displayAmount = roundedResult.toLocaleString();
              valueInput.value = (type === 'minus') ? `-â‚ª${displayAmount}` : `â‚ª${displayAmount}`;
            }
          } else if (valueInput && valueInput.value) {
            // FIXED: Parse amount considering it might already have a minus sign
            const amountText = (valueInput.value || '').trim();
            const hasMinusSign = amountText.includes('-');
            const value = Math.abs(parseFloat(amountText.replace(/[â‚ª,\s-]/g, '')) || 0);
            if (type === 'minus') {
              currentValue = currentValue - value;
            } else {
              currentValue = currentValue + value;
            }
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `â‚ª${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update owners cumulative
        updateCumulativeDisplay('××¡×¤×¨ ×‘×¢×œ×™×', currentValue);
        
        // Removed saveAdjustmentAmount - syncAdjustmentToHelper handles row-level cumulative properly
        
        // 6. Process Additional Market Adjustments
        const additionalRows = document.querySelectorAll('#allAdjustmentsList > div');
        additionalRows.forEach((row, index) => {
          const type = row.querySelector('select')?.value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const percentInput = inputs[1]; // Percentage field
          const valueInput = inputs[2];   // Value field
          
          if (percentInput && percentInput.value) {
            const percent = parseFloat(percentInput.value) || 0;
            if (percent !== 0) { // Changed from > 0 to !== 0 to handle negative percentages
              const adjustment = basicPrice * (Math.abs(percent) / 100);
              const signedAdjustment = (type === 'minus' || percent < 0) ? -adjustment : adjustment;
              currentValue += signedAdjustment;
            }
          } else if (valueInput && valueInput.value) {
            // FIXED: Parse amount considering it might already have a minus sign
            const amountText = (valueInput.value || '').trim();
            const hasMinusSign = amountText.includes('-');
            const value = Math.abs(parseFloat(amountText.replace(/[â‚ª,\s-]/g, '')) || 0);
            const signedValue = (type === 'minus') ? -value : value;
            currentValue += signedValue;
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `â‚ª${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update final result field
        const resultField = document.getElementById('fullMarketValueResult');
        if (resultField) {
          resultField.value = `â‚ª${Math.round(currentValue).toLocaleString()}`;
        }
        
        // Update bridge fields in helper.calculations for consistency (base_price only)
        if (helper.calculations) {
          const rawBasePrice = helper.valuation?.base_price || 
                               helper.car_details?.base_price || 
                               helper.levi_report?.base_price || 0;
          const originalBasePrice = parseFloat(String(rawBasePrice).replace(/[â‚ª,]/g, '')) || 0;
          helper.calculations.base_price = originalBasePrice;
          helper.calculations.full_market_value = Math.round(currentValue);
          // Note: final_adjustments_value should only be updated by the main calculation function
        }
        
      } catch (error) {
        console.error('Error in FULL market value calculation:', error);
      }
    }
    
    // Load data from helper for full market value calculation
    function loadFullMarketValueData() {
      try {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        
        // Load basic price (same as gross calculation)
        const fullBasicPriceField = document.getElementById('fullBasicPrice');
        const basicPriceField = document.getElementById('basicPrice');
        if (fullBasicPriceField && basicPriceField) {
          fullBasicPriceField.value = basicPriceField.value;
        } else if (fullBasicPriceField && helper.levi_report?.base_price) {
          fullBasicPriceField.value = `â‚ª${parseFloat(helper.levi_report.base_price).toLocaleString()}`;
        }
        
        // AGGRESSIVE FIX: Clear container completely and verify it's empty
        const container = document.getElementById('allAdjustmentsList');
        if (container) {
          // Remove all child elements one by one to ensure proper cleanup
          while (container.firstChild) {
            container.removeChild(container.firstChild);
          }
          // Double-check with innerHTML as backup
          container.innerHTML = '';
          // Force DOM refresh
          container.offsetHeight;
          
          // Add a flag to prevent duplicate loading
          if (container.hasAttribute('data-loading')) {
            return;
          }
          container.setAttribute('data-loading', 'true');
        }
        
        // Create a unified adjustments array to prevent duplicates
        const allAdjustments = [];
        const seenAdjustments = new Set();
        
        // Add Levi adjustments first (these are the main ones)
        if (helper.levi_report?.adjustments) {
          helper.levi_report.adjustments.forEach(adj => {
            const adjustmentType = adj.value >= 0 ? 'plus' : 'minus';
            const key = `${adj.description}-${adj.percentage || adj.percent || 0}-${adjustmentType}`;
            if (!seenAdjustments.has(key)) {
              allAdjustments.push({
                description: adj.description || '×”×ª×××” ××œ×•×™ ×™×¦×—×§',
                percentage: adj.percentage || adj.percent || 0,
                value: adj.value || 0,
                type: adjustmentType,
                source: 'levi'
              });
              seenAdjustments.add(key);
            }
          });
        }
        
        // Add custom adjustments only if they're not duplicates
        if (helper.custom_adjustments?.full_market_adjustments) {
          helper.custom_adjustments.full_market_adjustments.forEach(adj => {
            const adjustmentType = adj.type || 'plus';
            const key = `${adj.description}-${adj.percentage || adj.percent || 0}-${adjustmentType}`;
            if (!seenAdjustments.has(key)) {
              allAdjustments.push({
                description: adj.description || '×”×ª×××” ××•×ª×××ª',
                percentage: adj.percentage || adj.percent || 0,
                value: adj.value || 0,
                type: adjustmentType,
                source: 'custom'
              });
              seenAdjustments.add(key);
            }
          });
        }
        
        // REMOVED: Auto-population of allAdjustmentsList (×”×ª×××•×ª ×©×•×§ × ×•×¡×¤×•×ª)
        // These should be manual fields only, not auto-populated
        
        // Calculate initial full market value
        // updateFullMarketValueCalculation() removed
        
        // DISABLED: autoPopulateMarketAdjustments - causes override of final_report data
        // setTimeout(() => {
        //   autoPopulateMarketAdjustments();
        // }, 100);
        
        // Remove loading flag
        if (container) {
          container.removeAttribute('data-loading');
        }
        
        // Trigger calculation after data is loaded
        setTimeout(() => {
          updateFullMarketValueCalculation();
        }, 200);
        
      } catch (error) {
        console.error('Error loading full market value data:', error);
        // Remove loading flag on error too
        const container = document.getElementById('allAdjustmentsList');
        if (container) {
          container.removeAttribute('data-loading');
        }
      }
    }
    
    
    // FULL MARKET ADJUSTMENT CALCULATION - COPIED FROM WORKING DEPRECIATION
    function calculateFullMarketAdjustmentValue(percentInput) {
      const percent = parseFloat(percentInput.value) || 0;
      const row = percentInput.closest('.adjustment-row');
      
      if (!row) {
        console.log('âŒ No adjustment row found for percentage input');
        return;
      }
      
      // Get market value from same sources as depreciation calculation
      let marketValue = 0;
      
      // First try the basic price field from the same section
      const basicPriceField = document.getElementById('fullBasicPrice');
      if (basicPriceField && basicPriceField.value) {
        marketValue = parseFloat(basicPriceField.value.replace(/[â‚ª,]/g, '')) || 0;
        console.log('ğŸ“Š Using fullBasicPrice:', marketValue);
      }
      
      // If no basic price, try summary market value (priority)
      if (marketValue === 0) {
        const sumMarketValueField = document.getElementById('sumMarketValue');
        if (sumMarketValueField && sumMarketValueField.value) {
          marketValue = parseFloat(sumMarketValueField.value.replace(/[â‚ª,]/g, '')) || 0;
          console.log('ğŸ“Š Using sumMarketValue:', marketValue);
        }
      }
      
      // If still no value, try car market value
      if (marketValue === 0) {
        const carMarketValueField = document.getElementById('carMarketValue');
        if (carMarketValueField && carMarketValueField.value) {
          marketValue = parseFloat(carMarketValueField.value.replace(/[â‚ª,]/g, '')) || 0;
          console.log('ğŸ“Š Using carMarketValue:', marketValue);
        }
      }
      
      if (marketValue === 0) {
        console.log('âŒ No market value found for calculation');
      }
      
      // Calculate value exactly like working depreciation
      const calculatedValue = Math.round((marketValue * percent) / 100);
      console.log('ğŸ’° Calculation:', { marketValue, percent, calculatedValue });
      
      // Find value input (fourth column in the grid)
      const inputs = row.querySelectorAll('input');
      console.log('ğŸ“ Found inputs:', inputs.length);
      // Row structure: [description, select, percentage, value, button]
      // Input indices: [0=description, 1=percentage, 2=value]
      if (inputs.length >= 3) {
        const valueInput = inputs[2]; // Third input (value field)
        valueInput.value = calculatedValue ? `â‚ª${calculatedValue.toLocaleString()}` : '';
        console.log('âœ… Set value input to:', valueInput.value);
      } else {
        console.log('âŒ Not enough inputs found, expected >= 3, got:', inputs.length);
      }
      
      // Trigger calculation update
      // updateFullMarketValueCalculation() removed
    }
    
    // FINAL REPORT ADJUSTMENTS FUNCTIONS
    
    // Add final report adjustment row
    
    // Calculate final report adjustment value from percentage
    function calculateFinalReportAdjustmentValue(percentageInput) {
      const row = percentageInput.closest('div');
      let basicPrice = parseFloat(document.getElementById('basicPrice')?.value.replace(/[â‚ª,]/g, '')) || 0;
      const percentage = parseFloat(percentageInput.value) || 0;
      
      // Try alternative price sources if basicPrice is empty
      if (basicPrice === 0) {
        // Try grossMarketValue first (from calculations)
        const grossMarketValue = parseFloat(document.getElementById('grossMarketValue')?.value.replace(/[â‚ª,]/g, '')) || 0;
        if (grossMarketValue > 0) {
          basicPrice = grossMarketValue;
          console.log('ğŸ“Š Using grossMarketValue for final report adjustment calculation:', basicPrice);
        }
      }
      
      // If still no price, try to get from helper
      if (basicPrice === 0) {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        if (helper.levi_report?.base_price) {
          basicPrice = parseFloat(helper.levi_report.base_price);
        } else if (helper.expertise?.levi_report?.base_price) {
          basicPrice = parseFloat(helper.expertise.levi_report.base_price);
        } else if (helper.car_details?.base_price) {
          basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[â‚ª,]/g, ''));
        }
        console.log('ğŸ“Š Using helper price for final report adjustment calculation:', basicPrice);
      }
      
      if (percentage && basicPrice) {
        const calculatedValue = basicPrice * percentage / 100;
        const inputs = row.querySelectorAll('input');
        if (inputs.length > 2) {
          const valueInput = inputs[2]; // value field is the third input
          valueInput.value = `â‚ª${Math.round(calculatedValue).toLocaleString()}`;
          console.log(`ğŸ’° Calculated final report adjustment value: ${percentage}% Ã— â‚ª${basicPrice.toLocaleString()} = â‚ª${Math.round(calculatedValue).toLocaleString()}`);
          
          // Trigger change event to update other calculations
          valueInput.dispatchEvent(new Event('change', { bubbles: true }));
        } else {
          console.error('Cannot find value input field for final report adjustment calculation');
        }
      } else {
        console.warn(`âš ï¸ Cannot calculate final report adjustment value - basicPrice: ${basicPrice}, percentage: ${percentage}`);
        if (basicPrice === 0) {
          console.warn('âš ï¸ No car price found. Please set the basic price first.');
        }
      }
    }
    
    // Update final report adjustments in helper
    function updateFinalReportAdjustments() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      // Final report container removed - will return empty NodeList
      const adjustmentRows = document.querySelectorAll('#allAdjustmentsRows-final-report div[data-source="custom"]');
      const adjustments = [];
      
      adjustmentRows.forEach(row => {
        const inputs = row.querySelectorAll('input');
        const description = inputs[0].value;
        const type = row.querySelector('select').value;
        const percentage = parseFloat(inputs[1].value) || 0;
        const value = parseFloat(inputs[2].value.replace(/[â‚ª,]/g, '')) || 0;
        
        if (description && (percentage || value)) {
          adjustments.push({ description, type, percentage, value });
        }
      });
      
      // Save to helper
      if (!helper.levi) helper.levi = {};
      helper.levi.custom_adjustments = adjustments;
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      console.log('final report adjustments updated:', adjustments);
      
      // REMOVED: updateHelperFromAdjustments() to prevent overwriting calculated amounts during bulk updates
    }
    
    // REFRESH SECOND BULK FIELDS
    function refreshSecondBulkFields() {
      updateGrossPercentageFromGrossValue();
    }
    
    // UPDATE AUTHORIZED CLAIM DATA
    function updateAuthorizedClaim(element) {
      try {
        const helper = window.helper || {};
        let value = element.value;
        
        // Parse the numeric value from the input
        const numericValue = parseFloat(value.replace(/[â‚ª,]/g, '')) || 0;
        
        // Format currency display
        if (numericValue > 0) {
          value = `â‚ª${numericValue.toLocaleString()}`;
          element.value = value;
        }
        
        // Initialize helper sections if they don't exist
        if (!helper.claims_data) helper.claims_data = {};
        if (!helper.calculations) helper.calculations = {};
        
        // Write to both locations
        helper.claims_data.total_claim = value;
        helper.calculations.total_damage = numericValue;
        
        // Save to session storage and window.helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        console.log(`ğŸ’° Updated authorizedClaim: claims_data.total_claim = "${value}", calculations.total_damage = ${numericValue}`);
        console.log(`ğŸ” DEBUG: helper.calculations after update:`, helper.calculations);
        console.log(`ğŸ” DEBUG: sessionStorage updated successfully`);
        
      } catch (error) {
        console.error('Error updating authorized claim:', error);
      }
    }

    // UPDATE GROSS PERCENTAGE FIELD
    function updateGrossPercentageField() {
      try {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        let vehicleValueGross = helper.calculations?.vehicle_value_gross;
        
        // Get AUTHORIZED claim from the field (×¡×”"×› ×ª×‘×™×¢×” ×××•×©×¨) instead of total claim
        const authorizedClaimField = document.getElementById('authorizedClaim');
        const authorizedClaimValue = authorizedClaimField?.value || '';
        const authorizedClaim = parseFloat(authorizedClaimValue.replace(/[â‚ª,]/g, '')) || 0;
        
        // If vehicle_value_gross is missing, try to get it from the leviPriceList field
        if (!vehicleValueGross) {
          const leviPriceListField = document.getElementById('leviPriceList');
          if (leviPriceListField && leviPriceListField.value) {
            vehicleValueGross = parseFloat(leviPriceListField.value.replace(/[â‚ª,]/g, '')) || 0;
            console.log(`ğŸ”§ Got vehicle_value_gross from leviPriceList field: ${vehicleValueGross}`);
          }
        }
        
        console.log('ğŸ” Gross percentage calculation:', {
          vehicleValueGross: vehicleValueGross,
          authorizedClaim: authorizedClaim,
          authorizedClaimRaw: authorizedClaimValue,
          helperCalculations: helper.calculations
        });
        
        if (vehicleValueGross && vehicleValueGross > 0 && authorizedClaim > 0) {
          // Calculate gross percentage: (Authorized Claim Ã· Gross Market Value) Ã— 100
          const grossPercentage = (authorizedClaim / vehicleValueGross) * 100;
          const formattedPercentage = `${Math.round(grossPercentage * 100) / 100}%`;
          
          const grossPercentField = document.getElementById('grossPercent');
          if (grossPercentField) {
            grossPercentField.value = formattedPercentage;
            
            // Update helper claims data to maintain consistency
            helper.claims_data = helper.claims_data || {};
            helper.claims_data.gross_percent = formattedPercentage;
            
            // Also update expertise.calculations for system compatibility
            helper.expertise = helper.expertise || {};
            helper.expertise.calculations = helper.expertise.calculations || {};
            helper.expertise.calculations.damage_percent = Math.round(grossPercentage * 100) / 100;
            
            sessionStorage.setItem('helper', JSON.stringify(helper));
            
            console.log(`ğŸ“Š Updated gross percentage: ${authorizedClaim.toLocaleString()} Ã· ${vehicleValueGross.toLocaleString()} = ${formattedPercentage}`);
          }
        } else {
          console.log('â„¹ï¸ Gross percentage calculation skipped - values not ready:', {
            vehicleValueGross: vehicleValueGross,
            authorizedClaim: authorizedClaim
          });
          
          // Do NOT call updateGrossMarketValueField here to avoid infinite loop
        }
      } catch (error) {
        console.error('Error updating gross percentage field:', error);
      }
    }
    
    // UPDATE GROSS MARKET VALUE FIELD
    function updateGrossMarketValueField() {
      try {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        let vehicleValueGross = helper.calculations?.vehicle_value_gross;
        
        console.log('ğŸ” Updating gross market value field:', {
          vehicleValueGross: vehicleValueGross,
          helperCalculations: helper.calculations
        });
        
        // If no vehicle_value_gross, try to calculate from current gross calculation
        if (!vehicleValueGross) {
          const grossMarketValueField = document.getElementById('grossMarketValueResult');
          if (grossMarketValueField && grossMarketValueField.value) {
            vehicleValueGross = parseFloat(grossMarketValueField.value.replace(/[â‚ª,]/g, '')) || 0;
            console.log(`ğŸ”§ Got vehicle_value_gross from grossMarketValueResult field: ${vehicleValueGross}`);
          }
        }
        
        // If still no value, try to get from gross value field  
        if (!vehicleValueGross) {
          const leviPriceListField = document.getElementById('leviPriceList');
          if (leviPriceListField && leviPriceListField.value) {
            vehicleValueGross = parseFloat(leviPriceListField.value.replace(/[â‚ª,]/g, '')) || 0;
            console.log(`ğŸ”§ Got vehicle_value_gross from gross value field: ${vehicleValueGross}`);
          }
        }
        
        // Update the leviPriceList field with the gross market value
        const leviPriceListField = document.getElementById('leviPriceList');
        if (leviPriceListField && vehicleValueGross > 0) {
          leviPriceListField.value = `â‚ª${vehicleValueGross.toLocaleString()}`;
          console.log(`ğŸ“Š Updated leviPriceList field with gross market value: ${vehicleValueGross}`);
        }
        
        // Update helper if we found a value
        if (vehicleValueGross > 0) {
          helper.calculations = helper.calculations || {};
          helper.calculations.vehicle_value_gross = vehicleValueGross;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          console.log(`âœ… Updated helper with vehicle_value_gross: ${vehicleValueGross}`);
        } else {
          console.log('â„¹ï¸ vehicle_value_gross not found - will be calculated when needed');
        }
        
      } catch (error) {
        console.error('Error updating gross market value field:', error);
      }
    }
    
    // DEBUG CALCULATIONS
    function debugCalculations() {
      try {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        console.log('ğŸ› DEBUG CALCULATIONS:', {
          helper_calculations: helper.calculations,
          helper_expertise_calculations: helper.expertise?.calculations,
          helper_claims_data: helper.claims_data,
          grossMarketValueResult: document.getElementById('grossMarketValueResult')?.value,
          fullMarketValueResult: document.getElementById('fullMarketValueResult')?.value,
          totalClaim: document.getElementById('totalClaim')?.value,
          leviPriceList: document.getElementById('leviPriceList')?.value,
          grossPercent: document.getElementById('grossPercent')?.value,
          basicPrice: document.getElementById('basicPrice')?.value,
          carMarketValue: document.getElementById('carMarketValue')?.value,
          sumMarketValue: document.getElementById('sumMarketValue')?.value,
          sumClaim: document.getElementById('sumClaim')?.value,
          sumTotalClaim: document.getElementById('sumTotalClaim')?.value
        });
        
      } catch (error) {
        console.error('Error in debug calculations:', error);
      }
    }
    
    // CALCULATE DAMAGE PERCENTAGE
    function calculateDamagePercentage() {
      try {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Get total claim from damage centers or helper
        let totalClaim = 0;
        const totalClaimField = document.getElementById('totalClaim');
        if (totalClaimField && totalClaimField.value) {
          totalClaim = parseFloat(totalClaimField.value.replace(/[â‚ª,]/g, '')) || 0;
        } else {
          totalClaim = calculateTotalClaimFromDamageCenters();
        }
        
        // Get gross market value from helper or DOM
        let grossMarketValue = helper.calculations?.vehicle_value_gross || 0;
        if (!grossMarketValue) {
          const grossMarketValueField = document.getElementById('grossMarketValueResult');
          if (grossMarketValueField && grossMarketValueField.value) {
            grossMarketValue = parseFloat(grossMarketValueField.value.replace(/[â‚ª,]/g, '')) || 0;
          }
        }
        
        // Calculate damage percentage
        let damagePercentage = 0;
        if (grossMarketValue > 0 && totalClaim > 0) {
          damagePercentage = (totalClaim / grossMarketValue) * 100;
        }
        
        console.log('ğŸ”¢ Damage percentage calculation:', {
          totalClaim,
          grossMarketValue,
          damagePercentage
        });
        
        return damagePercentage;
        
      } catch (error) {
        console.error('Error calculating damage percentage:', error);
        return 0;
      }
    }

    // TRIGGER GLOBAL DEPRECIATION CALCULATION
    function triggerGlobalDepreciationCalc() {
      const globalDepInput = document.getElementById('globalDep1');
      if (globalDepInput && globalDepInput.value) {
        const event = new Event('input', { bubbles: true });
        globalDepInput.dispatchEvent(event);
      }
    }

    // ğŸ›ï¸ ADMIN HUB COMMUNICATION SETUP
    function initAdminHubCommunication() {
      console.log('ğŸ”Œ Initializing admin hub communication...');
      
      // Listen for messages from admin hub (parent frame)
      window.addEventListener('message', function(event) {
        // Security: Check origin if needed
        // if (event.origin !== 'https://yaron-cayouf-portal.netlify.app') return;
        
        console.log('ğŸ“¨ Received message from admin hub:', event.data);
        
        if (event.data && event.data.type) {
          switch (event.data.type) {
            case 'VAT_RATE_UPDATED':
              // Admin hub notifies us of VAT rate change
              const newVatRate = event.data.vatRate;
              console.log('ğŸ“¢ Received VAT rate update from admin hub:', newVatRate + '%');
              
              // Check if we should ignore admin updates due to recent manual override
              const now = Date.now();
              if (window.ignoreAdminVatUntil && now < window.ignoreAdminVatUntil) {
                const remainingTime = Math.ceil((window.ignoreAdminVatUntil - now) / 1000);
                console.log(`ğŸ›¡ï¸ IGNORING admin hub VAT update due to recent manual override (${remainingTime}s remaining) (final-report)`);
                console.log('ğŸ’¡ Manual session override takes precedence');
                break; // Exit without updating
              }
              
              // Clear protection flags if expired
              if (window.ignoreAdminVatUntil && now >= window.ignoreAdminVatUntil) {
                window.ignoreAdminVatUntil = null;
                window.lastManualVatUpdate = null;
                console.log('ğŸ”“ Manual VAT override protection expired, admin updates allowed (final-report)');
              }
              
              // CRITICAL: Update helper.calculations.vat_rate directly (source of truth)
              console.log('ğŸ” Checking setHelperVatRateFromAdmin availability:', typeof window.setHelperVatRateFromAdmin);
              
              if (typeof window.setHelperVatRateFromAdmin === 'function') {
                console.log('ğŸ¯ Calling setHelperVatRateFromAdmin with rate:', newVatRate);
                const success = window.setHelperVatRateFromAdmin(newVatRate, 'admin_hub');
                console.log(success ? 'âœ… Helper VAT rate updated successfully' : 'âŒ Failed to update helper VAT rate');
                
                // Verify the change
                setTimeout(() => {
                  const currentHelperVat = window.helper?.calculations?.vat_rate;
                  console.log('ğŸ” Verified helper.calculations.vat_rate:', currentHelperVat);
                  console.log('ğŸ” getHelperVatRate() returns:', window.getHelperVatRate ? window.getHelperVatRate() : 'function not available');
                }, 100);
                
              } else {
                console.warn('âš ï¸ setHelperVatRateFromAdmin function not available');
                console.log('ğŸ” Available window functions:', Object.keys(window).filter(k => k.includes('Helper') || k.includes('Vat')));
              }
              
              // Refresh VAT display
              if (window.initVatDisplay) {
                window.initVatDisplay();
              }
              
              // Refresh all calculations
              if (typeof refreshAllCalculations === 'function') {
                refreshAllCalculations();
              }
              
              break;
              
            case 'GET_VAT_RATE':
              // Admin hub requests current VAT rate
              const currentVat = window.getHelperVatRate ? window.getHelperVatRate() : 18;
              event.source.postMessage({
                type: 'VAT_RATE_RESPONSE',
                vatRate: currentVat
              }, event.origin);
              break;
              
            default:
              console.log('ğŸ“¨ Unknown message from admin hub:', event.data);
          }
        }
      });
      
      // Try to establish connection with admin hub
      if (window.parent && window.parent !== window) {
        console.log('ğŸ”— Attempting to connect to admin hub...');
        
        // Request current VAT rate from admin hub
        setTimeout(() => {
          window.parent.postMessage({ type: 'GET_VAT_RATE' }, '*');
        }, 500);
        
        // Notify admin hub that we're ready
        window.parent.postMessage({ 
          type: 'MODULE_READY', 
          module: 'final-report-builder',
          timestamp: Date.now()
        }, '*');
      } else {
        console.log('â„¹ï¸ No parent frame detected (not in admin hub iframe)');
      }
    }

    // Cleanup function to remove deprecated data structures
    function cleanupDeprecatedData() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        let updated = false;
        
        // Keep final_report.adjustments - it's now the primary data structure
        
        if (updated) {
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
      } catch (error) {
        console.error('Error cleaning deprecated data:', error);
      }
    }

    // Cleanup function to fix duplicated damage center numbers
    function cleanupDamageCenterNumbers() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        if (helper.centers && Array.isArray(helper.centers)) {
          let updated = false;
          
          helper.centers.forEach((center, index) => {
            if (center["Damage center Number"] && typeof center["Damage center Number"] === 'string') {
              // Check if it contains duplicated text
              if (center["Damage center Number"].includes('××•×§×“')) {
                // Extract just the number
                const match = center["Damage center Number"].match(/\d+$/);
                const cleanNumber = match ? match[0] : String(index + 1);
                center["Damage center Number"] = cleanNumber;
                updated = true;
              }
            }
          });
          
          if (updated) {
            sessionStorage.setItem('helper', JSON.stringify(helper));
            // Also update window.helper if it exists
            if (window.helper && window.helper.centers) {
              window.helper.centers = helper.centers;
            }
            console.log('Cleaned up damage center numbers');
          }
        }
      } catch (error) {
        console.error('Error cleaning damage center numbers:', error);
      }
    }

    async function initializeDamageCenterIds() {
      try {
        console.log('ğŸ” SESSION 56: Initializing damage center IDs from Supabase...');
        
        const helper = window.helper || {};
        
        if (!helper.centers || helper.centers.length === 0) {
          console.log('â„¹ï¸ SESSION 56: No damage centers in helper, skipping ID initialization');
          return;
        }
        
        console.log(`ğŸ“Š SESSION 56: Found ${helper.centers.length} centers in helper:`, helper.centers);
        
        const centersNeedingIds = helper.centers.filter((center, index) => {
          const hasId = !!(center.Id || center.id || center.code);
          if (!hasId) {
            console.log(`âš ï¸ SESSION 56: Center ${index} missing ID:`, center);
          }
          return !hasId;
        });
        
        if (centersNeedingIds.length === 0) {
          console.log('âœ… SESSION 56: All damage centers already have IDs');
          return;
        }
        
        console.log(`ğŸ”§ SESSION 56: ${centersNeedingIds.length} centers need IDs, querying Supabase...`);
        
        const plate = helper.meta?.plate || helper.vehicle?.plate || helper.car_details?.plate;
        if (!plate) {
          console.warn('âš ï¸ SESSION 56: No plate number found, cannot query Supabase');
          return;
        }
        
        const normalizedPlate = plate.replace(/-/g, '');
        
        if (!window.supabase) {
          console.warn('âš ï¸ SESSION 56: Supabase not available, cannot load damage center IDs');
          return;
        }
        
        const { data: partsData, error } = await window.supabase
          .from('parts_required')
          .select('damage_center_code, part_name, plate')
          .eq('plate', normalizedPlate);
        
        if (error) {
          console.error('âŒ SESSION 56: Error querying Supabase parts_required:', error);
          return;
        }
        
        if (!partsData || partsData.length === 0) {
          console.log('â„¹ï¸ SESSION 56: No parts found in Supabase for this plate');
          return;
        }
        
        const uniqueCenterCodes = [...new Set(partsData.map(p => p.damage_center_code).filter(Boolean))];
        console.log(`ğŸ“‹ SESSION 56: Found ${uniqueCenterCodes.length} unique damage center codes in Supabase:`, uniqueCenterCodes);
        
        uniqueCenterCodes.sort();
        
        helper.centers.forEach((center, index) => {
          if (center.Id || center.id || center.code) {
            return;
          }
          
          if (uniqueCenterCodes[index]) {
            center.Id = uniqueCenterCodes[index];
            console.log(`âœ… SESSION 56: Assigned ID to center ${index}: ${center.Id}`);
          } else {
            console.warn(`âš ï¸ SESSION 56: No matching Supabase ID for center ${index}, will generate on save`);
          }
        });
        
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        console.log('âœ… SESSION 56: Damage center IDs initialized successfully');
        
      } catch (error) {
        console.error('âŒ SESSION 56: Error initializing damage center IDs:', error);
      }
    }

    // ============================================================================
    // SESSION 88: INVOICE ASSIGNMENT BANNER SYSTEM
    // ============================================================================

    /**
     * Check for available invoices and show assignment banner if any exist
     */
    async function checkForAvailableInvoices() {
      console.log('ğŸ¯ SESSION 88: checkForAvailableInvoices() FUNCTION ENTRY - Starting execution...');
      try {
        console.log('ğŸ“„ SESSION 88: Checking for available invoices (replicating invoice upload.html logic)...');
        
        const helper = window.helper || {};
        
        // Enhanced case_id detection with multiple fallbacks
        const caseId = helper.case_info?.supabase_case_id || 
                      helper.case_info?.case_id || 
                      helper.meta?.case_id || 
                      helper.case_id;
                      
        const plateNumber = helper.case_info?.plate || 
                           helper.meta?.plate || 
                           helper.vehicle?.plate || 
                           helper.car_details?.plate;
        
        console.log('ğŸ” SESSION 88 COMPREHENSIVE DEBUG:');
        console.log('  helper keys:', Object.keys(helper));
        console.log('  helper.case_info:', helper.case_info);
        console.log('  caseId:', caseId);
        console.log('  plateNumber:', plateNumber);
        console.log('  window.supabase available:', !!window.supabase);
        console.log('  window.invoiceService available:', !!window.invoiceService);
        console.log('ğŸ” SESSION 90: Checking existing invoice data in helper...');
        console.log('  helper.invoices:', helper.invoices?.length || 'none');
        console.log('  helper.final_report?.invoice_assignments:', helper.final_report?.invoice_assignments?.length || 'none');
        console.log('  window.invoiceDataForDropdowns:', window.invoiceDataForDropdowns?.invoice_lines?.length || 'none');
        
        // SESSION 90: Note - Removed automatic test data injection
        // Test data can be added manually via manualInvoiceCheck() function
        console.log('â„¹ï¸ SESSION 90: Ready for invoice detection (no automatic test data)');
        
        if (!caseId && !plateNumber) {
          console.log('âŒ SESSION 90: No case_id or plate found - cannot check invoices');
          console.log('  helper.case_info?.supabase_case_id:', helper.case_info?.supabase_case_id);
          console.log('  helper.case_info?.case_id:', helper.case_info?.case_id);
          console.log('  helper.meta?.case_id:', helper.meta?.case_id);
          console.log('  helper.case_id:', helper.case_id);
          console.log('  Plate detected:', plateNumber);
          hideInvoiceAssignmentBanner();
          return;
        }
        
        if (!caseId && plateNumber) {
          console.log('ğŸ”„ SESSION 90: No case_id but using plate number as fallback:', plateNumber);
        }
        
        if (!plateNumber) {
          console.log('âŒ SESSION 88: No plate number found - cannot filter invoices');
          hideInvoiceAssignmentBanner();
          return;
        }
        
        if (!window.supabase) {
          console.warn('âš ï¸ SESSION 88: Supabase not available for invoice check');
          return;
        }
        
        // Try direct Supabase query first (fallback if invoiceService not available)
        if (!window.invoiceService) {
          console.warn('âš ï¸ SESSION 88: invoiceService not available, trying direct Supabase query...');
          
          let allInvoices = null;
          
          try {
            console.log('ğŸ” SESSION 88: About to execute Supabase query...');
            const result = await window.supabase
              .from('invoices')
              .select('*')
              .eq('case_id', caseId)
              // SESSION 91 TESTING MODE - Allow ACCEPTED invoices to be re-accepted
              .eq('status', 'ASSIGNED');  // Normal mode - only ASSIGNED invoices
              
            // TESTING MODE: Also check for ACCEPTED invoices
            const testMode = true; // SET TO FALSE FOR PRODUCTION
            if (testMode && (!allInvoices || allInvoices.length === 0)) {
              console.log('ğŸ§ª SESSION 91 TEST MODE: Checking for ACCEPTED invoices...');
              const acceptedResult = await window.supabase
                .from('invoices')
                .select('*')
                .eq('case_id', caseId)
                .eq('status', 'ACCEPTED');
              
              if (acceptedResult.data && acceptedResult.data.length > 0) {
                console.log('ğŸ§ª TEST MODE: Found', acceptedResult.data.length, 'ACCEPTED invoices');
                allInvoices = acceptedResult.data;
              }
            }
            
            console.log('ğŸ“¤ SESSION 88: Raw Supabase response:', result);
            const { data, error } = result;
            allInvoices = data || [];
            
            if (error) {
              console.error('âŒ SESSION 88: Error querying invoices directly:', error);
              console.error('âŒ SESSION 88: Error details:', error.message, error.code, error.details);
              return;
            }
            
            console.log('ğŸ“¦ SESSION 88: Direct Supabase query - all invoices:', allInvoices);
            console.log('ğŸ“Š SESSION 88: Query result type:', typeof allInvoices);
            console.log('ğŸ“Š SESSION 88: Query result length:', allInvoices?.length);
          } catch (queryError) {
            console.error('âŒ SESSION 88: Exception during Supabase query:', queryError);
            console.error('âŒ SESSION 88: Query error stack:', queryError.stack);
            return;
          }
          
          if (!allInvoices || allInvoices.length === 0) {
            console.log('â„¹ï¸ SESSION 88: No ASSIGNED invoices found for this case');
            
            // SESSION 91 FIX: Only clear archive if NO invoices exist at all (any status)
            // Check for ANY invoices including ACCEPTED ones
            const { data: anyInvoices } = await window.supabase
              .from('invoices')
              .select('id')
              .eq('case_id', caseId);
            
            if (!anyInvoices || anyInvoices.length === 0) {
              console.log('ğŸ§¹ SESSION 91: No invoices AT ALL in system');
              const helper = window.helper || {};
              
              // If we have an archive, restore centers from it
              if (helper.centers_archive && helper.centers_archive.length > 0) {
                console.log('ğŸ“¦ SESSION 91: Restoring centers from archive (no invoices)');
                helper.centers = JSON.parse(JSON.stringify(helper.centers_archive));
                
                // Clear the archive since we're back to no-invoice state
                delete helper.centers_archive;
                delete helper.centers_archive_meta;
                
                sessionStorage.setItem('helper', JSON.stringify(helper));
                window.helper = helper;
                
                console.log('âœ… Centers restored from archive - system back to wizard data');
                
                // Refresh UI to show restored data
                if (typeof loadDamageCentersFromHelper === 'function') {
                  setTimeout(() => {
                    loadDamageCentersFromHelper(helper);
                  }, 100);
                }
              } else {
                console.log('â„¹ï¸ No archive to restore from');
              }
            } else {
              console.log('â„¹ï¸ SESSION 91: Archive preserved - found', anyInvoices.length, 'invoices in system');
            }
            
            hideInvoiceAssignmentBanner();
            return;
          }
          
          // Filter by plate
          const plateInvoices = allInvoices.filter(inv => {
            console.log(`  Direct query - Comparing: "${inv.plate}" === "${plateNumber}" â†’ ${inv.plate === plateNumber}`);
            return inv.plate === plateNumber;
          });
          
          console.log(`ğŸ“Š SESSION 88: Direct query - Found ${plateInvoices.length} invoices for this plate`);
          
          if (plateInvoices.length === 0) {
            console.log('â„¹ï¸ SESSION 88: No invoices found for this plate');
            hideInvoiceAssignmentBanner();
            return;
          }
          
          // Show these invoices (even without mappings for now)
          console.log('ğŸ“‹ SESSION 88: Showing available invoices (direct query):', plateInvoices);
          showInvoiceAssignmentBanner(plateInvoices.map(inv => ({ ...inv, assignment_count: 0 })));
          return;
        }
        
        console.log(`ğŸ“‚ SESSION 88: Loading invoices via invoiceService for case: ${caseId}, plate: ${plateNumber}`);
        
        // Get all invoices for this case (same as invoice upload.html)
        const allInvoices = await window.invoiceService.getInvoicesByCase(caseId);
        console.log('ğŸ“¦ SESSION 88: invoiceService result - all invoices:', allInvoices);
        
        if (!allInvoices || allInvoices.length === 0) {
          console.log('â„¹ï¸ SESSION 88: No invoices returned by invoiceService');
          hideInvoiceAssignmentBanner();
          return;
        }
        
        // Filter by plate (same as invoice upload.html)
        const plateInvoices = allInvoices.filter(inv => {
          console.log(`  invoiceService - Comparing: "${inv.plate}" === "${plateNumber}" â†’ ${inv.plate === plateNumber}`);
          return inv.plate === plateNumber;
        });
        
        console.log(`ğŸ“Š SESSION 88: invoiceService - Found ${plateInvoices.length} invoices for this case and plate`);
        
        if (!plateInvoices || plateInvoices.length === 0) {
          console.log('â„¹ï¸ SESSION 88: No invoices found for this plate via invoiceService');
          hideInvoiceAssignmentBanner();
          return;
        }
        
        // Check which invoices have mappings in the database that haven't been applied yet
        const invoicesWithPendingAssignments = [];
        
        for (const invoice of plateInvoices) {
          // SESSION 91 TESTING ONLY - Allow ACCEPTED invoices to be re-accepted
          // if (invoice.status !== 'ASSIGNED') {
          //   console.log(`â­ï¸ Skipping invoice ${invoice.invoice_number} with status '${invoice.status}' (need 'ASSIGNED')`);
          //   continue;
          // }
          if (invoice.status !== 'ASSIGNED' && invoice.status !== 'ACCEPTED') {
            console.log(`â­ï¸ Skipping invoice ${invoice.invoice_number} with status '${invoice.status}'`);
            continue;
          }

          // Query invoice_damage_center_mappings table for this invoice
          const { data: mappings, error: mappingError } = await window.supabase
            .from('invoice_damage_center_mappings')
            .select('id, mapping_status, field_type, damage_center_id')
            .eq('invoice_id', invoice.id)
            .eq('case_id', caseId)
            .eq('mapping_status', 'pending'); // Look for pending mappings (assigned but not yet applied)
          
          if (mappingError) {
            console.error(`âŒ SESSION 88: Error querying mappings for invoice ${invoice.id}:`, mappingError);
            continue;
          }
          
          console.log(`ğŸ” SESSION 88: Invoice ${invoice.supplier_name} has ${mappings?.length || 0} active mappings`);
          
          if (mappings && mappings.length > 0) {
            // Check if these mappings have been applied to damage centers already
            // For now, assume if mapping_status = 'active', they need to be applied
            invoicesWithPendingAssignments.push({
              ...invoice,
              assignment_count: mappings.length,
              mappings: mappings
            });
          }
        }
        
        console.log(`ğŸ“‹ SESSION 88: Found ${invoicesWithPendingAssignments.length} invoices with pending assignments:`, invoicesWithPendingAssignments);
        
        if (invoicesWithPendingAssignments.length === 0) {
          console.log('â„¹ï¸ SESSION 88: No invoices with pending assignments');
          hideInvoiceAssignmentBanner();
          return;
        }
        
        showInvoiceAssignmentBanner(invoicesWithPendingAssignments);
        
      } catch (error) {
        console.error('âŒ SESSION 88: Error checking for invoices:', error);
        console.error('âŒ SESSION 88: Error stack:', error.stack);
        console.error('âŒ SESSION 88: Error name:', error.name);
        console.error('âŒ SESSION 88: Error message:', error.message);
        hideInvoiceAssignmentBanner();
      } finally {
        console.log('ğŸ SESSION 88: checkForAvailableInvoices() FUNCTION EXIT - Execution completed');
      }
    }

    /**
     * Show the invoice assignment banner with available invoices
     */
    function showInvoiceAssignmentBanner(invoices) {
      const banner = document.getElementById('invoiceAssignmentBanner');
      const content = document.getElementById('invoiceAssignmentContent');
      
      if (!banner || !content) {
        console.warn('âš ï¸ SESSION 88: Invoice banner elements not found');
        return;
      }
      
      // Build invoice list HTML (matching invoice upload.html format)
      let invoiceListHtml = `
        <div style="margin-bottom: 10px; font-weight: 600; color: #1565c0;">
          × ××¦××• ${invoices.length} ×—×©×‘×•× ×™×•×ª ×¢× ×”×§×¦××•×ª ×××ª×™× ×•×ª ×œ×”×—×œ×”:
        </div>
      `;
      
      invoices.forEach((invoice, index) => {
        // Extract invoice date following same pattern as other invoice fields (supplier_name, etc.)
        let invoiceDate = null;
        
        // Primary source: invoice.invoice_date field (if exists in database)
        if (invoice.invoice_date) {
          invoiceDate = invoice.invoice_date;
        }
        
        // Secondary source: OCR structured data with Hebrew field name
        if (!invoiceDate && invoice.ocr_structured_data && invoice.ocr_structured_data['×ª××¨×™×š']) {
          invoiceDate = invoice.ocr_structured_data['×ª××¨×™×š'];
        }
        
        // Tertiary source: helper.invoices array (legacy data)
        if (!invoiceDate) {
          const helperInvoice = helper.invoices?.find(inv => 
            inv.id === invoice.id || 
            (inv.invoice_number && inv.invoice_number === invoice.invoice_number)
          );
          if (helperInvoice) {
            invoiceDate = helperInvoice['×ª××¨×™×š'] || helperInvoice.date || helperInvoice.invoice_date;
          }
        }
        
        // Format date for display (same pattern as other fields)
        let displayDate;
        if (invoiceDate) {
          try {
            // Handle various date formats
            const dateObj = new Date(invoiceDate);
            if (!isNaN(dateObj.getTime())) {
              displayDate = dateObj.toLocaleDateString('he-IL');
            } else {
              // If parsing fails, use string as-is (might be Hebrew date)
              displayDate = invoiceDate.toString();
            }
          } catch (e) {
            displayDate = invoiceDate.toString();
          }
        } else {
          // Final fallback: upload date (same as supplier_name pattern: '×œ× ×¦×•×™×Ÿ')
          displayDate = new Date(invoice.created_at).toLocaleDateString('he-IL');
        }
        
        const supplierName = invoice.supplier_name || '×œ× ×¦×•×™×Ÿ';
        const displayTitle = `${supplierName} - ${displayDate}`;
        const assignmentCount = invoice.assignment_count || 0;
        
        invoiceListHtml += `
          <div style="
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 8px;
            background: #fafafa;
            display: flex;
            justify-content: space-between;
            align-items: center;
          ">
            <div>
              <div style="font-weight: 600; color: #333;">
                ${displayTitle}
              </div>
              <div style="font-size: 13px; color: #666;">
                ${assignmentCount} ×”×§×¦××•×ª | â‚ª${invoice.total_amount?.toLocaleString() || '0'}
              </div>
            </div>
            <div>
              <input type="checkbox" 
                     id="invoice_${invoice.id}" 
                     data-invoice-id="${invoice.id}"
                     style="transform: scale(1.2);">
            </div>
          </div>
        `;
      });
      
      content.innerHTML = invoiceListHtml;
      banner.style.display = 'block';
      
      // Store invoices data for later use
      window.availableInvoices = invoices;
      
      console.log('âœ… SESSION 88: Invoice assignment banner displayed');
    }

    /**
     * Hide the invoice assignment banner
     */
    function hideInvoiceAssignmentBanner() {
      const banner = document.getElementById('invoiceAssignmentBanner');
      if (banner) {
        banner.style.display = 'none';
      }
    }

    /**
     * Dismiss the invoice assignment banner (user clicked X)
     */
    function dismissInvoiceAssignmentBanner() {
      hideInvoiceAssignmentBanner();
      
      // Mark as dismissed in session storage
      sessionStorage.setItem('invoiceAssignmentDismissed', 'true');
      
      console.log('â„¹ï¸ SESSION 88: Invoice assignment banner dismissed by user');
    }

    /**
     * Show invoices differentials in a popup
     */
    async function showInvoicesDifferentials() {
      try {
        console.log('ğŸ“Š SESSION 88: Showing invoice differentials...');
        
        const checkedInvoices = getSelectedInvoices();
        if (checkedInvoices.length === 0) {
          alert('×× × ×‘×—×¨ ×œ×¤×—×•×ª ×—×©×‘×•× ×™×ª ××—×ª ×œ×”×¦×’×ª ×”×¤×¨×©×™×');
          return;
        }
        
        // Calculate differentials between wizard centers and invoice data
        const differentials = await calculateInvoiceDifferentials(checkedInvoices);
        
        // Show in popup or floating screen
        displayDifferentialsPopup(differentials);
        
      } catch (error) {
        console.error('âŒ SESSION 88: Error showing differentials:', error);
        alert('×©×’×™××” ×‘×”×¦×’×ª ×”×¤×¨×©×™ ×—×©×‘×•× ×™×•×ª');
      }
    }

    /**
     * Accept invoice assignment and perform center duplication
     */
    window.acceptInvoiceAssignment = async function acceptInvoiceAssignment() {
      try {
        console.log('ğŸš€ SESSION 88: Processing invoice assignment acceptance...');
        console.log('ğŸ” DEBUG: Function called successfully');
        console.log('ğŸ“‹ Getting selected invoices...');
        
        let checkedInvoices = getSelectedInvoices();
        console.log('ğŸ“‹ Selected invoices:', checkedInvoices);
        
        // If no invoices are manually selected, use all available invoices
        if (checkedInvoices.length === 0) {
          console.log('ğŸ” No invoices manually selected, checking available invoices...');
          checkedInvoices = window.availableInvoices || [];
          console.log('ğŸ“‹ Using all available invoices:', checkedInvoices);
        }
        
        if (checkedInvoices.length === 0) {
          console.warn('âš ï¸ No invoices available to process');
          alert('×œ× × ××¦××• ×—×©×‘×•× ×™×•×ª ×–××™× ×•×ª ×œ×¢×™×‘×•×“');
          return;
        }
        
        console.log(`âœ… Found ${checkedInvoices.length} selected invoices, showing confirmation...`);
        
        if (!confirm(`×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××©×¨ ×”×§×¦××ª ${checkedInvoices.length} ×—×©×‘×•× ×™×•×ª? ×¤×¢×•×œ×” ×–×• ×ª×“×¨×•×¡ ××ª × ×ª×•× ×™ ×”××•×§×“×™× ×”×§×™×™××™×.`)) {
          console.log('âŒ User cancelled confirmation');
          return;
        }
        
        console.log('âœ… User confirmed, starting process...');
        
        // Show loading state
        const acceptBtn = document.getElementById('acceptInvoiceAssignment');
        if (acceptBtn) {
          acceptBtn.disabled = true;
          acceptBtn.textContent = '××¢×‘×“...';
        }
        
        // Phase 1: Archive entire helper to helper_versions (one-time per case)
        await archiveEntireHelper();
        
        // Phase 2: Archive parts_search.required_parts before invoice import
        await archivePartsSearchData();
        
        // TASK 1: Create centers archive for ALL report types (SESSION 91 FIX)
        const helper = window.helper || {};
        const currentReportType = helper.final_report?.type || helper.final_report?.dropdown_type || 
                                document.querySelector('input[name="final-report-type"]:checked')?.value;

        console.log('ğŸ” Current report type:', currentReportType);

        // Create archive for ALL report types - simplifying the logic
        console.log('ğŸ“¦ SESSION 91: Creating centers archive for ALL report types...');
        
        if (!helper.centers_archive && helper.centers) {
          // Create deep copy of current centers BEFORE any modifications
          helper.centers_archive = JSON.parse(JSON.stringify(helper.centers));
          
          // Add metadata
          helper.centers_archive_meta = {
            created_at: new Date().toISOString(),
            report_type: currentReportType,
            original_centers_count: helper.centers.length,
            purpose: 'preserve_wizard_data_before_invoice_processing'
          };
          
          // Save to BOTH sessionStorage AND window.helper
          sessionStorage.setItem('helper', JSON.stringify(helper));
          window.helper = helper; // Ensure window.helper also has the archive
          
          console.log(`âœ… Created centers_archive with ${helper.centers.length} centers`);
          console.log('ğŸ“‹ Archive metadata:', helper.centers_archive_meta);
          console.log('ğŸ“‹ Archive saved to both sessionStorage and window.helper');
        } else if (helper.centers_archive) {
          console.log('â„¹ï¸ Centers archive already exists, skipping creation');
        } else {
          console.warn('âš ï¸ No helper.centers found to archive');
        }
        
        // Phase 3: Convert invoice mappings to helper format (Private reports only)
        // For other report types, invoice data will be available in dropdowns
        await convertInvoiceMappingsToHelperFormat(checkedInvoices);
        
        // Phase 4: Save updated helper.centers back to Supabase and sessionStorage
        await saveUpdatedHelper();
        
        // Phase 5: Update mapping status to 'applied' for tracking
        await updateMappingStatus(checkedInvoices, 'applied');
        
        // Phase 5b: Update invoice status from ASSIGNED to ACCEPTED (completing the status flow)
        await updateInvoiceStatusToAccepted(checkedInvoices);
        
        // Phase 6: Hide banner and refresh view
        hideInvoiceAssignmentBanner();
        
        // Force refresh the damage centers display with updated invoice data
        console.log('ğŸ” DEBUG: helper.centers AFTER all processing:', window.helper?.centers);
        console.log('ğŸ” DEBUG: About to refresh UI with updated damage centers...');
        
        // Method 1: Call loadDataFromHelper to refresh entire UI
        if (typeof loadDataFromHelper === 'function') {
          console.log('ğŸ”„ Calling loadDataFromHelper...');
          loadDataFromHelper();
          console.log('âœ… loadDataFromHelper completed');
        }
        
        // Method 2: Explicitly refresh damage centers section
        if (typeof loadDamageCentersFromHelper === 'function') {
          console.log('ğŸ”„ Explicitly refreshing damage centers...');
          console.log('ğŸ” DEBUG: helper.centers before refresh:', window.helper?.centers?.length);
          // Force reload of localStorage helper first
          const refreshedHelper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          window.helper = refreshedHelper;
          loadDamageCentersFromHelper(window.helper);
          console.log('âœ… Damage centers refreshed');
        }
        
        // Method 3: Force a UI refresh by triggering change events
        setTimeout(() => {
          console.log('ğŸ”„ Triggering final UI refresh...');
          // Trigger any change listeners that might refresh the display
          const helper = window.helper || {};
          window.helper = helper;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          // Dispatch custom event to notify other components
          window.dispatchEvent(new CustomEvent('invoiceAccepted', { 
            detail: { 
              helper: helper,
              updatedCenters: helper.centers 
            } 
          }));
        }, 500);
        
        // Different messages based on report type
        const currentReportType2 = helper.final_report?.type || helper.final_report?.dropdown_type || 
                                document.querySelector('input[name="final-report-type"]:checked')?.value;
        
        if (currentReportType2 === '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª') {
          alert('×”×§×¦××ª ×—×©×‘×•× ×™×•×ª ×”×•×©×œ××” ×‘×”×¦×œ×—×”! × ×ª×•× ×™ ×”×—×©×‘×•× ×™×•×ª × ×•×¡×¤×• ×œ××¨×›×–×™ ×”× ×–×§.');
        } else {
          alert('×”×§×¦××ª ×—×©×‘×•× ×™×•×ª ×”×•×©×œ××” ×‘×”×¦×œ×—×”! × ×ª×•× ×™ ×”×—×©×‘×•× ×™×•×ª ×–××™× ×™× ×›×¢×ª ×‘×¨×©×™××•×ª ×”× ×¤×ª×—×•×ª ×œ×•×¡×¤×” ×™×“× ×™×ª.');
        }
        
      } catch (error) {
        console.error('âŒ SESSION 88: Error accepting invoice assignment:', error);
        alert('×©×’×™××” ×‘×¢×™×‘×•×“ ×”×§×¦××ª ×—×©×‘×•× ×™×•×ª');
        
        // Reset button state
        const acceptBtn = document.getElementById('acceptInvoiceAssignment');
        if (acceptBtn) {
          acceptBtn.disabled = false;
          acceptBtn.textContent = '××©×¨ ×”×§×¦××ª ×—×©×‘×•× ×™×•×ª';
        }
      }
    };

    /**
     * Get selected invoices from checkboxes
     */
    window.getSelectedInvoices = function getSelectedInvoices() {
      console.log('ğŸ” DEBUG: getSelectedInvoices called');
      const checkboxes = document.querySelectorAll('[data-invoice-id]:checked');
      console.log('ğŸ” DEBUG: Found checkboxes:', checkboxes.length);
      const selectedIds = Array.from(checkboxes).map(cb => cb.getAttribute('data-invoice-id'));
      console.log('ğŸ” DEBUG: Selected IDs:', selectedIds);
      console.log('ğŸ” DEBUG: Available invoices:', window.availableInvoices);
      
      const filtered = (window.availableInvoices || []).filter(invoice => 
        selectedIds.includes(invoice.id)
      );
      console.log('ğŸ” DEBUG: Filtered invoices:', filtered);
      return filtered;
    };

    /**
     * Archive entire helper before invoice assignment (one-time per case)
     */
    async function archiveEntireHelper() {
      const helper = window.helper || {};
      
      // Check if archive already exists for this case
      if (helper.parts_search?.has_archived) {
        console.log('â„¹ï¸ SESSION 90: Archive already exists - skipping duplicate archive');
        return;
      }
      
      if (!helper.centers || helper.centers.length === 0) {
        console.log('â„¹ï¸ SESSION 90: No centers to archive');
        return;
      }
      
      try {
        // Create a clean snapshot of damage centers before invoice data is applied
        const centersSnapshot = JSON.parse(JSON.stringify(helper.centers));
        
        // Clean up any existing invoice data from the snapshot (keep only wizard data)
        centersSnapshot.forEach(center => {
          // Remove any existing InvoiceAssignments (legacy)
          if (center.InvoiceAssignments) {
            delete center.InvoiceAssignments;
            console.log(`ğŸ§¹ Removed legacy InvoiceAssignments from center ${center.Id}`);
          }
          
          // Remove any parts/works/repairs that have source: 'invoice'
          if (center.Parts?.parts_required) {
            const originalCount = center.Parts.parts_required.length;
            center.Parts.parts_required = center.Parts.parts_required.filter(part => 
              part.source !== 'invoice'
            );
            if (originalCount !== center.Parts.parts_required.length) {
              console.log(`ğŸ§¹ Cleaned ${originalCount - center.Parts.parts_required.length} invoice parts from center ${center.Id}`);
            }
          }
          if (center.Works?.works) {
            const originalCount = center.Works.works.length;
            center.Works.works = center.Works.works.filter(work => 
              work.source !== 'invoice'
            );
            if (originalCount !== center.Works.works.length) {
              console.log(`ğŸ§¹ Cleaned ${originalCount - center.Works.works.length} invoice works from center ${center.Id}`);
            }
          }
          if (center.Repairs?.repairs) {
            const originalCount = center.Repairs.repairs.length;
            center.Repairs.repairs = center.Repairs.repairs.filter(repair => 
              repair.source !== 'invoice'
            );
            if (originalCount !== center.Repairs.repairs.length) {
              console.log(`ğŸ§¹ Cleaned ${originalCount - center.Repairs.repairs.length} invoice repairs from center ${center.Id}`);
            }
          }
        });
        
        // Create archive data with clean snapshot
        const archiveData = {
          ...helper,
          centers: centersSnapshot,
          archive_metadata: {
            type: 'pre_invoice_snapshot',
            purpose: 'legal_work_trail',
            centers_count: centersSnapshot.length,
            created_before: 'invoice_acceptance',
            wizard_data_only: true,
            timestamp: new Date().toISOString()
          }
        };
        
        // Save clean snapshot using the existing version saving system
        if (typeof window.saveHelperVersion === 'function') {
          await window.saveHelperVersion('Pre-Invoice Centers Snapshot (Clean)', {
            trigger_event: 'before_invoice_acceptance',
            is_pre_invoice_wizard: true,
            centers_count: centersSnapshot.length,
            notes: 'Clean snapshot of damage centers before invoice data application - wizard data only for legal work trail'
          }, archiveData);
          
          // Mark as archived to prevent duplicate archives
          if (!helper.parts_search) helper.parts_search = {};
          helper.parts_search.has_archived = true;
          
          console.log('âœ… SESSION 90: Clean centers snapshot archived for legal work trail');
          console.log(`ğŸ“‹ Archived ${centersSnapshot.length} centers with wizard data only`);
        } else {
          console.warn('âš ï¸ SESSION 90: saveHelperVersion not available, skipping archive');
        }
        
      } catch (error) {
        console.error('âŒ SESSION 90: Error creating centers snapshot:', error);
        // Don't throw - this shouldn't block the invoice assignment process
      }
    }

    /**
     * Archive parts_search.required_parts before invoice import
     */
    async function archivePartsSearchData() {
      try {
        console.log('ğŸ“¦ SESSION 88: Archiving parts_search.required_parts...');
        
        const helper = window.helper || {};
        
        if (!helper.parts_search?.required_parts || helper.parts_search.required_parts.length === 0) {
          console.log('â„¹ï¸ SESSION 88: No parts_search.required_parts to archive');
          return;
        }
        
        const partsCount = helper.parts_search.required_parts.length;
        console.log(`ğŸ“‹ SESSION 88: Archiving ${partsCount} parts from parts_search.required_parts`);
        
        // Calculate total value of parts being archived
        const totalPartsValue = helper.parts_search.required_parts.reduce((sum, part) => {
          return sum + (parseFloat(part.total_cost) || 0);
        }, 0);
        
        // Archive parts data to Supabase using required_parts_archive table
        if (window.supabase) {
          try {
            console.log('ğŸ“¦ SESSION 88: Archiving parts to required_parts_archive table...');
            
            // Prepare archive records from parts_search.required_parts
            const archiveRecords = helper.parts_search.required_parts.map(part => {
              // Ensure all records have exactly the same structure
              const baseRecord = {
                // Archive metadata
                archive_type: 'pre_invoice_assignment',
                archive_reason: 'Parts archived before invoice assignment to preserve wizard data',
                archived_by: helper.user?.id || null,
                
                // Case identification
                case_id: helper.case_info?.supabase_case_id || null,
                plate: helper.case_info?.plate || null,
                damage_center_code: part.damage_center_code || null,
                
                // Part information
                part_name: part.part_name || null,
                quantity: part.quantity || 1,
                status: 'ARCHIVED',
                metadata: {
                  source: 'parts_search.required_parts',
                  original_status: part.status || null,
                  session: 'SESSION_88',
                  ...(part.metadata || {})
                },
                
                // Vehicle information
                make: part.make || helper.vehicle?.make || null,
                model: part.model || helper.vehicle?.model || null,
                trim: part.trim || helper.vehicle?.trim || null,
                year: part.year || helper.vehicle?.year || null,
                engine_volume: part.engine_volume || helper.vehicle?.engine_volume || null,
                engine_code: part.engine_code || helper.vehicle?.engine_code || null,
                engine_type: part.engine_type || helper.vehicle?.engine_type || null,
                vin: part.vin || helper.vehicle?.vin || null,
                
                // Part details
                pcode: part.pcode || null,
                cat_num_desc: part.cat_num_desc || null,
                source: part.source || null,
                oem: part.oem || null,
                availability: part.availability || null,
                location: part.location || null,
                comments: part.comments || null,
                supplier_name: part.supplier_name || null,
                part_family: part.part_family || null,
                description: part.description || null,
                
                // Pricing (ensure consistent types)
                price_per_unit: part.price_per_unit ? parseFloat(part.price_per_unit) : null,
                reduction_percentage: part.reduction_percentage ? parseFloat(part.reduction_percentage) : 0,
                wear_percentage: part.wear_percentage ? parseFloat(part.wear_percentage) : 0,
                updated_price: part.updated_price ? parseFloat(part.updated_price) : null,
                total_cost: part.total_cost ? parseFloat(part.total_cost) : null,
                
                // Original identifiers
                original_row_uuid: part.row_uuid || null,
                original_created_at: part.created_at || null,
                original_updated_at: part.updated_at || null,
                original_created_by: part.created_by || null,
                original_updated_by: part.updated_by || null
              };
              
              return baseRecord;
            });
            
            if (archiveRecords.length > 0) {
              console.log('ğŸ” SESSION 88: Archive records structure:', {
                count: archiveRecords.length,
                firstRecord: archiveRecords[0],
                allKeysMatch: archiveRecords.every(record => 
                  Object.keys(record).length === Object.keys(archiveRecords[0]).length
                )
              });
              
              const { data: archiveData, error: archiveError } = await window.supabase
                .from('required_parts_archive')
                .insert(archiveRecords)
                .select();
              
              if (archiveError) {
                console.error('âŒ SESSION 88: Error archiving to Supabase:', archiveError);
                console.log('ğŸ” Debug: Failed record structure:', archiveRecords[0]);
              } else {
                console.log(`âœ… SESSION 88: ${archiveData.length} parts archived to required_parts_archive table`);
              }
            } else {
              console.log('â„¹ï¸ SESSION 88: No parts to archive');
            }
            
          } catch (supabaseError) {
            console.error('âŒ SESSION 88: Supabase archive failed:', supabaseError);
          }
        } else {
          console.log('â„¹ï¸ SESSION 88: Supabase not available for parts archive');
        }
        
        // Also save version using existing version saving system for redundancy
        if (typeof window.saveHelperVersion === 'function') {
          await window.saveHelperVersion('Pre-Invoice Parts Archive', {
            trigger_event: 'parts_archive_before_invoice',
            archive_type: 'parts_search_required_parts',
            parts_count: partsCount,
            total_parts_value: totalPartsValue,
            notes: 'parts_search.required_parts archived before invoice assignment'
          });
          
          console.log('âœ… SESSION 88: Parts also archived to helper_versions for redundancy');
        }
        
        console.log(`âœ… SESSION 88: Successfully archived ${partsCount} parts (â‚ª${totalPartsValue.toLocaleString()})`);
        
      } catch (error) {
        console.error('âŒ SESSION 88: Error archiving parts_search data:', error);
        // Don't throw - this shouldn't block the invoice assignment process
      }
    }

    /**
     * Convert invoice mappings to helper format (no calculations - UI handles those)
     */
    async function convertInvoiceMappingsToHelperFormat(selectedInvoices) {
      try {
        console.log('ğŸ”„ SESSION 88: Converting invoice mappings to helper format...');
        console.log('ğŸ“‹ Selected invoices:', selectedInvoices);
        
        const helper = window.helper || {};
        console.log('ğŸ” Helper case_info:', helper.case_info);
        
        // Enhanced case_id detection with multiple fallbacks
        const caseId = helper.case_info?.supabase_case_id || 
                      helper.case_info?.case_id || 
                      helper.meta?.case_id || 
                      helper.case_id;
        console.log('ğŸ” Case ID:', caseId);
        
        // TASK 2 & 3: Check report type and handle accordingly (SESSION 91 FIX)
        const currentReportType = helper.final_report?.type || helper.final_report?.dropdown_type || 
                                document.querySelector('input[name="final-report-type"]:checked')?.value;
        console.log('ğŸ” Current report type:', currentReportType);
        
        // For ALL report types, ensure centers_archive exists
        if (!helper.centers_archive) {
          console.error('âŒ SESSION 91: centers_archive not found! This should have been created earlier');
          // Try to create it now as fallback
          if (helper.centers) {
            helper.centers_archive = JSON.parse(JSON.stringify(helper.centers));
            console.log('âš ï¸ Created centers_archive as fallback');
          }
        }
        
        // TASK 3: For Private reports - CLEAR existing damage center data
        if (currentReportType === '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª') {
          console.log('ğŸ§¹ SESSION 91: Private report - CLEARING damage center data before populating from invoice');
          
          // Clear parts, works, and repairs from ALL centers
          if (helper.centers && Array.isArray(helper.centers)) {
            helper.centers.forEach((center, idx) => {
              console.log(`ğŸ§¹ Clearing center ${idx + 1}: ${center.Id || center.Location}`);
              
              // Clear parts
              if (center.Parts && center.Parts.parts_required) {
                const partsBefore = center.Parts.parts_required.length;
                center.Parts.parts_required = [];
                console.log(`  - Cleared ${partsBefore} parts`);
              }
              
              // Clear works
              if (center.Works && center.Works.works) {
                const worksBefore = center.Works.works.length;
                center.Works.works = [];
                console.log(`  - Cleared ${worksBefore} works`);
              }
              
              // Clear repairs
              if (center.Repairs && center.Repairs.repairs) {
                const repairsBefore = center.Repairs.repairs.length;
                center.Repairs.repairs = [];
                console.log(`  - Cleared ${repairsBefore} repairs`);
              }
            });
          }
          
          console.log('âœ… Private report - damage centers cleared, ready for invoice data');
        } else {
          console.log('â„¹ï¸ Report type is not Private - will load data to dropdowns only');
          console.log('â„¹ï¸ Centers will display from centers_archive');
          
          // SESSION 91 FIX: For non-private reports, we need to ensure the UI uses the archive
          // The archive preserves the wizard data while invoice data goes to dropdowns only
          if (helper.centers_archive) {
            console.log('ğŸ“¦ SESSION 91: Non-private report - UI will read from centers_archive');
            console.log('ğŸ“‹ Archive has', helper.centers_archive.length, 'centers preserved from wizard');
            
            // Save helper to ensure centers_archive is available for UI
            sessionStorage.setItem('helper', JSON.stringify(helper));
            window.helper = helper;
          }
          
          // Load invoice data into global scope for dropdown access
          await prepareInvoiceDataForDropdowns(selectedInvoices, caseId);
          return; // Exit early for non-private reports
        }
        
        console.log('ğŸ” DEBUG: helper.centers AFTER clearing:', helper.centers);
        
        if (!caseId) {
          console.error('âŒ No case_id found in helper');
          throw new Error('No case_id found in helper');
        }
        
        if (!window.supabase) {
          console.error('âŒ Supabase not available');
          throw new Error('Supabase not available');
        }
        
        if (!helper.centers) {
          console.log('âš ï¸ No helper.centers found, initializing empty array');
          helper.centers = [];
        }
        console.log('ğŸ” Current helper.centers count:', helper.centers.length);
        
        for (const invoice of selectedInvoices) {
          console.log(`ğŸ“‹ Processing mappings for invoice ${invoice.invoice_number}...`);
          
          // Get all mappings for this invoice from invoice_damage_center_mappings table
          console.log(`ğŸ” Querying mappings for invoice_id: ${invoice.id}, case_id: ${caseId}`);
          
          const { data: mappings, error } = await window.supabase
            .from('invoice_damage_center_mappings')
            .select(`
              *,
              invoice_line:invoice_lines!inner(*)
            `)
            .eq('invoice_id', invoice.id)
            .eq('case_id', caseId)
            .eq('mapping_status', 'pending');  // Only get pending mappings
          
          console.log(`ğŸ“‹ Query result - mappings:`, mappings, 'error:', error);

          // ADD ENHANCED DEBUG BLOCK:
          if (!mappings || mappings.length === 0) {
            console.warn(`âš ï¸ No PENDING mappings found for invoice ${invoice.invoice_number}`);
            
            // Debug: Check what mappings exist for this case/invoice without status filter
            console.log(`ğŸ” DEBUG: Checking ALL mappings for invoice ${invoice.id}...`);
            const { data: allMappings } = await window.supabase
              .from('invoice_damage_center_mappings')
              .select('*')
              .eq('invoice_id', invoice.id)
              .eq('case_id', caseId);
            console.log(`ğŸ” DEBUG: All mappings found:`, allMappings);
            
            // Debug: Check mappings for this case with any status
            const { data: caseMappings } = await window.supabase
              .from('invoice_damage_center_mappings')
              .select('*')
              .eq('case_id', caseId);
            console.log(`ğŸ” DEBUG: All mappings for case ${caseId}:`, caseMappings);
            
            continue;
          }
          
          if (error) {
            console.error('âŒ Error fetching mappings:', error);
            continue;
          }
          
          if (!mappings || mappings.length === 0) {
            console.warn(`âš ï¸ No mappings found for invoice ${invoice.invoice_number}`);
            
            // Debug: Check what mappings exist for this case/invoice without status filter
            console.log(`ğŸ” DEBUG: Checking ALL mappings for invoice ${invoice.id}...`);
            const { data: allMappings } = await window.supabase
              .from('invoice_damage_center_mappings')
              .select('*')
              .eq('invoice_id', invoice.id)
              .eq('case_id', caseId);
            console.log(`ğŸ” DEBUG: All mappings found:`, allMappings);
            
            continue;
          }
          
          console.log(`ğŸ“Š Found ${mappings.length} mappings for invoice ${invoice.invoice_number}:`, mappings);
          console.log(`ğŸ” Available centers in helper.centers:`, helper.centers?.map(c => ({ Id: c.Id, name: c.Description || c.Location })));
          
          // Convert each mapping to UI format and add to helper.centers
          mappings.forEach((mapping, index) => {
            console.log(`ğŸ”„ Processing mapping ${index + 1}/${mappings.length}:`, mapping);
            
            const centerCode = mapping.damage_center_code || mapping.damage_center_id;
            const center = helper.centers?.find(c => 
              c.Id === centerCode || c.code === centerCode || c.damage_center_code === centerCode
            );
            
            console.log(`ğŸ” Looking for center '${centerCode}', found:`, center);
            
            if (!center) {
              console.warn(`âš ï¸ Center ${centerCode} not found in helper.centers`);
              console.log(`Available center IDs:`, helper.centers?.map(c => c.Id));
              return;
            }
            
            // Convert mapping to UI format based on field_type (no calculations)
            console.log(`ğŸ”§ Converting ${mapping.field_type} mapping to UI format for center ${centerCode}`);
            
            switch (mapping.field_type) {
              case 'part':
                const partItem = convertMappingToPart(mapping, invoice);
                if (!center.Parts) center.Parts = { parts_required: [] };
                if (!center.Parts.parts_required) center.Parts.parts_required = [];
                
                // ADD ENHANCED DEBUG:
                console.log(`ğŸ” DEBUG: BEFORE adding part - center ${centerCode} has ${center.Parts.parts_required.length} parts`);
                center.Parts.parts_required.push(partItem);
                console.log(`ğŸ” DEBUG: AFTER adding part - center ${centerCode} has ${center.Parts.parts_required.length} parts`);
                console.log(`ğŸ” DEBUG: Added part:`, partItem);
                
                console.log(`âœ… Added part to center. Total parts now: ${center.Parts.parts_required.length}`);
                break;
                
              case 'work':
                const workItem = convertMappingToWork(mapping, invoice);
                if (!center.Works) center.Works = { works: [] };
                if (!center.Works.works) center.Works.works = [];
                center.Works.works.push(workItem);
                console.log(`âœ… Added work to center. Total works now: ${center.Works.works.length}`);
                break;
                
              case 'repair':
                const repairItem = convertMappingToRepair(mapping, invoice);
                if (!center.Repairs) center.Repairs = { repairs: [] };
                if (!center.Repairs.repairs) center.Repairs.repairs = [];
                center.Repairs.repairs.push(repairItem);
                console.log(`âœ… Added repair to center. Total repairs now: ${center.Repairs.repairs.length}`);
                break;
            }
          });
        }
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        console.log('ğŸ” SESSION 91: Final centers state before UI refresh:');
        console.log('  - Total centers:', helper.centers.length);
        helper.centers.forEach((center, idx) => {
          console.log(`  - Center ${idx}: Parts=${center.Parts?.parts_required?.length || 0}, Works=${center.Works?.works?.length || 0}, Repairs=${center.Repairs?.repairs?.length || 0}`);
        });
        
        // SESSION 91 FIX: Force UI refresh for private reports
        if (currentReportType === '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª') {
          console.log('ğŸ”„ SESSION 91: Private report - forcing damage centers refresh with invoice data');
          
          // Method 1: Direct call to loadDamageCentersFromHelper
          if (typeof loadDamageCentersFromHelper === 'function') {
            console.log('ğŸ”„ Calling loadDamageCentersFromHelper directly...');
            loadDamageCentersFromHelper(helper);
          }
          
          // Method 2: Try loadDataFromHelper
          if (typeof loadDataFromHelper === 'function') {
            console.log('ğŸ”„ Calling loadDataFromHelper...');
            loadDataFromHelper();
          }
          
          // SESSION 92 FIX: Also prepare invoice data for dropdowns (private reports need it too)
          console.log('ğŸ“‹ SESSION 92: Preparing invoice data for dropdowns (private report)...');
          await prepareInvoiceDataForDropdowns(selectedInvoices, caseId);
          
          // SESSION 93: Create centers_after_invoice snapshot for private reports
          console.log('ğŸ“¸ SESSION 93: Creating centers_after_invoice snapshot...');
          if (helper.centers && helper.centers.length > 0) {
            helper.centers_after_invoice = JSON.parse(JSON.stringify(helper.centers));
            helper.centers_after_invoice_meta = {
              created_at: new Date().toISOString(),
              report_type: currentReportType,
              centers_count: helper.centers.length,
              purpose: 'preserve_invoice_populated_data_for_private_reports'
            };
            
            // Save to sessionStorage and window
            sessionStorage.setItem('helper', JSON.stringify(helper));
            window.helper = helper;
            
            console.log(`âœ… Created centers_after_invoice with ${helper.centers.length} centers (invoice data)`);
          }
          
        } else {
          // For non-private reports, just ensure the data is saved
          console.log('â„¹ï¸ Non-private report - data saved for dropdown access');
        }
        
        console.log('âœ… SESSION 88: Invoice mappings applied to damage centers');
        
      } catch (error) {
        console.error('âŒ SESSION 88: Error applying invoice mappings:', error);
        throw error;
      }
    }

    /**
     * Prepare invoice data for dropdown access (non-private reports)
     * Similar to loadPartsFromSupabase but for invoice data
     */
    async function prepareInvoiceDataForDropdowns(selectedInvoices, caseId) {
      try {
        console.log('ğŸ”„ SESSION 94: Preparing invoice data for dropdown access...');
        console.log('ğŸ“‹ Selected invoices:', selectedInvoices);
        console.log('ğŸ” Case ID:', caseId);
        
        if (!window.supabase) {
          console.error('âŒ Supabase not available');
          return;
        }
        
        if (!caseId) {
          console.error('âŒ No case_id provided');
          return;
        }
        
        if (!selectedInvoices || !Array.isArray(selectedInvoices) || selectedInvoices.length === 0) {
          console.log('âš ï¸ No valid selectedInvoices provided - skipping invoice lines loading');
          console.log('ğŸ” selectedInvoices value:', selectedInvoices);
          
          // Initialize empty structure to prevent errors elsewhere
          window.invoiceDataForDropdowns = {
            invoices: [],
            mappings: [],
            invoice_lines: [],
            prepared_at: new Date().toISOString()
          };
          return;
        }
        
        // Initialize global invoice data structure
        window.invoiceDataForDropdowns = {
          invoices: selectedInvoices,
          mappings: [],
          invoice_lines: [],
          prepared_at: new Date().toISOString()
        };
        
        // SESSION 94 FIX: Load invoice lines with proper UUID validation
        console.log('ğŸ” DEBUGGING selectedInvoices structure:');
        selectedInvoices.forEach((invoice, idx) => {
          console.log(`Invoice ${idx}:`, {
            invoice_number: invoice.invoice_number,
            id: invoice.id,
            uuid: invoice.uuid,
            invoice_uuid: invoice.invoice_uuid,
            case_id: invoice.case_id,
            plate: invoice.plate,
            allKeys: Object.keys(invoice)
          });
        });
        
        for (const invoice of selectedInvoices) {
          console.log(`ğŸ“‹ Processing invoice ${invoice.invoice_number}...`);
          
          // SESSION 94 FIX: Try multiple UUID field possibilities
          const invoiceUuid = invoice.id || invoice.uuid || invoice.invoice_uuid;
          const invoicePlate = invoice.plate;
          const invoiceCaseId = invoice.case_id;
          
          console.log('ğŸ” Invoice UUID identification:', {
            invoice_number: invoice.invoice_number,
            id: invoice.id,
            uuid: invoice.uuid, 
            invoice_uuid: invoice.invoice_uuid,
            selected_uuid: invoiceUuid,
            plate: invoicePlate,
            case_id: invoiceCaseId
          });
          
          if (!invoiceUuid) {
            console.log(`âš ï¸ Skipping invoice ${invoice.invoice_number} - no valid UUID found`);
            console.log('ğŸ” Full invoice object:', invoice);
            continue;
          }
          
          // Validate UUID format
          const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
          if (!uuidRegex.test(invoiceUuid)) {
            console.log(`âš ï¸ Skipping invoice ${invoice.invoice_number} - invalid UUID format:`, invoiceUuid);
            continue;
          }
          
          console.log(`âœ… Loading invoice lines for invoice ${invoice.invoice_number} with UUID: ${invoiceUuid}`);
          
          // Load ALL invoice lines for dropdown (not just mapped ones)
          const { data: invoiceLines, error: linesError } = await window.supabase
            .from('invoice_lines')
            .select('*')
            .eq('invoice_id', invoiceUuid);
          
          if (linesError) {
            console.error(`âŒ Error loading invoice lines:`, linesError);
            continue;
          }
          
          if (invoiceLines && invoiceLines.length > 0) {
            console.log(`âœ… Loaded ${invoiceLines.length} invoice lines for invoice ${invoice.invoice_number}`);
            window.invoiceDataForDropdowns.invoice_lines.push(...invoiceLines);
          }
          
          // Also load mappings for reference (but not for dropdown data)
          const { data: mappings, error: mappingsError } = await window.supabase
            .from('invoice_damage_center_mappings')
            .select('*')
            .eq('invoice_id', invoice.id)
            .eq('case_id', caseId)
            .eq('mapping_status', 'pending');
          
          if (mappings && mappings.length > 0) {
            console.log(`ğŸ“‹ Found ${mappings.length} pending mappings`);
            window.invoiceDataForDropdowns.mappings.push(...mappings);
          }
        }
        
        // Store data in helper structure as well for easy access
        const helper = window.helper || {};
        if (!helper.invoices) {
          helper.invoices = [];
        }
        
        // SESSION 91 FIX: Update helper with actual invoice lines
        selectedInvoices.forEach(invoice => {
          const existingInvoice = helper.invoices.find(inv => inv.id === invoice.id);
          // Get the invoice lines we loaded
          const invoiceLines = window.invoiceDataForDropdowns.invoice_lines
            .filter(line => line.invoice_id === invoice.id);
          
          if (existingInvoice) {
            // Update existing
            existingInvoice.line_items = invoiceLines;
            console.log(`ğŸ“‹ Updated existing invoice with ${invoiceLines.length} lines`);
          } else {
            // Add new
            helper.invoices.push({
              ...invoice,
              line_items: invoiceLines
            });
            console.log(`ğŸ“‹ Added new invoice with ${invoiceLines.length} lines`);
          }
        });
        
        // Update helper
        window.helper = helper;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log(`âœ… SESSION 90: Invoice data prepared for dropdowns:`);
        console.log(`  ğŸ“Š Total mappings: ${window.invoiceDataForDropdowns.mappings.length}`);
        console.log(`  ğŸ“‹ Total invoice lines: ${window.invoiceDataForDropdowns.invoice_lines.length}`);
        console.log(`  ğŸ§¾ Invoices in helper: ${helper.invoices.length}`);
        
      } catch (error) {
        console.error('âŒ SESSION 90: Error preparing invoice data for dropdowns:', error);
      }
    }

    /**
     * Save updated helper to Supabase and sessionStorage
     */
    async function saveUpdatedHelper() {
      try {
        console.log('ğŸ’¾ SESSION 88: Saving updated helper...');
        
        const helper = window.helper || {};
        
        if (!helper.centers || helper.centers.length === 0) {
          console.log('â„¹ï¸ SESSION 88: No centers to save');
          return;
        }
        
        // Update sessionStorage first
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        console.log('âœ… Updated helper in sessionStorage');
        
        // Save to case_helper table (correct structure)
        if (window.supabase && helper.case_info?.supabase_case_id) {
          const caseId = helper.case_info.supabase_case_id;
          
          // Update current helper in case_helper table
          const { error } = await window.supabase
            .from('case_helper')
            .update({ 
              helper_json: helper,
              updated_at: new Date().toISOString()
            })
            .eq('case_id', caseId)
            .eq('is_current', true);
          
          if (error) {
            console.error('âŒ Error saving helper to case_helper:', error);
          } else {
            console.log('âœ… Helper saved to case_helper table');
          }
        } else {
          console.log('â„¹ï¸ Supabase not available or no case_id - only saved to sessionStorage');
        }
        
        // Note: Version creation is handled by the normal auto-save system
        // No need to create additional versions here to avoid duplicates
        
        console.log(`âœ… SESSION 88: Saved ${helper.centers.length} updated centers`);
        
      } catch (error) {
        console.error('âŒ SESSION 88: Error saving updated damage centers:', error);
        // Don't throw - this shouldn't block the assignment process
      }
    }

    /**
     * Update mapping status for invoice tracking (instead of invoice 'PAID' status)
     */
    async function updateMappingStatus(invoices, status) {
      if (!window.supabase) {
        console.warn('âš ï¸ SESSION 88: Supabase not available for mapping status update');
        return;
      }
      
      const helper = window.helper || {};
      const caseId = helper.case_info?.supabase_case_id;
      
      if (!caseId) {
        console.warn('âš ï¸ SESSION 88: No case_id found for mapping status update');
        return;
      }
      
      const invoiceIds = invoices.map(i => i.id);
      
      // Update mapping status for each invoice
      for (const invoiceId of invoiceIds) {
        const { error } = await window.supabase
          .from('invoice_damage_center_mappings')
          .update({ 
            mapping_status: status,
            updated_at: new Date().toISOString()
          })
          .eq('invoice_id', invoiceId)
          .eq('case_id', caseId);
        
        if (error) {
          console.error(`âŒ Error updating mapping status for invoice ${invoiceId}:`, error);
        } else {
          console.log(`âœ… Updated mapping status to '${status}' for invoice ${invoiceId}`);
        }
      }
      
      console.log(`âœ… SESSION 88: Updated mapping status for ${invoiceIds.length} invoices to '${status}'`);
    }

    /**
     * Update invoice status from ASSIGNED to ACCEPTED (completing the status flow)
     */
    async function updateInvoiceStatusToAccepted(invoices) {
      if (!window.supabase) {
        console.warn('âš ï¸ SESSION 90: Supabase not available for invoice status update');
        return;
      }
      
      const invoiceIds = invoices.map(i => i.id);
      
      // Update invoice status for each invoice
      for (const invoiceId of invoiceIds) {
        const { error } = await window.supabase
          .from('invoices')
          .update({ 
            status: 'ACCEPTED',  // Final status - assignment workflow complete
            updated_at: new Date().toISOString()
          })
          .eq('id', invoiceId)
          .eq('status', 'ASSIGNED');  // Only update if currently ASSIGNED
        
        if (error) {
          console.error(`âŒ Error updating invoice status for invoice ${invoiceId}:`, error);
        } else {
          console.log(`âœ… Updated invoice status to 'ACCEPTED' for invoice ${invoiceId}`);
        }
      }
      
      console.log(`âœ… SESSION 90: Updated invoice status for ${invoiceIds.length} invoices from 'ASSIGNED' to 'ACCEPTED'`);
    }

    /**
     * Convert mapping to part format (follows UI structure exactly)
     */
    function convertMappingToPart(mapping, invoice) {
      const helper = window.helper || {};
      
      // SESSION 91 FIX: Use data from original_field_data JSON
      console.log('ğŸ” DEBUG: Converting mapping to part:', mapping);
      const fieldData = mapping.original_field_data || {};
      console.log('ğŸ“‹ DEBUG: fieldData content:', fieldData);
      console.log('ğŸ“‹ DEBUG: unit_price:', fieldData.unit_price, 'line_total:', fieldData.line_total);
      
      return {
        row_uuid: window.generateUUID ? window.generateUUID() : 'part_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        case_id: helper.case_info?.supabase_case_id || mapping.case_id,
        plate: helper.case_info?.plate || fieldData.plate || '',
        damage_center_code: mapping.damage_center_id || mapping.damage_center_code,
        // Get data from original_field_data
        part_name: fieldData.description || '',
        description: fieldData.description || '',
        pcode: fieldData.catalog_code || '',
        oem: mapping.mapped_data?.oem || '',
        supplier_name: fieldData.supplier_name || invoice?.supplier_name || '',
        // Price data from original_field_data
        price_per_unit: fieldData.unit_price || 0,  // ××—×™×¨ - unit price only
        reduction_percentage: mapping.user_modifications?.reduction_percentage || 0,
        wear_percentage: mapping.user_modifications?.wear_percentage || 0,
        updated_price: fieldData.unit_price || 0,  // Unit price, not total
        total_cost: 0,  // Let UI calculate this from quantity Ã— price
        quantity: fieldData.quantity || 1,
        source: 'invoice',
        _invoice_line_id: mapping.invoice_line_id,
        _invoice_id: mapping.invoice_id,
        make: helper.vehicle?.make || '',
        model: helper.vehicle?.model || '',
        year: helper.vehicle?.year || '',
        ××—×™×¨: fieldData.unit_price || mapping.mapped_data?.updated_price || mapping.mapped_data?.unit_price || mapping.invoice_line?.unit_price || 0,
        ××™×§×•×: '×™×©×¨××œ',
        ×”×¢×¨×•×ª: mapping.user_modifications?.notes || '',
        ×–××™× ×•×ª: '×–××™×Ÿ',
        metadata: mapping.original_field_data || {},
        updated_at: new Date().toISOString()
      };
    }

    /**
     * Convert mapping to work format (follows UI structure exactly)
     */
    function convertMappingToWork(mapping, invoice) {
      // SESSION 91 FIX: Use data from original_field_data JSON
      console.log('ğŸ” DEBUG: Converting mapping to work:', mapping);
      const fieldData = mapping.original_field_data || {};
      
      return {
        category: fieldData.category || fieldData.description || '',  // Keep existing mapping, add description as fallback
        cost: fieldData.line_total || fieldData.unit_price || 0,
        comments: fieldData.description || fieldData.comments || '',  // ×”×¢×¨×•×ª should show description (with fallback to existing)
        added_at: new Date().toISOString(),
        source: 'invoice',
        _invoice_line_id: mapping.invoice_line_id,
        _invoice_id: mapping.invoice_id
      };
    }

    /**
     * Convert mapping to repair format (follows UI structure exactly)
     */
    function convertMappingToRepair(mapping, invoice) {
      // SESSION 91 FIX: Use data from original_field_data JSON
      console.log('ğŸ” DEBUG: Converting mapping to repair:', mapping);
      const fieldData = mapping.original_field_data || {};
      
      return {
        name: fieldData.description || '',  // ×©× ×”×ª×™×§×•×Ÿ shows description
        cost: fieldData.line_total || fieldData.unit_price || 0,
        description: '',  // Leave empty or add notes if needed
        hours: fieldData.quantity || 1,  // ×©×¢×•×ª shows quantity
        added_at: new Date().toISOString(),
        source: 'invoice',
        _invoice_line_id: mapping.invoice_line_id,
        _invoice_id: mapping.invoice_id
      };
    }

    /**
     * Calculate differentials between wizard and invoice data
     */
    async function calculateInvoiceDifferentials(invoices) {
      try {
        console.log('ğŸ“Š SESSION 88: Calculating invoice differentials...');
        
        const helper = window.helper || {};
        const differentials = [];
        
        // Get wizard data from helper.centers for comparison
        const wizardCenters = helper.centers || [];
        
        for (const invoice of invoices) {
          console.log(`ğŸ“„ Processing invoice ${invoice.invoice_number}...`);
          
          for (const line of invoice.lines || []) {
            const centerCode = line.metadata?.damage_center_code;
            if (!centerCode) continue;
            
            // Find corresponding wizard center
            const wizardCenter = wizardCenters.find(c => 
              c.Id === centerCode || c.code === centerCode
            );
            
            if (!wizardCenter) {
              // Invoice line has no corresponding wizard center
              differentials.push({
                type: 'new_invoice_item',
                center_code: centerCode,
                invoice_id: invoice.id,
                invoice_number: invoice.invoice_number,
                line_id: line.id,
                description: line.description,
                category: line.metadata?.category,
                invoice_amount: line.line_total || 0,
                wizard_amount: 0,
                difference: line.line_total || 0,
                status: 'invoice_only'
              });
              continue;
            }
            
            // Compare invoice line with wizard center data
            const differential = await compareInvoiceLineWithWizardData(
              line, wizardCenter, invoice
            );
            
            if (differential) {
              differentials.push(differential);
            }
          }
        }
        
        // Check for wizard items not in invoices
        wizardCenters.forEach(center => {
          const centerInvoiceLines = [];
          invoices.forEach(invoice => {
            invoice.lines?.forEach(line => {
              if (line.metadata?.damage_center_code === center.Id || 
                  line.metadata?.damage_center_code === center.code) {
                centerInvoiceLines.push(line);
              }
            });
          });
          
          if (centerInvoiceLines.length === 0) {
            // Wizard center has no corresponding invoice lines
            const wizardTotal = calculateWizardCenterTotal(center);
            if (wizardTotal > 0) {
              differentials.push({
                type: 'wizard_only_center',
                center_code: center.Id || center.code,
                center_description: center.name || center.description,
                invoice_amount: 0,
                wizard_amount: wizardTotal,
                difference: -wizardTotal,
                status: 'wizard_only'
              });
            }
          }
        });
        
        console.log(`ğŸ“Š SESSION 88: Found ${differentials.length} differentials`);
        return differentials;
        
      } catch (error) {
        console.error('âŒ SESSION 88: Error calculating differentials:', error);
        return [];
      }
    }

    /**
     * Compare invoice line with wizard center data
     */
    async function compareInvoiceLineWithWizardData(line, wizardCenter, invoice) {
      try {
        const lineCategory = line.metadata?.category;
        let wizardAmount = 0;
        let comparison = null;
        
        // Calculate wizard amount based on category
        switch (lineCategory) {
          case 'part':
            wizardAmount = calculateWizardPartsTotal(wizardCenter);
            comparison = 'parts';
            break;
          case 'work':
            wizardAmount = calculateWizardWorksTotal(wizardCenter);
            comparison = 'works';
            break;
          case 'repair':
            wizardAmount = calculateWizardRepairsTotal(wizardCenter);
            comparison = 'repairs';
            break;
          default:
            // Unknown category - treat as general
            wizardAmount = calculateWizardCenterTotal(wizardCenter);
            comparison = 'total';
        }
        
        const invoiceAmount = line.line_total || 0;
        const difference = invoiceAmount - wizardAmount;
        
        // Only create differential if there's a significant difference (> 1 â‚ª)
        if (Math.abs(difference) > 1) {
          return {
            type: 'amount_difference',
            center_code: wizardCenter.Id || wizardCenter.code,
            center_description: wizardCenter.name || wizardCenter.description,
            invoice_id: invoice.id,
            invoice_number: invoice.invoice_number,
            line_id: line.id,
            description: line.description,
            category: lineCategory,
            comparison_type: comparison,
            invoice_amount: invoiceAmount,
            wizard_amount: wizardAmount,
            difference: difference,
            status: difference > 0 ? 'invoice_higher' : 'wizard_higher'
          };
        }
        
        return null;
        
      } catch (error) {
        console.error('âŒ SESSION 88: Error comparing line with wizard:', error);
        return null;
      }
    }

    /**
     * Calculate total for wizard center parts
     */
    function calculateWizardPartsTotal(center) {
      try {
        if (!center.Parts?.parts_required) return 0;
        
        return center.Parts.parts_required.reduce((sum, part) => {
          return sum + (parseFloat(part.total_cost) || 0);
        }, 0);
      } catch (error) {
        console.error('âŒ Error calculating wizard parts total:', error);
        return 0;
      }
    }

    /**
     * Calculate total for wizard center works
     */
    function calculateWizardWorksTotal(center) {
      try {
        if (!center.Works?.works_required) return 0;
        
        return center.Works.works_required.reduce((sum, work) => {
          return sum + (parseFloat(work.total_cost) || 0);
        }, 0);
      } catch (error) {
        console.error('âŒ Error calculating wizard works total:', error);
        return 0;
      }
    }

    /**
     * Calculate total for wizard center repairs
     */
    function calculateWizardRepairsTotal(center) {
      try {
        if (!center.Repairs?.repairs_required) return 0;
        
        return center.Repairs.repairs_required.reduce((sum, repair) => {
          return sum + (parseFloat(repair.total_cost) || 0);
        }, 0);
      } catch (error) {
        console.error('âŒ Error calculating wizard repairs total:', error);
        return 0;
      }
    }

    /**
     * Calculate total cost for entire wizard center
     */
    function calculateWizardCenterTotal(center) {
      try {
        const partsTotal = calculateWizardPartsTotal(center);
        const worksTotal = calculateWizardWorksTotal(center);
        const repairsTotal = calculateWizardRepairsTotal(center);
        
        return partsTotal + worksTotal + repairsTotal;
      } catch (error) {
        console.error('âŒ Error calculating wizard center total:', error);
        return 0;
      }
    }

    /**
     * Display differentials in popup
     */
    function displayDifferentialsPopup(differentials) {
      try {
        console.log('ğŸ“Š SESSION 88: Displaying differentials popup...');
        
        if (differentials.length === 0) {
          alert('×œ× × ××¦××• ×”×¤×¨×©×™× ×‘×™×Ÿ × ×ª×•× ×™ ×”××©×£ ×œ×—×©×‘×•× ×™×•×ª');
          return;
        }
        
        // Create popup overlay
        const overlay = document.createElement('div');
        overlay.id = 'differentialsOverlay';
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.5);
          z-index: 10000;
          display: flex;
          justify-content: center;
          align-items: center;
        `;
        
        // Create popup content
        const popup = document.createElement('div');
        popup.style.cssText = `
          background: white;
          border-radius: 12px;
          padding: 20px;
          max-width: 90vw;
          max-height: 90vh;
          overflow-y: auto;
          box-shadow: 0 4px 20px rgba(0,0,0,0.3);
          direction: rtl;
          font-family: sans-serif;
        `;
        
        // Build popup HTML
        let popupHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #e0e0e0; padding-bottom: 15px;">
            <h2 style="margin: 0; color: #1565c0; font-size: 20px;">×”×¤×¨×©×™ ×—×©×‘×•× ×™×•×ª ××•×œ ××©×£</h2>
            <button onclick="document.getElementById('differentialsOverlay').remove()" style="
              background: none;
              border: none;
              font-size: 24px;
              cursor: pointer;
              color: #666;
              padding: 0;
              width: 30px;
              height: 30px;
              display: flex;
              align-items: center;
              justify-content: center;
            ">Ã—</button>
          </div>
          
          <div style="margin-bottom: 15px; font-size: 14px; color: #666;">
            × ××¦××• ${differentials.length} ×”×¤×¨×©×™× ×‘×™×Ÿ × ×ª×•× ×™ ×”××©×£ ×œ×—×©×‘×•× ×™×•×ª
          </div>
          
          <div style="max-height: 60vh; overflow-y: auto;">
        `;
        
        // Add each differential
        differentials.forEach((diff, index) => {
          const statusColor = diff.status === 'invoice_higher' ? '#ff5722' : 
                             diff.status === 'wizard_higher' ? '#2196f3' : 
                             diff.status === 'invoice_only' ? '#ff9800' :
                             diff.status === 'wizard_only' ? '#607d8b' : '#666';
          
          const statusText = diff.status === 'invoice_higher' ? '×—×©×‘×•× ×™×ª ×’×‘×•×”×”' :
                            diff.status === 'wizard_higher' ? '××©×£ ×’×‘×•×”' :
                            diff.status === 'invoice_only' ? '×¨×§ ×‘×—×©×‘×•× ×™×ª' :
                            diff.status === 'wizard_only' ? '×¨×§ ×‘××©×£' : '×”×¤×¨×©';
          
          popupHTML += `
            <div style="
              border: 1px solid #e0e0e0;
              border-radius: 8px;
              padding: 15px;
              margin-bottom: 10px;
              background: #fafafa;
            ">
              <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                <div>
                  <div style="font-weight: 600; color: #333; margin-bottom: 5px;">
                    ${diff.description || diff.center_description || '×¤×¨×™×˜ ×œ× ××–×•×”×”'}
                  </div>
                  <div style="font-size: 13px; color: #666;">
                    ××•×§×“: ${diff.center_code} | 
                    ${diff.invoice_number ? `×—×©×‘×•× ×™×ª: ${diff.invoice_number}` : ''} |
                    ×§×˜×’×•×¨×™×”: ${diff.category || '×›×œ×œ×™'}
                  </div>
                </div>
                <div style="
                  background: ${statusColor};
                  color: white;
                  padding: 4px 8px;
                  border-radius: 4px;
                  font-size: 12px;
                  font-weight: 600;
                ">
                  ${statusText}
                </div>
              </div>
              
              <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; font-size: 14px;">
                <div style="text-align: center; padding: 8px; background: white; border-radius: 4px;">
                  <div style="color: #666; font-size: 12px; margin-bottom: 2px;">×—×©×‘×•× ×™×ª</div>
                  <div style="font-weight: 600; color: #ff5722;">â‚ª${diff.invoice_amount.toLocaleString()}</div>
                </div>
                <div style="text-align: center; padding: 8px; background: white; border-radius: 4px;">
                  <div style="color: #666; font-size: 12px; margin-bottom: 2px;">××©×£</div>
                  <div style="font-weight: 600; color: #2196f3;">â‚ª${diff.wizard_amount.toLocaleString()}</div>
                </div>
                <div style="text-align: center; padding: 8px; background: white; border-radius: 4px;">
                  <div style="color: #666; font-size: 12px; margin-bottom: 2px;">×”×¤×¨×©</div>
                  <div style="font-weight: 600; color: ${diff.difference > 0 ? '#ff5722' : '#2196f3'};">
                    ${diff.difference > 0 ? '+' : ''}â‚ª${diff.difference.toLocaleString()}
                  </div>
                </div>
              </div>
            </div>
          `;
        });
        
        popupHTML += `
          </div>
          
          <div style="margin-top: 20px; text-align: center; border-top: 1px solid #e0e0e0; padding-top: 15px;">
            <button onclick="document.getElementById('differentialsOverlay').remove()" style="
              background: #6c757d;
              color: white;
              border: none;
              padding: 10px 20px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 14px;
            ">×¡×’×•×¨</button>
          </div>
        `;
        
        popup.innerHTML = popupHTML;
        overlay.appendChild(popup);
        document.body.appendChild(overlay);
        
        console.log('âœ… SESSION 88: Differentials popup displayed');
        
      } catch (error) {
        console.error('âŒ SESSION 88: Error displaying differentials popup:', error);
        alert('×©×’×™××” ×‘×”×¦×’×ª ×”×¤×¨×©×™×');
      }
    }

    // ============================================================================
    // SESSION 88: DEBUG AND TESTING FUNCTIONS
    // ============================================================================

    /**
     * Manual test function to force show banner with sample data
     */
    window.testInvoiceBanner = function() {
      const sampleInvoices = [
        {
          id: 'test-invoice-1',
          invoice_number: 'INV-001',
          supplier_name: '×¡×¤×§ ×œ×“×•×’××”',
          total_amount: 5000,
          status: 'pending_assignment',
          lines: [
            { id: 'line1', description: '×—×œ×§ ×“×•×’××”', line_total: 2500, metadata: { category: 'part' } },
            { id: 'line2', description: '×¢×‘×•×“×” ×“×•×’××”', line_total: 2500, metadata: { category: 'work' } }
          ]
        }
      ];
      
      console.log('ğŸ§ª SESSION 88: Testing banner with sample data');
      showInvoiceAssignmentBanner(sampleInvoices);
    };

    /**
     * Manual function to refresh invoice check
     */
    window.refreshInvoiceCheck = function() {
      console.log('ğŸ”„ SESSION 88: Manual refresh of invoice check');
      sessionStorage.removeItem('invoiceAssignmentDismissed');
      checkForAvailableInvoices();
    };

    /**
     * Debug function to show current helper invoice assignments
     */
    /**
     * Manual trigger for testing invoice banner
     */
    window.testInvoiceBanner = async function() {
      console.log('ğŸ§ª MANUAL TEST: Triggering invoice banner check...');
      console.log('ğŸ§ª MANUAL TEST: checkForAvailableInvoices function type:', typeof checkForAvailableInvoices);
      console.log('ğŸ§ª MANUAL TEST: Function available:', typeof checkForAvailableInvoices === 'function');
      console.log('ğŸ§ª MANUAL TEST: Function in window?', typeof window.checkForAvailableInvoices);
      console.log('ğŸ§ª MANUAL TEST: All functions in scope:', Object.getOwnPropertyNames(window).filter(name => name.includes('Invoice')));
      
      if (typeof checkForAvailableInvoices === 'function') {
        console.log('ğŸ§ª MANUAL TEST: Calling function...');
        await checkForAvailableInvoices();
      } else {
        console.error('âŒ MANUAL TEST: checkForAvailableInvoices function not available!');
        console.log('ğŸ§ª Trying to call as window.checkForAvailableInvoices...');
        if (typeof window.checkForAvailableInvoices === 'function') {
          await window.checkForAvailableInvoices();
        }
      }
    };

    window.debugInvoiceAssignments = async function() {
      const helper = window.helper || {};
      
      // Enhanced case_id detection with multiple fallbacks
      const caseId = helper.case_info?.supabase_case_id || 
                    helper.case_info?.case_id || 
                    helper.meta?.case_id || 
                    helper.case_id;
      
      console.log('ğŸ” SESSION 88 DEBUG REPORT:');
      console.log('  Case ID:', caseId);
      console.log('  Plate:', helper.meta?.plate || helper.vehicle?.plate || helper.car_details?.plate);
      console.log('  helper.final_report?.invoice_assignments:', helper.final_report?.invoice_assignments);
      console.log('  helper.invoices:', helper.invoices);
      console.log('  Number of invoices in helper:', helper.invoices?.length || 0);
      
      if (helper.invoices && helper.invoices.length > 0) {
        helper.invoices.forEach((invoice, index) => {
          console.log(`  Helper Invoice ${index + 1}:`, {
            id: invoice.id,
            invoice_number: invoice.invoice_number,
            supplier_name: invoice.supplier_name,
            status: invoice.status
          });
        });
      }
      
      // Check Supabase data
      if (window.supabase && caseId) {
        try {
          console.log('ğŸ” Checking Supabase invoices table...');
          const { data: allInvoices, error: invoicesError } = await window.supabase
            .from('invoices')
            .select('id, invoice_number, supplier_name, status, case_id')
            .eq('case_id', caseId);
          
          if (invoicesError) {
            console.error('âŒ Error querying invoices:', invoicesError);
          } else {
            console.log(`  Found ${allInvoices?.length || 0} invoices in Supabase for case_id ${caseId}:`, allInvoices);
          }
          
          console.log('ğŸ” Checking invoice_damage_center_mappings table...');
          const { data: mappings, error: mappingsError } = await window.supabase
            .from('invoice_damage_center_mappings')
            .select('invoice_id, mapping_status, case_id')
            .eq('case_id', caseId);
          
          if (mappingsError) {
            console.error('âŒ Error querying mappings:', mappingsError);
          } else {
            console.log(`  Found ${mappings?.length || 0} mappings in Supabase for case_id ${caseId}:`, mappings);
          }
        } catch (error) {
          console.error('âŒ Error in debug query:', error);
        }
      }
      
      return {
        invoice_assignments: helper.final_report?.invoice_assignments,
        invoices: helper.invoices,
        case_id: caseId,
        case_info: helper.case_info,
        plate: helper.meta?.plate || helper.vehicle?.plate || helper.car_details?.plate
      };
    };

    // Initialize on load - FIXED ORDER
    console.log('ğŸ” SCRIPT DEBUG: About to add DOMContentLoaded listener...');
    console.log('ğŸ” SCRIPT DEBUG: document.readyState:', document.readyState);
    
    // Test checkForAvailableInvoices function immediately
    console.log('ğŸ§ª IMMEDIATE TEST: checkForAvailableInvoices type:', typeof checkForAvailableInvoices);
    console.log('ğŸ§ª IMMEDIATE TEST: checkForAvailableInvoices exists:', typeof checkForAvailableInvoices === 'function');
    
    // Create immediate test function available globally
    window.immediateInvoiceTest = function() {
      console.log('ğŸ§ª MANUAL IMMEDIATE TEST: Starting...');
      console.log('ğŸ§ª checkForAvailableInvoices available:', typeof checkForAvailableInvoices === 'function');
      console.log('ğŸ§ª window.helper available:', !!window.helper);
      console.log('ğŸ§ª helper.case_info:', window.helper?.case_info);
      
      if (typeof checkForAvailableInvoices === 'function') {
        console.log('ğŸ§ª Calling checkForAvailableInvoices now...');
        checkForAvailableInvoices().catch(e => console.error('ğŸ§ª Error:', e));
      } else {
        console.error('ğŸ§ª Function not available yet');
      }
    };
    
    // Create a persistent checker that runs until it succeeds
    let invoiceCheckAttempts = 0;
    window.persistentInvoiceChecker = function() {
      invoiceCheckAttempts++;
      console.log(`ğŸ” PERSISTENT CHECK #${invoiceCheckAttempts}: Testing invoice system...`);
      
      // Check multiple sources for helper data
      const helperFromWindow = window.helper;
      const helperFromSession = (() => {
        try {
          return JSON.parse(sessionStorage.getItem('helper') || '{}');
        } catch(e) {
          return {};
        }
      })();
      
      // SESSION 90: Enhanced validation - check for essential data, not just case_info
      const activeHelper = helperFromWindow || helperFromSession;
      const hasSupabase = !!window.supabase;
      const hasValidHelper = activeHelper && Object.keys(activeHelper).length > 5;
      const hasPlateData = activeHelper?.meta?.plate || activeHelper?.car_details?.plate || activeHelper?.vehicle?.plate;
      const hasCaseData = activeHelper?.case_info || activeHelper?.meta?.case_id || hasPlateData;
      
      if (typeof checkForAvailableInvoices === 'function' && hasSupabase && hasValidHelper && hasCaseData) {
        console.log('âœ… PERSISTENT CHECK: All requirements met, calling checkForAvailableInvoices...');
        console.log('  - Using helper from:', helperFromWindow ? 'window' : 'sessionStorage');
        console.log('  - Helper keys:', Object.keys(activeHelper).length);
        console.log('  - Plate data:', !!hasPlateData);
        console.log('  - Supabase:', hasSupabase);
        
        // Ensure window.helper is set
        if (!window.helper && helperFromSession && Object.keys(helperFromSession).length > 0) {
          window.helper = helperFromSession;
          console.log('ğŸ”„ Set window.helper from sessionStorage');
        }
        
        checkForAvailableInvoices().catch(e => console.error('ğŸ” Persistent error:', e));
        return true; // Success
      } else {
        console.log('âŒ PERSISTENT CHECK: Requirements not met yet');
        console.log('  - Function available:', typeof checkForAvailableInvoices === 'function');
        console.log('  - Supabase available:', hasSupabase);
        console.log('  - Helper valid:', hasValidHelper, `(${Object.keys(activeHelper || {}).length} keys)`);
        console.log('  - Plate data:', !!hasPlateData);
        console.log('  - Case data:', !!hasCaseData);
        
        if (invoiceCheckAttempts < 10) {
          setTimeout(window.persistentInvoiceChecker, 1000);
        } else {
          console.error('ğŸ” PERSISTENT CHECK: Gave up after 10 attempts');
          console.log('ğŸ”§ Manual check available: manualInvoiceCheck()');
        }
        return false; // Not ready yet
      }
    };
    
    // SESSION 90: Manual invoice check for debugging
    window.manualInvoiceCheck = function() {
      console.log('ğŸ§ª SESSION 90: MANUAL INVOICE CHECK');
      console.log('ğŸ“‹ Current state:');
      console.log('  - window.supabase:', !!window.supabase);
      console.log('  - window.helper keys:', window.helper ? Object.keys(window.helper).length : 0);
      console.log('  - Plate data:', window.helper?.meta?.plate || window.helper?.car_details?.plate || 'none');
      console.log('  - Test invoice data added');
      
      
      // Test hasInvoiceAssignments
      const hasAssignments = hasInvoiceAssignments();
      console.log('ğŸ” hasInvoiceAssignments():', hasAssignments);
      
      // Test 4-layer dropdown
      const dropdownData = getCombinedDropdownData('');
      console.log('ğŸ“‹ 4-layer dropdown total items:', dropdownData.length);
      
      // Show breakdown
      const breakdown = {
        'Layer 1 (Invoices)': dropdownData.filter(p => p.layer === 1).length,
        'Layer 2 (Selected)': dropdownData.filter(p => p.layer === 2).length,
        'Layer 3 (Catalog)': dropdownData.filter(p => p.layer === 3).length,
        'Layer 4 (Parts Bank)': dropdownData.filter(p => p.layer === 4).length
      };
      console.table(breakdown);
      
      // Run the invoice check
      if (typeof checkForAvailableInvoices === 'function') {
        console.log('ğŸš€ Running checkForAvailableInvoices...');
        checkForAvailableInvoices();
      }
      
      return { hasAssignments, dropdownData: breakdown, success: true };
    };
    
    // SESSION 90: Debug PARTS_BANK specifically
    window.debugPartsBank = function() {
      console.log('ğŸ”§ SESSION 90: PARTS_BANK Debug');
      console.log('ğŸ“‹ window.PARTS_BANK exists:', !!window.PARTS_BANK);
      console.log('ğŸ“‹ window.PARTS_BANK type:', typeof window.PARTS_BANK);
      console.log('ğŸ“‹ window.PARTS_BANK length:', window.PARTS_BANK?.length || 0);
      
      if (window.PARTS_BANK && Array.isArray(window.PARTS_BANK)) {
        console.log('âœ… PARTS_BANK structure:');
        window.PARTS_BANK.forEach((category, idx) => {
          console.log(`  Category ${idx}: "${category?.name}" (${category?.parts?.length || 0} parts)`);
          if (category?.parts && idx < 3) { // Show first 3 categories details
            category.parts.slice(0, 3).forEach((part, pidx) => {
              console.log(`    Part ${pidx}: "${part?.name}"`);
            });
          }
        });
        
        // Test the 4-layer system specifically for parts bank
        const allParts = getCombinedDropdownData('');
        const bankParts = allParts.filter(p => p.layer === 4);
        console.log(`ğŸ” Parts Bank in 4-layer system: ${bankParts.length} items`);
        
        if (bankParts.length > 0) {
          console.log('âœ… Sample bank parts from 4-layer system:');
          bankParts.slice(0, 5).forEach(part => {
            console.log(`  - ${part.name} (${part.source})`);
          });
        }
      } else {
        console.log('âŒ PARTS_BANK not loaded or invalid');
        console.log('ğŸ”§ Try running: loadPartsBank() or check parts.js loading');
      }
      
      return {
        available: !!window.PARTS_BANK,
        categories: window.PARTS_BANK?.length || 0,
        layerItems: getCombinedDropdownData('').filter(p => p.layer === 4).length
      };
    };

    // SESSION 91: Real data validation (no test data)
    window.validateRealInvoiceData = async function() {
      console.log('ğŸ§ª SESSION 91: REAL INVOICE DATA VALIDATION');
      console.log('ğŸ“‹ This function tests with REAL database data only');
      
      const helper = window.helper || {};
      const caseId = helper.case_info?.supabase_case_id || helper.meta?.case_id;
      
      if (!caseId) {
        console.error('âŒ No case_id found');
        return { error: 'No case_id found' };
      }
      
      if (!window.supabase) {
        console.error('âŒ Supabase not available');
        return { error: 'Supabase not available' };
      }
      
      console.log('ğŸ” Checking real database data...');
      
      // 1. Check invoices table
      const { data: invoices, error: invError } = await window.supabase
        .from('invoices')
        .select('*')
        .eq('case_id', caseId);
      
      console.log('ğŸ“‹ Real invoices in database:', invoices?.length || 0);
      if (invoices?.length > 0) {
        console.log('ğŸ“‹ Invoice statuses:', invoices.map(i => ({ id: i.id, status: i.status })));
      }
      
      // 2. Check mappings table
      const { data: mappings, error: mapError } = await window.supabase
        .from('invoice_damage_center_mappings')
        .select('*')
        .eq('case_id', caseId);
      
      console.log('ğŸ“‹ Real mappings in database:', mappings?.length || 0);
      if (mappings?.length > 0) {
        const statusBreakdown = {};
        mappings.forEach(m => {
          statusBreakdown[m.mapping_status] = (statusBreakdown[m.mapping_status] || 0) + 1;
        });
        console.log('ğŸ“‹ Mapping status breakdown:', statusBreakdown);
      }
      
      // 3. Test Layer 1 dropdown with real data ONLY
      console.log('ğŸ” Testing Layer 1 dropdown with real data...');
      
      // Temporarily clear any test data
      const originalInvoices = helper.invoices;
      delete helper.invoices;
      delete window.invoiceDataForDropdowns;
      
      const dropdownData = getCombinedDropdownData('');
      const layer1Items = dropdownData.filter(p => p.layer === 1);
      
      console.log('ğŸ“‹ Layer 1 items with real data only:', layer1Items.length);
      if (layer1Items.length > 0) {
        console.log('âœ… Sample Layer 1 items:', layer1Items.slice(0, 3));
      }
      
      // Restore original state
      if (originalInvoices) helper.invoices = originalInvoices;
      
      return {
        caseId,
        realInvoices: invoices?.length || 0,
        realMappings: mappings?.length || 0,
        pendingMappings: mappings?.filter(m => m.mapping_status === 'pending').length || 0,
        layer1ItemsReal: layer1Items.length,
        success: true
      };
    };

    // SESSION 91: Create a REAL test invoice in database
    window.createRealTestInvoice = async function() {
      console.log('ğŸ§ª SESSION 91: Creating REAL test invoice in database');
      
      const helper = window.helper || {};
      const caseId = helper.case_info?.supabase_case_id || helper.meta?.case_id;
      
      if (!caseId || !window.supabase) {
        console.error('âŒ Missing caseId or supabase');
        return { error: 'Missing requirements' };
      }
      
      // Create a real invoice in the database
      const testInvoice = {
        case_id: caseId,
        invoice_number: 'TEST-91-' + Date.now(),
        status: 'ASSIGNED',
        invoice_date: new Date().toISOString(),
        total_amount: 5000,
        created_at: new Date().toISOString()
      };
      
      const { data, error } = await window.supabase
        .from('invoices')
        .insert(testInvoice)
        .select()
        .single();
      
      if (error) {
        console.error('âŒ Error creating invoice:', error);
        return { error };
      }
      
      console.log('âœ… Real test invoice created:', data);
      
      // Now refresh the page or call manualInvoiceCheck
      return {
        success: true,
        invoice: data,
        message: 'Invoice created! Refresh page or call window.manualInvoiceCheck()'
      };
    };

    // SESSION 94: Sliding toggle between wizard/invoice data
    let currentMode = 'wizard'; // Default to wizard mode
    
    window.switchToWizard = function() {
      console.log('ğŸ”„ Switching to wizard mode');
      currentMode = 'wizard';
      updateToggleUI();
      loadWizardData();
      
      // SESSION 93: Re-add save buttons after data loading
      setTimeout(() => {
        if (typeof addSectionButtons === 'function') {
          addSectionButtons();
          console.log('âœ… SESSION 93: Re-added save buttons after wizard switch');
        }
      }, 100);
    };
    
    window.switchToInvoice = function() {
      console.log('ğŸ”„ Switching to invoice mode');
      currentMode = 'invoice';
      updateToggleUI();
      loadInvoiceData();
      
      // SESSION 93: Re-add save buttons after data loading
      setTimeout(() => {
        if (typeof addSectionButtons === 'function') {
          addSectionButtons();
          console.log('âœ… SESSION 93: Re-added save buttons after invoice switch');
        }
      }, 100);
    };
    
    function updateToggleUI() {
      const wizardOption = document.getElementById('wizardOption');
      const invoiceOption = document.getElementById('invoiceOption');
      const slider = document.getElementById('toggleSlider');
      const toggleContainer = document.querySelector('.sliding-toggle');
      
      if (!wizardOption || !invoiceOption || !slider || !toggleContainer) return;
      
      // Check if this is a private report
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const currentReportType = helper.final_report?.type || helper.final_report?.dropdown_type || 
                              document.querySelector('input[name="final-report-type"]:checked')?.value;
      const isPrivateReport = currentReportType === '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª';
      
      // Reset all elements to visible first (prevent disappearing)
      wizardOption.style.display = 'flex';
      invoiceOption.style.display = 'flex';
      wizardOption.style.flex = '1';
      invoiceOption.style.flex = '1';
      
      // Remove all classes first
      toggleContainer.classList.remove('private-report-mode', 'other-report-mode');
      wizardOption.classList.remove('active');
      invoiceOption.classList.remove('active');
      
      if (isPrivateReport) {
        // Private reports: Style as single-option showing "×—×©×‘×•× ×™×ª"
        toggleContainer.classList.add('private-report-mode');
        wizardOption.classList.add('active'); // wizardOption shows "×—×©×‘×•× ×™×ª" label
        currentMode = 'invoice';
        
        // Make inactive option less prominent but still clickable for testing
        invoiceOption.style.opacity = '0.5';
        wizardOption.style.opacity = '1';
        wizardOption.style.cursor = 'pointer';
        invoiceOption.style.cursor = 'pointer';
        
        console.log('ğŸ”’ Private report mode - ×—×©×‘×•× ×™×ª active');
      } else {
        // Other reports: Style as single-option showing "××©×£"
        toggleContainer.classList.add('other-report-mode');
        invoiceOption.classList.add('active'); // invoiceOption shows "××©×£" label
        currentMode = 'wizard';
        
        // Make inactive option less prominent but still clickable for testing
        wizardOption.style.opacity = '0.5';
        invoiceOption.style.opacity = '1';
        wizardOption.style.cursor = 'pointer';
        invoiceOption.style.cursor = 'pointer';
        
        console.log('ğŸ”’ Other report mode - ××©×£ active');
      }
      
      // Hide slider for both cases (single-option indicators)
      slider.style.display = 'none';
    }
    
    function loadWizardData() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const contentDiv = document.getElementById('damageCentersContent');
      
      console.log('ğŸ§™â€â™‚ï¸ WIZARD MODE: Loading original wizard data');
      
      let dataToLoad;
      let dataSource;
      
      // For wizard mode, always load from archive if available (original wizard data)
      if (helper.centers_archive) {
        dataToLoad = helper.centers_archive;
        dataSource = 'centers_archive';
        contentDiv.classList.add('archive-data-mode');
        contentDiv.classList.remove('invoice-data-mode');
        console.log('ğŸ“¦ WIZARD: Loading from centers_archive (original wizard data)');
      } else {
        dataToLoad = helper.centers;
        dataSource = 'centers';
        contentDiv.classList.remove('invoice-data-mode', 'archive-data-mode');
        console.log('ğŸ“¦ WIZARD: Loading from centers (no archive available)');
      }
      
      console.log('ğŸ” WIZARD DATA SOURCE:', dataSource);
      console.log('ğŸ” WIZARD DATA LENGTH:', dataToLoad?.length || 0);
      
      if (dataToLoad && dataToLoad.length > 0) {
        // Auto-save wizard data to centers when switching to wizard mode
        if (helper.centers_archive && dataToLoad === helper.centers_archive) {
          helper.centers = JSON.parse(JSON.stringify(dataToLoad));
          window.helper = helper;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          console.log('ğŸ’¾ Auto-saved wizard data to centers');
        }
        
        const normalizedBlocks = dataToLoad.map((center, index) => adaptCenterToBlock(center, index));
        loadDamageCentersFromHelper(normalizedBlocks);
        console.log(`âœ… WIZARD: Displayed ${dataToLoad.length} centers from ${dataSource}`);
      }
    }
    
    function loadInvoiceData() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const contentDiv = document.getElementById('damageCentersContent');
      
      console.log('ğŸ§¾ INVOICE MODE: Loading invoice-populated data');
      
      let dataToLoad;
      let dataSource;
      const currentReportType = helper.final_report?.type || helper.final_report?.dropdown_type || 
                              document.querySelector('input[name="final-report-type"]:checked')?.value;
      const isPrivateReport = currentReportType === '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª';
      
      // For invoice mode, prioritize invoice-populated data
      if (isPrivateReport && helper.centers_after_invoice) {
        dataToLoad = helper.centers_after_invoice;
        dataSource = 'centers_after_invoice';
        console.log('ğŸ“¦ INVOICE: Loading from centers_after_invoice (private report with invoice data)');
      } else {
        dataToLoad = helper.centers;
        dataSource = 'centers';
        console.log('ğŸ“¦ INVOICE: Loading from centers (current centers data)');
      }
      
      console.log('ğŸ” INVOICE DATA SOURCE:', dataSource);
      console.log('ğŸ” INVOICE DATA LENGTH:', dataToLoad?.length || 0);
      
      // Auto-save invoice data to centers when switching to invoice mode
      if (dataToLoad) {
        helper.centers = JSON.parse(JSON.stringify(dataToLoad));
        window.helper = helper;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        console.log('ğŸ’¾ Auto-saved invoice data to centers');
      }
      
      contentDiv.classList.add('invoice-data-mode');
      contentDiv.classList.remove('archive-data-mode');
      
      if (dataToLoad && dataToLoad.length > 0) {
        const normalizedBlocks = dataToLoad.map((center, index) => adaptCenterToBlock(center, index));
        loadDamageCentersFromHelper(normalizedBlocks);
        console.log(`âœ… INVOICE: Displayed ${dataToLoad.length} centers from ${dataSource}`);
      }
    }

    // Test function to verify clicks work correctly
    window.testToggleClicks = function() {
      console.log('ğŸ§ª TESTING TOGGLE CLICKS');
      
      const wizardOption = document.getElementById('wizardOption');
      const invoiceOption = document.getElementById('invoiceOption');
      
      console.log('ğŸ“Š Current Labels:');
      console.log('  - wizardOption label:', wizardOption?.textContent);
      console.log('  - invoiceOption label:', invoiceOption?.textContent);
      
      console.log('ğŸ–±ï¸ Testing clicks...');
      
      // Test clicking "×—×©×‘×•× ×™×ª" (should call switchToInvoice)
      if (wizardOption) {
        console.log('Clicking "×—×©×‘×•× ×™×ª" (wizardOption)...');
        wizardOption.click();
        setTimeout(() => {
          console.log('  Current mode after click:', currentMode);
          console.log('  Expected: invoice');
        }, 500);
      }
      
      setTimeout(() => {
        // Test clicking "××©×£" (should call switchToWizard)
        if (invoiceOption) {
          console.log('Clicking "××©×£" (invoiceOption)...');
          invoiceOption.click();
          setTimeout(() => {
            console.log('  Current mode after click:', currentMode);
            console.log('  Expected: wizard');
          }, 500);
        }
      }, 2000);
      
      return 'Test started - check console for results';
    };

    // Test function to verify toggle stability after fixes
    window.testToggleStability = function() {
      console.log('ğŸ§ª TESTING TOGGLE STABILITY');
      
      const wizardOption = document.getElementById('wizardOption');
      const invoiceOption = document.getElementById('invoiceOption');
      const toggleContainer = document.getElementById('dataToggleContainer');
      const saveButton = document.querySelector('#damageCentersContent .section-save-button');
      
      console.log('ğŸ“Š Element Status:');
      console.log('  - wizardOption visible:', wizardOption ? wizardOption.style.display !== 'none' : 'not found');
      console.log('  - invoiceOption visible:', invoiceOption ? invoiceOption.style.display !== 'none' : 'not found');
      console.log('  - toggleContainer visible:', toggleContainer ? toggleContainer.style.display !== 'none' : 'not found');
      console.log('  - save button visible:', !!saveButton);
      
      // Test report type switching
      console.log('ğŸ”„ Testing report type switching...');
      const reportTypeInputs = document.querySelectorAll('input[name="final-report-type"]');
      reportTypeInputs.forEach((input, index) => {
        setTimeout(() => {
          input.click();
          console.log(`âœ… Clicked report type ${index + 1}: ${input.value}`);
          
          setTimeout(() => {
            const wizardVisible = wizardOption ? wizardOption.style.display !== 'none' : false;
            const invoiceVisible = invoiceOption ? invoiceOption.style.display !== 'none' : false;
            const saveStillThere = !!document.querySelector('#damageCentersContent .section-save-button');
            
            console.log(`  After switch: wizard=${wizardVisible}, invoice=${invoiceVisible}, save=${saveStillThere}`);
          }, 500);
        }, index * 2000);
      });
      
      return 'Test started - check console for results';
    };

    // Debug function to test toggle functionality
    window.debugToggleState = function() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('ğŸ” TOGGLE DEBUG STATE:');
      console.log('  - Current mode:', currentMode);
      console.log('  - centers exists:', !!helper.centers);
      console.log('  - centers_archive exists:', !!helper.centers_archive);
      console.log('  - centers_after_invoice exists:', !!helper.centers_after_invoice);
      console.log('  - centers length:', helper.centers?.length || 0);
      console.log('  - archive length:', helper.centers_archive?.length || 0);
      console.log('  - after_invoice length:', helper.centers_after_invoice?.length || 0);
      
      const currentReportType = helper.final_report?.type || helper.final_report?.dropdown_type || 
                              document.querySelector('input[name="final-report-type"]:checked')?.value;
      console.log('  - Report type:', currentReportType);
      console.log('  - Is private:', currentReportType === '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª');
      
      // Test manual switches
      console.log('ğŸ§ª Testing manual switch to wizard...');
      switchToWizard();
      setTimeout(() => {
        console.log('ğŸ§ª Testing manual switch to invoice...');
        switchToInvoice();
      }, 2000);
    };

    // SESSION 93: Test save button visibility fix
    window.testSaveButtonFix = function() {
      console.log('ğŸ§ª SESSION 93: Testing Save Button Fix');
      
      // 1. Force call addSectionButtons to create buttons
      console.log('ğŸ“‹ Step 1: Calling addSectionButtons...');
      if (typeof addSectionButtons === 'function') {
        addSectionButtons();
        console.log('âœ… addSectionButtons called');
      } else {
        console.log('âŒ addSectionButtons function not found');
      }
      
      // 2. Check if save button was created
      console.log('ğŸ“‹ Step 2: Checking for save button...');
      const damageCentersSummary = document.getElementById('damageCentersSummary');
      const damageCentersContent = document.getElementById('damageCentersContent');
      
      let saveButton = null;
      if (damageCentersSummary) {
        saveButton = damageCentersSummary.querySelector('.section-save-button');
        console.log('ğŸ” Save button in damageCentersSummary:', !!saveButton);
      }
      
      if (!saveButton && damageCentersContent) {
        saveButton = damageCentersContent.querySelector('.section-save-button');
        console.log('ğŸ” Save button in damageCentersContent:', !!saveButton);
      }
      
      // 3. Test repositioning function
      console.log('ğŸ“‹ Step 3: Testing repositioning...');
      if (typeof repositionDamageCentersSaveButton === 'function') {
        repositionDamageCentersSaveButton();
        console.log('âœ… repositionDamageCentersSaveButton called');
      } else {
        console.log('âŒ repositionDamageCentersSaveButton function not found');
      }
      
      // 4. Final check
      console.log('ğŸ“‹ Step 4: Final button visibility check...');
      if (saveButton) {
        const isVisible = saveButton.offsetParent !== null;
        const computedStyle = window.getComputedStyle(saveButton);
        console.log('âœ… Save button found and visible:', isVisible);
        console.log('ğŸ” Button display:', computedStyle.display);
        console.log('ğŸ” Button visibility:', computedStyle.visibility);
        console.log('ğŸ” Button position:', saveButton.getBoundingClientRect());
      } else {
        console.log('âŒ Save button not found after fix attempt');
      }
      
      return {
        buttonExists: !!saveButton,
        buttonVisible: saveButton ? saveButton.offsetParent !== null : false,
        damageCentersSummaryExists: !!damageCentersSummary,
        damageCentersContentExists: !!damageCentersContent
      };
    };

    // SESSION 93: Test save button persistence during toggle operations
    window.testSaveButtonPersistence = function() {
      console.log('ğŸ§ª SESSION 93: Testing Save Button Persistence During Toggle Operations');
      
      return new Promise((resolve) => {
        // Initial setup
        console.log('ğŸ“‹ Step 1: Initial save button setup...');
        const initialResult = window.testSaveButtonFix();
        
        if (!initialResult.buttonExists) {
          console.log('âŒ Save button not found initially, test cannot proceed');
          resolve({ success: false, reason: 'No initial button' });
          return;
        }
        
        console.log('âœ… Initial save button found');
        
        // Test 1: Switch to wizard and back
        console.log('ğŸ“‹ Step 2: Testing wizard switch...');
        switchToWizard();
        
        setTimeout(() => {
          let saveButton = document.querySelector('#damageCentersSummary .section-save-button') || 
                          document.querySelector('#damageCentersContent .section-save-button');
          const wizardTest = !!saveButton && saveButton.offsetParent !== null;
          console.log('ğŸ” Save button visible after wizard switch:', wizardTest);
          console.log('ğŸ” SESSION 93: Button should be re-added by timeout function');
          
          // Test 2: Switch to invoice and back
          console.log('ğŸ“‹ Step 3: Testing invoice switch...');
          switchToInvoice();
          
          setTimeout(() => {
            saveButton = document.querySelector('#damageCentersSummary .section-save-button') || 
                        document.querySelector('#damageCentersContent .section-save-button');
            const invoiceTest = !!saveButton && saveButton.offsetParent !== null;
            console.log('ğŸ” Save button visible after invoice switch:', invoiceTest);
            
            // Test 3: Multiple rapid switches
            console.log('ğŸ“‹ Step 4: Testing rapid switches...');
            switchToWizard();
            setTimeout(() => switchToInvoice(), 100);
            setTimeout(() => switchToWizard(), 200);
            setTimeout(() => switchToInvoice(), 300);
            
            setTimeout(() => {
              saveButton = document.querySelector('#damageCentersSummary .section-save-button') || 
                          document.querySelector('#damageCentersContent .section-save-button');
              const rapidTest = !!saveButton && saveButton.offsetParent !== null;
              console.log('ğŸ” Save button visible after rapid switches:', rapidTest);
              
              const finalResult = {
                success: wizardTest && invoiceTest && rapidTest,
                initialButton: initialResult.buttonExists,
                wizardSwitch: wizardTest,
                invoiceSwitch: invoiceTest,
                rapidSwitches: rapidTest,
                finalButtonVisible: rapidTest
              };
              
              if (finalResult.success) {
                console.log('âœ… SESSION 93: Save button persistence test PASSED');
              } else {
                console.log('âŒ SESSION 93: Save button persistence test FAILED');
                console.log('ğŸ“‹ Test results:', finalResult);
              }
              
              resolve(finalResult);
            }, 1000);
          }, 500);
        }, 500);
      });
    };

    // SESSION 93: Complete save button fix test
    window.testCompleteSaveButtonFix = function() {
      console.log('ğŸ§ª SESSION 93: Testing Complete Save Button Fix');
      
      return new Promise((resolve) => {
        let testResults = {
          initialButtonExists: false,
          buttonExistsAfterWizard: false,
          buttonExistsAfterInvoice: false,
          buttonVisibleAfterWizard: false,
          buttonVisibleAfterInvoice: false,
          positioningWorks: false
        };
        
        // Step 1: Initial setup
        console.log('ğŸ“‹ Step 1: Initial button creation...');
        if (typeof addSectionButtons === 'function') {
          addSectionButtons();
        }
        
        setTimeout(() => {
          let saveButton = document.querySelector('#damageCentersSummary .section-save-button') || 
                          document.querySelector('#damageCentersContent .section-save-button');
          testResults.initialButtonExists = !!saveButton;
          console.log('ğŸ” Initial button exists:', testResults.initialButtonExists);
          
          // Step 2: Test wizard switch
          console.log('ğŸ“‹ Step 2: Testing wizard switch...');
          switchToWizard();
          
          setTimeout(() => {
            saveButton = document.querySelector('#damageCentersSummary .section-save-button') || 
                        document.querySelector('#damageCentersContent .section-save-button');
            testResults.buttonExistsAfterWizard = !!saveButton;
            testResults.buttonVisibleAfterWizard = saveButton ? saveButton.offsetParent !== null : false;
            console.log('ğŸ” Button exists after wizard:', testResults.buttonExistsAfterWizard);
            console.log('ğŸ” Button visible after wizard:', testResults.buttonVisibleAfterWizard);
            
            // Step 3: Test invoice switch
            console.log('ğŸ“‹ Step 3: Testing invoice switch...');
            switchToInvoice();
            
            setTimeout(() => {
              saveButton = document.querySelector('#damageCentersSummary .section-save-button') || 
                          document.querySelector('#damageCentersContent .section-save-button');
              testResults.buttonExistsAfterInvoice = !!saveButton;
              testResults.buttonVisibleAfterInvoice = saveButton ? saveButton.offsetParent !== null : false;
              console.log('ğŸ” Button exists after invoice:', testResults.buttonExistsAfterInvoice);
              console.log('ğŸ” Button visible after invoice:', testResults.buttonVisibleAfterInvoice);
              
              // Step 4: Test positioning
              console.log('ğŸ“‹ Step 4: Testing positioning...');
              if (typeof repositionDamageCentersSaveButton === 'function') {
                repositionDamageCentersSaveButton();
                testResults.positioningWorks = true;
              }
              
              const allTestsPass = testResults.initialButtonExists && 
                                 testResults.buttonExistsAfterWizard && 
                                 testResults.buttonExistsAfterInvoice && 
                                 testResults.buttonVisibleAfterWizard && 
                                 testResults.buttonVisibleAfterInvoice;
              
              if (allTestsPass) {
                console.log('âœ… SESSION 93: Complete save button fix test PASSED');
              } else {
                console.log('âŒ SESSION 93: Complete save button fix test FAILED');
                console.log('ğŸ“‹ Detailed results:', testResults);
              }
              
              resolve({
                success: allTestsPass,
                ...testResults
              });
            }, 200);
          }, 200);
        }, 100);
      });
    };

    // SESSION 93: Test save button positioning before ×”× ×—×•×ª ×•×”×¤×¨×©×™×
    window.testSaveButtonPositioning = function() {
      console.log('ğŸ§ª SESSION 93: Testing Save Button Positioning Before ×”× ×—×•×ª ×•×”×¤×¨×©×™×');
      
      return new Promise((resolve) => {
        // Step 1: Ensure buttons are created
        console.log('ğŸ“‹ Step 1: Creating save buttons...');
        if (typeof addSectionButtons === 'function') {
          addSectionButtons();
        }
        
        setTimeout(() => {
          // Step 2: Find the save button
          let saveButton = document.querySelector('#damageCentersSummary .section-save-button') || 
                          document.querySelector('#damageCentersContent .section-save-button');
          
          // Step 3: Find ×”× ×—×•×ª ×•×”×¤×¨×©×™× section
          const differentialsSection = document.getElementById('differentialsSection');
          
          console.log('ğŸ” Save button exists:', !!saveButton);
          console.log('ğŸ” ×”× ×—×•×ª ×•×”×¤×¨×©×™× section exists:', !!differentialsSection);
          
          if (!saveButton || !differentialsSection) {
            resolve({
              success: false,
              saveButtonExists: !!saveButton,
              differentialsSectionExists: !!differentialsSection,
              reason: 'Missing required elements'
            });
            return;
          }
          
          // Step 4: Test positioning
          console.log('ğŸ“‹ Step 2: Testing positioning...');
          repositionDamageCentersSaveButton();
          
          setTimeout(() => {
            // Step 5: Verify positioning
            saveButton = document.querySelector('#damageCentersSummary .section-save-button') || 
                        document.querySelector('#damageCentersContent .section-save-button');
            
            if (!saveButton) {
              resolve({
                success: false,
                reason: 'Save button disappeared after repositioning'
              });
              return;
            }
            
            // Check if button is positioned before ×”× ×—×•×ª ×•×”×¤×¨×©×™×
            const buttonContainer = saveButton.parentElement;
            const buttonPosition = Array.from(buttonContainer.parentNode.children).indexOf(buttonContainer);
            const differentialsPosition = Array.from(differentialsSection.parentNode.children).indexOf(differentialsSection);
            
            const isPositionedCorrectly = buttonPosition < differentialsPosition;
            
            console.log('ğŸ” Button position index:', buttonPosition);
            console.log('ğŸ” ×”× ×—×•×ª ×•×”×¤×¨×©×™× position index:', differentialsPosition);
            console.log('ğŸ” Button positioned before ×”× ×—×•×ª ×•×”×¤×¨×©×™×:', isPositionedCorrectly);
            
            // Step 6: Check visibility
            const isVisible = saveButton.offsetParent !== null;
            console.log('ğŸ” Button is visible:', isVisible);
            
            const success = isPositionedCorrectly && isVisible;
            
            if (success) {
              console.log('âœ… SESSION 93: Save button positioning test PASSED');
            } else {
              console.log('âŒ SESSION 93: Save button positioning test FAILED');
            }
            
            resolve({
              success,
              saveButtonExists: true,
              differentialsSectionExists: true,
              isPositionedCorrectly,
              isVisible,
              buttonPosition,
              differentialsPosition
            });
          }, 100);
        }, 100);
      });
    };

    // Legacy function kept for compatibility
    window.toggleDataSource = function() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const currentReportType = helper.final_report?.type || helper.final_report?.dropdown_type || 
                              document.querySelector('input[name="final-report-type"]:checked')?.value;
      const isPrivateReport = currentReportType === '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª';
      const toggle = document.getElementById('dataSourceToggle');
      const contentDiv = document.getElementById('damageCentersContent');
      
      console.log('ğŸ”„ Toggling data source...');
      console.log('  Report type:', currentReportType);
      console.log('  Is private:', isPrivateReport);
      console.log('  Toggle checked:', toggle.checked);
      
      let dataToLoad;
      
      if (isPrivateReport) {
        // Private report: toggle between centers and centers_after_invoice
        if (toggle.checked && helper.centers_after_invoice) {
          console.log('ğŸ“„ Loading invoice data from centers_after_invoice');
          dataToLoad = helper.centers_after_invoice;
          contentDiv.classList.add('invoice-data-mode');
          contentDiv.classList.remove('archive-data-mode');
        } else {
          console.log('ğŸ¯ Loading current centers data');
          dataToLoad = helper.centers;
          contentDiv.classList.remove('invoice-data-mode', 'archive-data-mode');
        }
      } else {
        // Other reports: toggle between centers and centers_archive
        if (toggle.checked && helper.centers_archive) {
          console.log('ğŸ“¦ Loading wizard data from centers_archive');
          dataToLoad = helper.centers_archive;
          contentDiv.classList.add('archive-data-mode');
          contentDiv.classList.remove('invoice-data-mode');
        } else {
          console.log('ğŸ¯ Loading current centers data');
          dataToLoad = helper.centers;
          contentDiv.classList.remove('invoice-data-mode', 'archive-data-mode');
        }
      }
      
      // Load the data
      if (dataToLoad && dataToLoad.length > 0) {
        const normalizedBlocks = dataToLoad.map((center, index) => adaptCenterToBlock(center, index));
        loadDamageCentersFromHelper(normalizedBlocks);
        console.log(`âœ… Loaded ${dataToLoad.length} damage centers`);
      } else {
        console.warn('âš ï¸ No data to load');
      }
      
      // Update toggle visibility based on available data
      updateToggleVisibility();
    };
    
    // Update toggle visibility based on report type and available data
    window.updateToggleVisibility = function() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const currentReportType = helper.final_report?.type || helper.final_report?.dropdown_type || 
                              document.querySelector('input[name="final-report-type"]:checked')?.value;
      const isPrivateReport = currentReportType === '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª';
      const toggleContainer = document.getElementById('dataToggleContainer');
      
      if (!toggleContainer) return;
      
      // Show toggle only if alternative data exists
      if ((isPrivateReport && helper.centers_after_invoice) || (!isPrivateReport && helper.centers_archive)) {
        toggleContainer.style.display = 'flex';
        // Initialize to wizard mode
        currentMode = 'wizard';
        updateToggleUI();
        console.log('âœ… Toggle shown for available alternative data');
      } else {
        toggleContainer.style.display = 'none';
        console.log('â„¹ï¸ Toggle hidden - no alternative data available');
      }
    };
    
    window.createTestMappings = async function() {
      console.log('ğŸ§ª SESSION 91: Creating test mappings with PENDING status');
      
      const helper = window.helper || {};
      const caseId = helper.case_info?.supabase_case_id || helper.meta?.case_id;
      
      if (!caseId || !window.supabase) {
        console.error('âŒ Missing caseId or supabase');
        return { error: 'Missing requirements' };
      }
      
      // First, get an invoice for this case (or create one)
      const { data: invoices } = await window.supabase
        .from('invoices')
        .select('*')
        .eq('case_id', caseId)
        .limit(1);
      
      let invoiceId;
      if (invoices && invoices.length > 0) {
        invoiceId = invoices[0].id;
        console.log('âœ… Using existing invoice:', invoiceId);
      } else {
        console.error('âŒ No invoices found for this case');
        return { error: 'No invoices found' };
      }
      
      // Get damage centers from helper
      const centers = helper.centers || [];
      if (centers.length === 0) {
        console.error('âŒ No damage centers found in helper');
        return { error: 'No damage centers' };
      }
      
      // Create test mappings
      const testMappings = [
        {
          case_id: caseId,
          invoice_id: invoiceId,
          damage_center_code: centers[0]?.Id || 'CENTER1',
          field_type: 'part',
          line_item_description: '×¤×’×•×© ×§×“××™ - ××—×©×‘×•× ×™×ª',
          line_item_amount: 1500,
          mapping_status: 'pending',
          created_at: new Date().toISOString()
        },
        {
          case_id: caseId,
          invoice_id: invoiceId,
          damage_center_code: centers[0]?.Id || 'CENTER1',
          field_type: 'work',
          line_item_description: '×¢×‘×•×“×ª ×¦×‘×¢ - ××—×©×‘×•× ×™×ª',
          line_item_amount: 800,
          mapping_status: 'pending',
          created_at: new Date().toISOString()
        }
      ];
      
      console.log('ğŸ“‹ Creating test mappings:', testMappings);
      
      const { data, error } = await window.supabase
        .from('invoice_damage_center_mappings')
        .insert(testMappings)
        .select();
      
      if (error) {
        console.error('âŒ Error creating mappings:', error);
        return { error };
      }
      
      console.log('âœ… Test mappings created:', data);
      
      // Also update invoice status to ASSIGNED
      await window.supabase
        .from('invoices')
        .update({ status: 'ASSIGNED' })
        .eq('id', invoiceId);
      
      return {
        success: true,
        mappingsCreated: data.length,
        invoiceId,
        caseId,
        message: 'Test mappings created! Now try clicking Accept Invoice Assignment'
      };
    };

    // SESSION 91: Test UI refresh with manual data
    window.testUIRefresh = function() {
      console.log('ğŸ§ª SESSION 91: Testing UI refresh with manual data injection');
      
      const helper = window.helper || {};
      
      if (!helper.centers || helper.centers.length === 0) {
        console.error('âŒ No damage centers found');
        return { error: 'No damage centers' };
      }
      
      // Manually add a test part to first center
      const testPart = {
        part_name: 'ğŸ§ª TEST PART FROM SESSION 91',
        part_description: 'This part should appear in UI if refresh works',
        price: 999,
        quantity: 1,
        total: 999,
        source: 'manual_test',
        row_uuid: 'test_' + Date.now()
      };
      
      // Ensure Parts structure exists
      if (!helper.centers[0].Parts) {
        helper.centers[0].Parts = { parts_required: [] };
      }
      if (!helper.centers[0].Parts.parts_required) {
        helper.centers[0].Parts.parts_required = [];
      }
      
      console.log('ğŸ“‹ BEFORE: Center has', helper.centers[0].Parts.parts_required.length, 'parts');
      helper.centers[0].Parts.parts_required.push(testPart);
      console.log('ğŸ“‹ AFTER: Center has', helper.centers[0].Parts.parts_required.length, 'parts');
      
      // Save to sessionStorage
      sessionStorage.setItem('helper', JSON.stringify(helper));
      window.helper = helper;
      
      // Now try all refresh methods
      console.log('ğŸ”„ Attempting UI refresh...');
      
      // Method 1
      if (typeof loadDataFromHelper === 'function') {
        console.log('Calling loadDataFromHelper()');
        loadDataFromHelper();
      }
      
      // Method 2
      if (typeof loadDamageCentersFromHelper === 'function') {
        console.log('Calling loadDamageCentersFromHelper()');
        loadDamageCentersFromHelper(helper);
      }
      
      // Method 3 - Direct manipulation
      const damageCentersContent = document.getElementById('damageCentersContent');
      if (damageCentersContent) {
        console.log('Found damageCentersContent element, checking for part:', testPart.part_name);
        setTimeout(() => {
          const content = damageCentersContent.innerHTML;
          if (content.includes('TEST PART FROM SESSION 91')) {
            console.log('âœ… SUCCESS: Test part appears in UI!');
          } else {
            console.log('âŒ FAIL: Test part NOT found in UI');
            console.log('UI content length:', content.length);
          }
        }, 1000);
      }
      
      return {
        success: true,
        partAdded: testPart,
        centerPartsCount: helper.centers[0].Parts.parts_required.length
      };
    };

    // SESSION 91 FIX: Debug centers data
    window.debugCentersData = function() {
      console.log('ğŸ” SESSION 91: Debugging centers data');
      const helper = window.helper || {};
      
      console.log('ğŸ“‹ Helper structure:');
      console.log('  - centers exists:', !!helper.centers);
      console.log('  - centers length:', helper.centers?.length || 0);
      console.log('  - centers_archive exists:', !!helper.centers_archive);
      console.log('  - centers_archive length:', helper.centers_archive?.length || 0);
      
      if (helper.centers && helper.centers.length > 0) {
        console.log('ğŸ“‹ Centers content:');
        helper.centers.forEach((center, idx) => {
          console.log(`  Center ${idx}:`, {
            id: center.Id || center.Location,
            parts: center.Parts?.parts_required?.length || 0,
            works: center.Works?.works?.length || 0,
            repairs: center.Repairs?.repairs?.length || 0
          });
        });
      }
      
      if (helper.centers_archive && helper.centers_archive.length > 0) {
        console.log('ğŸ“‹ Archive content:');
        helper.centers_archive.forEach((center, idx) => {
          console.log(`  Archive Center ${idx}:`, {
            id: center.Id || center.Location,
            parts: center.Parts?.parts_required?.length || 0,
            works: center.Works?.works?.length || 0,
            repairs: center.Repairs?.repairs?.length || 0
          });
        });
      }
      
      // Test what the UI would load
      const currentReportType = helper.final_report?.type || helper.final_report?.dropdown_type || 
                              document.querySelector('input[name="final-report-type"]:checked')?.value;
      console.log('ğŸ“‹ Current report type:', currentReportType);
      console.log('ğŸ“‹ UI would load from:', 
        (helper.centers_archive && currentReportType !== '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª') ? 'centers_archive' : 'centers'
      );
      
      return {
        reportType: currentReportType,
        centersCount: helper.centers?.length || 0,
        archiveCount: helper.centers_archive?.length || 0,
        centersData: helper.centers?.map(c => ({
          parts: c.Parts?.parts_required?.length || 0,
          works: c.Works?.works?.length || 0,
          repairs: c.Repairs?.repairs?.length || 0
        }))
      };
    };

    // SESSION 91 EMERGENCY: Restore centers from archive
    window.restoreCentersFromArchive = function() {
      console.log('ğŸš¨ SESSION 91: Emergency restore - copying centers_archive back to centers');
      const helper = window.helper || {};
      
      if (!helper.centers_archive || helper.centers_archive.length === 0) {
        console.error('âŒ No centers_archive found to restore from!');
        return { error: 'No archive exists' };
      }
      
      console.log('ğŸ“‹ Before restore:');
      console.log('  - centers length:', helper.centers?.length || 0);
      console.log('  - archive length:', helper.centers_archive.length);
      
      // Deep copy archive back to centers
      helper.centers = JSON.parse(JSON.stringify(helper.centers_archive));
      
      // Save to both sessionStorage and window.helper
      sessionStorage.setItem('helper', JSON.stringify(helper));
      window.helper = helper;
      
      console.log('âœ… Restored centers from archive');
      console.log('ğŸ“‹ After restore:');
      console.log('  - centers length:', helper.centers.length);
      
      // Refresh UI
      if (typeof loadDamageCentersFromHelper === 'function') {
        console.log('ğŸ”„ Refreshing UI...');
        loadDamageCentersFromHelper(helper);
      }
      
      return {
        success: true,
        centersRestored: helper.centers.length,
        message: 'Centers restored from archive'
      };
    };

    // SESSION 91: Clear centers archive manually
    function clearCentersArchive() {
      console.log('ğŸ§¹ SESSION 91: Manually clearing centers_archive');
      const helper = window.helper || {};
      
      if (!helper.centers_archive) {
        console.log('â„¹ï¸ No archive exists to clear');
        return { message: 'No archive exists' };
      }
      
      console.log('ğŸ“‹ Before clearing:');
      console.log('  - Archive had', helper.centers_archive.length, 'centers');
      console.log('  - Archive metadata:', helper.centers_archive_meta);
      
      // Delete archive and its metadata
      delete helper.centers_archive;
      delete helper.centers_archive_meta;
      
      // Save changes
      sessionStorage.setItem('helper', JSON.stringify(helper));
      window.helper = helper;
      
      console.log('âœ… Archive cleared successfully');
      console.log('â„¹ï¸ System is now in no-invoice state');
      
      // Refresh UI to reflect changes
      if (typeof loadDamageCentersFromHelper === 'function') {
        loadDamageCentersFromHelper(helper);
      }
      
      return {
        success: true,
        message: 'Archive cleared - system in no-invoice state'
      };
    };
    window.clearCentersArchive = clearCentersArchive;

    // SESSION 91 EMERGENCY: Force populate centers (failsafe)
    window.forcePopulateCenters = function() {
      console.log('ğŸš¨ SESSION 91: Force populate centers');
      const helper = window.helper || {};
      
      // Priority order to find data
      let sourceData = null;
      let source = '';
      
      if (helper.centers_archive && helper.centers_archive.length > 0) {
        sourceData = helper.centers_archive;
        source = 'centers_archive';
      } else if (helper.expertise?.damage_blocks && helper.expertise.damage_blocks.length > 0) {
        sourceData = helper.expertise.damage_blocks;
        source = 'expertise.damage_blocks';
      } else {
        console.error('âŒ No source data found!');
        return { error: 'No data source available' };
      }
      
      console.log(`ğŸ“‹ Populating centers from ${source} (${sourceData.length} items)`);
      
      // Deep copy to centers
      helper.centers = JSON.parse(JSON.stringify(sourceData));
      
      // Save everywhere
      sessionStorage.setItem('helper', JSON.stringify(helper));
      window.helper = helper;
      
      // Force UI refresh
      if (typeof loadDamageCentersFromHelper === 'function') {
        loadDamageCentersFromHelper(helper);
      }
      if (typeof loadDataFromHelper === 'function') {
        loadDataFromHelper();
      }
      
      console.log('âœ… Centers populated and UI refreshed');
      
      return {
        success: true,
        source: source,
        centersCount: helper.centers.length
      };
    };

    // SESSION 91 FIX: Test archive usage
    window.testArchiveUsage = function() {
      console.log('ğŸ§ª SESSION 91: Testing centers_archive usage');
      const helper = window.helper || {};
      
      const currentReportType = helper.final_report?.type || helper.final_report?.dropdown_type || 
                              document.querySelector('input[name="final-report-type"]:checked')?.value;
      
      console.log('ğŸ“‹ Current report type:', currentReportType);
      console.log('ğŸ“‹ centers exists:', !!helper.centers, 'length:', helper.centers?.length || 0);
      console.log('ğŸ“‹ centers_archive exists:', !!helper.centers_archive, 'length:', helper.centers_archive?.length || 0);
      console.log('ğŸ“‹ Archive metadata:', helper.centers_archive_meta);
      
      // Test what loadDamageCentersFromHelper would use
      const hasAcceptedInvoice = helper.centers_archive && helper.centers_archive_meta;
      const wouldUseArchive = hasAcceptedInvoice && currentReportType !== '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª' && helper.centers_archive.length > 0;
      
      console.log('ğŸ“‹ Has accepted invoice:', hasAcceptedInvoice);
      console.log('ğŸ“‹ Would use archive:', wouldUseArchive);
      
      if (wouldUseArchive) {
        console.log('âœ… Non-private report will correctly use centers_archive');
      } else if (currentReportType === '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª') {
        console.log('âœ… Private report will use centers (with invoice data)');
      } else {
        console.log('â„¹ï¸ No invoice accepted yet - will use centers');
      }
      
      return {
        reportType: currentReportType,
        hasArchive: !!helper.centers_archive,
        archiveLength: helper.centers_archive?.length || 0,
        centersLength: helper.centers?.length || 0,
        wouldUseArchive: wouldUseArchive
      };
    };

    // SESSION 91: Step-by-step flow tester
    window.testAcceptFlowStep = async function(step) {
      console.log(`ğŸ§ª SESSION 91: Testing step ${step} of accept flow`);
      
      const helper = window.helper || {};
      
      switch(step) {
        case 1:
          console.log('STEP 1: Check selected invoices');
          const selected = getSelectedInvoices();
          console.log('Selected invoices:', selected);
          return { step: 1, selectedInvoices: selected.length, success: true };
          
        case 2:
          console.log('STEP 2: Test query for mappings');
          const caseId = helper.case_info?.supabase_case_id;
          if (!caseId || !window.supabase) {
            return { step: 2, error: 'Missing case_id or supabase' };
          }
          
          const { data: mappings } = await window.supabase
            .from('invoice_damage_center_mappings')
            .select('*')
            .eq('case_id', caseId)
            .eq('mapping_status', 'pending');
          
          console.log('Pending mappings found:', mappings?.length || 0);
          return { step: 2, pendingMappings: mappings?.length || 0, success: true };
          
        case 3:
          console.log('STEP 3: Test helper.centers modification');
          const beforeCount = helper.centers?.reduce((sum, c) => sum + (c.Parts?.parts_required?.length || 0), 0) || 0;
          console.log('Parts before:', beforeCount);
          
          // Simulate adding a part
          if (helper.centers && helper.centers[0]) {
            if (!helper.centers[0].Parts) helper.centers[0].Parts = { parts_required: [] };
            helper.centers[0].Parts.parts_required.push({
              part_name: 'TEST PART',
              source: 'test',
              row_uuid: 'test_' + Date.now()
            });
          }
          
          const afterCount = helper.centers?.reduce((sum, c) => sum + (c.Parts?.parts_required?.length || 0), 0) || 0;
          console.log('Parts after:', afterCount);
          
          return { step: 3, partsBefore: beforeCount, partsAfter: afterCount, success: afterCount > beforeCount };
          
        case 4:
          console.log('STEP 4: Test UI refresh');
          if (typeof loadDamageCentersFromHelper === 'function') {
            loadDamageCentersFromHelper(helper);
            return { step: 4, refreshCalled: true, success: true };
          }
          return { step: 4, error: 'loadDamageCentersFromHelper not available' };
          
        default:
          return { error: 'Invalid step number' };
      }
    };
    
    // SESSION 91: Clear test invoices from helper
    window.clearTestInvoices = function() {
      console.log('ğŸ§¹ SESSION 91: Clearing test invoices from helper');
      
      const helper = window.helper || {};
      
      if (helper.invoices && Array.isArray(helper.invoices)) {
        const beforeCount = helper.invoices.length;
        
        // Remove any test invoices
        helper.invoices = helper.invoices.filter(inv => {
          const isTest = inv.invoice_number?.includes('TEST') || 
                        inv.invoice_number?.includes('MANUAL') ||
                        inv.id?.includes('test');
          if (isTest) {
            console.log('ğŸ—‘ï¸ Removing test invoice:', inv.invoice_number);
          }
          return !isTest;
        });
        
        const afterCount = helper.invoices.length;
        
        // Save cleaned helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        console.log(`âœ… Cleaned ${beforeCount - afterCount} test invoices`);
        console.log(`ğŸ“‹ Remaining real invoices: ${afterCount}`);
        
        return {
          removed: beforeCount - afterCount,
          remaining: afterCount
        };
      }
      
      return { removed: 0, remaining: 0 };
    };

    // SESSION 91: Test Layer 1 dropdown by adding invoice data
    window.testLayer1Dropdown = function() {
      console.log('ğŸ§ª SESSION 91: Testing Layer 1 dropdown with manual invoice data');
      
      const helper = window.helper || {};
      
      // Add test invoice data to helper
      if (!helper.invoices) {
        helper.invoices = [];
      }
      
      const testInvoice = {
        id: 'test-invoice-91',
        invoice_number: 'TEST-91',
        status: 'ASSIGNED',
        line_items: [
          { description: '×¤×’×•×© ×§×“××™ - ××‘×“×™×§×ª SESSION 91', unit_price: 1200, line_total: 1200 },
          { description: '×“×œ×ª ×™××™×Ÿ - ××‘×“×™×§×ª SESSION 91', unit_price: 800, line_total: 800 },
          { description: '×¤× ×¡ ×¨××©×™ ×©×××œ - ××‘×“×™×§×ª SESSION 91', unit_price: 450, line_total: 450 }
        ]
      };
      
      helper.invoices.push(testInvoice);
      
      // Save to sessionStorage and window
      sessionStorage.setItem('helper', JSON.stringify(helper));
      window.helper = helper;
      
      console.log('ğŸ“‹ Added test invoice with', testInvoice.line_items.length, 'items');
      
      // Test the dropdown data
      const dropdownData = getCombinedDropdownData('');
      const layer1Items = dropdownData.filter(p => p.layer === 1);
      
      console.log('ğŸ“Š Layer 1 items found:', layer1Items.length);
      if (layer1Items.length > 0) {
        console.log('âœ… SUCCESS: Layer 1 items:', layer1Items);
      } else {
        console.log('âŒ FAIL: No Layer 1 items found');
        console.log('All dropdown data:', dropdownData);
      }
      
      // Also set the global variable that some functions might use
      if (!window.invoiceDataForDropdowns) {
        window.invoiceDataForDropdowns = {};
      }
      window.invoiceDataForDropdowns.invoice_lines = testInvoice.line_items;
      
      return {
        success: layer1Items.length > 0,
        invoiceAdded: testInvoice,
        layer1Items: layer1Items.length,
        allItems: dropdownData.length
      };
    };

    // Start the persistent checker immediately
    // DISABLED IN SESSION 91 - causing repeated checks and flooding helper
    console.log('ğŸ” DISABLED: Persistent invoice checker disabled to prevent flooding');
    // window.persistentInvoiceChecker();
    
    // Check if DOM is already loaded
    if (document.readyState === 'loading') {
      console.log('ğŸ” SCRIPT DEBUG: DOM still loading, adding event listener...');
      document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
      console.log('ğŸ” SCRIPT DEBUG: DOM already loaded, calling initializeApp immediately...');
      initializeApp();
    }
    
    // Since DOMContentLoaded isn't firing, use timer-based approach
    console.log('ğŸ”§ FALLBACK: Timer-based approach DISABLED in SESSION 91 to prevent flooding');
    
    // Try multiple approaches to ensure invoice check runs
    // DISABLED IN SESSION 91 - causing repeated checks
    /*setTimeout(() => {
      console.log('ğŸ• TIMER 1000ms: Checking invoice system...');
      // Check multiple sources for helper data
      const helperFromWindow = window.helper;
      const helperFromSession = (() => {
        try {
          return JSON.parse(sessionStorage.getItem('helper') || '{}');
        } catch(e) {
          return {};
        }
      })();
      
      const hasValidHelper = (helperFromWindow && helperFromWindow.case_info) || 
                            (helperFromSession && helperFromSession.case_info);
      
      if (typeof checkForAvailableInvoices === 'function' && hasValidHelper) {
        console.log('ğŸš€ TIMER: Calling checkForAvailableInvoices...');
        console.log('  - Using helper from:', helperFromWindow?.case_info ? 'window' : 'sessionStorage');
        checkForAvailableInvoices().catch(e => console.error('ğŸ”§ Timer error:', e));
      } else {
        console.log('âŒ TIMER: Function or helper not ready yet');
        console.log('  - Function available:', typeof checkForAvailableInvoices === 'function');
        console.log('  - Helper (window) with case_info:', !!helperFromWindow?.case_info);
        console.log('  - Helper (session) with case_info:', !!helperFromSession?.case_info);
      }
    }, 1000);*/
    
    /*setTimeout(() => {
      console.log('ğŸ• TIMER 3000ms: Secondary check for invoice system...');
      // Check multiple sources for helper data
      const helperFromWindow = window.helper;
      const helperFromSession = (() => {
        try {
          return JSON.parse(sessionStorage.getItem('helper') || '{}');
        } catch(e) {
          return {};
        }
      })();
      
      const hasValidHelper = (helperFromWindow && helperFromWindow.case_info) || 
                            (helperFromSession && helperFromSession.case_info);
      
      if (typeof checkForAvailableInvoices === 'function' && hasValidHelper) {
        console.log('ğŸš€ TIMER: Secondary call to checkForAvailableInvoices...');
        console.log('  - Using helper from:', helperFromWindow?.case_info ? 'window' : 'sessionStorage');
        checkForAvailableInvoices().catch(e => console.error('ğŸ”§ Timer 2 error:', e));
      } else {
        console.log('âŒ TIMER: Function or helper still not ready at 3000ms');
        console.log('  - Function available:', typeof checkForAvailableInvoices === 'function');
        console.log('  - Helper (window) with case_info:', !!helperFromWindow?.case_info);
        console.log('  - Helper (session) with case_info:', !!helperFromSession?.case_info);
      }
    }, 3000);*/
    
    // Also add a direct event listener for when DOM loads to test
    document.addEventListener('DOMContentLoaded', function() {
      console.log('ğŸ”¥ DIRECT DOMContentLoaded FIRED! Now testing invoice functions...');
      console.log('ğŸ”¥ checkForAvailableInvoices type after DOM loaded:', typeof checkForAvailableInvoices);
      
      // Try to call the function directly
      // DISABLED IN SESSION 91 
      /*if (typeof checkForAvailableInvoices === 'function') {
        console.log('ğŸ”¥ Calling checkForAvailableInvoices directly from DOMContentLoaded...');
        setTimeout(() => {
          checkForAvailableInvoices().catch(e => console.error('ğŸ”¥ Error calling function:', e));
        }, 1000);
      }*/
    });
    
    async function initializeApp() {
      console.log('ğŸš€ SCRIPT DEBUG: initializeApp called!');
      
      // Initialize window.helper from sessionStorage FIRST
      window.helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('ğŸš€ Initialized window.helper from sessionStorage:', window.helper);
      
      // SESSION 94: Load catalog items and invoice lines for 4-layer dropdown
      console.log('ğŸ”„ Loading catalog items and invoice lines for dropdown...');
      try {
        await loadCatalogItems();
        await loadInvoiceLinesForDropdown();
      } catch (err) {
        console.error('âš ï¸ Error loading dropdown data:', err);
      }
      
      await initializeDamageCenterIds();
      
      // Debug depreciation data locations
      console.log('ğŸ” DEBUG - Depreciation data locations:');
      console.log('  helper.depreciation:', window.helper.depreciation);
      console.log('  helper.final_report?.depreciation:', window.helper.final_report?.depreciation);
      console.log('  helper.expertise?.depreciation:', window.helper.expertise?.depreciation);
      
      // Clean up deprecated data structures
      cleanupDeprecatedData();
      
      // First clean up any duplicated damage center numbers in helper
      // cleanupDamageCenterNumbers(); // Commented out - leave existing data as is
      
      // First initialize the FinalReportCalculations object
      console.log('ğŸš€ Initializing FinalReportCalculations object first');
      
      // Then load data from helper after FinalReportCalculations is available
      setTimeout(() => {
        try {
          console.log('ğŸ” DEBUG STEP 1: setTimeout started, calling loadDataFromHelper...');
          loadDataFromHelper();
        } catch (error) {
          console.error('âŒ FATAL ERROR in loadDataFromHelper:', error);
        }
        console.log('ğŸ” DEBUG STEP 2: loadDataFromHelper completed, calling loadAttachmentsData...');
        loadAttachmentsData();
        console.log('ğŸ” DEBUG STEP 3: loadAttachmentsData completed, calling loadClaimsDataToUI...');
        loadClaimsDataToUI(); // Load claims data to UI fields
        console.log('ğŸ” DEBUG STEP 4: loadClaimsDataToUI completed, calling loadLegalText...');
        loadLegalText().catch(console.error);
        console.log('ğŸ” DEBUG STEP 5: loadLegalText completed, calling updateGlobalDepreciationCalculation...');
        updateGlobalDepreciationCalculation();
        console.log('ğŸ” DEBUG STEP 6: updateGlobalDepreciationCalculation completed');
        
        // Load additional notes field and summary fields IMMEDIATELY
        console.log('ğŸ” DEBUG STEP 7: calling loadAdditionalNotesField...');
        loadAdditionalNotesField();
        console.log('ğŸ” DEBUG STEP 8: getting helper data...');
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        console.log('ğŸ” DEBUG STEP 9: calling loadSummaryFieldsFromHelper...');
        loadSummaryFieldsFromHelper(helper);
        console.log('ğŸ” DEBUG STEP 10: loadSummaryFieldsFromHelper completed');
        
        // Initialize summary fields and manual inputs immediately
        console.log('ğŸ” DEBUG STEP 11: calling initializeSummaryFieldsFix...');
        initializeSummaryFieldsFix();
        console.log('ğŸ” DEBUG STEP 12: calling initializeHelperDataSafeguards...');
        initializeHelperDataSafeguards();
        console.log('ğŸ” DEBUG STEP 13: initializeHelperDataSafeguards completed');
        
        // Calculate totals after fields are populated
        setTimeout(() => {
          calculateSummaryTotals();
        }, 100);
        
        console.log('ğŸ” PRE-SESSION 88: About to set setTimeout for invoice check...');
        console.log('ğŸ” PRE-SESSION 88: checkForAvailableInvoices function exists:', typeof checkForAvailableInvoices === 'function');
        
        // Test immediate function availability
        try {
          if (typeof checkForAvailableInvoices === 'function') {
            console.log('âœ… PRE-SESSION 88: Function available immediately');
          } else {
            console.log('âŒ PRE-SESSION 88: Function NOT available immediately');
          }
        } catch (e) {
          console.error('âŒ PRE-SESSION 88: Error testing function:', e);
        }
        
        // SESSION 88: Check for available invoices after data loads
        setTimeout(() => {
          console.log('ğŸš€ SESSION 88 DEBUG: setTimeout function triggered!');
          console.log('ğŸ” SESSION 88: sessionStorage invoiceAssignmentDismissed:', sessionStorage.getItem('invoiceAssignmentDismissed'));
          console.log('ğŸ” SESSION 88: typeof checkForAvailableInvoices:', typeof checkForAvailableInvoices);
          console.log('ğŸ” SESSION 88: checkForAvailableInvoices function exists:', typeof checkForAvailableInvoices === 'function');
          
          // SESSION 91: Re-enabled but will check for REAL invoices only
          if (!sessionStorage.getItem('invoiceAssignmentDismissed')) {
            console.log('ğŸ” SESSION 91: Checking for REAL invoice assignments (no test data)...');
            console.log('  helper.final_report?.invoice_assignments:', window.helper?.final_report?.invoice_assignments);
            console.log('ğŸš€ SESSION 91: About to call checkForAvailableInvoices()...');
            checkForAvailableInvoices();
            console.log('âœ… SESSION 91: checkForAvailableInvoices() call completed');
          } else {
            console.log('â„¹ï¸ SESSION 91: Invoice assignment banner dismissed by user');
          }
        }, 200);
        
        // DO NOT initialize admin hub communication here - wait for helper.js to load first
        console.log('â„¹ï¸ Waiting for helper.js to load before initializing admin hub communication...');
        
        // Wait for MathEngine to be ready before initializing VAT display
        if (typeof window.MathEngine !== 'undefined') {
          // MathEngine already loaded
          if (typeof window.initVatDisplay === 'function') {
            window.initVatDisplay();
          }
        } else {
          // Wait for MathEngine ready event
          window.addEventListener('mathEngineReady', function() {
            console.log('ğŸ¯ MathEngine ready, initializing VAT display...');
            if (typeof window.initVatDisplay === 'function') {
              window.initVatDisplay();
            }
          });
        }
        
        // Log that admin hub functions are now available
        console.log('ğŸ”§ Admin hub functions loaded. Try: verifyAdminHubFunctions() or testAdminHubConnection()');
        
        // Automatically verify functions are loaded (after MathEngine loads)
        setTimeout(() => {
          if (typeof window.verifyAdminHubFunctions === 'function') {
            window.verifyAdminHubFunctions();
          }
        }, 200);
      }, 100);
      
      // Initialize adjustment system with event listeners
      setTimeout(() => {
        console.log('ğŸš€ Initializing adjustment system on page load');
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // DISABLED: Legacy loadAllAdjustments that overrides new configuration
        // if (helper.levi?.custom_adjustments || helper.levi?.adjustments) {
        //   loadAllAdjustments(helper);
        // }
        console.log('âš ï¸ Legacy loadAllAdjustments disabled - using new loadTotalValueSectionAdjustments instead');
        
        // Ensure event listeners are attached
        addAdjustmentEventListeners();
        
        // Trigger initial auto-calculation for existing adjustments
        if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments.length > 0) {
          console.log('ğŸ”„ Running initial auto-calculation for existing adjustments');
          helper.levi.custom_adjustments.forEach((adjustment, index) => {
            if (adjustment.percentage && adjustment.percentage !== 0) {
              calculateAdjustmentValue('custom', index, adjustment.percentage);
            }
          });
        }
      }, 400);
      
      // Trigger initial calculation after page loads
      setTimeout(triggerGlobalDepreciationCalc, 500);
      
      // Add listener to garage days field
      const garageDaysField = document.getElementById('garageDays');
      if (garageDaysField) {
        garageDaysField.addEventListener('input', loadLegalText);
      }
      
      // Add listener to payment method field
      const paymentMethodField = document.getElementById('paymentMethod');
      if (paymentMethodField) {
        paymentMethodField.addEventListener('input', loadLegalText);
      }
      
      // Add listener to legal text textarea to save changes
      const legalTextArea = document.getElementById('legal-text-content');
      if (legalTextArea) {
        // Function to save legal text to helper
        function saveLegalTextToHelper() {
          const helper = window.helper || {};
          
          // Initialize final_report object if it doesn't exist
          if (!helper.final_report) {
            helper.final_report = {};
          }
          helper.final_report.legal_text = legalTextArea.value;
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          // âœ… BIDIRECTIONAL INTEGRATION: Update builder state in real-time
          updateBuilderCurrentState('final_report.legal_text', legalTextArea.value);
        }
        
        // Save on input
        legalTextArea.addEventListener('input', saveLegalTextToHelper);
        
        // Save on change (when user finishes editing)
        legalTextArea.addEventListener('change', saveLegalTextToHelper);
        
        // Initial save if there's already content (after page load)
        setTimeout(() => {
          if (legalTextArea.value && legalTextArea.value.trim() !== '') {
            saveLegalTextToHelper();
            console.log('âœ… Initial legal text saved to helper:', legalTextArea.value.substring(0, 100) + '...');
          }
        }, 1000);
      }
      
      // Add listener to additional notes textarea to save comments
      const additionalNotesArea = document.getElementById('additional-notes');
      if (additionalNotesArea) {
        // Function to save comments to helper
        function saveCommentsToHelper() {
          const helper = window.helper || {};
          
          // Initialize final_report object if it doesn't exist
          if (!helper.final_report) {
            helper.final_report = {};
          }
          // Save to both 'comments' and 'notes' for consistency
          helper.final_report.comments = additionalNotesArea.value;
          helper.final_report.notes = additionalNotesArea.value;
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          // âœ… BIDIRECTIONAL INTEGRATION: Update builder state in real-time
          updateBuilderCurrentState('final_report.comments', additionalNotesArea.value);
          updateBuilderCurrentState('final_report.notes', additionalNotesArea.value);
        }
        
        // Save on input
        additionalNotesArea.addEventListener('input', saveCommentsToHelper);
        
        // Save on change (when user finishes editing)
        additionalNotesArea.addEventListener('change', saveCommentsToHelper);
        
        // Initial save if there's already content (after page load)
        setTimeout(() => {
          if (additionalNotesArea.value && additionalNotesArea.value.trim() !== '') {
            saveCommentsToHelper();
            console.log('âœ… Initial comments saved to helper:', additionalNotesArea.value.substring(0, 50) + '...');
          }
        }, 1000);
      }
      
      // Capture all summary fields to helper.final_report.summary
      function captureSummaryFields() {
        const helper = window.helper || {};
        
        // Initialize final_report object if it doesn't exist
        if (!helper.final_report) {
          helper.final_report = {};
        }
        if (!helper.final_report.summary) {
          helper.final_report.summary = {};
        }
        
        // Get all summary input fields from all summary blocks
        const summaryInputs = document.querySelectorAll('.summary-block input[type="text"], .summary-block input[type="date"], .summary-block input[type="number"]');
        
        summaryInputs.forEach(input => {
          if (input.id && input.value) {
            helper.final_report.summary[input.id] = input.value;
          }
        });
        
        // Save to sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('âœ… Summary fields captured:', helper.final_report.summary);
      }
      
      // Add event listeners to all summary fields (EXCLUDING calculated fields that get overridden)
      function addSummaryFieldListeners() {
        const summaryInputs = document.querySelectorAll('.summary-block input[type="text"]:not(#afterSaleDamage):not(#afterSaleTotal):not(#afterSaleLegal), .summary-block input[type="date"], .summary-block input[type="number"]');
        
        summaryInputs.forEach(input => {
          // Save on input
          input.addEventListener('input', captureSummaryFields);
          // Save on change
          input.addEventListener('change', captureSummaryFields);
        });
        
        console.log(`âœ… Added listeners to ${summaryInputs.length} summary fields`);
      }
      
      // Initialize summary field listeners
      setTimeout(() => {
        addSummaryFieldListeners();
        // Capture initial values
        captureSummaryFields();
      }, 1000);
      
      // AUTO-SAVE ATTACHMENTS ON INPUT
      const attachmentsArea = document.getElementById('attachments-content');
      if (attachmentsArea) {
        attachmentsArea.addEventListener('input', function() {
          // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          if (!helper.final_report) helper.final_report = {};
          helper.final_report.attachments = this.value;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          // âœ… BIDIRECTIONAL INTEGRATION: Update builder state in real-time
          updateBuilderCurrentState('final_report.attachments', this.value);
        });
      }
      
      // Combined report type change handler
      const reportTypeSelect = document.getElementById('reportType');
      if (reportTypeSelect) {
        reportTypeSelect.addEventListener('change', function() {
          const selectedType = this.value;
          
          // Save dropdown selection to helper AND sessionStorage for persistence
          const helper = window.helper || {};
          if (!helper.final_report) helper.final_report = {};
          helper.final_report.dropdown_type = selectedType;
          window.helper = helper;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          sessionStorage.setItem('selectedReportVariant', selectedType);
          console.log('ğŸ’¾ Saved dropdown report type to helper and sessionStorage:', selectedType);
          
          updateReportType();
          loadLegalText().catch(console.error);
          
          // Re-initialize summary field listeners after report type changes
          setTimeout(() => {
            addSummaryFieldListeners();
            captureSummaryFields();
          }, 500); // Wait for summary blocks to update
        });
      }
    } // End of initializeApp function

    // PARTS SEARCH FUNCTIONALITY
    // SESSION 89: Dynamic Part Input Handler
    // Checks if invoice data is available, shows invoice dropdowns or falls back to search
    function handlePartInput(input, centerIndex, partIndex) {
      // SESSION 94 CHANGE: Always use 4-layer system for consistent experience
      console.log('ğŸ” SESSION 94: Using 4-layer dropdown system for part input');
      
      // Always use 4-layer suggestions for consistency
      show4LayerPartSuggestions(input, centerIndex, partIndex);
    }

    // SESSION 94: New function for 4-layer suggestions without invoice priority
    function show4LayerPartSuggestions(input, centerIndex, partIndex) {
      try {
        const query = input.value.toLowerCase().trim();
        const suggestionsDiv = input.nextElementSibling;
        
        if (query.length < 1) {
          suggestionsDiv.style.display = 'none';
          return;
        }

        console.log('ğŸ“‹ SESSION 94: Showing 4-layer part suggestions for query:', query);
        
        // Get all parts using the 4-layer system
        const allParts = getCombinedDropdownData(query);
        
        if (allParts.length > 0) {
          displayPartSuggestions(suggestionsDiv, allParts, input, centerIndex, partIndex);
          console.log(`âœ… SESSION 94: Displayed ${allParts.length} parts from 4-layer system`);
        } else {
          // Even with no results, show a message rather than falling back
          suggestionsDiv.innerHTML = '<div style="padding: 8px; color: #666; text-align: center;">×œ× × ××¦××• ×—×œ×§×™× ××ª××™××™×</div>';
          suggestionsDiv.style.display = 'block';
          console.log('â„¹ï¸ SESSION 94: No parts found in 4-layer system for query:', query);
        }
      } catch (error) {
        console.error('âŒ SESSION 94: Error showing 4-layer part suggestions:', error);
        // Fallback to original search only in case of error
        showPartSuggestions(input, centerIndex, partIndex);
      }
    }

    // SESSION 89: Dynamic Part Click Handler
    // On click, show available options (invoice data if available, search if not)
    function handlePartClick(input, centerIndex, partIndex) {
      // SESSION 94 CHANGE: Always use 4-layer system
      console.log('ğŸ” SESSION 94: Using 4-layer dropdown system for part click');
      
      // Always show all available parts from 4-layer system
      showAll4LayerParts(input, centerIndex, partIndex);
    }

    // SESSION 94: Show all available parts from 4-layer system (on click)
    function showAll4LayerParts(input, centerIndex, partIndex) {
      try {
        const suggestionsDiv = input.nextElementSibling;
        console.log('ğŸ“‹ SESSION 94: Showing all available parts from 4-layer system');
        
        // Get all parts from 4-layer system (no query filter)
        const allParts = getCombinedDropdownData('');
        
        if (allParts.length > 0) {
          displayPartSuggestions(suggestionsDiv, allParts, input, centerIndex, partIndex);
          console.log(`âœ… SESSION 94: Displayed ${allParts.length} parts from all 4 layers`);
        } else {
          // Show message if no parts available
          suggestionsDiv.innerHTML = '<div style="padding: 8px; color: #666; text-align: center;">××™×Ÿ ×—×œ×§×™× ×–××™× ×™× ×‘××¢×¨×›×ª</div>';
          suggestionsDiv.style.display = 'block';
          console.log('â„¹ï¸ SESSION 94: No parts available in 4-layer system');
        }
      } catch (error) {
        console.error('âŒ SESSION 94: Error showing all 4-layer parts:', error);
      }
    }

    // SESSION 89: Check if invoice assignments are available
    function hasInvoiceAssignments() {
      try {
        const helper = window.helper;
        const caseId = helper?.case_info?.supabase_case_id;
        
        console.log('ğŸ” SESSION 94: Comprehensive invoice data detection...');
        console.log('  - Case ID:', caseId);
        console.log('  - Helper centers:', helper?.centers?.length || 0);
        
        // SESSION 94 ENHANCEMENT: More comprehensive detection
        const detectionChecks = [
          // PRIMARY CHECK: Direct invoice data in helper
          () => {
            if (helper?.invoices && Array.isArray(helper.invoices) && helper.invoices.length > 0) {
              console.log('ğŸ“‹ âœ… Found helper.invoices:', helper.invoices.length);
              return true;
            }
            return false;
          },
          
          // SECONDARY CHECK: Global invoice data for dropdowns  
          () => {
            if (window.invoiceDataForDropdowns?.invoice_lines && window.invoiceDataForDropdowns.invoice_lines.length > 0) {
              console.log('ğŸ“‹ âœ… Found global invoiceDataForDropdowns:', window.invoiceDataForDropdowns.invoice_lines.length);
              return true;
            }
            return false;
          },
          
          // SESSION 94 NEW: Check centers_after_invoice (private reports)
          () => {
            if (helper?.centers_after_invoice && Array.isArray(helper.centers_after_invoice) && helper.centers_after_invoice.length > 0) {
              console.log('ğŸ“‹ âœ… Found centers_after_invoice:', helper.centers_after_invoice.length);
              return true;
            }
            return false;
          },
          
          // LEGACY CHECK: Original assignments in helper
          () => {
            const assignments = helper?.final_report?.invoice_assignments;
            if (assignments && assignments.length > 0) {
              console.log('ğŸ“‹ âœ… Found invoice assignments in helper:', assignments.length);
              return true;
            }
            return false;
          },
          
          // ENHANCED CHECK: Parts with invoice source markers or external_ref
          () => {
            const mappedData = helper?.centers;
            if (mappedData && Array.isArray(mappedData)) {
              const hasMappedParts = mappedData.some(center => 
                center.Parts?.parts_required?.some(part => part.source === 'invoice' || part.external_ref) ||
                center.Works?.works?.some(work => work.source === 'invoice' || work.external_ref) ||
                center.Repairs?.repairs?.some(repair => repair.source === 'invoice' || repair.external_ref) ||
                center.parts?.some(part => part.external_ref || part.invoice_source)
              );
              if (hasMappedParts) {
                console.log('ğŸ“‹ âœ… Found mapped invoice data in centers');
                return true;
              }
            }
            return false;
          }
        ];
        
        // Run all checks and return true if any pass
        for (let i = 0; i < detectionChecks.length; i++) {
          try {
            if (detectionChecks[i]()) {
              console.log(`ğŸ“‹ âœ… SESSION 94: Invoice data detected via check ${i + 1}`);
              return true;
            }
          } catch (checkError) {
            console.warn(`âš ï¸ Detection check ${i + 1} failed:`, checkError);
          }
        }
        
        console.log('ğŸ“‹ âŒ SESSION 94: No invoice data found - but will still use 4-layer system');
        // SESSION 94 CHANGE: Return false but don't fallback - always use 4-layer system
        return false;
      } catch (error) {
        console.error('âŒ Error checking invoice assignments:', error);
        return false;
      }
    }

    // SESSION 89: Show invoice-based part suggestions
    async function showInvoicePartSuggestions(input, centerIndex, partIndex) {
      try {
        const query = input.value.toLowerCase().trim();
        const suggestionsDiv = input.nextElementSibling;
        
        if (query.length < 1) {
          suggestionsDiv.style.display = 'none';
          return;
        }

        console.log('ğŸ“‹ Showing invoice part suggestions for query:', query);
        
        // Get invoice parts using the damage center mapper
        const caseId = window.helper?.case_info?.supabase_case_id;
        const invoiceId = null; // Will load all assigned invoices
        
        if (window.damageCenterMapper) {
          const invoiceParts = await window.damageCenterMapper.getDropdownItems('part', caseId, invoiceId);
          
          // Filter parts based on query
          const filteredParts = invoiceParts.filter(part => 
            part.name.toLowerCase().includes(query) || 
            part.description?.toLowerCase().includes(query)
          );
          
          if (filteredParts.length > 0) {
            displayPartSuggestions(suggestionsDiv, filteredParts, input, centerIndex, partIndex);
          } else {
            // No invoice matches, fallback to search
            showPartSuggestions(input, centerIndex, partIndex);
          }
        } else {
          console.log('âš ï¸ SESSION 89: damageCenterMapper not available, using direct helper fallback');
          // Direct fallback: extract parts from helper data
          const fallbackParts = getInvoicePartsFromHelper(query);
          if (fallbackParts.length > 0) {
            displayPartSuggestions(suggestionsDiv, fallbackParts, input, centerIndex, partIndex);
          } else {
            // No invoice data available, fallback to search
            showPartSuggestions(input, centerIndex, partIndex);
          }
        }
      } catch (error) {
        console.error('âŒ Error showing invoice part suggestions:', error);
        // Fallback to original search
        showPartSuggestions(input, centerIndex, partIndex);
      }
    }

    // SESSION 89: Show all available invoice parts (on click)
    async function showAllInvoiceParts(input, centerIndex, partIndex) {
      try {
        const suggestionsDiv = input.nextElementSibling;
        console.log('ğŸ“‹ Showing all available invoice parts');
        
        // Get all invoice parts
        const caseId = window.helper?.case_info?.supabase_case_id;
        const invoiceId = null; // Will load all assigned invoices
        
        if (window.damageCenterMapper) {
          const invoiceParts = await window.damageCenterMapper.getDropdownItems('part', caseId, invoiceId);
          
          if (invoiceParts.length > 0) {
            displayPartSuggestions(suggestionsDiv, invoiceParts, input, centerIndex, partIndex);
          } else {
            // No invoice parts available, show message
            suggestionsDiv.innerHTML = '<div style="padding: 8px; color: #666; text-align: center;">××™×Ÿ ×—×œ×¤×™× ×–××™× ×™× ××—×©×‘×•× ×™×•×ª</div>';
            suggestionsDiv.style.display = 'block';
          }
        } else {
          console.log('âš ï¸ SESSION 89: damageCenterMapper not available, using direct helper fallback for all parts');
          // Direct fallback: get all parts from helper data
          const fallbackParts = getInvoicePartsFromHelper('');
          if (fallbackParts.length > 0) {
            displayPartSuggestions(suggestionsDiv, fallbackParts, input, centerIndex, partIndex);
          } else {
            // No invoice parts available, show message
            suggestionsDiv.innerHTML = '<div style="padding: 8px; color: #666; text-align: center;">××™×Ÿ ×—×œ×¤×™× ×–××™× ×™× ××—×©×‘×•× ×™×•×ª</div>';
            suggestionsDiv.style.display = 'block';
          }
        }
      } catch (error) {
        console.error('âŒ Error showing all invoice parts:', error);
      }
    }

    // SESSION 89: Display part suggestions in dropdown format (matches parts-required style)
    function displayPartSuggestions(suggestionsDiv, parts, input, centerIndex, partIndex) {
      // Update dropdown styling to match parts-required
      suggestionsDiv.style.cssText = `
        position: absolute;
        top: 100%;
        right: 0;
        left: 0;
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        text-align: right;
        z-index: 1000;
        max-height: 200px;
        overflow-y: auto;
        max-width: 100%;
        box-sizing: border-box;
        contain: layout;
        display: block;
      `;
      
      const suggestionsHTML = parts.map(part => {
        // SESSION 94: Add layer indicators with emojis
        let layerIcon = '';
        let layerColor = '#666';
        
        switch (part.layer) {
          case 1:
            layerIcon = 'ğŸ§¾';
            layerColor = '#2196F3'; // Blue for invoices
            break;
          case 2:
            layerIcon = 'ğŸ“‹';
            layerColor = '#4CAF50'; // Green for selected parts
            break;
          case 3:
            layerIcon = 'ğŸ¦';
            layerColor = '#FF9800'; // Orange for catalog
            break;
          case 4:
            layerIcon = 'ğŸ“„';
            layerColor = '#9C27B0'; // Purple for parts bank
            break;
          default:
            layerIcon = 'â“';
            layerColor = '#666';
        }
        
        return `
        <div class="suggestion-item" 
             style="padding: 8px 12px; cursor: pointer; font-size: 13px; border-right: 4px solid ${layerColor};"
             onmouseover="this.style.background='#f0f0f0'" 
             onmouseout="this.style.background='white'"
             onclick="selectInvoicePart(this, '${part.name}', '${part.price || 0}', '${part.source || ''}', ${centerIndex}, ${partIndex})">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div style="flex: 1;">
              <div style="font-weight: 500; color: #333; font-size: 13px;">
                <span style="margin-left: 8px; font-size: 16px;">${layerIcon}</span>
                ${part.name}
              </div>
              ${part.description ? `<div style="font-size: 11px; color: #666; margin-top: 2px;">${part.description}</div>` : ''}
              <div style="font-size: 10px; color: ${layerColor}; margin-top: 2px; font-weight: 500;">${part.source}</div>
            </div>
            <div style="text-align: left; margin-left: 10px;">
              <div style="font-weight: 500; color: #2563eb; font-size: 12px;">â‚ª${parseFloat(part.price || 0).toLocaleString()}</div>
            </div>
          </div>
        </div>
        `;
      }).join('');
      
      suggestionsDiv.innerHTML = suggestionsHTML;
    }

    // SESSION 89: Select invoice part and populate fields
    function selectInvoicePart(element, partName, partPrice, source, centerIndex, partIndex) {
      try {
        // Find the part row
        const partRow = document.querySelector(`.part-row[data-center="${centerIndex}"][data-part="${partIndex}"]`);
        if (!partRow) return;
        
        // Populate fields
        const nameInput = partRow.querySelector('.part-name');
        const priceInput = partRow.querySelector('.part-price-per-unit');
        
        if (nameInput) nameInput.value = partName;
        if (priceInput) priceInput.value = partPrice;
        
        // Hide suggestions
        const suggestionsDiv = element.closest('.part-suggestions');
        if (suggestionsDiv) suggestionsDiv.style.display = 'none';
        
        // Auto-save changes
        if (typeof autoSaveDamageCenterChanges === 'function') {
          autoSaveDamageCenterChanges();
        }
        
        console.log(`âœ… Selected invoice part: ${partName} (â‚ª${partPrice}) from ${source}`);
        
        // Show user feedback
        showPartSelectionFeedback(partRow, source);
        
      } catch (error) {
        console.error('âŒ Error selecting invoice part:', error);
      }
    }

    // SESSION 94: Test 4-layer dropdown system
    window.test4LayerDropdown = function() {
      console.log('ğŸ§ª SESSION 94: Testing 4-layer dropdown system...');
      
      // Check data sources first
      console.log('ğŸ” Data Sources Check:');
      console.log('  - INVOICE_LINES:', !!window.INVOICE_LINES, window.INVOICE_LINES?.length || 0);
      console.log('  - PARTS_CATALOG:', !!window.PARTS_CATALOG, window.PARTS_CATALOG?.length || 0);
      console.log('  - PARTS_BANK:', !!window.PARTS_BANK, typeof window.PARTS_BANK);
      console.log('  - helper.case_info.supabase_case_id:', window.helper?.case_info?.supabase_case_id);
      
      // Test with empty query to get all items
      const allItems = getCombinedDropdownData('');
      
      const breakdown = {
        'Layer 1 (Invoice)': allItems.filter(p => p.layer === 1).length,
        'Layer 2 (Selected)': allItems.filter(p => p.layer === 2).length,
        'Layer 3 (Catalog)': allItems.filter(p => p.layer === 3).length,
        'Layer 4 (Parts Bank)': allItems.filter(p => p.layer === 4).length
      };
      
      console.log('ğŸ“Š 4-Layer Breakdown:', breakdown);
      console.log('ğŸ“Š Total Items:', allItems.length);
      
      // Test with query
      const queryResults = getCombinedDropdownData('×˜××¡×”');
      console.log('ğŸ” Query "×˜××¡×”" results:', queryResults.length);
      
      // Show samples from each layer
      [1,2,3,4].forEach(layer => {
        const layerItems = allItems.filter(p => p.layer === layer);
        if (layerItems.length > 0) {
          console.log(`ğŸ” Layer ${layer} sample:`, layerItems.slice(0, 2));
        } else {
          console.log(`âš ï¸ Layer ${layer} has no items`);
        }
      });
      
      // Return comprehensive status
      const result = {
        totalItems: allItems.length,
        breakdown: breakdown,
        dataSources: {
          invoiceLines: !!window.INVOICE_LINES && window.INVOICE_LINES.length > 0,
          catalog: !!window.PARTS_CATALOG && window.PARTS_CATALOG.length > 0,
          partsBank: !!window.PARTS_BANK,
          caseId: !!window.helper?.case_info?.supabase_case_id
        },
        layersWorking: {
          layer1: breakdown['Layer 1 (Invoice)'] > 0,
          layer2: breakdown['Layer 2 (Selected)'] > 0,
          layer3: breakdown['Layer 3 (Catalog)'] > 0,
          layer4: breakdown['Layer 4 (Parts Bank)'] > 0
        },
        allLayersWorking: breakdown['Layer 1 (Invoice)'] > 0 && 
                         breakdown['Layer 3 (Catalog)'] > 0 &&
                         breakdown['Layer 4 (Parts Bank)'] > 0
      };
      
      console.log('ğŸ“‹ Final Status:', result);
      return result;
    };
    
    // Helper function to reload data sources
    window.reloadDropdownData = async function() {
      console.log('ğŸ”„ Reloading dropdown data sources...');
      
      // Clear cached data
      window.INVOICE_LINES = null;
      window.PARTS_CATALOG = null;
      
      try {
        await loadCatalogItems();
        await loadInvoiceLinesForDropdown();
        console.log('âœ… Data reloaded successfully');
        
        // Test again
        return window.test4LayerDropdown();
      } catch (err) {
        console.error('âŒ Error reloading data:', err);
        return false;
      }
    };
    
    // SESSION 94: Invoice UUID debugging helper
    window.debugInvoiceQueries = function() {
      console.log('ğŸ” Invoice Queries Debug:');
      
      // Check current invoice data structures
      console.log('ğŸ“Š Current Invoice Data Structures:');
      console.log('  - window.INVOICE_LINES:', !!window.INVOICE_LINES, window.INVOICE_LINES?.length || 0);
      console.log('  - window.invoiceDataForDropdowns:', !!window.invoiceDataForDropdowns);
      if (window.invoiceDataForDropdowns) {
        console.log('  - invoiceDataForDropdowns.invoices:', window.invoiceDataForDropdowns.invoices?.length || 0);
        console.log('  - invoiceDataForDropdowns.invoice_lines:', window.invoiceDataForDropdowns.invoice_lines?.length || 0);
      }
      
      // Check helper invoices
      console.log('ğŸ“‹ Helper Invoice Data:');
      console.log('  - helper.invoices:', !!window.helper?.invoices, window.helper?.invoices?.length || 0);
      if (window.helper?.invoices?.length > 0) {
        console.log('  - Sample helper invoice:', window.helper.invoices[0]);
      }
      
      return {
        cachedInvoiceLines: window.INVOICE_LINES?.length || 0,
        dropdownInvoices: window.invoiceDataForDropdowns?.invoices?.length || 0,
        dropdownLines: window.invoiceDataForDropdowns?.invoice_lines?.length || 0,
        helperInvoices: window.helper?.invoices?.length || 0
      };
    };

    // Debug helper function
    window.debugCaseId = function() {
      console.log('ğŸ” Case ID Debug Information:');
      console.log('  - window.helper:', window.helper);
      console.log('  - helper.case_info:', window.helper?.case_info);
      console.log('  - helper.case_info.supabase_case_id:', window.helper?.case_info?.supabase_case_id);
      console.log('  - typeof supabase_case_id:', typeof window.helper?.case_info?.supabase_case_id);
      console.log('  - sessionStorage helper case_info:', JSON.parse(sessionStorage.getItem('helper') || '{}')?.case_info);
      
      // Check URL sources
      const urlParams = new URLSearchParams(window.location.search);
      const caseIdFromUrl = urlParams.get('case_id') || urlParams.get('caseId');
      console.log('  - URL case_id param:', caseIdFromUrl);
      console.log('  - Current URL:', window.location.href);
      
      const currentCaseId = window.helper?.case_info?.supabase_case_id;
      
      // Check if we can set case_id manually for testing
      if (caseIdFromUrl && !currentCaseId) {
        console.log('ğŸ”§ Setting case_id from URL to helper.case_info.supabase_case_id');
        if (!window.helper) window.helper = {};
        if (!window.helper.case_info) window.helper.case_info = {};
        window.helper.case_info.supabase_case_id = caseIdFromUrl;
        sessionStorage.setItem('helper', JSON.stringify(window.helper));
      }
      
      return {
        helperExists: !!window.helper,
        caseInfoExists: !!window.helper?.case_info,
        supabaseCaseId: currentCaseId,
        urlCaseId: caseIdFromUrl,
        canLoadInvoices: !!(currentCaseId && window.supabase)
      };
    };

    // SESSION 94: Load catalog items from Supabase and cache them
    async function loadCatalogItems() {
      try {
        if (window.PARTS_CATALOG && window.PARTS_CATALOG.length > 0) {
          console.log('âœ… Catalog items already cached:', window.PARTS_CATALOG.length);
          return window.PARTS_CATALOG;
        }
        
        if (!window.supabase) {
          console.log('âš ï¸ Supabase not available for catalog loading');
          return [];
        }
        
        console.log('ğŸ”„ Loading catalog items from Supabase...');
        const { data: catalogData, error } = await window.supabase
          .from('catalog_items')
          .select('cat_num_desc, pcode, supplier_name, price, make, model')
          .limit(1000); // Limit for performance
        
        if (catalogData && !error) {
          console.log(`âœ… Loaded ${catalogData.length} catalog items from Supabase`);
          window.PARTS_CATALOG = catalogData; // Cache for future use
          return catalogData;
        } else {
          console.log('âš ï¸ No catalog data loaded:', error?.message || 'Unknown error');
          window.PARTS_CATALOG = []; // Cache empty array to avoid repeated calls
          return [];
        }
      } catch (err) {
        console.error('âŒ Error loading catalog items:', err);
        window.PARTS_CATALOG = []; // Cache empty array to avoid repeated calls
        return [];
      }
    }

    // SESSION 94: Simple invoice lines loader for dropdown
    async function loadInvoiceLinesForDropdown() {
      try {
        if (window.INVOICE_LINES && window.INVOICE_LINES.length > 0) {
          console.log('âœ… Invoice lines already cached:', window.INVOICE_LINES.length);
          return window.INVOICE_LINES;
        }
        
        if (!window.supabase) {
          console.log('âš ï¸ Supabase not available');
          window.INVOICE_LINES = [];
          return [];
        }
        
        const caseId = window.helper?.case_info?.supabase_case_id;
        if (!caseId) {
          console.log('âš ï¸ No case_id available');
          window.INVOICE_LINES = [];
          return [];
        }
        
        console.log('ğŸ”„ Loading invoice lines for case:', caseId);
        
        // Simple approach: Get all invoice lines and filter by case
        const { data: allLines, error } = await window.supabase
          .from('invoice_lines')
          .select('*');
        
        if (error) {
          console.error('âŒ Error loading invoice lines:', error);
          window.INVOICE_LINES = [];
          return [];
        }
        
        console.log(`âœ… Loaded ${allLines?.length || 0} total invoice lines`);
        window.INVOICE_LINES = allLines || [];
        return allLines || [];
        
      } catch (err) {
        console.error('âŒ Error in loadInvoiceLinesForDropdown:', err);
        window.INVOICE_LINES = [];
        return [];
      }
    }

    // SESSION 89: Get all 4-layer dropdown data (Invoice + Selected + Catalog + Bank)
    function getCombinedDropdownData(query = '') {
      try {
        console.log('ğŸ” SESSION 89: Building 4-layer dropdown data...');
        const helper = window.helper;
        const allParts = [];
        
        // LAYER 1: ğŸ§¾ Invoice lines (Use cached INVOICE_LINES data)
        console.log('ğŸ“‹ ×©×›×‘×” 1: ×‘×“×™×§×ª ×©×•×¨×•×ª ×—×©×‘×•× ×™×ª...');
        let invoiceCount = 0;

        // Use cached data if available, otherwise show 0 items
        if (window.INVOICE_LINES && Array.isArray(window.INVOICE_LINES)) {
          console.log(`ğŸ“‹ Using cached invoice lines: ${window.INVOICE_LINES.length} items`);
          
          window.INVOICE_LINES.forEach(line => {
            const description = line.description || '';
            if (description && (!query || description.toLowerCase().includes(query.toLowerCase()))) {
              const partData = {
                name: description,
                description: `×›××•×ª: ${line.quantity || 1}`,
                price: line.unit_price || line.line_total || 0,
                source: `ğŸ§¾ ×—×©×‘×•× ×™×ª`,
                layer: 1,
                original: line
              };
              allParts.push(partData);
              invoiceCount++;
            }
          });
        } else {
          console.log('âš ï¸ No cached invoice lines - need to load via Supabase');
        }
        
        // Fallback: Try helper.invoices (legacy support)
        if (invoiceCount === 0 && helper?.invoices && Array.isArray(helper.invoices)) {
          console.log('ğŸ”„ Using fallback helper.invoices data...');
          helper.invoices.forEach((invoice, idx) => {
            // Handle different invoice structures
            let lineItems = [];
            if (invoice.line_items && Array.isArray(invoice.line_items)) {
              lineItems = invoice.line_items;
            } else if (invoice.lines && Array.isArray(invoice.lines)) {
              lineItems = invoice.lines;
            }
            
            lineItems.forEach((line, lineIdx) => {
              const description = line.description || line.metadata?.name || '';
              const unitPrice = line.unit_price || line.line_total || 0;
              
              if (description && (!query || description.toLowerCase().includes(query.toLowerCase()))) {
                const partData = {
                  name: description,
                  description: `×›××•×ª: ${line.quantity || 1}`,
                  price: unitPrice,
                  source: `ğŸ§¾ ×—×©×‘×•× ×™×ª ${invoice.invoice_number || `${idx + 1}`}`,
                  layer: 1,
                  original: line,
                  metadata: line.metadata
                };
                allParts.push(partData);
                invoiceCount++;
              }
            });
          });
        }
        
        console.log(`âœ… SESSION 90: Layer 1 loaded ${invoiceCount} invoice parts`);
        
        // LAYER 2: ğŸ“‹ Selected parts (from Supabase selected_parts table via helper)
        console.log('ğŸ“‹ ×©×›×‘×” 2: ×‘×“×™×§×ª ×—×œ×§×™× × ×‘×—×¨×™×...');
        if (helper?.parts_search?.selected_parts && Array.isArray(helper.parts_search.selected_parts)) {
          helper.parts_search.selected_parts.forEach(part => {
            if (part.name && (!query || part.name.toLowerCase().includes(query.toLowerCase()))) {
              allParts.push({
                name: part.name,
                description: part.description || '',
                price: part.price || part.cost || 0,
                source: 'ğŸ“‹ ×—×œ×§×™× × ×‘×—×¨×™×',
                layer: 2,
                original: part
              });
            }
          });
        }
        
        // Also check damage centers for existing parts
        if (helper?.centers && Array.isArray(helper.centers)) {
          helper.centers.forEach((center, idx) => {
            if (center.parts && Array.isArray(center.parts)) {
              center.parts.forEach(part => {
                if (part.name && (!query || part.name.toLowerCase().includes(query.toLowerCase()))) {
                  allParts.push({
                    name: part.name,
                    description: part.description || '',
                    price: part.price || part.cost || 0,
                    source: `ğŸ“‹ ××¨×›×– × ×–×§ ${idx + 1}`,
                    layer: 2,
                    original: part
                  });
                }
              });
            }
          });
        }
        
        // LAYER 3: ğŸ¦ Global catalog (from catalog_items table)
        console.log('ğŸ“‹ ×©×›×‘×” 3: ×§×˜×œ×•×’ ×’×œ×•×‘×œ×™ - ×‘×“×™×§×ª × ×ª×•× ×™×...');
        
        // Use cached catalog data if available
        let catalogItems = window.PARTS_CATALOG || [];
        let catalogCount = 0;
        
        if (catalogItems.length > 0) {
          console.log(`ğŸ”„ Using cached catalog data: ${catalogItems.length} items`);
          
          // Add catalog items to dropdown
          catalogItems.forEach(item => {
            const description = item.cat_num_desc || '';
            const partCode = item.pcode || '';
            const supplier = item.supplier_name || '';
            const make = item.make || '';
            const model = item.model || '';
            
            if (description && (!query || description.toLowerCase().includes(query.toLowerCase()))) {
              allParts.push({
                name: description,
                description: `×§×•×“: ${partCode} | ×¡×¤×§: ${supplier} | ×™×¦×¨×Ÿ: ${make}${model ? ` ${model}` : ''}`,
                price: item.price || 0,
                source: `ğŸ¦ ×§×˜×œ×•×’ ×’×œ×•×‘×œ×™ (${supplier})`,
                layer: 3,
                original: item
              });
              catalogCount++;
            }
          });
        } else {
          console.log('âš ï¸ No catalog data cached - call loadCatalogItems() first');
        }
        
        console.log(`âœ… Layer 3 loaded ${catalogCount} catalog items`);
        
        // LAYER 4: ğŸ“„ Parts.js bank (from PARTS_BANK)
        console.log('ğŸ“‹ ×©×›×‘×” 4: ×‘×“×™×§×ª ×‘× ×§ ×—×œ×§×™×...');
        console.log('ğŸ” window.PARTS_BANK available:', !!window.PARTS_BANK);
        console.log('ğŸ” window.PARTS_BANK type:', typeof window.PARTS_BANK);
        
        if (window.PARTS_BANK) {
          let categoriesProcessed = 0;
          let partsAdded = 0;
          
          // SESSION 94 FIX: Handle both object and array structures
          if (Array.isArray(window.PARTS_BANK)) {
            // Original expected format - array of category objects
            console.log('âœ… PARTS_BANK is array format, processing categories...');
            window.PARTS_BANK.forEach((category, idx) => {
              console.log(`ğŸ” Category ${idx}:`, category?.name, 'parts:', category?.parts?.length || 0);
              if (category.parts && Array.isArray(category.parts)) {
                categoriesProcessed++;
                category.parts.forEach(part => {
                  if (part.name && (!query || part.name.toLowerCase().includes(query.toLowerCase()))) {
                    allParts.push({
                      name: part.name,
                      description: part.description || `××§×˜×’×•×¨×™×”: ${category.name}`,
                      price: part.price || 0,
                      source: `ğŸ“„ ×‘× ×§ ×—×œ×§×™× (${category.name})`,
                      layer: 4,
                      original: part
                    });
                    partsAdded++;
                  }
                });
              }
            });
          } else if (typeof window.PARTS_BANK === 'object') {
            // SESSION 94 FIX: Actual format - object with category keys
            console.log('âœ… PARTS_BANK is object format, converting and processing...');
            Object.keys(window.PARTS_BANK).forEach(categoryName => {
              const parts = window.PARTS_BANK[categoryName];
              console.log(`ğŸ” Category "${categoryName}":`, 'parts:', parts?.length || 0);
              
              if (Array.isArray(parts)) {
                categoriesProcessed++;
                parts.forEach(partName => {
                  // Handle both string and object parts
                  const name = typeof partName === 'string' ? partName : partName.name;
                  if (name && (!query || name.toLowerCase().includes(query.toLowerCase()))) {
                    allParts.push({
                      name: name,
                      description: `××§×˜×’×•×¨×™×”: ${categoryName}`,
                      price: typeof partName === 'object' ? partName.price || 0 : 0,
                      source: `ğŸ“„ ×‘× ×§ ×—×œ×§×™× (${categoryName})`,
                      layer: 4,
                      original: partName
                    });
                    partsAdded++;
                  }
                });
              }
            });
          }
          
          console.log(`âœ… SESSION 94: Processed ${categoriesProcessed} categories, added ${partsAdded} parts from PARTS_BANK`);
        } else {
          console.log('âŒ PARTS_BANK not available');
        }
        
        console.log(`âœ… SESSION 89: × ××¦××• ${allParts.length} ×—×œ×§×™× ×‘-4 ×©×›×‘×•×ª:`, {
          '×©×›×‘×” 1 - ×—×©×‘×•× ×™×•×ª': allParts.filter(p => p.layer === 1).length,
          '×©×›×‘×” 2 - ×—×œ×§×™× × ×‘×—×¨×™×': allParts.filter(p => p.layer === 2).length, 
          '×©×›×‘×” 3 - ×§×˜×œ×•×’ ×’×œ×•×‘×œ×™': allParts.filter(p => p.layer === 3).length,
          '×©×›×‘×” 4 - ×‘× ×§ ×—×œ×§×™×': allParts.filter(p => p.layer === 4).length
        });
        
        return allParts;
        
      } catch (error) {
        console.error('âŒ Error building 4-layer dropdown data:', error);
        return [];
      }
    }

    // SESSION 89: Fallback function to get invoice parts directly from helper (legacy support)
    function getInvoicePartsFromHelper(query = '') {
      // Use the new 4-layer system
      return getCombinedDropdownData(query);
    }

    // SESSION 89: Show visual feedback that part was selected from invoice
    function showPartSelectionFeedback(partRow, source) {
      try {
        const nameInput = partRow.querySelector('.part-name');
        if (!nameInput) return;
        
        // Add visual indicator
        const originalStyle = nameInput.style.border;
        nameInput.style.border = '2px solid #10b981';
        nameInput.style.background = '#f0fdf4';
        
        // Create source indicator
        let indicator = partRow.querySelector('.invoice-source-indicator');
        if (!indicator) {
          indicator = document.createElement('div');
          indicator.className = 'invoice-source-indicator';
          indicator.style.cssText = `
            position: absolute;
            top: -8px;
            right: 8px;
            background: #10b981;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 8px;
            z-index: 100;
          `;
          const inputContainer = nameInput.parentElement;
          if (inputContainer.style.position !== 'relative') {
            inputContainer.style.position = 'relative';
          }
          inputContainer.appendChild(indicator);
        }
        indicator.textContent = source || '×—×©×‘×•× ×™×ª';
        
        // Reset border after 3 seconds
        setTimeout(() => {
          nameInput.style.border = originalStyle;
          nameInput.style.background = '';
        }, 3000);
        
      } catch (error) {
        console.error('âŒ Error showing part selection feedback:', error);
      }
    }

    // SESSION 89: WORKS ENHANCEMENT FUNCTIONS
    
    // Handle work dropdown click to show invoice works
    async function handleWorkClick(select, centerIndex, workIndex) {
      try {
        if (hasInvoiceAssignments()) {
          await addInvoiceWorksToDropdown(select, centerIndex, workIndex);
        }
      } catch (error) {
        console.error('âŒ Error handling work click:', error);
      }
    }

    // Add invoice works to the work dropdown
    async function addInvoiceWorksToDropdown(select, centerIndex, workIndex) {
      try {
        console.log('ğŸ“‹ Adding invoice works to dropdown');
        
        // Get invoice works using the damage center mapper
        const caseId = window.helper?.case_info?.supabase_case_id;
        
        if (window.damageCenterMapper) {
          const invoiceWorks = await window.damageCenterMapper.getDropdownItems('work', caseId, null);
          
          if (invoiceWorks.length > 0) {
            // Remove existing invoice options (cleanup)
            const existingInvoiceOptions = select.querySelectorAll('.invoice-work-option');
            existingInvoiceOptions.forEach(option => option.remove());
            
            // Add separator if not already exists
            let separator = select.querySelector('.invoice-separator');
            if (!separator) {
              separator = document.createElement('option');
              separator.className = 'invoice-separator';
              separator.disabled = true;
              separator.textContent = '--- ×¢×‘×•×“×•×ª ××—×©×‘×•× ×™×•×ª ---';
              separator.style.fontWeight = 'bold';
              separator.style.color = '#2563eb';
              select.appendChild(separator);
            }
            
            // Add invoice works as options
            invoiceWorks.forEach(work => {
              const option = document.createElement('option');
              option.className = 'invoice-work-option';
              option.value = work.category || work.name;
              option.textContent = `${work.name} (â‚ª${parseFloat(work.cost || 0).toLocaleString()})`;
              option.setAttribute('data-invoice-cost', work.cost || 0);
              option.setAttribute('data-invoice-source', work.source || '×—×©×‘×•× ×™×ª');
              option.style.color = '#2563eb';
              option.style.fontWeight = '500';
              select.appendChild(option);
            });
            
            console.log(`âœ… Added ${invoiceWorks.length} invoice works to dropdown`);
          }
        }
      } catch (error) {
        console.error('âŒ Error adding invoice works to dropdown:', error);
      }
    }

    // Enhanced work type change handler
    function handleWorkTypeChange(select, centerIndex, workIndex) {
      try {
        const selectedOption = select.options[select.selectedIndex];
        const workRow = select.closest('.work-row');
        if (!workRow) return;
        
        // Handle "Other" work type
        const otherInput = workRow.querySelector('.work-type-other');
        if (otherInput) {
          otherInput.style.display = select.value === '××—×¨' ? 'block' : 'none';
        }
        
        // If this is an invoice work option, populate cost
        if (selectedOption.classList.contains('invoice-work-option')) {
          const cost = selectedOption.getAttribute('data-invoice-cost');
          const source = selectedOption.getAttribute('data-invoice-source');
          
          // Populate cost field
          const costInput = workRow.querySelector('.work-cost');
          if (costInput && cost) {
            costInput.value = cost;
          }
          
          console.log(`âœ… Selected invoice work: ${select.value} (â‚ª${cost}) from ${source}`);
          
          // Show visual feedback
          showWorkSelectionFeedback(workRow, source);
        }
        
        // Auto-save changes
        if (typeof autoSaveDamageCenterChanges === 'function') {
          autoSaveDamageCenterChanges();
        }
        
      } catch (error) {
        console.error('âŒ Error handling work type change:', error);
      }
    }

    // Show visual feedback for work selection
    function showWorkSelectionFeedback(workRow, source) {
      try {
        const select = workRow.querySelector('.work-type');
        if (!select) return;
        
        // Add visual indicator
        const originalStyle = select.style.border;
        select.style.border = '2px solid #10b981';
        select.style.background = '#f0fdf4';
        
        // Create source indicator
        let indicator = workRow.querySelector('.invoice-work-indicator');
        if (!indicator) {
          indicator = document.createElement('div');
          indicator.className = 'invoice-work-indicator';
          indicator.style.cssText = `
            position: absolute;
            top: -8px;
            right: 8px;
            background: #10b981;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 8px;
            z-index: 100;
          `;
          const container = select.parentElement;
          if (container.style.position !== 'relative') {
            container.style.position = 'relative';
          }
          container.appendChild(indicator);
        }
        indicator.textContent = source || '×—×©×‘×•× ×™×ª';
        
        // Reset border after 3 seconds
        setTimeout(() => {
          select.style.border = originalStyle;
          select.style.background = '';
        }, 3000);
        
      } catch (error) {
        console.error('âŒ Error showing work selection feedback:', error);
      }
    }

    // SESSION 89: REPAIRS ENHANCEMENT FUNCTIONS
    
    // Handle repair input click to show invoice repairs
    async function handleRepairClick(input, centerIndex, repairIndex) {
      try {
        if (hasInvoiceAssignments()) {
          await showInvoiceRepairSuggestions(input, centerIndex, repairIndex);
        }
      } catch (error) {
        console.error('âŒ Error handling repair click:', error);
      }
    }

    // Show invoice repair suggestions
    async function showInvoiceRepairSuggestions(input, centerIndex, repairIndex) {
      try {
        console.log('ğŸ“‹ Showing invoice repair suggestions');
        
        // Get invoice repairs using the damage center mapper
        const caseId = window.helper?.case_info?.supabase_case_id;
        
        if (window.damageCenterMapper) {
          const invoiceRepairs = await window.damageCenterMapper.getDropdownItems('repair', caseId, null);
          
          if (invoiceRepairs.length > 0) {
            // Create suggestions dropdown
            let suggestionsDiv = input.nextElementSibling;
            if (!suggestionsDiv || !suggestionsDiv.classList.contains('repair-suggestions')) {
              // Create suggestions container
              suggestionsDiv = document.createElement('div');
              suggestionsDiv.className = 'repair-suggestions';
              suggestionsDiv.style.cssText = `
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: white;
                border: 1px solid #ddd;
                border-top: none;
                border-radius: 0 0 4px 4px;
                z-index: 1000;
                max-height: 200px;
                overflow-y: auto;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
              `;
              
              // Make parent container relative if needed
              const parent = input.parentElement;
              if (parent.style.position !== 'relative') {
                parent.style.position = 'relative';
              }
              parent.appendChild(suggestionsDiv);
            }
            
            // Display repair suggestions
            displayRepairSuggestions(suggestionsDiv, invoiceRepairs, input, centerIndex, repairIndex);
          }
        }
      } catch (error) {
        console.error('âŒ Error showing invoice repair suggestions:', error);
      }
    }

    // Display repair suggestions in dropdown format
    function displayRepairSuggestions(suggestionsDiv, repairs, input, centerIndex, repairIndex) {
      const suggestionsHTML = repairs.map(repair => `
        <div class="suggestion-item" 
             style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center;"
             onmouseover="this.style.background='#f0f0f0'" 
             onmouseout="this.style.background='white'"
             onclick="selectInvoiceRepair(this, '${repair.name}', '${repair.description || ''}', '${repair.cost || 0}', '${repair.hours || 0}', '${repair.source || ''}', ${centerIndex}, ${repairIndex})">
          <div>
            <div style="font-weight: 500; color: #333;">${repair.name}</div>
            ${repair.description ? `<div style="font-size: 12px; color: #666;">${repair.description}</div>` : ''}
          </div>
          <div style="text-align: left;">
            <div style="font-weight: 500; color: #2563eb;">â‚ª${parseFloat(repair.cost || 0).toLocaleString()}</div>
            ${repair.hours ? `<div style="font-size: 11px; color: #666;">${repair.hours} ×©×¢×•×ª</div>` : ''}
            <div style="font-size: 11px; color: #666; background: #f3f4f6; padding: 2px 6px; border-radius: 10px;">${repair.source || '×—×©×‘×•× ×™×ª'}</div>
          </div>
        </div>
      `).join('');
      
      suggestionsDiv.innerHTML = suggestionsHTML;
      suggestionsDiv.style.display = 'block';
    }

    // Select invoice repair and populate fields
    function selectInvoiceRepair(element, repairName, repairDescription, repairCost, repairHours, source, centerIndex, repairIndex) {
      try {
        // Find the repair row
        const repairRow = document.querySelector(`.repair-row[data-center="${centerIndex}"][data-repair="${repairIndex}"]`);
        if (!repairRow) return;
        
        // Populate fields
        const nameInput = repairRow.querySelector('.repair-name');
        const textArea = repairRow.querySelector('.repair-text');
        const hoursInput = repairRow.querySelector('.repair-hours');
        const costInput = repairRow.querySelector('.repair-cost');
        
        if (nameInput) nameInput.value = repairName;
        if (textArea) textArea.value = repairDescription;
        if (hoursInput) hoursInput.value = repairHours;
        if (costInput) costInput.value = repairCost;
        
        // Hide suggestions
        const suggestionsDiv = element.closest('.repair-suggestions');
        if (suggestionsDiv) suggestionsDiv.style.display = 'none';
        
        // Auto-save changes
        if (typeof autoSaveDamageCenterChanges === 'function') {
          autoSaveDamageCenterChanges();
        }
        
        console.log(`âœ… Selected invoice repair: ${repairName} (â‚ª${repairCost}, ${repairHours}h) from ${source}`);
        
        // Show user feedback
        showRepairSelectionFeedback(repairRow, source);
        
      } catch (error) {
        console.error('âŒ Error selecting invoice repair:', error);
      }
    }

    // Show visual feedback for repair selection
    function showRepairSelectionFeedback(repairRow, source) {
      try {
        const nameInput = repairRow.querySelector('.repair-name');
        if (!nameInput) return;
        
        // Add visual indicator
        const originalStyle = nameInput.style.border;
        nameInput.style.border = '2px solid #10b981';
        nameInput.style.background = '#f0fdf4';
        
        // Create source indicator
        let indicator = repairRow.querySelector('.invoice-repair-indicator');
        if (!indicator) {
          indicator = document.createElement('div');
          indicator.className = 'invoice-repair-indicator';
          indicator.style.cssText = `
            position: absolute;
            top: -8px;
            right: 8px;
            background: #10b981;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 8px;
            z-index: 100;
          `;
          const container = nameInput.parentElement;
          if (container.style.position !== 'relative') {
            container.style.position = 'relative';
          }
          container.appendChild(indicator);
        }
        indicator.textContent = source || '×—×©×‘×•× ×™×ª';
        
        // Reset border after 3 seconds
        setTimeout(() => {
          nameInput.style.border = originalStyle;
          nameInput.style.background = '';
        }, 3000);
        
      } catch (error) {
        console.error('âŒ Error showing repair selection feedback:', error);
      }
    }

    // SESSION 89: DEBUG TEST FUNCTION - Call this manually to test
    window.testInvoiceIntegration = function() {
      console.log('ğŸ§ª SESSION 90: ×‘×“×™×§×ª ××™× ×˜×’×¨×¦×™×™×ª ×—×©×‘×•× ×™×•×ª ××ª×§×“××ª...');
      
      // Test 1: Check if we detect invoice assignments
      const hasAssignments = hasInvoiceAssignments();
      console.log('×‘×“×™×§×” 1 - ×–×™×”×•×™ ×”×§×¦××•×ª:', hasAssignments);
      
      // Test 1b: Show what invoice data sources are available
      console.log('×‘×“×™×§×” 1b - ××§×•×¨×•×ª × ×ª×•× ×™× ×–××™× ×™×:');
      console.log('  helper.invoices:', window.helper?.invoices?.length || 0);
      console.log('  helper.final_report?.invoice_assignments:', window.helper?.final_report?.invoice_assignments?.length || 0);
      console.log('  window.invoiceDataForDropdowns:', window.invoiceDataForDropdowns?.invoice_lines?.length || 0);
      
      // Test 2: Check helper data structure
      const helper = window.helper;
      console.log('×‘×“×™×§×” 2 - ××‘× ×” Helper:', {
        '××¨×›×–×™ × ×–×§': helper?.centers?.length || 0,
        '×—×©×‘×•× ×™×•×ª': helper?.invoices?.length || 0,
        '×”×§×¦××•×ª': helper?.final_report?.invoice_assignments?.length || 0
      });
      
      // Test 3: Check if mapper is available
      console.log('×‘×“×™×§×” 3 - Mapper ×–××™×Ÿ:', !!window.damageCenterMapper);
      
      // Test 4: Try to get 4-layer parts data
      const allParts = getCombinedDropdownData('');
      console.log('×‘×“×™×§×” 4 - ×—×œ×§×™× ×‘-4 ×©×›×‘×•×ª:', allParts.length, '× ××¦×');
      
      // Test 4b: Show breakdown by layer
      const layerBreakdown = {
        '×—×©×‘×•× ×™×•×ª (ğŸ§¾)': allParts.filter(p => p.layer === 1).length,
        '×—×œ×§×™× × ×‘×—×¨×™× (ğŸ“‹)': allParts.filter(p => p.layer === 2).length,
        '×§×˜×œ×•×’ ×’×œ×•×‘×œ×™ (ğŸ¦)': allParts.filter(p => p.layer === 3).length,
        '×‘× ×§ ×—×œ×§×™× (ğŸ“„)': allParts.filter(p => p.layer === 4).length
      };
      console.log('×¤×™×¨×•×˜ ×œ×¤×™ ×©×›×‘×•×ª:', layerBreakdown);
      
      // Test 5: Show sample part field enhancement
      const partInput = document.querySelector('.part-name');
      if (partInput) {
        console.log('×‘×“×™×§×” 5 - × ××¦× ×©×“×” ×—×œ×§, ×‘×“×™×§×ª ×˜×™×¤×•×œ ×‘×§×œ×™×§...');
        handlePartClick(partInput, 0, 0);
      } else {
        console.log('×‘×“×™×§×” 5 - ×œ× × ××¦× ×©×“×” ×—×œ×§');
      }
      
      return {
        hasAssignments,
        helperStructure: { 
          centers: helper?.centers?.length || 0,
          invoices: helper?.invoices?.length || 0 
        },
        mapperAvailable: !!window.damageCenterMapper,
        totalParts: allParts.length,
        layerBreakdown
      };
    };
    
    // SESSION 90: Test function specifically for 4-layer dropdown system
    window.test4LayerDropdown = function() {
      console.log('ğŸ§ª SESSION 90: Testing 4-layer dropdown system...');
      
      // Test hasInvoiceAssignments detection
      const hasAssignments = hasInvoiceAssignments();
      console.log('ğŸ” hasInvoiceAssignments():', hasAssignments);
      
      // Test getCombinedDropdownData
      const dropdownData = getCombinedDropdownData('');
      console.log('ğŸ“‹ 4-Layer dropdown data:', dropdownData.length, 'items found');
      
      // Show breakdown by layer
      const layerBreakdown = {
        'Layer 1 (Invoices)': dropdownData.filter(p => p.layer === 1).length,
        'Layer 2 (Selected)': dropdownData.filter(p => p.layer === 2).length,
        'Layer 3 (Catalog)': dropdownData.filter(p => p.layer === 3).length,
        'Layer 4 (Parts Bank)': dropdownData.filter(p => p.layer === 4).length
      };
      console.table(layerBreakdown);
      
      // Show first few items from each layer
      [1,2,3,4].forEach(layer => {
        const layerItems = dropdownData.filter(p => p.layer === layer).slice(0, 3);
        if (layerItems.length > 0) {
          console.log(`ğŸ“‹ Layer ${layer} examples:`, layerItems.map(p => p.name));
        }
      });
      
      return {
        hasAssignments,
        totalItems: dropdownData.length,
        breakdown: layerBreakdown,
        success: dropdownData.length > 0
      };
    };

    // Original search function (preserved for fallback)
    function showPartSuggestions(input, centerIndex, partIndex) {
      const query = input.value.toLowerCase().trim();
      const suggestionsDiv = input.nextElementSibling;
      
      if (query.length < 2) {
        suggestionsDiv.style.display = 'none';
        return;
      }
      
      // Get stored search results from helper
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const storedResults = helper.parts_search?.results || [];
      
      // Filter results based on query
      const filteredResults = storedResults.filter(part => 
        part.name?.toLowerCase().includes(query) || 
        part.desc?.toLowerCase().includes(query)
      );
      
      if (filteredResults.length > 0) {
        let suggestionsHTML = '';
        filteredResults.slice(0, 10).forEach(part => {
          suggestionsHTML += `
            <div onclick="selectPartSuggestion('${part.name}', '${part.desc}', '${part.price || 0}', '${part.source || ''}', ${centerIndex}, ${partIndex})" 
                 style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 13px;"
                 onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='white'">
              <strong>${part.name}</strong><br>
              <small style="color: #666;">${part.desc || ''} ${part.price ? '- â‚ª' + part.price : ''}</small>
            </div>
          `;
        });
        
        // Add option to search for new parts
        suggestionsHTML += `
          <div onclick="openPartsSearchModule('${query}', ${centerIndex}, ${partIndex})" 
               style="padding: 8px; cursor: pointer; background: #e3f2fd; border-top: 1px solid #ddd; font-size: 13px; color: #1976d2;"
               onmouseover="this.style.background='#bbdefb'" onmouseout="this.style.background='#e3f2fd'">
            ğŸ” ×—×¤×© ×—×œ×§×™× ×—×“×©×™× ×¢×‘×•×¨: "${query}"
          </div>
        `;
        
        suggestionsDiv.innerHTML = suggestionsHTML;
        suggestionsDiv.style.display = 'block';
      } else {
        // Show only search option if no stored results
        suggestionsDiv.innerHTML = `
          <div onclick="openPartsSearchModule('${query}', ${centerIndex}, ${partIndex})" 
               style="padding: 8px; cursor: pointer; background: #e3f2fd; font-size: 13px; color: #1976d2;"
               onmouseover="this.style.background='#bbdefb'" onmouseout="this.style.background='#e3f2fd'">
            ğŸ” ×—×¤×© ×—×œ×§×™× ×¢×‘×•×¨: "${query}"
          </div>
        `;
        suggestionsDiv.style.display = 'block';
      }
    }

    // SELECT PART FROM SUGGESTIONS
    function selectPartSuggestion(name, desc, price, source, centerIndex, partIndex) {
      const partRow = document.querySelector(`.part-row[data-center="${centerIndex}"][data-part="${partIndex}"]`);
      if (partRow) {
        partRow.querySelector('.part-name').value = name;
        const descField = partRow.querySelector('.part-description');
        if (descField) descField.value = desc;
        
        // SESSION 46 FIX: Set price_per_unit instead of old part-price
        const priceField = partRow.querySelector('.part-price-per-unit');
        if (priceField) {
          priceField.value = price;
          // Trigger calculation with new price
          calculatePartPriceFields(partRow);
        }
        
        const sourceField = partRow.querySelector('.part-source');
        if (sourceField) sourceField.value = source;
        
        // Hide suggestions
        const suggestions = partRow.querySelector('.part-suggestions');
        if (suggestions) suggestions.style.display = 'none';
        
        // Trigger save and recalculation
        saveDamageCenterChanges();
      }
    }

    // OPEN PARTS SEARCH MODULE
    function openPartsSearchModule(query, centerIndex, partIndex) {
      // Store the target location for the search result
      sessionStorage.setItem('partSearchTarget', JSON.stringify({
        centerIndex,
        partIndex,
        query
      }));
      
      // Open independent parts search module
      const partsSearchUrl = 'parts search.html?query=' + encodeURIComponent(query);
      window.open(partsSearchUrl, 'partsSearch', 'width=1000,height=700,scrollbars=yes,resizable=yes');
    }

    // CALCULATE PART PRICE FIELDS - SESSION 46: Auto-calculate updated price and totals (ROUNDED)
    function calculatePartPriceFields(partRow) {
      if (!partRow) return;
      
      // Get input values
      const pricePerUnit = parseFloat(partRow.querySelector('.part-price-per-unit')?.value) || 0;
      const reduction = parseFloat(partRow.querySelector('.part-reduction')?.value) || 0;
      const wear = parseFloat(partRow.querySelector('.part-wear')?.value) || 0;
      const quantity = parseInt(partRow.querySelector('.part-quantity')?.value) || 1;
      
      // Step 1: Apply reduction (discount)
      const afterReduction = pricePerUnit * (1 - reduction / 100);
      
      // Step 2: Apply wear
      const updatedPrice = afterReduction * (1 - wear / 100);
      
      // Step 3: Calculate total cost - SESSION 46: ROUND all values (no decimals)
      const totalCost = Math.round(updatedPrice * quantity);
      
      // Update hidden updated-price field
      const updatedPriceField = partRow.querySelector('.part-updated-price');
      if (updatedPriceField) {
        updatedPriceField.value = Math.round(updatedPrice);
      }
      
      // Update visible total cost field
      const totalCostField = partRow.querySelector('.part-total-cost');
      if (totalCostField) {
        totalCostField.value = `â‚ª${totalCost.toLocaleString()}`;
      }
      
      // Recalculate center totals
      const centerBlock = partRow.closest('.damage-center-block');
      if (centerBlock) {
        recalculateCenterCosts(centerBlock);
      }
      
      // Auto-save changes
      autoSaveDamageCenterChanges(partRow);
    }
    
    // SESSION 50: Auto-save damage center part changes to helper AND Supabase (like floating screen)
    async function autoSaveDamageCenterChanges(partRow) {
      if (!partRow) return;
      
      try {
        const centerIndex = parseInt(partRow.dataset.center);
        const partIndex = parseInt(partRow.dataset.part);
        
        // Get updated values from form
        // âœ… SESSION 54 FIX: Use correct class name .part-catalog-code-visible (not .part-code)
        const pcode = partRow.querySelector('.part-catalog-code-visible')?.value || '';
        const partName = partRow.querySelector('.part-name')?.value || '';
        const quantity = parseInt(partRow.querySelector('.part-quantity')?.value) || 1;
        const pricePerUnit = parseFloat(partRow.querySelector('.part-price-per-unit')?.value) || 0;
        const reduction = parseFloat(partRow.querySelector('.part-reduction')?.value) || 0;
        const wear = parseFloat(partRow.querySelector('.part-wear')?.value) || 0;
        const updatedPrice = parseFloat(partRow.querySelector('.part-updated-price')?.value) || 0;
        const totalCostText = partRow.querySelector('.part-total-cost')?.value || 'â‚ª0';
        const totalCost = parseFloat(totalCostText.replace(/[â‚ª,]/g, '')) || 0;
        
        // Update helper.centers[].Parts.parts_required[]
        if (window.helper?.centers?.[centerIndex]?.Parts?.parts_required?.[partIndex]) {
          const part = window.helper.centers[centerIndex].Parts.parts_required[partIndex];
          
          part.pcode = pcode;
          part.oem = pcode;
          part.catalog_code = pcode;
          part.part_name = partName;
          part.name = partName;
          part.quantity = quantity;
          part.qty = quantity;
          part.price_per_unit = pricePerUnit;
          part.price = pricePerUnit;
          part.cost = pricePerUnit;
          part.expected_cost = pricePerUnit;
          part.reduction_percentage = reduction;
          part.reduction = reduction;
          part.wear_percentage = wear;
          part.wear = wear;
          part.updated_price = updatedPrice;
          part.total_cost = totalCost;
        }
        
        // âœ… SESSION 54 FIX: Upsert to Supabase (INSERT new parts, UPDATE existing)
        if (window.supabase && window.helper?.meta?.plate) {
          const plate = window.helper.meta.plate;
          const normalizedPlate = plate.replace(/-/g, '');
          
          const centerCard = partRow.closest('.editable-damage-card');
          const centerIdFromDOM = centerCard?.dataset?.centerId || '';
          
          const center = window.helper?.centers?.[centerIndex] || {};
          const centerIdFromHelper = center.Id || center.id || center.code || '';
          
          const centerId = centerIdFromDOM || centerIdFromHelper;
          
          console.log(`ğŸ” SESSION 56 FIX: Saving part to center ${centerIndex}:`, {
            centerIdFromDOM,
            centerIdFromHelper,
            finalCenterId: centerId,
            centerObject: center
          });
          
          if (!centerId) {
            console.error('âŒ SESSION 56: Cannot save part - no damage center ID found in DOM or helper');
            console.error('  DOM data-center-id:', centerIdFromDOM);
            console.error('  Helper center:', center);
            return;
          }
          
          // âœ… SESSION 60 EMERGENCY FIX 1: Don't use || {} - check if part actually exists
          const part = window.helper.centers[centerIndex]?.Parts?.parts_required?.[partIndex];
          
          if (!part) {
            console.error('âŒ SESSION 60: Part not found in helper.centers at index', centerIndex, partIndex);
            console.error('  Available parts:', window.helper.centers[centerIndex]?.Parts?.parts_required);
            return; // Exit early - can't save part that doesn't exist
          }
          
          // Get case UUID from Supabase cases table (not filing_case_id string)
          let caseUuid = part.case_id || ''; // Preserve if already exists
          if (!caseUuid) {
            try {
              const { data: caseData } = await window.supabase
                .from('cases')
                .select('id')
                .eq('plate', normalizedPlate)
                .order('created_at', { ascending: false })
                .limit(1)
                .single();
              caseUuid = caseData?.id || '';
            } catch (err) {
              console.warn('Could not lookup case UUID, skipping case_id field');
            }
          }
          
          // âœ… SESSION 60 FINAL FIX: Simple - preserve existing or generate new
          let rowUuid = part.row_uuid;
          
          if (!rowUuid) {
            rowUuid = crypto.randomUUID();
            part.row_uuid = rowUuid;
            window.helper.centers[centerIndex].Parts.parts_required[partIndex].row_uuid = rowUuid;
            console.log('âœ… SESSION 60: Generated UUID for new/existing part without one:', partName, rowUuid);
          }
          
          const supabaseData = {
            // âœ… SESSION 54 FIX: row_uuid is the PRIMARY KEY for upsert
            row_uuid: rowUuid || part.row_uuid,
            
            // Required fields
            plate: normalizedPlate,
            damage_center_code: centerId,
            part_name: partName,
            
            // All other fields (only columns that exist in Supabase schema)
            pcode: pcode,
            oem: pcode,
            quantity: quantity,
            price_per_unit: pricePerUnit,
            price: pricePerUnit,
            reduction_percentage: reduction,
            wear_percentage: wear,
            updated_price: updatedPrice,
            total_cost: totalCost,
            
            // Preserve existing fields
            description: part.description || part.desc || '',
            source: part.source || part.××§×•×¨ || '',
            case_id: caseUuid || null,
            
            // Vehicle context
            make: window.helper?.vehicle?.manufacturer || '',
            model: window.helper?.vehicle?.model || '',
            year: window.helper?.vehicle?.year || '',
            
            // Timestamp
            updated_at: new Date().toISOString()
          };
          
          // âŒ SESSION 60 TASK 3: REMOVED - Don't update helper.row_uuid here (already done above if needed)
          // This code block was causing duplicate UUIDs by updating helper after Supabase save
          
          // Use upsert with row_uuid as conflict key (as per Session 39 docs)
          const { error } = await window.supabase
            .from('parts_required')
            .upsert(supabaseData, { 
              onConflict: 'row_uuid',
              ignoreDuplicates: false 
            });
          
          if (error) {
            console.error('âŒ Supabase upsert error:', error);
          } else {
            console.log('âœ… Part upserted to Supabase:', partName, '(center:', centerId, ')');
          }
        }
        
      } catch (error) {
        console.error('âŒ Auto-save error:', error);
      }
    }
    
    // RECALCULATE CENTER COSTS - SESSION: Updated to use new total_cost field
    function recalculateCenterCosts(centerBlock) {
      if (!centerBlock) return;
      
      const centerIndex = centerBlock.dataset.center;
      
      // Calculate parts total from total-cost fields
      let partsCosts = 0;
      centerBlock.querySelectorAll('.part-row').forEach(row => {
        const totalCostText = row.querySelector('.part-total-cost')?.value || 'â‚ª0';
        const cost = parseFloat(totalCostText.replace(/[â‚ª,]/g, '')) || 0;
        partsCosts += cost;
      });
      
      // Calculate works total
      let workCosts = 0;
      centerBlock.querySelectorAll('.work-row').forEach(row => {
        const cost = parseFloat(row.querySelector('.work-cost')?.value) || 0;
        workCosts += cost;
      });
      
      // Calculate repairs total
      let repairsCosts = 0;
      centerBlock.querySelectorAll('.repair-row').forEach(row => {
        const cost = parseFloat(row.querySelector('.repair-cost')?.value) || 0;
        repairsCosts += cost;
      });
      
      // Calculate totals
      const subtotal = partsCosts + workCosts + repairsCosts;
      const vatRate = 17; // Standard VAT rate
      const totalWithVAT = subtotal * (1 + vatRate / 100);
      
      // Update display fields
      const partsDisplay = centerBlock.querySelector('.parts-costs-display');
      const worksDisplay = centerBlock.querySelector('.work-costs-display');
      const repairsDisplay = centerBlock.querySelector('.repairs-costs-display');
      const totalDisplay = centerBlock.querySelector('.total-with-vat-display');
      
      if (partsDisplay) partsDisplay.textContent = `â‚ª${Math.round(partsCosts).toLocaleString()}`;
      if (worksDisplay) worksDisplay.textContent = `â‚ª${Math.round(workCosts).toLocaleString()}`;
      if (repairsDisplay) repairsDisplay.textContent = `â‚ª${Math.round(repairsCosts).toLocaleString()}`;
      if (totalDisplay) totalDisplay.textContent = `â‚ª${Math.round(totalWithVAT).toLocaleString()}`;
    }

    // ADD/REMOVE ROW FUNCTIONS
    function addPartRow(centerIndex) {
      const partsList = document.querySelector(`.parts-list[data-center="${centerIndex}"]`);
      const newPartIndex = partsList.children.length;
      const newPartHTML = createEditablePartRow({}, centerIndex, newPartIndex);
      partsList.insertAdjacentHTML('beforeend', newPartHTML);
      
      // Add event listeners to new row
      setTimeout(addDamageCenterEventListeners, 50);
    }

    function addWorkRow(centerIndex) {
      const worksList = document.querySelector(`.works-list[data-center="${centerIndex}"]`);
      const newWorkIndex = worksList.children.length;
      const newWorkHTML = createEditableWorkRow('', centerIndex, newWorkIndex);
      worksList.insertAdjacentHTML('beforeend', newWorkHTML);
      
      // Add event listeners to new row
      setTimeout(addDamageCenterEventListeners, 50);
    }

    function addRepairRow(centerIndex) {
      const repairsList = document.querySelector(`.repairs-list[data-center="${centerIndex}"]`);
      const newRepairIndex = repairsList.children.length;
      const newRepairHTML = createEditableRepairRow('', centerIndex, newRepairIndex);
      repairsList.insertAdjacentHTML('beforeend', newRepairHTML);
      
      // Add event listeners to new row
      setTimeout(addDamageCenterEventListeners, 50);
    }

    async function removePartRow(centerIndex, partIndex) {
      const partRow = document.querySelector(`.part-row[data-center="${centerIndex}"][data-part="${partIndex}"]`);
      if (!partRow) return;
      
      // SESSION 56 FIX: Delete from Supabase BEFORE removing from DOM
      const helper = window.helper || {};
      const part = helper.centers?.[centerIndex]?.Parts?.parts_required?.[partIndex];
      
      if (part && part.row_uuid && window.supabase) {
        console.log(`ğŸ—‘ï¸ SESSION 56: Deleting part from Supabase, row_uuid: ${part.row_uuid}`);
        
        try {
          const { error } = await window.supabase
            .from('parts_required')
            .delete()
            .eq('row_uuid', part.row_uuid);
          
          if (error) {
            console.error('âŒ SESSION 56: Error deleting part from Supabase:', error);
          } else {
            console.log('âœ… SESSION 56: Part deleted from Supabase successfully');
          }
        } catch (err) {
          console.error('âŒ SESSION 56: Exception deleting part:', err);
        }
      } else {
        console.warn('âš ï¸ SESSION 56: No row_uuid found for part, skipping Supabase delete');
      }
      
      // Remove from DOM
      partRow.remove();
      
      // Update helper
      saveDamageCenterChanges();
    }

    function removeWorkRow(centerIndex, workIndex) {
      const workRow = document.querySelector(`.work-row[data-center="${centerIndex}"][data-work="${workIndex}"]`);
      if (workRow) {
        workRow.remove();
        saveDamageCenterChanges();
      }
    }

    function removeRepairRow(centerIndex, repairIndex) {
      const repairRow = document.querySelector(`.repair-row[data-center="${centerIndex}"][data-repair="${repairIndex}"]`);
      if (repairRow) {
        repairRow.remove();
        saveDamageCenterChanges();
      }
    }

    function removeDamageCenter(centerIndex) {
      if (confirm('×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª ××•×§×“ ×”× ×–×§ ×”×–×”?')) {
        const centerCard = document.querySelector(`.editable-damage-card[data-center-index="${centerIndex}"]`);
        if (centerCard) {
          centerCard.remove();
          saveDamageCenterChanges();
        }
      }
    }

    function addNewDamageCenter() {
      const container = document.getElementById('editableDamageCenters');
      if (!container) {
        // If no container exists, create it
        document.getElementById('damageCentersContent').innerHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters"></div>';
      }
      
      const newIndex = document.querySelectorAll('.editable-damage-card').length;
      const newBlock = {
        damage_center_name: `××•×§×“ × ×–×§ ${newIndex + 1}`,
        parts: [],
        works: [],
        repairs: [],
        work_cost: 0,
        parts_cost: 0
      };
      
      const newCardHTML = createEditableDamageCenterCard(newBlock, newIndex);
      document.getElementById('editableDamageCenters').insertAdjacentHTML('beforeend', newCardHTML);
      
      setTimeout(addDamageCenterEventListeners, 100);
    }

    // ğŸ” SESSION 61: Save guard variables for final-report
    let isSavingDamageCentersFinalReport = false;
    let lastSaveTimeFinalReport = 0;
    
    // SAVE DAMAGE CENTER CHANGES TO HELPER
    function saveDamageCenterChanges() {
      // ğŸ” SESSION 61 FIX: Prevent duplicate saves within 2 seconds
      const now = Date.now();
      if (isSavingDamageCentersFinalReport) {
        console.warn('âš ï¸ SESSION 61 FINAL-REPORT: Save already in progress, skipping');
        return false;
      }
      if (now - lastSaveTimeFinalReport < 2000) {
        console.warn(`âš ï¸ SESSION 61 FINAL-REPORT: Last save was ${Math.round((now - lastSaveTimeFinalReport) / 1000)}s ago, skipping (2s debounce)`);
        return false;
      }
      
      isSavingDamageCentersFinalReport = true;
      lastSaveTimeFinalReport = now;
      console.log('âœ… SESSION 61 FINAL-REPORT: Starting save operation');
      
      try {
        // ğŸ”§ 2-WAY DATA FLOW: Save back to helper.centers (the source of truth)
        const helper = window.helper || {};
        
        // Initialize centers if not exists
        if (!helper.centers) helper.centers = [];
        
        // Clean up any redundant damage_assessment.centers (duplicate section)
        if (helper.damage_assessment?.centers) {
          console.log('ğŸ§¹ Cleaning up redundant damage_assessment.centers');
          delete helper.damage_assessment.centers;
          if (Object.keys(helper.damage_assessment).length === 0) {
            delete helper.damage_assessment;
          }
        }
        
        // Also maintain expertise.damage_blocks for backward compatibility
        if (!helper.expertise) helper.expertise = {};
        if (!helper.expertise.damage_blocks) helper.expertise.damage_blocks = [];
        
        // Clear both structures
        helper.centers = [];
        helper.expertise.damage_blocks = [];
        
        // Store damage center names for depreciation section
        const damageCenterNames = [];
        
        // Collect data from all damage center cards
        document.querySelectorAll('.editable-damage-card').forEach((card, index) => {
          // Extract just the number from the damage center number field
          const centerNumberField = card.querySelector('.damage-center-number').value;
          // Extract the number (e.g., "××•×§×“ × ×–×§ ××¡' 1" -> "1")
          const numberMatch = centerNumberField.match(/\d+$/);
          const centerNumber = numberMatch ? numberMatch[0] : String(index + 1);
          const centerLocation = card.querySelector('.damage-center-location').value;
          const centerDescription = card.querySelector('.damage-center-description').value;
          const centerRepairNature = card.querySelector('.damage-center-repair-nature')?.value || '';
          
          // SESSION 54 FIX: Get existing center data once for reuse
          const existingCenter = helper.centers ? helper.centers[index] : null;
          
          // Collect parts - SESSION 54 FIX: PRESERVE existing data like repairs
          const parts = [];
          const existingParts = existingCenter?.Parts?.parts_required || [];
          
          card.querySelectorAll('.part-row').forEach((row, partIndex) => {
            const name = row.querySelector('.part-name')?.value || '';
            const catalogCode = row.querySelector('.part-catalog-code-visible')?.value || '';
            const descField = row.querySelector('.part-description');
            const desc = descField ? descField.value : '';
            
            const pricePerUnit = parseFloat(row.querySelector('.part-price-per-unit')?.value) || 0;
            const reduction = parseFloat(row.querySelector('.part-reduction')?.value) || 0;
            const wear = parseFloat(row.querySelector('.part-wear')?.value) || 0;
            const quantity = parseInt(row.querySelector('.part-quantity')?.value) || 1;
            
            const totalCostField = row.querySelector('.part-total-cost');
            const totalCostText = totalCostField ? totalCostField.value : 'â‚ª0';
            const totalCost = Math.round(parseFloat(totalCostText.replace(/[â‚ª,]/g, '')) || 0);
            
            // SESSION 61: Don't read source from UI (field doesn't exist) - preserve from existing data instead
            // const source = row.querySelector('.part-source')?.value || '';  // REMOVED
            
            if (name.trim()) {
              // ğŸ” SESSION 61 FIX: Get UUID from DOM and validate
              const rowUuidFromDOM = row.getAttribute('data-row-uuid') || row.dataset.rowUuid;
              
              console.log(`ğŸ” SESSION 61 FINAL-REPORT: Processing part "${name}" (index ${partIndex})`);
              console.log(`  rowUuidFromDOM: "${rowUuidFromDOM}" (empty: ${!rowUuidFromDOM || rowUuidFromDOM === ''})`);
              
              // CRITICAL: Skip parts without UUID
              if (!rowUuidFromDOM || rowUuidFromDOM === '') {
                console.error(`âŒ SESSION 61 FINAL-REPORT: SKIPPING part "${name}" - no UUID in DOM!`);
                return;
              }
              
              // Match by UUID (not index!)
              const existingPart = existingParts.find(p => p.row_uuid === rowUuidFromDOM) || {};
              
              if (existingPart && existingPart.row_uuid) {
                console.log(`  âœ… Matched existing part by UUID: ${existingPart.row_uuid}`);
              } else {
                console.warn(`  âš ï¸ UUID "${rowUuidFromDOM}" from DOM but NO matching part - this is a NEW part`);
              }
              
              // âœ… SESSION 54 FIX: Merge existing data with new data (preserve all fields)
              // ğŸ” SESSION 61 CRITICAL FIX: Use UUID from DOM (already validated above)
              const partObject = {
                ...existingPart,                    // Preserve ALL existing fields first
                row_uuid: rowUuidFromDOM,           // âœ… SESSION 61: Use UUID from DOM
                name: name,                         // Update from UI
                part_name: name,
                catalog_code: catalogCode,          // Update from UI
                pcode: catalogCode,
                oem: catalogCode,
                desc: desc,                         // Update from UI
                description: desc,
                price_per_unit: pricePerUnit,       // Update from UI
                reduction_percentage: reduction,    // Update from UI
                reduction: reduction,
                wear_percentage: wear,              // Update from UI
                wear: wear,
                quantity: quantity,                 // Update from UI
                qty: quantity,
                total_cost: totalCost,              // Update from UI
                cost: totalCost,
                price: pricePerUnit,                // For backward compatibility
                // SESSION 61: Don't overwrite source/manufacturer/supplier_name (not in UI) - preserved via ...existingPart
                updated_at: new Date().toISOString()
              };
              
              parts.push(partObject);
            }
          });
          
          // Collect works
          const works = [];
          card.querySelectorAll('.work-row').forEach(row => {
            let type = row.querySelector('.work-type').value;
            const note = row.querySelector('.work-note').value;
            const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
            
            // If "××—×¨" is selected, get the custom text from the input
            if (type === '××—×¨') {
              const otherInput = row.querySelector('.work-type-other');
              if (otherInput && otherInput.value.trim()) {
                type = otherInput.value.trim();
              }
            }
            
            if (type) {
              works.push({ category: type, comments: note, cost });
            }
          });
          
          // Collect repairs - PRESERVE EXISTING DATA
          const repairs = [];
          const existingRepairs = existingCenter?.Repairs?.repairs || [];
          
          card.querySelectorAll('.repair-row').forEach((row, repairIndex) => {
            const name = row.querySelector('.repair-name').value;
            const text = row.querySelector('.repair-text').value;
            const hours = parseFloat(row.querySelector('.repair-hours').value) || 0;
            const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
            
            if (text.trim() || name.trim()) {
              // Get existing repair data to preserve all fields
              const existingRepair = existingRepairs[repairIndex] || {};
              
              // Merge existing data with new data (preserve all fields)
              const repairObject = {
                ...existingRepair,           // Preserve all existing fields
                name: name,                  // Update name from UI
                description: text,           // Update description from UI
                hours: hours,                // Update hours from UI
                cost: cost                   // Update cost from UI
              };
              
              repairs.push(repairObject);
            }
          });
          
          // Calculate costs using individual cost fields
          const partsCost = parts.reduce((sum, part) => sum + (parseFloat(part.price) || 0), 0);
          const workCost = works.reduce((sum, work) => sum + (parseFloat(work.cost) || 0), 0);
          const repairsCost = repairs.reduce((sum, repair) => sum + (parseFloat(repair.cost) || 0), 0);
          const totalCost = partsCost + workCost + repairsCost;
          
          const centerIdFromDOM = card.dataset?.centerId || '';
          const centerIdFromHelper = existingCenter?.Id || existingCenter?.id || existingCenter?.code || '';
          let centerId = centerIdFromDOM || centerIdFromHelper;
          
          if (!centerId) {
            console.warn(`âš ï¸ SESSION 56: Center ${index} has NO ID from DOM or helper.`);
            console.warn('  Checking if this center already has parts in helper with damage_center_code...');
            
            const existingParts = existingCenter?.Parts?.parts_required || [];
            if (existingParts.length > 0 && existingParts[0].damage_center_code) {
              centerId = existingParts[0].damage_center_code;
              console.log(`âœ… SESSION 56: Found ID from existing parts: ${centerId}`);
            } else {
              console.warn(`âš ï¸ SESSION 56: No existing parts with ID. Center ${index} will not be saved to prevent phantom centers.`);
              console.warn('  This center must be created/edited in wizard first to get a proper ID.');
              return;
            }
          }
          
          console.log(`ğŸ†” SESSION 56: saveDamageCenterChanges center ${index} ID resolution:`, {
            fromDOM: centerIdFromDOM,
            fromHelper: centerIdFromHelper,
            final: centerId
          });
          
          // Create center object in helper.centers format (source of truth)
          const centerObject = {
            Id: centerId,
            "Damage center Number": centerNumber || (index + 1),
            Location: centerLocation,
            Description: centerDescription,
            RepairNature: centerRepairNature,
            Parts: {
              parts_required: parts,
              parts_meta: {
                total_items: parts.length,
                total_cost: partsCost
              }
            },
            Works: {
              works: works,
              works_meta: {
                total_items: works.length,
                total_cost: workCost
              }
            },
            Repairs: {
              repairs: repairs,
              repairs_meta: {
                total_items: repairs.length,
                total_cost: repairsCost
              }
            },
            Summary: {
              "Total with VAT": totalCost * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100)
            }
          };
          
          // Save to helper.centers (primary source)
          helper.centers.push(centerObject);
          
          // Also save to damage_blocks for backward compatibility
          helper.expertise.damage_blocks.push({
            damage_center_name: centerLocation,
            damage_center_number: index + 1,
            center_header: centerNumber,
            description: centerDescription,
            repair_nature: centerRepairNature,
            parts,
            works,
            repairs,
            parts_cost: partsCost,
            work_cost: workCost,
            repairs_cost: repairsCost
          });
          
          
          // Store damage center data for depreciation section (complete object)
          if (centerLocation.trim()) {
            damageCenterNames.push({
              name: centerLocation.trim(),
              number: centerNumber || (index + 1),
              description: centerDescription || '',
              RepairNature: centerRepairNature
            });
          }
          
          // Update cost display for this card
          updateCostDisplay(card, partsCost, workCost, repairsCost);
        });
        
        // ğŸ†• UPDATE SPECIFIC DESTINATIONS (like estimator does)
        
        // 1. Update damage_centers array with ALL data + source = 'final_report'
        helper.damage_centers = helper.centers.map((center, index) => ({
          "Id": center.Id || `dc_${Date.now()}_${index + 1}`,
          "Damage center Number": center["Damage center Number"] || (index + 1).toString(),
          "Location": center.Location || '',
          "Description": center.Description || '',
          "RepairNature": center.RepairNature || '',
          "Parts": center.Parts || {
            "parts_required": [],
            "parts_meta": { "total_items": 0, "total_cost": 0 }
          },
          "Works": center.Works || {
            "works": [],
            "works_meta": { "total_items": 0, "total_cost": 0 }
          },
          "Repairs": center.Repairs || {
            "repairs": [],
            "repairs_meta": { "total_items": 0, "total_cost": 0 }
          },
          "Summary": center.Summary || { "Total with VAT": 0 },
          source: 'final_report',
          last_updated: new Date().toISOString()
        }));
        console.log('âœ… Updated damage_centers from final_report with source tracking');
        
        // 2. Recreate damage_assessment.damage_centers with id + repair_nature + source
        if (!helper.damage_assessment) helper.damage_assessment = {};
        helper.damage_assessment.damage_centers = helper.centers.map(center => ({
          Id: center.Id || `dc_${Date.now()}_${Math.random()}`,
          repair_nature: center.RepairNature || '',
          source: 'final_report',
          last_updated: new Date().toISOString()
        }));
        console.log('âœ… Recreated damage_assessment.damage_centers from final_report');
        
        // 3. Recreate damage_assessment.comprehensive.centers with descriptions only + source
        if (!helper.damage_assessment.comprehensive) helper.damage_assessment.comprehensive = {};
        helper.damage_assessment.comprehensive.centers = helper.centers.map(center => ({
          location: center.Location || '',
          description: center.Description || '',
          RepairNature: center.RepairNature || '',
          repair_nature: center.RepairNature || '', // Duplicate field for compatibility
          source: 'final_report',
          last_updated: new Date().toISOString()
        }));
        console.log('âœ… Recreated damage_assessment.comprehensive.centers from final_report');
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // DON'T auto-update depreciation - preserve manual entries
        // updateDepreciationFromDamageCenters(damageCenterNames);
        
        // Update/recreate damage_assessment summary sections with current data
        updateDamageAssessmentSummary(helper);
        
        // Trigger floating screen refresh
        triggerFloatingScreenRefresh();
        
        console.log('Damage centers saved:', helper.expertise.damage_blocks);
        console.log('âœ… SESSION 61 FINAL-REPORT: Save operation completed successfully');
        
      } catch (error) {
        console.error('âŒ SESSION 61 FINAL-REPORT: Error saving damage center changes:', error);
      } finally {
        // ğŸ” SESSION 61: Reset save guard
        isSavingDamageCentersFinalReport = false;
        console.log('ğŸ”“ SESSION 61 FINAL-REPORT: Save guard released');
      }
    }
    
    // UPDATE DEPRECIATION SECTION FROM DAMAGE CENTERS
    function updateDepreciationFromDamageCenters(damageCenterNames) {
      try {
        
        // If no data provided, get current data from helper.centers
        if (!damageCenterNames || damageCenterNames.length === 0) {
          const helper = window.helper || {};
          damageCenterNames = [];
          
          if (helper.centers && helper.centers.length > 0) {
            helper.centers.forEach((center, index) => {
              // Get the actual location and center number properly
              const location = center.Location || center.damage_center_name || '';
              
              // Extract just the number from "Damage center Number" field
              // e.g., "××•×§×“ × ×–×§ ××¡' ××•×§×“ × ×–×§ ××¡' 1" -> "1"
              let centerNum = center["Damage center Number"] || String(index + 1);
              // Extract all numbers and take the last one
              const numberMatch = String(centerNum).match(/\d+/g);
              centerNum = numberMatch ? numberMatch[numberMatch.length - 1] : String(index + 1);
              
              damageCenterNames.push({
                name: location,  // The actual location/part name
                number: centerNum,  // Just the number (1, 2, 3, etc.)
                description: center.Description || '',
                RepairNature: center.RepairNature || ''
              });
            });
          }
        }
        
        
        const depreciationTable = document.getElementById('depreciationBulkTable');
        if (!depreciationTable) {
          return;
        }
        
        // DON'T clear existing depreciation rows - preserve manual data!
        // Only add new rows if the table is empty
        const existingRows = depreciationTable.querySelectorAll('.dep-row');
        if (existingRows.length > 0) {
          console.log('âš ï¸ Depreciation table already has data - preserving existing manual entries');
          return;
        }
        
        // Add a row for each damage center
        damageCenterNames.forEach(centerData => {
          // Handle both old string format and new object format
          const centerName = (typeof centerData === 'string') ? centerData : centerData.name;
          const centerNumber = (typeof centerData === 'object') ? centerData.number : null;
          const centerDescription = (typeof centerData === 'object') ? centerData.description : '';
          const centerRepairNature = (typeof centerData === 'object') ? centerData.RepairNature : '';
          
          // âœ… FIXED: Correct field mapping for depreciation from damage centers
          // "××¡' ××•×§×“" should show the center number
          // "×”×—×œ×§ ×”× ×™×–×•×§" should show LOCATION/PART (use centerName which contains the damage location)  
          // "××”×•×ª ×”×ª×™×§×•×Ÿ" should show REPAIR NATURE (use centerRepairNature which contains repair nature details)
          const centerNum = centerNumber || (damageCenterNames.indexOf(centerData) + 1); // Fallback to index + 1
          const damageLocation = centerName || ''; // This is the location/part that was damaged
          const workEssence = centerRepairNature || '';
          
          // Create row directly in the table
          const row = document.createElement('div');
          row.className = 'dep-row';
          row.style.cssText = 'display:grid; grid-template-columns:70px 2fr 2fr 80px 90px 80px; gap:10px; margin-bottom:8px;';
          
          row.innerHTML = `
            <div><input type="text" placeholder="××¡' ××•×§×“" value="${centerNum || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" style="text-align: center;" title="${centerNum || ''}" /></div>
            <div><input type="text" placeholder="×”×—×œ×§ ×”× ×™×–×•×§" value="${damageLocation}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="${damageLocation}" /></div>
            <div><input type="text" placeholder="××”×•×ª ×”×ª×™×§×•×Ÿ" value="${workEssence}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="${workEssence}" /></div>
            <div><input type="text" placeholder="×™×¨×™×“×ª ×¢×¨×š (××¡×¤×¨)" value="" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="" style="direction: ltr; text-align: right;" /></div>
            <div><input type="text" placeholder="×¢×¨×š ×‘-â‚ª" value="" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="" /></div>
            <div><button class="btn remove" onclick="removeDepField('${row.id || 'depRow_' + Date.now()}')">××—×§</button></div>
          `;
          
          // Set unique ID for the row
          row.id = 'depRow_' + Date.now() + '_' + (damageCenterNames.indexOf(centerData));
          
          // Append to table
          depreciationTable.appendChild(row);
          
          // Add tooltip update listeners to all input fields
          const inputs = row.querySelectorAll('input');
          inputs.forEach(input => {
            input.addEventListener('input', function() {
              this.title = this.value;
            });
          });
          
          // Add auto-calculation functionality to the percentage field
          const percentInput = row.querySelector('input[placeholder="×™×¨×™×“×ª ×¢×¨×š (××¡×¤×¨)"]');
          const valueInput = row.querySelector('input[placeholder="×¢×¨×š ×‘-â‚ª"]');
          
          if (percentInput && valueInput) {
            percentInput.addEventListener('input', function() {
              // Clean the value to extract the numeric part
              const cleanValue = this.value.replace('%', '').replace(/[^0-9.-]/g, '');
              let percent = parseFloat(cleanValue) || 0;
              
              // Keep value as clean decimal number without % sign
              this.value = cleanValue;
              
              // Calculate value from market price automatically
              const marketValueField = document.getElementById('carMarketValue') || document.getElementById('sumMarketValue');
              const marketValueStr = marketValueField?.value.replace(/[â‚ª,]/g, '') || '0';
              const marketValue = parseFloat(marketValueStr) || 0;
              
              const calculatedValue = (marketValue * percent) / 100;
              valueInput.value = calculatedValue ? `â‚ª${Math.round(calculatedValue).toLocaleString()}` : '';
              
              // Save data after calculation
              saveDepreciationData();
            });
          }
        });
        
        
      } catch (error) {
        console.error('Error updating depreciation from damage centers:', error);
      }
    }

    // ADD EVENT LISTENERS
    function addDamageCenterEventListeners() {
      // Remove existing listeners by cloning elements (prevents duplicates)
      document.querySelectorAll('.damage-center-number, .damage-center-location, .damage-center-name, .damage-center-area-name, .damage-center-description, .damage-center-repair-nature, .part-name, .part-desc, .part-price, .work-type, .work-type-other, .work-note, .work-cost, .repair-name, .repair-text, .repair-hours, .repair-cost').forEach(input => {
        // Check if already has listeners
        if (!input.hasAttribute('data-listeners-added')) {
          input.addEventListener('change', () => {
            saveDamageCenterChanges();
            updateAllCostDisplays();
          });
          input.addEventListener('blur', () => {
            saveDamageCenterChanges();
            updateAllCostDisplays();
          });
          input.addEventListener('input', () => {
            updateAllCostDisplays();
          });
          
          // Mark as having listeners to prevent duplicates
          input.setAttribute('data-listeners-added', 'true');
          console.log(`ğŸ“ Added event listeners to: ${input.className}`);
        }
      });
      
      // Hide suggestions when clicking outside
      document.addEventListener('click', function(e) {
        if (!e.target.closest('.part-row')) {
          document.querySelectorAll('.part-suggestions').forEach(div => {
            div.style.display = 'none';
          });
        }
      });
    }

    // UPDATE WORK COST FROM TYPE SELECTION
    function updateWorkCostFromType(selectElement, centerIndex, workIndex) {
      // REMOVED: Predefined work rates that were forcing costs
      // Work costs should be manually entered based on specific case requirements
      
      // Only trigger save and recalculation without changing cost
      saveDamageCenterChanges();
      updateAllCostDisplays();
      
      console.log(`ğŸ”§ Work type changed: ${selectElement.value} (cost remains manual)`);
    }

    function handleWorkTypeChange(selectElement, centerIndex, workIndex) {
      const workRow = selectElement.closest('.work-row');
      const otherInput = workRow.querySelector('.work-type-other');
      
      if (selectElement.value === '××—×¨') {
        otherInput.style.display = 'block';
        otherInput.focus();
      } else {
        otherInput.style.display = 'none';
        otherInput.value = '';
      }
      
      // Call the original function
      updateWorkCostFromType(selectElement, centerIndex, workIndex);
    }

    // COST CALCULATION FUNCTIONS
    function calculateWorkCost(works) {
      return works.reduce((total, work) => {
        const cost = typeof work === 'object' ? (work.cost || 0) : 0;
        return total + parseFloat(cost);
      }, 0);
    }

    function calculateRepairsCost(repairs) {
      return repairs.reduce((total, repair) => {
        const cost = typeof repair === 'object' ? (repair.cost || 0) : 0;
        return total + parseFloat(cost);
      }, 0);
    }

    function calculatePartsCost(parts) {
      return parts.reduce((total, part) => {
        const cost = typeof part === 'object' ? (part.price || 0) : 0;
        return total + parseFloat(cost);
      }, 0);
    }

    function updateCostDisplay(card, partsCost, workCost, repairsCost) {
      const totalCost = partsCost + workCost + repairsCost;
      const totalWithVAT = totalCost * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100);
      
      // Update display elements
      const workDisplay = card.querySelector('.work-costs-display');
      const partsDisplay = card.querySelector('.parts-costs-display');
      const repairsDisplay = card.querySelector('.repairs-costs-display');
      const totalDisplay = card.querySelector('.total-with-vat-display');
      
      if (workDisplay) {
        workDisplay.textContent = `â‚ª${workCost.toLocaleString()}`;
        console.log(`ğŸ’¼ Work costs updated: â‚ª${workCost.toLocaleString()}`);
      }
      if (partsDisplay) {
        partsDisplay.textContent = `â‚ª${partsCost.toLocaleString()}`;
        console.log(`ğŸ”§ Parts costs updated: â‚ª${partsCost.toLocaleString()}`);
      }
      if (repairsDisplay) {
        repairsDisplay.textContent = `â‚ª${repairsCost.toLocaleString()}`;
        console.log(`ğŸ”¨ Repairs costs updated (ONLY repairs): â‚ª${repairsCost.toLocaleString()}`);
      }
      if (totalDisplay) {
        totalDisplay.textContent = `â‚ª${Math.round(totalWithVAT).toLocaleString()}`;
        console.log(`ğŸ’° Total with VAT updated: â‚ª${Math.round(totalWithVAT).toLocaleString()}`);
      }
    }

    function updateAllCostDisplays() {
      document.querySelectorAll('.editable-damage-card').forEach(card => {
        // Recalculate costs for this card using individual cost fields
        let partsCost = 0;
        card.querySelectorAll('.part-row').forEach(row => {
          // SESSION 46 FIX: Use new .part-total-cost field instead of .part-price
          const totalCostField = row.querySelector('.part-total-cost');
          if (totalCostField) {
            const totalCostText = totalCostField.value || 'â‚ª0';
            const cost = parseFloat(totalCostText.replace(/[â‚ª,]/g, '')) || 0;
            partsCost += cost;
          }
        });
        
        let workCost = 0;
        card.querySelectorAll('.work-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
          workCost += cost;
        });
        
        let repairsCost = 0;
        card.querySelectorAll('.repair-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
          repairsCost += cost;
        });
        
        updateCostDisplay(card, partsCost, workCost, repairsCost);
      });
      
      // Update summary section totals
      updateSummaryTotalsFromDamageCenters();
      
      // Update damage centers subtotal
      updateDamageCentersSubtotal();
    }

    function updateSummaryTotalsFromDamageCenters() {
      let totalClaimBeforeVAT = 0;
      
      document.querySelectorAll('.editable-damage-card').forEach(card => {
        // Calculate total cost for each damage center (parts + works + repairs)
        let partsCost = 0;
        card.querySelectorAll('.part-row').forEach(row => {
          // SESSION 46 FIX: Use new .part-total-cost field instead of .part-price
          const totalCostField = row.querySelector('.part-total-cost');
          if (totalCostField) {
            const totalCostText = totalCostField.value || 'â‚ª0';
            const cost = parseFloat(totalCostText.replace(/[â‚ª,]/g, '')) || 0;
            partsCost += cost;
          }
        });
        
        let workCost = 0;
        card.querySelectorAll('.work-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
          workCost += cost;
        });
        
        let repairsCost = 0;
        card.querySelectorAll('.repair-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
          repairsCost += cost;
        });
        
        totalClaimBeforeVAT += partsCost + workCost + repairsCost;
      });
      
      // Calculate total claim with VAT (admin configured rate)
      const totalClaimWithVAT = Math.round(totalClaimBeforeVAT * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100));
      
      // Update summary fields
      const sumClaimField = document.getElementById('sumClaim');
      const totalClaimField = document.getElementById('totalClaim');
      
      if (totalClaimWithVAT > 0) {
        const formattedAmount = `â‚ª${totalClaimWithVAT.toLocaleString()}`;
        
        // Update both summary claim and total claim fields WITH VAT
        if (sumClaimField) {
          sumClaimField.value = formattedAmount;
        }
        // Update main total claim field (div element)
        if (totalClaimField && totalClaimField.tagName === 'DIV') {
          totalClaimField.innerText = formattedAmount;
        } else if (totalClaimField) {
          totalClaimField.value = formattedAmount;
        }
        
        console.log(`ğŸ’° Updated total claim with VAT: ${totalClaimBeforeVAT.toLocaleString()} â†’ ${totalClaimWithVAT.toLocaleString()}`);
        
        // SAFE SUMMARY UPDATE: Update helper directly instead of triggering events that cascade
        setTimeout(() => {
          if (sumClaimField) {
            // Update helper directly without triggering event cascade that overrides calculations
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            helper.final_report = helper.final_report || {};
            helper.final_report.summary = helper.final_report.summary || {};
            helper.final_report.summary.total_claim = formattedAmount;
            sessionStorage.setItem('helper', JSON.stringify(helper));
            console.log('ğŸ”’ SAFE UPDATE: Updated total_claim in helper without triggering calculation overrides');
          }
        }, 100);
        
        // New bulk system will handle gross calculations when total claim changes
      }
    }

    // Make functions global
    window.loadDataFromHelper = loadDataFromHelper;
    window.loadLegalText = loadLegalText;
    window.loadLegalTextFromVault = loadLegalTextFromVault;
    window.resetLegalText = resetLegalText;
    window.loadAttachmentsFromVault = loadAttachmentsFromVault;
    window.resetAttachments = resetAttachments;
    window.addDepField = addDepField;
    window.updateReportType = updateReportType;
    window.addCustomSummaryField = addCustomSummaryField;
    window.loadDamageCentersSummary = loadDamageCentersSummary;
    window.loadAllAdjustments = loadAllAdjustments;
    window.updateGlobalDepreciationCalculation = updateGlobalDepreciationCalculation;
    window.calculateDamagePercentage = calculateDamagePercentage;
    window.triggerGlobalDepreciationCalc = triggerGlobalDepreciationCalc;
    window.showPartSuggestions = showPartSuggestions;
    window.selectPartSuggestion = selectPartSuggestion;
    window.openPartsSearchModule = openPartsSearchModule;
    window.addPartRow = addPartRow;
    window.addWorkRow = addWorkRow;
    window.addRepairRow = addRepairRow;
    window.removePartRow = removePartRow;
    window.removeWorkRow = removeWorkRow;
    window.removeRepairRow = removeRepairRow;
    window.removeDamageCenter = removeDamageCenter;
    window.addNewDamageCenter = addNewDamageCenter;
    window.saveDamageCenterChanges = saveDamageCenterChanges;
    window.addDamageCenterEventListeners = addDamageCenterEventListeners;
    window.calculateWorkCost = calculateWorkCost;
    window.updateWorkCostFromType = updateWorkCostFromType;
    window.updateCostDisplay = updateCostDisplay;
    window.updateAllCostDisplays = updateAllCostDisplays;
    window.updateSummaryTotalsFromDamageCenters = updateSummaryTotalsFromDamageCenters;
    window.updateGrossMarketValueField = updateGrossMarketValueField;
    window.updateAuthorizedClaim = updateAuthorizedClaim;
    window.updateGrossPercentageField = updateGrossPercentageField;
    window.calculateGrossMarketValue = calculateGrossMarketValue;
    window.calculateGrossPercentage = calculateGrossPercentage;
    window.calculateFullMarketValue = calculateFullMarketValue;
    window.addFeatureAdjustment = addFeatureAdjustment;
    window.addRegistrationAdjustment = addRegistrationAdjustment;
    window.removeAdjustmentRow = removeAdjustmentRow;
    window.updateHelperFromContactField = updateHelperFromContactField;
    window.loadGrossAdjustments = loadGrossAdjustments;
    window.loadTotalValueSectionAdjustments = loadTotalValueSectionAdjustments;
    window.syncUISection = syncUISection;
    window.updateGrossMarketValueCalculation = updateGrossMarketValueCalculation;
    window.loadGrossCalculationData = loadGrossCalculationData;
    
    // loadGrossAdjustments is now properly called during data loading
    
    // FORCE MANUAL CALCULATION - Last resort function
    function forceManualCalculation() {
      console.log('ğŸ”§ === FORCE MANUAL CALCULATION ===');
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Manual gross market value calculation
      let vehicleValueGross = 0;
      const leviPriceListField = document.getElementById('leviPriceList');
      const grossPercentField = document.getElementById('grossPercent');
      const totalClaimField = document.getElementById('totalClaim');
      
      // Try to get a market value from anywhere
      if (helper.levi_report?.final_price) {
        vehicleValueGross = parseFloat(helper.levi_report.final_price);
        console.log('ğŸ”§ Using levi_report.final_price as vehicleValueGross:', vehicleValueGross);
      } else if (helper.calculations?.full_market_value) {
        vehicleValueGross = parseFloat(helper.calculations.full_market_value);
        console.log('ğŸ”§ Using calculations.full_market_value as vehicleValueGross:', vehicleValueGross);
      } else if (helper.levisummary?.final_price) {
        vehicleValueGross = parseFloat(helper.levisummary.final_price);
        console.log('ğŸ”§ Using levisummary.final_price as vehicleValueGross:', vehicleValueGross);
      }
      
      // If we have a value, populate the field
      if (vehicleValueGross > 0) {
        leviPriceListField.value = `â‚ª${vehicleValueGross.toLocaleString()}`;
        
        // Update helper
        helper.calculations = helper.calculations || {};
        helper.calculations.vehicle_value_gross = vehicleValueGross;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('ğŸ”§ Manually set vehicleValueGross:', vehicleValueGross);
        
        // Now calculate percentage
        const totalClaim = parseFloat(totalClaimField?.value?.replace(/[â‚ª,]/g, '') || '0');
        if (totalClaim > 0) {
          const grossPercentage = (totalClaim / vehicleValueGross) * 100;
          const formattedPercentage = `${Math.round(grossPercentage * 100) / 100}%`;
          
          grossPercentField.value = formattedPercentage;
          
          // Update helper
          helper.claims_data = helper.claims_data || {};
          helper.claims_data.gross_percent = formattedPercentage;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          console.log('ğŸ”§ Manually calculated gross percentage:', formattedPercentage);
        }
      } else {
        console.warn('âš ï¸ No market value found for manual calculation');
      }
      
      console.log('ğŸ”§ === FORCE MANUAL CALCULATION COMPLETE ===');
    }
    
    // DEBUG HELPER FUNCTION
    function debugCalculations() {
      console.log('ğŸ” === DEBUG CALCULATIONS ===');
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('Helper data:', helper);
      console.log('Calculations:', helper.calculations);
      console.log('Levi report:', helper.levi_report);
      console.log('Expertise:', helper.expertise);
      
      // Check current field values
      const leviPriceListField = document.getElementById('leviPriceList');
      const grossPercentField = document.getElementById('grossPercent');
      const totalClaimField = document.getElementById('totalClaim');
      
      console.log('ğŸ” Current field values:', {
        leviPriceList: leviPriceListField?.value || 'NOT FOUND',
        grossPercent: grossPercentField?.value || 'NOT FOUND',
        totalClaim: totalClaimField?.value || 'NOT FOUND'
      });
      
      // Force refresh all calculations
      updateAllCostDisplays();
      updateSummaryTotalsFromDamageCenters();
      // New bulk system will handle gross calculations
      
      // Check values after refresh
      setTimeout(() => {
        console.log('ğŸ” After refresh field values:', {
          leviPriceList: leviPriceListField?.value || 'NOT FOUND',
          grossPercent: grossPercentField?.value || 'NOT FOUND',
          totalClaim: totalClaimField?.value || 'NOT FOUND'
        });
        
        // If still empty, try force manual calculation
        if (!leviPriceListField?.value || !grossPercentField?.value) {
          console.log('ğŸ”§ Fields still empty, trying force manual calculation...');
          forceManualCalculation();
        }
      }, 100);
      
      console.log('ğŸ” === DEBUG CALCULATIONS COMPLETE ===');
    }
    window.debugCalculations = debugCalculations;
    window.forceManualCalculation = forceManualCalculation;
    
    // ğŸŒ GLOBAL CALCULATION INTERFACE FOR FINAL REPORT MODULES
    window.FinalReportCalculations = {
      // Main calculation functions
      updateGrossMarketValueField: updateGrossMarketValueField,
      updateGrossPercentageField: updateGrossPercentageField,
      updateSummaryTotalsFromDamageCenters: updateSummaryTotalsFromDamageCenters,
      updateAllCostDisplays: updateAllCostDisplays,
      calculateDamagePercentage: calculateDamagePercentage,
      
      // Cost calculation functions
      calculateRepairsCost: calculateRepairsCost,
      calculatePartsCost: calculatePartsCost,
      calculateWorkCost: calculateWorkCost,
      updateCostDisplay: updateCostDisplay,
      
      // Helper utilities
      updateHelperFromField: updateHelperFromField,
      loadDataFromHelper: loadDataFromHelper,
      saveDamageCenterChanges: saveDamageCenterChanges,
      debugCalculations: debugCalculations,
      
      // Get calculated values from 3-bulk system
      getGrossMarketValue: function() {
        try {
          // First try to get from the gross market value result field (Bulk 1)
          const grossMarketValueField = document.getElementById('grossMarketValueResult');
          if (grossMarketValueField && grossMarketValueField.value) {
            return parseFloat(grossMarketValueField.value.replace(/[â‚ª,]/g, '')) || 0;
          }
          
          // Fallback to helper data
          // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          return helper.calculations?.vehicle_value_gross || 0;
        } catch (error) {
          console.error('Error getting gross market value:', error);
          return 0;
        }
      },
      
      getFullMarketValue: function() {
        try {
          // First try to get from the full market value result field (Bulk 3)
          const fullMarketValueField = document.getElementById('fullMarketValueResult');
          if (fullMarketValueField && fullMarketValueField.value) {
            return parseFloat(fullMarketValueField.value.replace(/[â‚ª,]/g, '')) || 0;
          }
          
          // Fallback to helper data
          // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          return helper.calculations?.market_value || helper.calculations?.full_market_value || helper.levi_report?.final_price || 0;
        } catch (error) {
          console.error('Error getting full market value:', error);
          return 0;
        }
      },
      
      getTotalClaim: function() {
        try {
          // First try to get from the total claim field (Bulk 2)
          const totalClaimField = document.getElementById('totalClaim');
          if (totalClaimField && totalClaimField.value) {
            return parseFloat(totalClaimField.value.replace(/[â‚ª,]/g, '')) || 0;
          }
          
          // Fallback: calculate from damage centers
          const totalFromDamageCenters = calculateTotalClaimFromDamageCenters();
          if (totalFromDamageCenters > 0) {
            return totalFromDamageCenters;
          }
          
          // Final fallback to helper data
          // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          return parseFloat(helper.claims_data?.total_claim?.replace(/[â‚ª,]/g, '') || '0') || 
                 parseFloat(helper.calculations?.total_damage) || 0;
        } catch (error) {
          console.error('Error getting total claim:', error);
          return 0;
        }
      },
      
      getGrossPercentage: function() {
        try {
          // First try to get from the gross percentage field (Bulk 2)
          const grossPercentField = document.getElementById('grossPercent');
          if (grossPercentField && grossPercentField.value) {
            return parseFloat(grossPercentField.value.replace(/[%]/g, '')) || 0;
          }
          
          // Calculate from current values if not available
          const grossMarketValue = this.getGrossMarketValue();
          const totalClaim = this.getTotalClaim();
          if (grossMarketValue > 0 && totalClaim > 0) {
            return (totalClaim / grossMarketValue) * 100;
          }
          
          // Fallback to helper data
          // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          return parseFloat(helper.claims_data?.gross_percent?.replace(/[%]/g, '') || '0') || 
                 parseFloat(helper.calculations?.damage_percent) || 0;
        } catch (error) {
          console.error('Error getting gross percentage:', error);
          return 0;
        }
      },
      
      // Get damage centers data
      getDamageCentersData: function() {
        try {
          // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          return helper.expertise?.damage_centers || [];
        } catch (error) {
          console.error('Error getting damage centers data:', error);
          return [];
        }
      },
      
      // Calculate totals from damage centers
      calculateDamageCentersTotals: function() {
        const damageCenters = this.getDamageCentersData();
        let totalParts = 0;
        let totalWorks = 0;
        let totalRepairs = 0;
        
        damageCenters.forEach(center => {
          totalParts += this.calculatePartsCost(center.parts || []);
          totalWorks += this.calculateWorkCost(center.works || []);
          totalRepairs += this.calculateRepairsCost(center.repairs || []);
        });
        
        return {
          parts: totalParts,
          works: totalWorks,
          repairs: totalRepairs,
          total: totalParts + totalWorks + totalRepairs,
          totalWithVAT: (totalParts + totalWorks + totalRepairs) * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100)
        };
      },
      
      // Force refresh all calculations
      refreshAllCalculations: function() {
        this.updateAllCostDisplays();
        this.updateSummaryTotalsFromDamageCenters();
        
        // Refresh all 3 bulks
        setTimeout(() => {
          try {
            // Refresh Bulk 1 (Gross Market Value)
            if (typeof updateGrossMarketValueCalculation === 'function') {
              updateGrossMarketValueCalculation();
            }
            
            // Refresh Bulk 2 (Gross Percentage)
            if (typeof refreshSecondBulkFields === 'function') {
              refreshSecondBulkFields();
            }
            
            // Refresh Bulk 3 (Full Market Value)
            if (typeof updateFullMarketValueCalculation === 'function') {
              // updateFullMarketValueCalculation() removed
            }
            
            // Trigger floating screen refresh with updated calculations
            if (typeof triggerFloatingScreenRefresh === 'function') {
              triggerFloatingScreenRefresh();
            }
            
            console.log('âœ… All 3-bulk calculations refreshed from FinalReportCalculations interface');
          } catch (error) {
            console.error('Error refreshing 3-bulk calculations:', error);
          }
        }, 100);
      }
    };
    
    // Make it also available via window for backward compatibility
    window.getFinalReportCalculations = () => window.FinalReportCalculations;
    // Maintain backward compatibility
    window.getFinalReportCalculations = () => window.FinalReportCalculations;

    // MESSAGE LISTENER FOR PARTS SEARCH RESULTS
    window.addEventListener('message', function(event) {
      if (event.data.type === 'PARTS_SELECTED') {
        try {
          const { parts, target } = event.data;
          const { centerIndex, partIndex } = target;
          
          // Find the specific part row
          const targetCard = document.querySelector(`.editable-damage-card[data-center-index="${centerIndex}"]`);
          if (targetCard) {
            const partRows = targetCard.querySelectorAll('.part-row');
            const targetRow = partRows[partIndex];
            
            if (targetRow && parts.length > 0) {
              // Fill the first selected part into the target row - SESSION 46 FIX
              const firstPart = parts[0];
              const nameInput = targetRow.querySelector('.part-name');
              const catalogInput = targetRow.querySelector('.part-catalog-code-visible');
              const descInput = targetRow.querySelector('.part-description');
              const priceInput = targetRow.querySelector('.part-price-per-unit');
              const sourceInput = targetRow.querySelector('.part-source');
              
              if (nameInput) nameInput.value = firstPart.name || '';
              if (catalogInput) catalogInput.value = firstPart.pcode || firstPart.catalog_code || '';
              if (descInput) descInput.value = firstPart.description || '';
              if (priceInput) {
                priceInput.value = firstPart.price || firstPart.price_per_unit || '';
                // Trigger calculation
                calculatePartPriceFields(targetRow);
              }
              if (sourceInput) sourceInput.value = firstPart.source || '';
              
              // Add additional parts if more than one selected
              if (parts.length > 1) {
                const partsList = targetCard.querySelector('.parts-list');
                for (let i = 1; i < parts.length; i++) {
                  const part = parts[i];
                  const newPartIndex = partsList.children.length;
                  const newPartHTML = createEditablePartRow(part, centerIndex, newPartIndex);
                  partsList.insertAdjacentHTML('beforeend', newPartHTML);
                }
              }
              
              // Save changes and update costs
              saveDamageCenterChanges();
              updateAllCostDisplays();
              
              console.log(`âœ… Added ${parts.length} parts to damage center ${centerIndex + 1}`);
            }
          }
        } catch (error) {
          console.error('Error processing parts selection:', error);
        }
      }
    });
    
    // LOAD HELPER DATA AND POPULATE FIELDS
    function loadHelperData() {
      try {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        // Ensure window.helper is initialized from sessionStorage
        if (!window.helper || Object.keys(window.helper).length === 0) {
          window.helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        }
        const helper = window.helper;
        
        console.log('ğŸ“¥ Loading helper data:', helper);
        
        // Load report type selection from helper
        const savedReportType = helper.final_report?.type || helper.manual_final_report_type?.finalReportType;
        if (savedReportType) {
          const radioButton = document.querySelector(`input[name="final-report-type"][value="${savedReportType}"]`);
          if (radioButton) {
            radioButton.checked = true;
            console.log('ğŸ“‹ Loaded report type from helper:', savedReportType);
            // Trigger change event to update legal text and attachments
            setTimeout(() => {
              loadLegalText().catch(console.error);
              loadAttachmentsFromVault();
            }, 100);
          }
        }
        
        // Load dropdown report type selection from helper
        const savedDropdownType = helper.final_report?.dropdown_type || helper.reportType;
        if (savedDropdownType) {
          const dropdown = document.getElementById('reportType');
          if (dropdown) {
            dropdown.value = savedDropdownType;
            console.log('ğŸ“‹ Loaded dropdown report type from helper:', savedDropdownType);
            // Trigger change to update summary visibility and legal text
            setTimeout(() => {
              updateReportType();
              loadLegalText().catch(console.error);
            }, 150);
          }
        }
        
        // Auto-fill basic price field from helper - ENHANCED
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField) {
          let basicPrice = 0;
          
          // Try multiple sources for BASE PRICE (not market value) - FIXED PRIORITY
          if (helper.levi_report?.base_price) {
            basicPrice = parseFloat(helper.levi_report.base_price);
            console.log('ğŸ“„ Found BASE PRICE in helper.levi_report.base_price:', basicPrice);
          } else if (helper.expertise?.levi_report?.base_price) {
            basicPrice = parseFloat(helper.expertise.levi_report.base_price);
            console.log('ğŸ“„ Found BASE PRICE in helper.expertise.levi_report.base_price:', basicPrice);
          } else if (helper.levisummary?.base_price) {
            basicPrice = parseFloat(helper.levisummary.base_price);
            console.log('ğŸ“„ Found BASE PRICE in helper.levisummary.base_price:', basicPrice);
          } else if (helper.car_details?.base_price) {
            basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[â‚ª,]/g, ''));
            console.log('ğŸ“„ Found BASE PRICE in helper.car_details.base_price:', basicPrice);
          } else {
            // REMOVED market_value fallback - we need BASE price only
            console.warn('âš ï¸ No BASE PRICE found in helper - this field requires Levi base price, not market value');
          }
          
          if (basicPrice > 0) {
            basicPriceField.value = `â‚ª${basicPrice.toLocaleString()}`;
            console.log('âœ… Auto-filled basic price field:', basicPrice);
            
            // Trigger calculation after loading
            setTimeout(() => {
              updateGrossMarketValueCalculation();
            }, 100);
          } else {
            // Check if the field already has a value before warning
            const currentFieldValue = basicPriceField?.value;
            if (!currentFieldValue) {
              console.warn('âš ï¸ No base price found in helper, basic price field will be empty');
            } else {
              console.info('â„¹ï¸ Basic price field already populated with:', currentFieldValue, '(not from helper data)');
            }
            console.log('Debug helper data:', {
              levi_report: helper.levi_report,
              expertise: helper.expertise,
              levisummary: helper.levisummary,
              car_details: helper.car_details
            });
            
            // Enhanced debugging: Log full helper structure
            console.group('ğŸ” FULL HELPER STRUCTURE DEBUG');
            console.log('Complete helper object keys:', Object.keys(helper));
            console.log('Helper size:', JSON.stringify(helper).length);
            
            // Check all possible base price locations
            console.log('All possible base price locations:');
            console.log('- helper.levi_report?.base_price:', helper.levi_report?.base_price);
            console.log('- helper.expertise?.levi_report?.base_price:', helper.expertise?.levi_report?.base_price);
            console.log('- helper.levisummary?.base_price:', helper.levisummary?.base_price);
            console.log('- helper.car_details?.base_price:', helper.car_details?.base_price);
            console.log('- helper.vehicle?.base_price:', helper.vehicle?.base_price);
            console.log('- helper.calculations?.base_price:', helper.calculations?.base_price);
            console.log('- helper.expertise?.calculations?.base_price:', helper.expertise?.calculations?.base_price);
            
            // Check vehicle_value_gross locations
            console.log('All possible vehicle_value_gross locations:');
            console.log('- helper.calculations?.vehicle_value_gross:', helper.calculations?.vehicle_value_gross);
            console.log('- helper.expertise?.calculations?.vehicle_value_gross:', helper.expertise?.calculations?.vehicle_value_gross);
            
            // Check damage data locations
            console.log('All possible damage data locations:');
            console.log('- helper.expertise?.damage_blocks:', helper.expertise?.damage_blocks);
            console.log('- helper.damage_centers:', helper.damage_centers);
            console.log('- helper.damage_sections:', helper.damage_sections);
            
            // Log sessionStorage raw data
            console.log('Raw sessionStorage helper:', sessionStorage.getItem('helper'));
            console.groupEnd();
          }
        }
        
        // Auto-fill car details fields
        const carFields = {
          carPlate: helper.meta?.plate || helper.car_details?.plate || '',
          carManufacturer: helper.car_details?.manufacturer || helper.vehicle?.manufacturer || '',
          carModel: helper.car_details?.model || helper.vehicle?.model || '',
          carYear: helper.car_details?.year || helper.vehicle?.year || '',
          carModelCode: helper.car_details?.model_code || helper.vehicle?.model_code || '',
          carBasePrice: helper.levi_report?.base_price || helper.expertise?.levi_report?.base_price || '',
          carMarketValue: helper.car_details?.market_value || helper.vehicle?.market_value || helper.levi_report?.final_price || '',
          carReportDate: convertToDateInputFormat(helper.car_details?.report_date || new Date().toISOString().split('T')[0])
        };
        
        Object.entries(carFields).forEach(([fieldId, value]) => {
          const field = document.getElementById(fieldId);
          if (field && !field.value && value) {
            field.value = value;
          }
        });
        
        // DEBUGGING: Check all possible damage center data locations
        console.log('ğŸ” DEBUG: Checking all damage center data sources...');
        console.log('helper.expertise?.damage_blocks:', helper.expertise?.damage_blocks);
        console.log('helper.centers:', helper.centers);
        console.log('helper.damage_centers:', helper.damage_centers);
        
        // Load damage centers from helper - CHECK REPORT TYPE FIRST
        // SESSION 93 FIX: Use archive for non-private reports on page load
        const currentReportType = helper.final_report?.type || helper.final_report?.dropdown_type || 
                                document.querySelector('input[name="final-report-type"]:checked')?.value;
        const hasArchive = helper.centers_archive && helper.centers_archive.length > 0;
        const shouldUseArchive = hasArchive && currentReportType !== '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª';
        
        console.log('ğŸ” Page load - Report type:', currentReportType);
        console.log('ğŸ” Has archive:', hasArchive);
        console.log('ğŸ” Should use archive:', shouldUseArchive);
        
        if (shouldUseArchive) {
          console.log('ğŸ”„ Loading from helper.centers_archive (Non-private report - using preserved wizard data)');
          const normalizedBlocks = helper.centers_archive.map((center, index) => adaptCenterToBlock(center, index));
          loadDamageCentersFromHelper(normalizedBlocks);
        } else if (helper.centers && helper.centers.length > 0) {
          console.log('ğŸ”„ Loading from helper.centers (PRIMARY SOURCE - has parts_required data)');
          const normalizedBlocks = helper.centers.map((center, index) => adaptCenterToBlock(center, index));
          loadDamageCentersFromHelper(normalizedBlocks);
        } else if (helper.expertise?.damage_blocks && helper.expertise.damage_blocks.length > 0) {
          console.log('ğŸ”„ Loading from helper.expertise.damage_blocks (FALLBACK - may have empty parts)');
          const normalizedBlocks = helper.expertise.damage_blocks.map((center, index) => adaptCenterToBlock(center, index));
          loadDamageCentersFromHelper(normalizedBlocks);
        } else if (helper.damage_centers && helper.damage_centers.length > 0) {
          console.log('ğŸ”„ Loading from helper.damage_centers');
          const normalizedBlocks = helper.damage_centers.map((center, index) => adaptCenterToBlock(center, index));
          loadDamageCentersFromHelper(normalizedBlocks);
        } else {
          console.log('âŒ No damage center data found in any location');
        }
        
        // SESSION 93: Update toggle visibility after loading damage centers
        if (typeof updateToggleVisibility === 'function') {
          updateToggleVisibility();
        }
        
        console.log('âœ… Helper data loaded successfully');
        
      } catch (error) {
        console.error('Error loading helper data:', error);
      }
    }
    
    // UPDATE DAMAGE ASSESSMENT SUMMARY SECTIONS
    function updateDamageAssessmentSummary(helper) {
      try {
        // Calculate current totals from helper.centers
        let totalWorks = 0;
        let totalParts = 0; 
        let totalRepairs = 0;
        let totalCenters = 0;
        
        if (helper.centers && helper.centers.length > 0) {
          totalCenters = helper.centers.length;
          
          helper.centers.forEach(center => {
            // Sum from parts_required
            if (center.Parts?.parts_required) {
              center.Parts.parts_required.forEach(part => {
                // âœ… SESSION 54 FIX: Use total_cost (includes quantity, reductions, wear) not price (per unit)
                totalParts += parseFloat(part.total_cost) || 0;
              });
            }
            
            // Sum from works
            if (center.Works?.works) {
              center.Works.works.forEach(work => {
                totalWorks += parseFloat(work.cost) || 0;
              });
            }
            
            // Sum from repairs
            if (center.Repairs?.repairs) {
              center.Repairs.repairs.forEach(repair => {
                totalRepairs += parseFloat(repair.cost) || 0;
              });
            }
          });
        }
        
        const totalWithoutVAT = totalWorks + totalParts + totalRepairs;
        const totalWithVAT = totalWithoutVAT * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100);
        
        // Update or create damage_assessment section - PRESERVE comprehensive section
        if (!helper.damage_assessment) helper.damage_assessment = {};
        
        // Update only the specific sections, preserving comprehensive and other existing data
        helper.damage_assessment.total_centers = totalCenters;
        helper.damage_assessment.total_items = totalCenters;
        
        helper.damage_assessment.summary = {
          total_works: totalWorks,
          total_parts: totalParts,
          total_repairs: totalRepairs,
          total_without_vat: Math.round(totalWithoutVAT),
          total_with_vat: Math.round(totalWithVAT)
        };
        
        helper.damage_assessment.totals = {
          "Total works": totalWorks,
          "Total parts": totalParts,
          "Total repairs": totalRepairs,
          "Total without VAT": Math.round(totalWithoutVAT),
          "Total with VAT": Math.round(totalWithVAT)
        };
        
        helper.damage_assessment.last_updated = new Date().toISOString();
        
        // Preserve existing comprehensive section if it exists
        
        console.log('âœ… Updated damage_assessment summary:', helper.damage_assessment);
        
      } catch (error) {
        console.error('âŒ Error updating damage assessment summary:', error);
      }
    }
    
    // UPDATE DAMAGE CENTERS SUBTOTAL DISPLAY
    function updateDamageCentersSubtotal() {
      let totalWorks = 0;
      let totalParts = 0;
      let totalRepairs = 0;
      
      // Calculate totals from all damage center cards
      document.querySelectorAll('.editable-damage-card').forEach(card => {
        // Sum parts costs - SESSION 56 FIX: Use ORIGINAL price Ã— quantity for RIGHT window (×›×œ×œ×™)
        // RIGHT window shows original prices BEFORE discounts/wear
        // LEFT window (after differentials) will apply reductions separately
        card.querySelectorAll('.part-row').forEach(row => {
          const pricePerUnitField = row.querySelector('.part-price-per-unit');
          const quantityField = row.querySelector('.part-quantity');
          
          if (pricePerUnitField && quantityField) {
            const pricePerUnit = parseFloat(pricePerUnitField.value) || 0;
            const quantity = parseInt(quantityField.value) || 1;
            const originalCost = Math.round(pricePerUnit * quantity);
            totalParts += originalCost;
          }
        });
        
        // Sum work costs
        card.querySelectorAll('.work-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
          totalWorks += cost;
        });
        
        // Sum repair costs
        card.querySelectorAll('.repair-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
          totalRepairs += cost;
        });
      });
      
      let rawTotalWithoutVat = totalWorks + totalParts + totalRepairs;
      let rawTotalWithVat = rawTotalWithoutVat * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100);
      
      console.log('ğŸ“Š SESSION 56: RIGHT window (×›×œ×œ×™) calculation:');
      console.log('  Parts (original ××—×™×¨ Ã— ×›××•×ª):', Math.round(totalParts));
      console.log('  Works:', Math.round(totalWorks));
      console.log('  Repairs:', Math.round(totalRepairs));
      console.log('  Total (no discounts applied):', Math.round(rawTotalWithoutVat));
      
      // SESSION 48: Save category totals BEFORE differentials to helper.final_report
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (!helper.final_report) helper.final_report = {};
      helper.final_report.category_totals_before_differentials = {
        Parts: Math.round(totalParts),
        Works: Math.round(totalWorks),
        Repairs: Math.round(totalRepairs)
      };
      sessionStorage.setItem('helper', JSON.stringify(helper));
      if (window.helper) {
        if (!window.helper.final_report) window.helper.final_report = {};
        window.helper.final_report.category_totals_before_differentials = helper.final_report.category_totals_before_differentials;
      }
      
      // Calculate category-specific differentials
      let finalTotalWorks = totalWorks;
      let finalTotalParts = totalParts;
      let finalTotalRepairs = totalRepairs;
      let finalTotalWithoutVat = rawTotalWithoutVat;
      let finalTotalWithVat = rawTotalWithVat;
      
      // SESSION 52: FIX - Extract ALL differential components from helper.final_report.differential
      if (helper.final_report?.differential?.has_differentials) {
        console.log('ğŸ” SESSION 52: Extracting all differential components...');
        
        // 1. Extract parts reductions (×”× ×—×ª ×¨×›×™×‘)
        const partsReductionsTotal = helper.final_report.differential.parts_reductions?.total || 0;
        console.log('   ×”× ×—×ª ×¨×›×™×‘ (Parts Reductions):', partsReductionsTotal);
        
        // 2. Extract parts wear (×‘×œ××™ ×¨×›×™×‘)
        const partsWearTotal = helper.final_report.differential.parts_wear?.total || 0;
        console.log('   ×‘×œ××™ ×¨×›×™×‘ (Parts Wear):', partsWearTotal);
        
        // 3. Extract category differentials and sum by category type
        const categoryDiffItems = helper.final_report.differential.category_differentials?.items || [];
        let categoryDiffForParts = 0;
        let categoryDiffForWorks = 0;
        let categoryDiffForRepairs = 0;
        
        categoryDiffItems.forEach(item => {
          // Extract the reduction value from category_value field (e.g., "â‚ª134")
          const reductionValue = parseFloat(String(item.category_value || '0').replace(/[â‚ª,]/g, '')) || 0;
          const categoryType = item.category_type || item.type || '';
          
          console.log(`   Category Diff: ${categoryType} = â‚ª${reductionValue}`);
          
          if (categoryType === 'Parts' || categoryType === '×—×œ×§×™×') {
            categoryDiffForParts += reductionValue;
          } else if (categoryType === 'Works' || categoryType === '×¢×‘×•×“×•×ª') {
            categoryDiffForWorks += reductionValue;
          } else if (categoryType === 'Repairs' || categoryType === '×ª×™×§×•× ×™×') {
            categoryDiffForRepairs += reductionValue;
          }
        });
        
        console.log('   Category Differentials - Parts:', categoryDiffForParts, ', Works:', categoryDiffForWorks, ', Repairs:', categoryDiffForRepairs);
        
        // 4. Extract invoice differentials by nature
        const invoiceDiffItems = helper.final_report.differential.invoice_differentials?.items || [];
        let invoicePartsDiff = 0;
        let invoiceWorksDiff = 0;
        let invoiceRepairsDiff = 0;
        
        invoiceDiffItems.forEach(item => {
          const amount = item.amount_without_vat || item.amount || 0;
          const nature = item.nature || '';
          
          if (nature === 'parts' || nature === '×—×œ×§×™×') {
            invoicePartsDiff += amount;
          } else if (nature === 'works' || nature === '×¢×‘×•×“×•×ª') {
            invoiceWorksDiff += amount;
          } else if (nature === 'repairs' || nature === '×ª×™×§×•× ×™×') {
            invoiceRepairsDiff += amount;
          }
        });
        
        console.log('   Invoice Differentials - Parts:', invoicePartsDiff, ', Works:', invoiceWorksDiff, ', Repairs:', invoiceRepairsDiff);
        
        // SESSION 52: Apply CORRECT formulas for each category
        // Parts = Original - ×”× ×—×ª ×¨×›×™×‘ - ×‘×œ××™ ×¨×›×™×‘ - Category Diff (Parts) - Invoice Diff (parts)
        finalTotalParts = Math.max(0, totalParts - partsReductionsTotal - partsWearTotal - categoryDiffForParts - invoicePartsDiff);
        
        // Works = Original - Category Diff (Works) - Invoice Diff (works)
        finalTotalWorks = Math.max(0, totalWorks - categoryDiffForWorks - invoiceWorksDiff);
        
        // Repairs = Original - Category Diff (Repairs) - Invoice Diff (repairs)
        finalTotalRepairs = Math.max(0, totalRepairs - categoryDiffForRepairs - invoiceRepairsDiff);
        
        // SESSION 52: FIX - Total Without VAT = sum of category finals (already includes all differentials)
        finalTotalWithoutVat = finalTotalParts + finalTotalWorks + finalTotalRepairs;
        
        // Apply VAT to the final amount
        const vatRate = window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18);
        finalTotalWithVat = Math.round(finalTotalWithoutVat * (1 + vatRate / 100));
        
        console.log('ğŸ“‰ SESSION 52: Applied ALL differentials correctly:');
        console.log('   Original - Parts:', totalParts, ', Works:', totalWorks, ', Repairs:', totalRepairs, ', Total:', rawTotalWithoutVat);
        console.log('   Differentials - Parts:', (partsReductionsTotal + partsWearTotal + categoryDiffForParts + invoicePartsDiff));
        console.log('                - Works:', (categoryDiffForWorks + invoiceWorksDiff));
        console.log('                - Repairs:', (categoryDiffForRepairs + invoiceRepairsDiff));
        console.log('   Final (after) - Parts:', finalTotalParts, ', Works:', finalTotalWorks, ', Repairs:', finalTotalRepairs);
        console.log('   Final Total Without VAT:', finalTotalWithoutVat, ', With VAT:', finalTotalWithVat);
      }
      
      // SESSION 48: Check if we're using dual container layout (updated for new structure)
      const hasDifferentials = helper.final_report?.differential?.has_differentials && 
                              helper.final_report?.differential?.grand_total &&
                              (helper.final_report.differential.grand_total.without_vat > 0 || 
                               helper.final_report.differential.grand_total.with_vat > 0);
      
      if (hasDifferentials) {
        // Update ORIGINAL values (left container - ×›×œ×œ×™)
        const totalWorksOriginal = document.getElementById('totalWorksOriginal');
        const totalPartsOriginal = document.getElementById('totalPartsOriginal');
        const totalRepairsOriginal = document.getElementById('totalRepairsOriginal');
        const totalWithoutVatOriginal = document.getElementById('totalWithoutVatOriginal');
        const totalWithVatOriginal = document.getElementById('totalWithVatOriginal');
        
        if (totalWorksOriginal) totalWorksOriginal.textContent = `â‚ª${totalWorks.toLocaleString()}`;
        if (totalPartsOriginal) totalPartsOriginal.textContent = `â‚ª${totalParts.toLocaleString()}`;
        if (totalRepairsOriginal) totalRepairsOriginal.textContent = `â‚ª${totalRepairs.toLocaleString()}`;
        if (totalWithoutVatOriginal) totalWithoutVatOriginal.textContent = `â‚ª${Math.round(rawTotalWithoutVat).toLocaleString()}`;
        if (totalWithVatOriginal) totalWithVatOriginal.textContent = `â‚ª${Math.round(rawTotalWithVat).toLocaleString()}`;
        
        // Update AFTER DIFFERENTIALS values (right container - ××—×¨×™ ×”×¤×¨×©×™×)
        const totalWorksSubtotal = document.getElementById('totalWorksSubtotal');
        const totalPartsSubtotal = document.getElementById('totalPartsSubtotal');
        const totalRepairsSubtotal = document.getElementById('totalRepairsSubtotal');
        const totalWithoutVatSubtotal = document.getElementById('totalWithoutVatSubtotal');
        const totalWithVatSubtotal = document.getElementById('totalWithVatSubtotal');
        const totalDifferentialsDisplay = document.getElementById('totalDifferentialsDisplay');
        
        if (totalWorksSubtotal) totalWorksSubtotal.textContent = `â‚ª${Math.round(finalTotalWorks).toLocaleString()}`;
        if (totalPartsSubtotal) totalPartsSubtotal.textContent = `â‚ª${Math.round(finalTotalParts).toLocaleString()}`;
        if (totalRepairsSubtotal) totalRepairsSubtotal.textContent = `â‚ª${Math.round(finalTotalRepairs).toLocaleString()}`;
        if (totalWithoutVatSubtotal) totalWithoutVatSubtotal.textContent = `â‚ª${Math.round(finalTotalWithoutVat).toLocaleString()}`;
        if (totalWithVatSubtotal) totalWithVatSubtotal.textContent = `â‚ª${Math.round(finalTotalWithVat).toLocaleString()}`;
        
        // SESSION 48: Display total differentials from helper
        if (totalDifferentialsDisplay && helper.final_report?.differential?.grand_total) {
          const differentialsTotal = helper.final_report.differential.grand_total.without_vat || 0;
          totalDifferentialsDisplay.textContent = `â‚ª${Math.round(differentialsTotal).toLocaleString()}`;
        }
        
      } else {
        // Single container - use final values (which equals raw values when no differentials)
        const totalWorksElement = document.getElementById('totalWorksSubtotal');
        const totalPartsElement = document.getElementById('totalPartsSubtotal');
        const totalRepairsElement = document.getElementById('totalRepairsSubtotal');
        const totalWithoutVatElement = document.getElementById('totalWithoutVatSubtotal');
        const totalWithVatElement = document.getElementById('totalWithVatSubtotal');
        
        if (totalWorksElement) totalWorksElement.textContent = `â‚ª${Math.round(finalTotalWorks).toLocaleString()}`;
        if (totalPartsElement) totalPartsElement.textContent = `â‚ª${Math.round(finalTotalParts).toLocaleString()}`;
        if (totalRepairsElement) totalRepairsElement.textContent = `â‚ª${Math.round(finalTotalRepairs).toLocaleString()}`;
        if (totalWithoutVatElement) totalWithoutVatElement.textContent = `â‚ª${Math.round(finalTotalWithoutVat).toLocaleString()}`;
        if (totalWithVatElement) totalWithVatElement.textContent = `â‚ª${Math.round(finalTotalWithVat).toLocaleString()}`;
      }
      
      // Update helper with after differentials totals
      if (!helper.damage_assessment) helper.damage_assessment = {};
      if (!helper.damage_assessment.totals_after_differentials) {
        helper.damage_assessment.totals_after_differentials = {};
      }
      
      helper.damage_assessment.totals_after_differentials = {
        "Total works": Math.round(finalTotalWorks),
        "Total parts": Math.round(finalTotalParts), 
        "Total repairs": Math.round(finalTotalRepairs),
        "Total without VAT": Math.round(finalTotalWithoutVat),
        "Total with VAT": Math.round(finalTotalWithVat),
        "last_updated": new Date().toISOString()
      };
      
      // Save updated helper
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Also update window.helper
      if (window.helper) {
        if (!window.helper.damage_assessment) window.helper.damage_assessment = {};
        window.helper.damage_assessment.totals_after_differentials = helper.damage_assessment.totals_after_differentials;
      }
      
      console.log('ğŸ’° Updated damage centers subtotal:', {
        originalWorks: totalWorks,
        originalParts: totalParts,
        originalRepairs: totalRepairs,
        finalWorks: finalTotalWorks,
        finalParts: finalTotalParts,
        finalRepairs: finalTotalRepairs,
        finalWithoutVat: finalTotalWithoutVat,
        finalWithVat: finalTotalWithVat,
        showingDifferentialsOverlay: hasDifferentials
      });
      
      console.log('ğŸ“Š Saved totals_after_differentials to helper:', helper.damage_assessment.totals_after_differentials);
      
      // Update authorizedClaim field - ALWAYS use original totals (NOT after differentials)
      const authorizedClaimField = document.getElementById('authorizedClaim');
      if (authorizedClaimField) {
        // Always use original totals, same as totalClaimGross
        const claimTotal = helper.damage_assessment?.totals?.["Total with VAT"] || 0;
        const claimValue = claimTotal ? `â‚ª${claimTotal.toLocaleString()}` : '';
        
        authorizedClaimField.value = claimValue;
        
        // Update helper data
        if (!helper.claims_data) helper.claims_data = {};
        if (!helper.calculations) helper.calculations = {};
        helper.claims_data.total_claim = claimValue;
        helper.calculations.total_damage = claimTotal;
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        if (window.helper) {
          if (!window.helper.claims_data) window.helper.claims_data = {};
          if (!window.helper.calculations) window.helper.calculations = {};
          window.helper.claims_data.total_claim = claimValue;
          window.helper.calculations.total_damage = claimTotal;
        }
        
        // Trigger gross percentage recalculation
        setTimeout(() => {
          if (typeof updateGrossPercentageField === 'function') {
            updateGrossPercentageField();
          }
        }, 100);
      }
    }
    
    // SESSION 47: CREATE ×”×¤×¨×©×™× SECTION WITH 4 CATEGORIES
    function createDifferentialsSection() {
      return `
        <div class="form-section" id="differentialsSection" style="margin-top: 20px;">
          <h3>×”× ×—×•×ª ×•×”×¤×¨×©×™×</h3>
          <label style="margin-bottom:10px; display:flex; align-items:center; gap:6px;">
            <span style="background:#ff4444; color:white; padding:2px 6px; border-radius:3px; font-size:11px;">ğŸ”´</span>
            ×”×× ×§×™×™××™× ×”× ×—×•×ª ×•×”×¤×¨×©×™×?
            <input type="checkbox" id="hasDifferentials" style="width:auto; margin-right:6px;" onchange="toggleDifferentialsTable(); setTimeout(saveDifferentialsToHelper, 100);">
          </label>
          
          <div id="differentialsMainContainer" style="display:none; margin-top:15px;">
            
            <!-- CATEGORY 1: PARTS REDUCTIONS (AUTO-IMPORTED - RED) -->
            <div id="partsReductionsSection" style="margin-bottom:15px; border:2px solid #dc3545; border-radius:6px; padding:10px; background:#fff5f5;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; cursor:pointer;" onclick="toggleCollapsibleSection('partsReductionsContent')">
                <h4 style="margin:0; color:#dc3545; font-size:14px;">
                  <span style="background:#dc3545; color:white; padding:2px 6px; border-radius:3px; font-size:10px; margin-left:6px;">ğŸ”´</span>
                  ×”× ×—×ª ×¨×›×™×‘
                </h4>
                <span id="partsReductionsToggle" style="font-size:18px; color:#dc3545;">â–¼</span>
              </div>
              <div id="partsReductionsContent" style="display:block;">
                <div id="partsReductionsList" style="font-size:12px; color:#666; margin-bottom:8px;">
                  <!-- Auto-populated from parts reduction breakdown -->
                </div>
                <div style="background:#f8f9fa; padding:8px; border-radius:4px; text-align:left; font-weight:bold;">
                  ×¡×”"×› ×”× ×—×ª ×¨×›×™×‘: <span id="totalPartsReductions">â‚ª0</span>
                </div>
              </div>
            </div>
            
            <!-- CATEGORY 2: PARTS WEAR (AUTO-IMPORTED - RED) -->
            <div id="partsWearSection" style="margin-bottom:15px; border:2px solid #dc3545; border-radius:6px; padding:10px; background:#fff5f5;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; cursor:pointer;" onclick="toggleCollapsibleSection('partsWearContent')">
                <h4 style="margin:0; color:#dc3545; font-size:14px;">
                  <span style="background:#dc3545; color:white; padding:2px 6px; border-radius:3px; font-size:10px; margin-left:6px;">ğŸ”´</span>
                  ×‘×œ××™ ×¨×›×™×‘
                </h4>
                <span id="partsWearToggle" style="font-size:18px; color:#dc3545;">â–¼</span>
              </div>
              <div id="partsWearContent" style="display:block;">
                <div id="partsWearList" style="font-size:12px; color:#666; margin-bottom:8px;">
                  <!-- Auto-populated from parts wear breakdown -->
                </div>
                <div style="background:#f8f9fa; padding:8px; border-radius:4px; text-align:left; font-weight:bold;">
                  ×¡×”"×› ×‘×œ××™ ×¨×›×™×‘: <span id="totalPartsWear">â‚ª0</span>
                </div>
              </div>
            </div>
            
            <!-- CATEGORY 3: CATEGORY DIFFERENTIALS (MANUAL ENTRY - COLLAPSIBLE) -->
            <div id="categoryDifferentialsSection" style="margin-bottom:15px; border:2px solid #6c757d; border-radius:6px; padding:10px; background:#f8f9fa;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; cursor:pointer;" onclick="toggleCollapsibleSection('categoryDifferentialsContent')">
                <h4 style="margin:0; color:#6c757d; font-size:14px;">
                  ×”×¤×¨×©×™ ×§×˜×’×•×¨×™×”
                </h4>
                <span id="categoryDifferentialsToggle" style="font-size:18px; color:#6c757d;">â–¼</span>
              </div>
              <div id="categoryDifferentialsContent" style="display:none;">
                <div id="categoryDifferentialsList">
                  <!-- Manual category differentials rows -->
                </div>
                <button class="btn add" type="button" onclick="addCategoryDifferentialRow()" style="font-size:12px; padding:6px 12px;">×”×•×¡×£ ×”×¤×¨×© ×§×˜×’×•×¨×™×”</button>
              </div>
            </div>
            
            <!-- CATEGORY 4: INVOICE DIFFERENTIALS (EXISTING - GRAY) -->
            <div id="invoiceDifferentialsSection" style="margin-bottom:15px; border:2px solid #6c757d; border-radius:6px; padding:10px; background:#f1f1f1;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; cursor:pointer;" onclick="toggleCollapsibleSection('invoiceDifferentialsContent')">
                <h4 style="margin:0; color:#212529; font-size:14px;">
                  ×”×¤×¨×©×™ ×—×©×‘×•× ×™×•×ª
                </h4>
                <span id="invoiceDifferentialsToggle" style="font-size:18px; color:#212529;">â–¼</span>
              </div>
              <div id="invoiceDifferentialsContent" style="display:none;">
                
                <!-- Invoice Selection for Differentials -->
                <div style="margin-bottom: 15px; padding: 10px; background: #e3f2fd; border-radius: 6px; border: 1px solid #2196f3;">
                  <label style="display: block; font-size: 12px; color: #1565c0; margin-bottom: 4px; font-weight: 600;">××™×–×” ×—×©×‘×•× ×™×•×ª ×–××™× ×•×ª</label>
                  <select id="invoiceSelectionForDifferentials" onchange="handleInvoiceSelectionForDifferentials(this)" 
                          style="width:100%; padding:10px; border-radius:6px; border:1px solid #2196f3; font-size:14px; background: white;">
                    <option value="">×‘×—×™×¨×ª ×¤×¨×™×˜ ×ª××œ× ××•×˜×•××˜×™×ª ××ª ×›×œ ×”×©×“×•×ª ×‘×©×•×¨×”</option>
                  </select>
                </div>
                
                <div id="differentialsRows"></div>
                <button class="btn add" type="button" onclick="addDifferentialRow()" style="font-size:12px; padding:6px 12px;">×”×•×¡×£ ×”×¤×¨×©</button>
              </div>
            </div>
            
            <!-- SUBTOTALS SECTION -->
            <div id="differentialsSubtotalsSection" style="margin-top:20px;">
              <!-- Gray box: Total component differentials (reductions + wear + category) -->
              <div style="background:#6c757d; color:white; padding:10px; border-radius:6px; margin-bottom:10px; display:flex; justify-content:space-between; align-items:center;">
                <span style="font-size:14px; font-weight:bold;">×¡×”"×› ×”×¤×¨×©×™ ×¨×›×™×‘×™×:</span>
                <span id="totalComponentWear" style="font-size:16px; font-weight:bold;">â‚ª0</span>
              </div>
              
              <!-- SESSION 48: Changed to blue color matching section colors -->
              <div style="background:#17a2b8; color:white; padding:10px; border-radius:6px; margin-bottom:15px; display:flex; justify-content:space-between; align-items:center;">
                <span style="font-size:14px; font-weight:bold;">×¡×”"×› ×”×¤×¨×©×™ ×—×©×‘×•× ×™×•×ª:</span>
                <span id="totalInvoiceDifferentials" style="font-size:16px; font-weight:bold;">â‚ª0</span>
              </div>
              
              <!-- SESSION 48: Grand totals in a nice bordered box -->
              <div style="border:3px solid #000; border-radius:8px; padding:12px; background:#f8f9fa;">
                <div style="background:#343a40; color:white; padding:10px; border-radius:6px; margin-bottom:8px; display:flex; justify-content:space-between; align-items:center;">
                  <span style="font-size:14px; font-weight:bold;">×¡×”"×› ×›×œ×œ×™ ×”×¤×¨×©×™× (×œ×œ× ××¢"×):</span>
                  <span id="grandTotalDifferentialsWithoutVAT" style="font-size:16px; font-weight:bold;">â‚ª0</span>
                </div>
                
                <div style="background:#495057; color:white; padding:10px; border-radius:6px; margin-bottom:8px; display:flex; justify-content:space-between; align-items:center;">
                  <span style="font-size:14px; font-weight:bold;">××¢"×:</span>
                  <span id="grandTotalDifferentialsVAT" style="font-size:16px; font-weight:bold;">â‚ª0</span>
                </div>
                
                <div style="background:#000; color:white; padding:14px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; border:2px solid #ffc107;">
                  <span style="font-size:16px; font-weight:bold;">×¡×”"×› ×›×œ×œ×™ ×”×¤×¨×©×™× (×›×•×œ×œ ××¢"×):</span>
                  <span id="grandTotalDifferentialsWithVAT" style="font-size:20px; font-weight:bold;">â‚ª0</span>
                </div>
              </div>
            </div>
            
            <!-- Save button -->
            <div style="margin-top:15px; text-align:center;">
              <button class="btn save" type="button" onclick="saveDifferentials()" style="background:#28a745; color:white; padding:10px 20px; border-radius:6px; border:none; font-size:14px; cursor:pointer;">×©××•×¨ ×”×¤×¨×©×™×</button>
            </div>
          </div>
        </div>
      `;
    }
    
    // ========================================
    // SESSION 62: CASE REDUCTION SECTION (×”× ×—×ª ×ª×™×§)
    // ========================================
    function createCaseReductionSection() {
      return `
        <!-- SESSION 62: Case Reduction Section (×”× ×—×ª ×ª×™×§) -->
        <div class="form-section" id="caseReductionSection" style="margin-top: 20px;">
          <h3>×”× ×—×ª ×ª×™×§</h3>
          
          <label style="margin-bottom:10px; display:flex; align-items:center; gap:6px;">
            <span style="background:#17a2b8; color:white; padding:2px 6px; border-radius:3px; font-size:11px;">ğŸ’°</span>
            ×”×× ×§×™×™××ª ×”× ×—×ª ×ª×™×§?
            <input type="checkbox" id="hasCaseReduction" style="width:auto; margin-right:6px;" 
                   onchange="toggleCaseReductionTable();">
          </label>
          
          <div id="caseReductionContainer" style="display:none; margin-top:15px;">
            <div style="margin-bottom:15px; border:2px solid #17a2b8; border-radius:6px; padding:10px; background:#e7f4f9;">
              <table style="width:100%; border-collapse:collapse; font-size:13px;">
                <thead>
                  <tr style="background:#17a2b8; color:white;">
                    <th style="padding:8px; text-align:right;">×©× ×©×•×¨×”</th>
                    <th style="padding:8px; text-align:right; width:100px;">××—×•×–</th>
                    <th style="padding:8px; text-align:right; width:120px;">×¡×›×•× ××§×•×¨×™</th>
                    <th style="padding:8px; text-align:right; width:120px;">×¢×¨×š ×”×”× ×—×”</th>
                    <th style="padding:8px; text-align:right; width:120px;">×¡×›×•× ×¡×•×¤×™</th>
                    <th style="padding:8px; text-align:right; width:140px;">×›×•×œ×œ ××¢"×</th>
                  </tr>
                </thead>
                <tbody>
                  <tr style="background:white;">
                    <td style="padding:8px; border:1px solid #ddd;">×”× ×—×ª ×ª×™×§</td>
                    <td style="padding:8px; border:1px solid #ddd;">
                      <input type="number" id="caseReductionPercentage" min="0" max="100" step="0.01" value="0" 
                             style="width:100%; text-align:center; padding:4px; border-radius:4px; border:1px solid #ccc;"
                             oninput="calculateCaseReduction();">
                    </td>
                    <td style="padding:8px; border:1px solid #ddd; font-weight:bold;" id="caseOriginalSum">â‚ª0.00</td>
                    <td style="padding:8px; border:1px solid #ddd; font-weight:bold; color:#dc3545;" id="caseDiscountValue">â‚ª0.00</td>
                    <td style="padding:8px; border:1px solid #ddd; font-weight:bold; color:#28a745;" id="caseTotalAfter">â‚ª0.00</td>
                    <td style="padding:8px; border:1px solid #ddd; font-weight:bold; color:#17a2b8;" id="caseTotalWithVAT">â‚ª0.00</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      `;
    }
    
    // SESSION 48: AUTO-CHECK DIFFERENTIALS CHECKBOX IF PARTS HAVE REDUCTIONS OR WEAR
    function autoCheckDifferentialsIfNeeded() {
      const breakdown = calculatePartsDifferentialsBreakdown();
      const hasDifferentialsCheckbox = document.getElementById('hasDifferentials');
      
      if (breakdown.reductions.length > 0 || breakdown.wear.length > 0) {
        if (hasDifferentialsCheckbox && !hasDifferentialsCheckbox.checked) {
          hasDifferentialsCheckbox.checked = true;
          toggleDifferentialsTable();
          console.log('âœ… SESSION 48: Auto-checked ×”×¤×¨×©×™× checkbox - found imported reductions/wear');
        }
      }
    }
    
    // SESSION 47: RENDER PARTS REDUCTIONS LIST
    function renderPartsReductionsSection() {
      const breakdown = calculatePartsDifferentialsBreakdown();
      const listContainer = document.getElementById('partsReductionsList');
      const totalContainer = document.getElementById('totalPartsReductions');
      
      if (!listContainer || !totalContainer) return;
      
      if (breakdown.reductions.length === 0) {
        listContainer.innerHTML = '<p style="color:#999; font-style:italic;">××™×Ÿ ×”× ×—×•×ª ×¨×›×™×‘</p>';
        totalContainer.textContent = 'â‚ª0';
        return;
      }
      
      let html = '<div style="display:grid; gap:4px;">';
      breakdown.reductions.forEach(item => {
        html += `
          <div style="display:grid; grid-template-columns: 120px 1fr 60px 80px; gap:6px; padding:4px; background:white; border-radius:3px; font-size:11px; align-items:center;">
            <div style="color:#666;">${item.centerName}</div>
            <div style="color:#333;">${item.partName}</div>
            <div style="text-align:center; font-weight:bold; color:#dc3545; background:#fff5f5; padding:2px 4px; border-radius:3px;">${item.percentage}%</div>
            <div style="text-align:left; font-weight:bold; color:#dc3545;">â‚ª${item.amount.toLocaleString()}</div>
          </div>
        `;
      });
      html += '</div>';
      
      listContainer.innerHTML = html;
      totalContainer.textContent = `â‚ª${breakdown.totalReduction.toLocaleString()}`;
      
      // SESSION 48: Auto-check checkbox after rendering
      autoCheckDifferentialsIfNeeded();
    }
    
    // SESSION 47: RENDER PARTS WEAR LIST
    function renderPartsWearSection() {
      const breakdown = calculatePartsDifferentialsBreakdown();
      const listContainer = document.getElementById('partsWearList');
      const totalContainer = document.getElementById('totalPartsWear');
      
      if (!listContainer || !totalContainer) return;
      
      if (breakdown.wear.length === 0) {
        listContainer.innerHTML = '<p style="color:#999; font-style:italic;">××™×Ÿ ×‘×œ××™ ×¨×›×™×‘</p>';
        totalContainer.textContent = 'â‚ª0';
        return;
      }
      
      let html = '<div style="display:grid; gap:4px;">';
      breakdown.wear.forEach(item => {
        html += `
          <div style="display:grid; grid-template-columns: 120px 1fr 60px 80px; gap:6px; padding:4px; background:white; border-radius:3px; font-size:11px; align-items:center;">
            <div style="color:#666;">${item.centerName}</div>
            <div style="color:#333;">${item.partName}</div>
            <div style="text-align:center; font-weight:bold; color:#dc3545; background:#fff5f5; padding:2px 4px; border-radius:3px;">${item.percentage}%</div>
            <div style="text-align:left; font-weight:bold; color:#dc3545;">â‚ª${item.amount.toLocaleString()}</div>
          </div>
        `;
      });
      html += '</div>';
      
      listContainer.innerHTML = html;
      totalContainer.textContent = `â‚ª${breakdown.totalWear.toLocaleString()}`;
    }
    
    // SESSION 47: TOGGLE COLLAPSIBLE SECTIONS
    function toggleCollapsibleSection(contentId) {
      const content = document.getElementById(contentId);
      const toggleIcon = document.getElementById(contentId.replace('Content', 'Toggle'));
      
      if (!content) return;
      
      if (content.style.display === 'none') {
        content.style.display = 'block';
        if (toggleIcon) toggleIcon.textContent = 'â–¼';
      } else {
        content.style.display = 'none';
        if (toggleIcon) toggleIcon.textContent = 'â—€';
      }
    }
    
    // SESSION 47: ADD CATEGORY DIFFERENTIAL ROW
    window.addCategoryDifferentialRow = function addCategoryDifferentialRow() {
      const container = document.getElementById('categoryDifferentialsList');
      if (!container) return;
      
      const rowIndex = container.children.length;
      const rowHTML = `
        <div class="category-differential-row" data-index="${rowIndex}" style="background:white; border:1px solid #ddd; border-radius:4px; padding:8px; margin-bottom:8px;">
          <div style="display:grid; grid-template-columns: 1fr 80px 120px 100px; gap:8px; align-items:end;">
            <div>
              <label style="font-size:11px; color:#666;">×‘×—×¨ ×§×˜×’×•×¨×™×”:</label>
              <select class="category-diff-type" style="width:100%; padding:4px; border:1px solid #ddd; border-radius:3px; font-size:12px;" onchange="updateCategoryDifferentialsTotal()">
                <option value="">×‘×—×¨</option>
                <option value="Parts">×—×œ×§×™×</option>
                <option value="Works">×¢×‘×•×“×•×ª</option>
                <option value="Repairs">×ª×™×§×•× ×™×</option>
              </select>
            </div>
            <div>
              <label style="font-size:11px; color:#666;">××—×•×–:</label>
              <input type="text" class="category-diff-percentage" value="0%" placeholder="0%" style="width:100%; padding:4px; border:1px solid #ddd; border-radius:3px; font-size:12px; text-align:center;" oninput="updateCategoryDifferentialsTotal()">
            </div>
            <div>
              <label style="font-size:11px; color:#666;">×¢×¨×š ×”×”× ×—×”:</label>
              <input type="text" class="category-diff-category-value" value="â‚ª0" readonly style="width:100%; padding:4px; border:1px solid #ddd; border-radius:3px; font-size:12px; background:#f8f9fa; text-align:center;">
            </div>
            <div>
              <label style="font-size:11px; color:#666;">×¡×›×•× (×œ×œ× ××¢"×):</label>
              <input type="number" class="category-diff-amount" value="0" readonly style="width:100%; padding:4px; border:1px solid #ddd; border-radius:3px; font-size:12px; background:#f8f9fa; text-align:center;">
            </div>
          </div>
          <button type="button" onclick="removeCategoryDifferentialRow(this)" style="margin-top:6px; padding:4px 8px; font-size:11px; background:#dc3545; color:white; border:none; border-radius:3px; cursor:pointer;">××—×§</button>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', rowHTML);
      
      // SESSION 48: Attach event listeners after row creation
      const newRow = container.lastElementChild;
      if (newRow) {
        const typeSelect = newRow.querySelector('.category-diff-type');
        const amountInput = newRow.querySelector('.category-diff-amount');
        
        if (typeSelect) {
          typeSelect.addEventListener('change', function() {
            console.log('ğŸ”„ Category dropdown changed to:', this.value);
            updateCategoryDifferentialsTotal();
          });
        }
        
        if (amountInput) {
          amountInput.addEventListener('input', function() {
            console.log('ğŸ”„ Amount input changed to:', this.value);
            updateCategoryDifferentialsTotal();
          });
        }
      }
    }
    
    // SESSION 47: REMOVE CATEGORY DIFFERENTIAL ROW
    window.removeCategoryDifferentialRow = function removeCategoryDifferentialRow(button) {
      button.closest('.category-differential-row').remove();
      updateCategoryDifferentialsTotal();
    }
    
    // SESSION 48: User enters percentage â†’ calculate ×¢×¨×š ×”×”× ×—×” and ×¡×›×•×
    window.updateCategoryDifferentialsTotal = function updateCategoryDifferentialsTotal() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // SESSION 48: Read from final_report.category_totals_before_differentials (built from UI)
      const categoryTotalsFromUI = helper.final_report?.category_totals_before_differentials || {};
      
      const categoryOriginalCosts = {
        'Parts': parseFloat(categoryTotalsFromUI.Parts || 0),
        'Works': parseFloat(categoryTotalsFromUI.Works || 0),
        'Repairs': parseFloat(categoryTotalsFromUI.Repairs || 0)
      };
      
      const rows = document.querySelectorAll('.category-differential-row');
      let total = 0;
      
      rows.forEach(row => {
        const typeSelect = row.querySelector('.category-diff-type');
        const percentageInput = row.querySelector('.category-diff-percentage');
        const reductionValueInput = row.querySelector('.category-diff-category-value'); // ×¢×¨×š ×”×”× ×—×”
        const updatedCostInput = row.querySelector('.category-diff-amount'); // ×¡×›×•× (×œ×œ× ××¢"×)
        
        const categoryType = typeSelect?.value || '';
        const percentageText = percentageInput?.value || '0%';
        const percentageNum = parseFloat(percentageText.replace('%', '')) || 0;
        
        if (categoryType && categoryOriginalCosts[categoryType] > 0) {
          const originalCost = categoryOriginalCosts[categoryType];
          
          // ×¢×¨×š ×”×”× ×—×” = percentage Ã— original cost
          const reductionValue = Math.round((percentageNum / 100) * originalCost);
          
          // ×¡×›×•× (×œ×œ× ××¢"×) = original cost - ×¢×¨×š ×”×”× ×—×”
          const updatedCost = Math.round(originalCost - reductionValue);
          
          if (reductionValueInput) reductionValueInput.value = `â‚ª${reductionValue.toLocaleString()}`;
          if (updatedCostInput) updatedCostInput.value = updatedCost;
          
          total += updatedCost;
        } else {
          if (reductionValueInput) reductionValueInput.value = 'â‚ª0';
          if (updatedCostInput) updatedCostInput.value = 0;
        }
      });
      
      updateAllDifferentialsSubtotals();
      setTimeout(saveDifferentialsToHelper, 100);
    }
    
    // SESSION 47: POPULATE DAMAGE CENTERS DROPDOWN
    function populateDamageCentersDropdown(selectElement) {
      if (!selectElement) return;
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const centers = helper.centers || [];
      
      let options = '<option value="">×‘×—×¨ ××•×§×“ × ×–×§</option>';
      centers.forEach((center, index) => {
        const centerName = center["Damage center Name"] || center.name || `××•×§×“ × ×–×§ ${index + 1}`;
        options += `<option value="${index}">${centerName}</option>`;
      });
      
      selectElement.innerHTML = options;
    }
    
    // SESSION 47: CALCULATE PARTS DIFFERENTIALS BREAKDOWN (REDUCTION VS WEAR)
    function calculatePartsDifferentialsBreakdown() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const centers = helper.centers || [];
      
      const breakdown = {
        reductions: [],
        wear: [],
        totalReduction: 0,
        totalWear: 0
      };
      
      centers.forEach((center, centerIndex) => {
        const centerName = center["Damage center Name"] || center.name || `××•×§×“ × ×–×§ ${centerIndex + 1}`;
        const partsRequired = center.Parts?.parts_required || [];
        
        partsRequired.forEach((part, partIndex) => {
          const pricePerUnit = parseFloat(part.price_per_unit || part.unit_price || part.price || 0);
          const reductionPct = parseFloat(part.reduction_percentage || part.reduction || 0);
          const wearPct = parseFloat(part.wear_percentage || part.wear || 0);
          const quantity = parseInt(part.quantity || part.×›××•×ª || 1);
          const partName = part.name || part.part_name || `×—×œ×§ ${partIndex + 1}`;
          
          if (reductionPct > 0) {
            const priceAfterReduction = pricePerUnit * (1 - reductionPct / 100);
            const reductionAmount = Math.round((pricePerUnit - priceAfterReduction) * quantity);
            
            if (reductionAmount > 0) {
              breakdown.reductions.push({
                centerName,
                partName,
                amount: reductionAmount,
                percentage: reductionPct
              });
              breakdown.totalReduction += reductionAmount;
            }
          }
          
          if (wearPct > 0) {
            const priceAfterReduction = pricePerUnit * (1 - reductionPct / 100);
            const priceAfterWear = priceAfterReduction * (1 - wearPct / 100);
            const wearAmount = Math.round((priceAfterReduction - priceAfterWear) * quantity);
            
            if (wearAmount > 0) {
              breakdown.wear.push({
                centerName,
                partName,
                amount: wearAmount,
                percentage: wearPct
              });
              breakdown.totalWear += wearAmount;
            }
          }
        });
      });
      
      breakdown.totalReduction = Math.round(breakdown.totalReduction);
      breakdown.totalWear = Math.round(breakdown.totalWear);
      
      console.log('ğŸ“Š SESSION 47: Parts differentials breakdown:', breakdown);
      return breakdown;
    }

    // CREATE DAMAGE CENTERS SUBTOTAL SECTION
    function createDamageCentersSubtotal(hasDifferentials = false) {
      if (!hasDifferentials) {
        // Single container when no differentials
        return `
          <div id="damageCentersSubtotal" style="background: #f8f9fa; border: 2px solid #28a745; border-radius: 6px; padding: 12px; margin-top: 15px;">
            <h4 style="margin: 0 0 10px 0; color: #28a745; text-align: center; font-size: 14px; font-weight: bold;">ğŸ§® ×¡×™×›×•× ×›×œ×œ×™ - ××¨×›×–×™ × ×–×§</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 8px;">
              <div style="background: #17a2b8; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                <div style="font-size: 16px; font-weight: bold;" id="totalWorksSubtotal">â‚ª0</div>
                <div style="font-size: 10px; opacity: 0.9;">×¡×”"×› ×¢×‘×•×“×•×ª</div>
              </div>
              <div style="background: #28a745; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                <div style="font-size: 16px; font-weight: bold;" id="totalPartsSubtotal">â‚ª0</div>
                <div style="font-size: 10px; opacity: 0.9;">×¡×”"×› ×—×œ×§×™×</div>
              </div>
              <div style="background: #ffc107; color: #212529; padding: 8px; border-radius: 4px; text-align: center;">
                <div style="font-size: 16px; font-weight: bold;" id="totalRepairsSubtotal">â‚ª0</div>
                <div style="font-size: 10px; opacity: 0.9;">×¡×”"×› ×ª×™×§×•× ×™×</div>
              </div>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
              <div style="background: #6c757d; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                <div style="font-size: 18px; font-weight: bold;" id="totalWithoutVatSubtotal">â‚ª0</div>
                <div style="font-size: 11px; opacity: 0.9;">×¡×”"×› ×œ×œ× ××¢"×</div>
              </div>
              <div style="background: #dc3545; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                <div style="font-size: 18px; font-weight: bold;" id="totalWithVatSubtotal">â‚ª0</div>
                <div style="font-size: 11px; opacity: 0.9;">×¡×”"×› ×›×•×œ×œ ××¢"×</div>
              </div>
            </div>
          </div>
        `;
      } else {
        // Dual containers when differentials exist (50/50)
        return `
          <div id="damageCentersSubtotal" style="margin-top: 15px;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
              
              <!-- Left Container: ×›×œ×œ×™ -->
              <div style="background: #f8f9fa; border: 2px solid #28a745; border-radius: 6px; padding: 12px;">
                <h4 style="margin: 0 0 10px 0; color: #28a745; text-align: center; font-size: 14px; font-weight: bold;">×›×œ×œ×™</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 6px; margin-bottom: 6px;">
                  <div style="background: #17a2b8; color: white; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalWorksOriginal">â‚ª0</div>
                    <div style="font-size: 9px; opacity: 0.9;">×¢×‘×•×“×•×ª</div>
                  </div>
                  <div style="background: #28a745; color: white; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalPartsOriginal">â‚ª0</div>
                    <div style="font-size: 9px; opacity: 0.9;">×—×œ×§×™×</div>
                  </div>
                  <div style="background: #ffc107; color: #212529; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalRepairsOriginal">â‚ª0</div>
                    <div style="font-size: 9px; opacity: 0.9;">×ª×™×§×•× ×™×</div>
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                  <div style="background: #6c757d; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold;" id="totalWithoutVatOriginal">â‚ª0</div>
                    <div style="font-size: 10px; opacity: 0.9;">×œ×œ× ××¢"×</div>
                  </div>
                  <div style="background: #dc3545; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold;" id="totalWithVatOriginal">â‚ª0</div>
                    <div style="font-size: 10px; opacity: 0.9;">×›×•×œ×œ ××¢"×</div>
                  </div>
                </div>
              </div>
              
              <!-- Right Container: ××—×¨×™ ×”×¤×¨×©×™× -->
              <div style="background: #f8f9fa; border: 2px solid #dc3545; border-radius: 6px; padding: 12px;">
                <h4 style="margin: 0 0 10px 0; color: #dc3545; text-align: center; font-size: 14px; font-weight: bold;">××—×¨×™ ×”×¤×¨×©×™×</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 6px; margin-bottom: 6px;">
                  <div style="background: #17a2b8; color: white; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalWorksSubtotal">â‚ª0</div>
                    <div style="font-size: 9px; opacity: 0.9;">×¢×‘×•×“×•×ª</div>
                  </div>
                  <div style="background: #28a745; color: white; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalPartsSubtotal">â‚ª0</div>
                    <div style="font-size: 9px; opacity: 0.9;">×—×œ×§×™×</div>
                  </div>
                  <div style="background: #ffc107; color: #212529; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalRepairsSubtotal">â‚ª0</div>
                    <div style="font-size: 9px; opacity: 0.9;">×ª×™×§×•× ×™×</div>
                  </div>
                  <!-- SESSION 48: Add differentials total field after repairs -->
                  <div style="background: #fd7e14; color: white; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalDifferentialsDisplay">â‚ª0</div>
                    <div style="font-size: 9px; opacity: 0.9;">×”×¤×¨×©×™×</div>
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                  <div style="background: #6c757d; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold;" id="totalWithoutVatSubtotal">â‚ª0</div>
                    <div style="font-size: 10px; opacity: 0.9;">×œ×œ× ××¢"×</div>
                  </div>
                  <div style="background: #dc3545; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold;" id="totalWithVatSubtotal">â‚ª0</div>
                    <div style="font-size: 10px; opacity: 0.9;">×›×•×œ×œ ××¢"×</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;
      }
    }
    
    // HANDLE NATURE DROPDOWN CHANGES - SHOW/HIDE OTHER TEXT FIELD
    function toggleNatureOtherField(dropdown) {
      const row = dropdown.closest('.differential-row');
      const otherField = row.querySelector('.diff-nature-other');
      const hiddenField = row.querySelector('.diff-nature');
      
      if (dropdown.value === 'other') {
        otherField.style.display = 'block';
        otherField.focus();
        hiddenField.value = otherField.value;
      } else {
        otherField.style.display = 'none';
        hiddenField.value = dropdown.value;
      }
      
      console.log('ğŸ”„ Nature changed to:', dropdown.value);
      setTimeout(saveDifferentialsToHelper, 100);
    }
    
    // REFRESH DAMAGE CENTERS CONTAINER LAYOUT WHEN DIFFERENTIALS TOGGLE
    function refreshDamageCentersContainerLayout() {
      console.log('ğŸ”„ Refreshing damage centers container layout...');
      
      // Check current differential state
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      // SESSION 48: Check using new grand_total structure
      const hasDifferentials = helper.final_report?.differential?.has_differentials && 
                              helper.final_report?.differential?.grand_total &&
                              (helper.final_report.differential.grand_total.without_vat > 0 || 
                               helper.final_report.differential.grand_total.with_vat > 0);
      
      // Find existing subtotal container and replace it
      const existingSubtotal = document.getElementById('damageCentersSubtotal');
      if (existingSubtotal) {
        const newSubtotalHTML = createDamageCentersSubtotal(hasDifferentials);
        existingSubtotal.outerHTML = newSubtotalHTML;
        
        // Update calculations with new layout
        setTimeout(() => {
          updateDamageCentersSubtotal();
        }, 100);
        
        console.log('âœ… Container layout refreshed - hasDifferentials:', hasDifferentials);
      }
    }
    
    // REPOSITION DAMAGE CENTERS SAVE BUTTON TO APPEAR BEFORE ×”× ×—×•×ª ×•×”×¤×¨×©×™×
    function repositionDamageCentersSaveButton() {
      try {
        console.log('ğŸ” SESSION 93: Searching for damage centers save button...');
        
        // Look in both locations - damageCentersSummary (old) and damageCentersContent (new)
        let saveButton = null;
        let differentialsSection = null;
        
        // Try damageCentersSummary first (now the correct location after fix)
        const damageCentersSection = document.getElementById('damageCentersSummary');
        console.log('ğŸ” damageCentersSummary exists:', !!damageCentersSection);
        if (damageCentersSection) {
          saveButton = damageCentersSection.querySelector('.section-save-button');
          console.log('ğŸ” Save button in damageCentersSummary:', !!saveButton);
        }
        
        // Try damageCentersContent if not found (fallback)
        if (!saveButton) {
          const damageCentersContent = document.getElementById('damageCentersContent');
          console.log('ğŸ” damageCentersContent exists:', !!damageCentersContent);
          if (damageCentersContent) {
            saveButton = damageCentersContent.querySelector('.section-save-button');
            console.log('ğŸ” Save button in damageCentersContent:', !!saveButton);
          }
        }
        
        // Look for ×”× ×—×•×ª ×•×”×¤×¨×©×™× section globally
        differentialsSection = document.getElementById('differentialsSection');
        console.log('ğŸ” ×”× ×—×•×ª ×•×”×¤×¨×©×™× section found:', !!differentialsSection);
        
        if (saveButton && differentialsSection) {
          const buttonContainer = saveButton.parentElement;
          // Move button container to before ×”× ×—×•×ª ×•×”×¤×¨×©×™× section
          differentialsSection.parentNode.insertBefore(buttonContainer, differentialsSection);
          console.log('âœ… SESSION 93: Repositioned damage centers save button before ×”× ×—×•×ª ×•×”×¤×¨×©×™×');
        } else {
          console.log('âŒ SESSION 93: Save button or ×”× ×—×•×ª ×•×”×¤×¨×©×™× section not found for repositioning');
          console.log('  - Save button found:', !!saveButton);
          console.log('  - ×”× ×—×•×ª ×•×”×¤×¨×©×™× section found:', !!differentialsSection);
          
          // Additional debug: list all buttons in both sections
          if (damageCentersSection) {
            const allButtons = damageCentersSection.querySelectorAll('button');
            console.log('ğŸ” All buttons in damageCentersSummary:', allButtons.length);
            allButtons.forEach((btn, i) => {
              console.log(`  Button ${i}: class="${btn.className}", text="${btn.textContent?.trim()?.substring(0, 20)}"`);
            });
          }
        }
      } catch (error) {
        console.error('âŒ Error repositioning damage centers save button:', error);
      }
    }
    
    // LOAD DAMAGE CENTERS FROM HELPER
    function loadDamageCentersFromHelper(damageBlocksOrHelper) {
      try {
        const damageCentersContent = document.getElementById('damageCentersContent');
        if (!damageCentersContent) return;
        
        // Handle two cases: called with damageBlocks array OR helper object (from refresh)
        let damageBlocks;
        if (Array.isArray(damageBlocksOrHelper)) {
          // Called with damage blocks directly
          damageBlocks = damageBlocksOrHelper;
        } else {
          // Called with helper object (from refresh system) - extract and normalize damage centers
          const helper = damageBlocksOrHelper || {};
          
          // SESSION 91 FIX: Priority order for loading damage centers
          const currentReportType = helper.final_report?.type || helper.final_report?.dropdown_type || 
                                  document.querySelector('input[name="final-report-type"]:checked')?.value;
          const hasArchive = helper.centers_archive && helper.centers_archive.length > 0;
          
          // DEBUG: Log report type detection
          console.log('ğŸ” loadDamageCentersFromHelper - Report type detection:');
          console.log('  - helper.final_report?.type:', helper.final_report?.type);
          console.log('  - helper.final_report?.dropdown_type:', helper.final_report?.dropdown_type);
          console.log('  - Checkbox value:', document.querySelector('input[name="final-report-type"]:checked')?.value);
          console.log('  - Final currentReportType:', currentReportType);
          console.log('  - hasArchive:', hasArchive);
          console.log('  - Should use archive:', hasArchive && currentReportType !== '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª');
          
          // For non-private reports: use archive if it exists (invoice was accepted before)
          // Archive persists even if invoice is deleted later
          if (hasArchive && currentReportType !== '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª') {
            console.log('ğŸ“¦ SESSION 91: Non-private report - Loading from centers_archive (wizard data preserved)');
            console.log('ğŸ“‹ Archive has', helper.centers_archive.length, 'centers');
            damageBlocks = helper.centers_archive.map((center, index) => adaptCenterToBlock(center, index));
          } else if (helper.centers && helper.centers.length > 0) {
            console.log('ğŸ“‹ Loading from centers - count:', helper.centers.length);
            damageBlocks = helper.centers.map((center, index) => adaptCenterToBlock(center, index));
          } else if (helper.expertise?.damage_blocks && helper.expertise.damage_blocks.length > 0) {
            console.log('ğŸ“‹ No centers found - falling back to expertise');
            damageBlocks = helper.expertise.damage_blocks.map((center, index) => adaptCenterToBlock(center, index));
          } else {
            console.log('âš ï¸ No damage centers data found');
            damageBlocks = [];
          }
        }
        
        console.log('ğŸ”„ loadDamageCentersFromHelper: Loading', damageBlocks.length, 'damage centers');
        
        // Clear existing content
        damageCentersContent.innerHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters"></div>';
        
        // Add each damage center from helper
        damageBlocks.forEach((block, index) => {
          const newCardHTML = createEditableDamageCenterCard(block, index);
          document.getElementById('editableDamageCenters').insertAdjacentHTML('beforeend', newCardHTML);
        });
        
        // Add ×”×¤×¨×©×™× section before subtotal
        const differentialsHTML = createDifferentialsSection();
        document.getElementById('editableDamageCenters').insertAdjacentHTML('afterend', differentialsHTML);
        
        // Check if differentials exist to determine layout
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        // SESSION 48: Check using new grand_total structure
        const hasDifferentials = helper.final_report?.differential?.has_differentials && 
                                helper.final_report?.differential?.grand_total &&
                                (helper.final_report.differential.grand_total.without_vat > 0 || 
                                 helper.final_report.differential.grand_total.with_vat > 0);
        
        // Add subtotal section after differentials
        const subtotalHTML = createDamageCentersSubtotal(hasDifferentials);
        document.getElementById('differentialsSection').insertAdjacentHTML('afterend', subtotalHTML);
        
        // SESSION 62: Add case reduction section before × ×ª×•× ×™ ×ª×‘×™×¢×”
        const caseReductionHTML = createCaseReductionSection();
        document.getElementById('caseReductionPlaceholder').insertAdjacentHTML('afterend', caseReductionHTML);
        
        // SESSION 93: Re-add save buttons after content is rebuilt, then reposition
        setTimeout(() => {
          if (typeof addSectionButtons === 'function') {
            addSectionButtons();
            console.log('âœ… SESSION 93: Re-added save buttons after loadDamageCentersFromHelper');
          }
          repositionDamageCentersSaveButton();
        }, 100);
        
        // Add event listeners
        setTimeout(() => {
          addDamageCenterEventListeners();
          updateAllCostDisplays();
          
          // DON'T auto-update depreciation - preserve manual entries
          // updateDepreciationFromDamageCenters([]);
          // Update damage assessment totals
          updateDamageAssessmentSummary(window.helper || {});
        }, 100);
        
        
      } catch (error) {
        console.error('Error loading damage centers from helper:', error);
      }
    }
    
    // ADD FIELD CHANGE LISTENERS - CRITICAL FOR HELPER UPDATES
    function addFieldChangeListeners() {
      try {
        console.log('ğŸ”— Adding field change listeners...');
        
        // Car details fields
        const carFields = [
          'carPlate', 'carManufacturer', 'carModel', 'carYear', 'carModelCode',
          'carBasePrice', 'carMarketValue', 'carReportDate', 'carMileage'
        ];
        
        carFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
              
              // Recalculate adjustment values when base price changes
              if (fieldId === 'carBasePrice') {
                console.log('ğŸ“Š Base price changed, recalculating all adjustment values');
                setTimeout(() => {
                  recalculateAllAdjustmentValues();
                }, 100);
              }
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Contact/communication fields
        const contactFields = [
          'ownerName', 'ownerPhone', 'ownerAddress', 'ownerEmail',
          'insuranceAgent', 'agentPhone', 'agentEmail',
          'insuranceCompany', 'insuranceEmail'
        ];
        
        contactFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Claims data fields
        const claimsFields = ['totalClaim'];
        
        claimsFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
              
              // Update gross percentage when total claim changes
              if (fieldId === 'totalClaim') {
                updateGrossPercentageFromGrossValue();
              }
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Basic price field with special handling for 3-bulk system
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField) {
          basicPriceField.addEventListener('change', function() {
            updateHelperFromField({ target: this });
            updateGrossMarketValueCalculation();
            recalculateAllAdjustmentValues();
          });
          basicPriceField.addEventListener('blur', function() {
            updateHelperFromField({ target: this });
            updateGrossMarketValueCalculation();
          });
        }
        
        // Full basic price field
        const fullBasicPriceField = document.getElementById('fullBasicPrice');
        if (fullBasicPriceField) {
          fullBasicPriceField.addEventListener('change', function() {
            updateHelperFromField({ target: this });
            // updateFullMarketValueCalculation() removed
          });
        }
        
        // Summary data fields
        const summaryFields = ['sumMarketValue', 'sumClaim', 'sumVAT', 'sumTotalClaim', 'depCompensation', 'salvageValue', 'garageDays'];
        
        summaryFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Legal text field
        const legalTextField = document.getElementById('legal-text-content');
        if (legalTextField) {
          legalTextField.addEventListener('change', function() {
            updateHelperFromField({ target: this });
          });
        }
        
        // Final report type change listener
        document.querySelectorAll('input[name="final-report-type"]').forEach(radio => {
          radio.addEventListener('change', function() {
            updateReportType();
            loadLegalText().catch(console.error);
            
            // Update toggle visibility based on report type
            if (typeof updateToggleUI === 'function') {
              updateToggleUI();
              
              // Load appropriate data based on report type (moved from updateToggleUI to prevent loops)
              const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
              const reportType = helper.final_report?.type || helper.final_report?.dropdown_type || 
                               document.querySelector('input[name="final-report-type"]:checked')?.value;
              const isPrivate = reportType === '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª';
              
              setTimeout(() => {
                if (isPrivate && typeof loadInvoiceData === 'function') {
                  loadInvoiceData();
                } else if (!isPrivate && typeof loadWizardData === 'function') {
                  loadWizardData();
                }
                
                // Ensure save button positioning is maintained after data loading
                setTimeout(() => {
                  if (typeof repositionDamageCentersSaveButton === 'function') {
                    repositionDamageCentersSaveButton();
                  }
                }, 200);
              }, 100); // Small delay to prevent conflicts
            }
          });
        });
        
        console.log('âœ… Field change listeners added successfully');
        
      } catch (error) {
        console.error('Error adding field change listeners:', error);
      }
    }
    
    // INITIALIZE 3-BULK SYSTEM ON PAGE LOAD
    document.addEventListener('DOMContentLoaded', function() {
      console.log('ğŸš€ Initializing 3-bulk system...');
      
      // Wait for all objects to be initialized before loading data
      setTimeout(() => {
        // Load saved helper data first
        loadHelperData();
        
        // Add field change listeners - CRITICAL FOR HELPER UPDATES
        addFieldChangeListeners();
      }, 200);
      
      // Initialize gross calculation data
      setTimeout(() => {
        // loadGrossCalculationData(); // DISABLED - causes duplicate Levi data
        console.log('âœ… Bulk 1 & 2 initialized');
        
        // REMOVED: Auto-call updateHelperFromAdjustments on page load to prevent duplication
        // updateHelperFromAdjustments should only be called when user makes actual changes
        // setTimeout(() => {
        //   updateHelperFromAdjustments();
        //   console.log('ğŸ”§ Initial helper update completed for Levi floating screen');
        // }, 500);
      }, 500);
      
      // Initialize full market value calculation
      setTimeout(() => {
        loadFullMarketValueData();
        console.log('âœ… Bulk 3 initialized');
        console.log('âœ… Complete 3-bulk system initialized');
        
        // Restore saved adjustment amounts after data is loaded
        setTimeout(() => {
          console.log('ğŸ¯ About to call restoreAdjustmentAmounts...');
          restoreAdjustmentAmounts();
          console.log('âœ… Adjustment amounts restored');
          
          // Load additional adjustments UI
          loadAdditionalAdjustments();
          console.log('âœ… Additional adjustments loaded');
          
          // Clear flag after restoration is complete
          setTimeout(() => {
            window.pageLoadInProgress = false;
            console.log('âœ… Page load complete, sync enabled');
            
            // Trigger final calculations to update cumulative values
            console.log('ğŸ”„ Running final calculations to update cumulative values...');
            updateGrossMarketValueCalculation();
            updateFullMarketValueCalculation();
            
            // Sync all adjustments to ensure cumulative values are saved
            setTimeout(() => {
              console.log('ğŸ”„ Syncing all adjustment data to helper...');
              
              // CRITICAL: Now safe to run updateFullMarketValueToFinalReportAndValuation after page load
              const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
              updateFullMarketValueToFinalReportAndValuation(helper);
              console.log('ğŸ’¾ Safe to update final_report after page load complete');
              const categories = ['features', 'registration', 'mileage', 'ownership_type', 'ownership_history', 'additional'];
              categories.forEach(category => {
                const containers = {
                  'features': ['featuresAdjustmentsList', 'fullFeaturesAdjustmentsList'],
                  'registration': ['registrationAdjustmentsList', 'fullRegistrationAdjustmentsList'],
                  'mileage': ['mileageAdjustmentsList'],
                  'ownership_type': ['ownershipAdjustmentsList'],
                  'ownership_history': ['ownersAdjustmentsList'],
                  'additional': ['allAdjustmentsList']
                };
                
                const categoryContainers = containers[category] || [];
                categoryContainers.forEach(containerId => {
                  const container = document.getElementById(containerId);
                  if (container) {
                    const firstInput = container.querySelector('input');
                    if (firstInput) {
                      syncAdjustmentToHelper(firstInput, category);
                    }
                  }
                });
              });
              console.log('âœ… All adjustments synced with cumulative values');
            }, 100);
          }, 500);
        }, 200);
      }, 700);
      
      // Add event listeners for damage center changes
      const damageCentersContent = document.getElementById('damageCentersContent');
      if (damageCentersContent) {
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'childList' || mutation.type === 'subtree') {
              // When damage centers change, update second bulk
              setTimeout(() => {
                refreshSecondBulkFields();
              }, 100);
            }
          });
        });
        
        observer.observe(damageCentersContent, {
          childList: true,
          subtree: true
        });
      }
    });
    
    // ENHANCED SAVE DAMAGE CENTER CHANGES TO TRIGGER BULK UPDATES
    const originalSaveDamageCenterChanges = saveDamageCenterChanges;
    saveDamageCenterChanges = function() {
      originalSaveDamageCenterChanges.call(this);
      
      // After saving damage centers, update second bulk
      setTimeout(() => {
        refreshSecondBulkFields();
      }, 100);
    };
    
    // ENHANCED UPDATE ALL COST DISPLAYS TO TRIGGER BULK UPDATES
    const originalUpdateAllCostDisplays = updateAllCostDisplays;
    updateAllCostDisplays = function() {
      originalUpdateAllCostDisplays.call(this);
      
      // After updating costs, update second bulk
      setTimeout(() => {
        refreshSecondBulkFields();
      }, 100);
    };
    
    // ENHANCED CALCULATE SUMMARY TOTALS TO TRIGGER BULK UPDATES
    const originalCalculateSummaryTotals = calculateSummaryTotals;
    calculateSummaryTotals = function() {
      originalCalculateSummaryTotals.call(this);
      
      // After calculating summary totals, update second bulk
      setTimeout(() => {
        refreshSecondBulkFields();
      }, 100);
    };
    
    // GLOBAL FUNCTIONS FOR EXTERNAL ACCESS
    window.calculateGrossMarketValue = calculateGrossMarketValue;
    window.calculateGrossPercentage = calculateGrossPercentage;
    window.calculateFullMarketValue = calculateFullMarketValue;
    window.refreshSecondBulkFields = refreshSecondBulkFields;
    window.updateGrossMarketValueCalculation = updateGrossMarketValueCalculation;
    window.updateGrossPercentageFromGrossValue = updateGrossPercentageFromGrossValue;
    window.updateFullMarketValueCalculation = updateFullMarketValueCalculation;
    window.testFullCalculation = updateFullMarketValueCalculation; // Easy test function
    
    // Test function to verify dropdown functionality
    window.testDropdowns = function() {
      console.log('ğŸ”§ Testing all dropdowns in FULL section...');
      const containers = ['mileageAdjustmentsList', 'ownershipAdjustmentsList', 'ownersAdjustmentsList'];
      
      containers.forEach(containerId => {
        const container = document.getElementById(containerId);
        if (container) {
          const dropdowns = container.querySelectorAll('select');
          dropdowns.forEach((dropdown, index) => {
            console.log(`ğŸ”§ ${containerId} dropdown[${index}]:`, dropdown.value, 'onchange:', dropdown.onchange ? 'EXISTS' : 'MISSING');
            
            // Test changing the dropdown
            const originalValue = dropdown.value;
            const newValue = originalValue === 'plus' ? 'minus' : 'plus';
            console.log(`ğŸ”§ Changing ${containerId} dropdown[${index}] from ${originalValue} to ${newValue}`);
            dropdown.value = newValue;
            dropdown.dispatchEvent(new Event('change', { bubbles: true }));
            
            // Change it back
            setTimeout(() => {
              dropdown.value = originalValue;
              dropdown.dispatchEvent(new Event('change', { bubbles: true }));
            }, 100);
          });
        }
      });
    };
    window.loadFullMarketValueData = loadFullMarketValueData;
    window.addFullMarketAdjustment = addFullMarketAdjustment;
    window.debugCalculations = debugCalculations;
    
    // Global debug function for helper data structure investigation
    window.debugHelperDataStructure = function() {
      console.group('ğŸ” HELPER DATA STRUCTURE INVESTIGATION');
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      console.log('=== HELPER OVERVIEW ===');
      console.log('Helper keys:', Object.keys(helper));
      console.log('Helper size:', JSON.stringify(helper).length, 'characters');
      
      console.log('\n=== BASE PRICE INVESTIGATION ===');
      const basePriceLocations = {
        'helper.levi_report?.base_price': helper.levi_report?.base_price,
        'helper.expertise?.levi_report?.base_price': helper.expertise?.levi_report?.base_price,
        'helper.levisummary?.base_price': helper.levisummary?.base_price,
        'helper.car_details?.base_price': helper.car_details?.base_price,
        'helper.vehicle?.base_price': helper.vehicle?.base_price,
        'helper.calculations?.base_price': helper.calculations?.base_price,
        'helper.expertise?.calculations?.base_price': helper.expertise?.calculations?.base_price
      };
      
      Object.entries(basePriceLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`âœ… FOUND: ${path} = ${value}`);
        } else {
          console.log(`âŒ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== VEHICLE VALUE GROSS INVESTIGATION ===');
      const vehicleValueLocations = {
        'helper.calculations?.vehicle_value_gross': helper.calculations?.vehicle_value_gross,
        'helper.expertise?.calculations?.vehicle_value_gross': helper.expertise?.calculations?.vehicle_value_gross,
        'helper.levi_report?.final_price': helper.levi_report?.final_price,
        'helper.expertise?.levi_report?.final_price': helper.expertise?.levi_report?.final_price,
        'helper.levisummary?.final_price': helper.levisummary?.final_price
      };
      
      Object.entries(vehicleValueLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`âœ… FOUND: ${path} = ${value}`);
        } else {
          console.log(`âŒ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== DAMAGE DATA INVESTIGATION ===');
      const damageLocations = {
        'helper.expertise?.damage_blocks': helper.expertise?.damage_blocks,
        'helper.damage_centers': helper.damage_centers,
        'helper.damage_sections': helper.damage_sections,
        'helper.expertise?.damage_sections': helper.expertise?.damage_sections
      };
      
      Object.entries(damageLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`âœ… FOUND: ${path} = ${Array.isArray(value) ? value.length + ' items' : typeof value}`);
          if (Array.isArray(value) && value.length > 0) {
            console.log(`  First item keys:`, Object.keys(value[0]));
          }
        } else {
          console.log(`âŒ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== CALCULATION INVESTIGATION ===');
      const calculationLocations = {
        'helper.calculations': helper.calculations,
        'helper.expertise?.calculations': helper.expertise?.calculations
      };
      
      Object.entries(calculationLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`âœ… FOUND: ${path} =`, value);
        } else {
          console.log(`âŒ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== LEVI DATA INVESTIGATION ===');
      const leviLocations = {
        'helper.levi_report': helper.levi_report,
        'helper.expertise?.levi_report': helper.expertise?.levi_report,
        'helper.levisummary': helper.levisummary
      };
      
      Object.entries(leviLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`âœ… FOUND: ${path} =`, value);
        } else {
          console.log(`âŒ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== RAW SESSION STORAGE ===');
      console.log('sessionStorage.getItem("helper"):', sessionStorage.getItem('helper'));
      
      console.groupEnd();
      
      return helper;
    };
    
    // Manual trigger for all calculations
    window.forceCalculateAllAdjustments = function() {
      console.log('ğŸ”„ Forcing calculation of all adjustments...');
      
      // First ensure basic price is loaded
      loadHelperData();
      
      setTimeout(() => {
        // Calculate all adjustment values
        const allPercentInputs = document.querySelectorAll('#featuresAdjustmentsList input[placeholder="××—×•×–"], #registrationAdjustmentsList input[placeholder="××—×•×–"]');
        console.log(`Found ${allPercentInputs.length} percentage inputs`);
        
        allPercentInputs.forEach((input, index) => {
          if (input.value) {
            console.log(`Calculating adjustment ${index + 1}: ${input.value}`);
            calculateAdjustmentValue(input);
          }
        });
        
        // Update gross market value calculation
        updateGrossMarketValueCalculation();
        
        console.log('âœ… All adjustment calculations completed');
      }, 200);
    };
    
    console.log('ğŸ¯ 3-bulk system functions loaded and ready');
    
    // SECTION-SPECIFIC SAVE AND REFRESH FUNCTIONALITY
    
    // Section configuration mapping - Updated to include ALL sections with editable fields
    const sectionConfig = {
      'final-report-type': {
        helperKey: 'manual_final_report_type',
        fields: ['final-report-type'],
        loadFunction: null,
        name: '×¡×•×’ ××•××“×Ÿ'
      },
      'vehicle-data': {
        helperKey: 'manual_vehicle_data',
        fields: ['carPlate', 'carManufacturer', 'carModel', 'carYear', 'carModelCode', 'carBasePrice', 'carMarketValue', 'carReportDate'],
        loadFunction: 'loadVehicleData',
        name: '× ×ª×•× ×™ ×”×¨×›×‘'
      },
      'contact-data': {
        helperKey: 'manual_contact_data',
        fields: ['ownerName', 'ownerAddress', 'ownerPhone', 'insuranceCompany', 'insuranceEmail', 'insuranceAgent', 'insuranceAgentPhone', 'insuranceAgentEmail'],
        loadFunction: 'loadContactData',
        name: '×¤×¨×˜×™ ×§×©×¨'
      },
      'damage-centers': {
        helperKey: 'manual_damage_centers',
        fields: [],
        loadFunction: 'loadDamageCentersFromHelper',
        name: '××¨×›×–×™ × ×–×§',
        dynamicContent: true
      },
      'gross-calculation': {
        helperKey: 'manual_gross_calculation',
        fields: ['basicPrice'],
        loadFunction: 'loadGrossCalculationData',
        name: '×—×™×©×•×‘ ××—×•×– × ×–×§ ×‘×¨×•×˜×•',
        dynamicContent: true
      },
      'gross-result': {
        helperKey: 'manual_gross_result',
        fields: ['grossMarketValueResult', 'totalClaim', 'grossPercent'],
        loadFunction: null,
        name: '×ª×•×¦××ª ×—×™×©×•×‘ ×‘×¨×•×˜×•'
      },
      'full-market-value': {
        helperKey: 'manual_full_market_value',
        fields: ['fullBasicPrice', 'fullMarketValueResult'],
        loadFunction: 'loadFullMarketValueData',
        name: '×—×™×©×•×‘ ×¢×¨×š ×”×©×•×§ ×”××œ×',
        dynamicContent: true
      },
      'depreciation': {
        helperKey: 'depreciation',
        fields: ['globalDep1', 'globalDepValue', 'garageDays'],
        loadFunction: 'loadDepreciationData',
        name: '×—×™×©×•×‘ ×™×¨×™×“×ª ×¢×¨×š',
        dynamicContent: true
      },
      'summary': {
        helperKey: 'manual_summary',
        fields: ['sumMarketValue', 'sumClaim', 'sumGrossPercent', 'sumAuthorizedClaim', 'sumTotalVat', 'sumSalvageValue', 'sumNetClaim'],
        loadFunction: 'loadSummaryData',
        name: '×¡×™×›×•× ×—×•×•×ª ×”×“×¢×ª'
      },
      'notes': {
        helperKey: 'manual_notes',
        fields: ['additional-notes'],
        loadFunction: null,
        name: '×”×¢×¨×•×ª × ×•×¡×¤×•×ª'
      },
      'legal-text': {
        helperKey: 'manual_legal_text',
        fields: ['legal-text'],
        loadFunction: 'loadLegalText',
        name: '×˜×§×¡×˜ ××©×¤×˜×™'
      }
    };
    
    // Generic save function for any section
    function saveSectionData(sectionId) {
      try {
        const config = sectionConfig[sectionId];
        if (!config) {
          console.error(`Unknown section: ${sectionId}`);
          return;
        }
        
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        const sectionData = {};
        
        // Collect data from all fields in the section
        config.fields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            if (field.type === 'radio') {
              const checked = document.querySelector(`input[name="${field.name}"]:checked`);
              sectionData[fieldId] = checked ? checked.value : '';
            } else {
              sectionData[fieldId] = field.value;
            }
          }
        });
        
        // Handle special cases for dynamic content
        if (sectionId === 'final-report-type') {
          const checkedRadio = document.querySelector('input[name="final-report-type"]:checked');
          sectionData.finalReportType = checkedRadio ? checkedRadio.value : '';
        } else if (sectionId === 'damage-centers') {
          sectionData.damageCenters = collectDamageCentersData();
        } else if (sectionId === 'gross-calculation') {
          sectionData.featuresAdjustments = collectAdjustmentData('#featuresAdjustmentsList');
          sectionData.registrationAdjustments = collectAdjustmentData('#registrationAdjustmentsList');
        } else if (sectionId === 'full-market-value') {
          // CRITICAL FIX: Save ALL adjustment categories, not just additional
          // Use the proven syncAdjustmentToHelper pattern to preserve user edits
          console.log('ğŸ’¾ FULL-MARKET-VALUE SAVE: Using syncAdjustmentToHelper to preserve all user edits');
          
          const categories = [
            { category: 'features', containerId: 'fullFeaturesAdjustmentsList' },
            { category: 'registration', containerId: 'fullRegistrationAdjustmentsList' },
            { category: 'mileage', containerId: 'mileageAdjustmentsList' },
            { category: 'ownership_type', containerId: 'ownershipAdjustmentsList' },
            { category: 'ownership_history', containerId: 'ownersAdjustmentsList' },
            { category: 'additional', containerId: 'allAdjustmentsList' }
          ];
          
          categories.forEach(({ category, containerId }) => {
            const container = document.getElementById(containerId);
            if (container && container.children.length > 0) {
              // Trigger syncAdjustmentToHelper for each category to preserve user edits
              const firstInput = container.children[0].querySelector('input');
              if (firstInput) {
                console.log(`ğŸ’¾ Saving ${category} from ${containerId} using syncAdjustmentToHelper`);
                syncAdjustmentToHelper(firstInput, category);
              }
            }
          });
          
          // Also collect for backward compatibility
          sectionData.allAdjustments = collectAdjustmentData('#allAdjustmentsList');
        } else if (sectionId === 'depreciation') {
          // âœ… FIX: Use saveDepreciationData() instead of collectDepreciationData() to avoid conflicts
          saveDepreciationData();
          return; // Exit early, saveDepreciationData handles everything
        }
        
        // Save to helper with timestamp
        helper[config.helperKey] = {
          ...sectionData,
          lastSaved: new Date().toISOString(),
          isManualSave: true
        };
        
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        
        // Show success message
        showSectionMessage(sectionId, `âœ… ${config.name} × ×©××¨ ×‘×”×¦×œ×—×”`, 'success');
        
        // Trigger refresh for related screens
        triggerFloatingScreenRefresh();
        
        console.log(`âœ… Section ${sectionId} saved successfully`);
        
      } catch (error) {
        console.error(`Error saving section ${sectionId}:`, error);
        showSectionMessage(sectionId, `âŒ ×©×’×™××” ×‘×©××™×¨×ª ${config.name}`, 'error');
      }
    }
    
    // Update depreciation calculations for all fields
    function updateDepreciationCalculation() {
      try {
        // Trigger calculation for global depreciation
        const globalDepInput = document.getElementById('globalDep1');
        if (globalDepInput && globalDepInput.value) {
          const event = new Event('input', { bubbles: true });
          globalDepInput.dispatchEvent(event);
        }
        
        // Trigger calculation for all bulk depreciation rows
        const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
        depRows.forEach(row => {
          const percentInput = row.querySelector('input[placeholder="×™×¨×™×“×ª ×¢×¨×š (××¡×¤×¨)"]');
          if (percentInput && percentInput.value) {
            const event = new Event('input', { bubbles: true });
            percentInput.dispatchEvent(event);
          }
        });
        
        console.log('ğŸ“Š Depreciation calculations updated');
      } catch (error) {
        console.error('Error updating depreciation calculations:', error);
      }
    }
    
    // Refresh system - SIMPLE VERSION: Just reload page
    function refreshSectionData(sectionId) {
      console.log(`ğŸ”„ Refreshing section ${sectionId} by reloading page...`);
      window.location.reload();
    }
    
    // Helper function to collect adjustment data from dynamic tables
    function collectAdjustmentData(containerSelector) {
      const container = document.querySelector(containerSelector);
      if (!container) return [];
      
      const adjustments = [];
      container.querySelectorAll('div[class*="adjustment-row"], div[id*="Adj_"]').forEach(row => {
        const inputs = row.querySelectorAll('input');
        const select = row.querySelector('select');
        
        if (inputs.length >= 2) {
          adjustments.push({
            description: inputs[0].value,
            percentage: inputs[1].value,
            value: inputs[2] ? inputs[2].value : '',
            type: select ? select.value : 'plus'
          });
        }
      });
      
      return adjustments;
    }
    
    // Helper function to collect depreciation data
    function collectDepreciationData(containerSelector) {
      const container = document.querySelector(containerSelector);
      if (!container) return [];
      
      console.log('ğŸ”„ Collecting depreciation data from container:', containerSelector);
      const depreciations = [];
      container.querySelectorAll('div[class*="dep-row"], div[id*="depRow_"]').forEach(row => {
        const inputs = row.querySelectorAll('input');
        
        // Depreciation rows have 5 inputs: center_number, damaged_part, repair_type, percent, value
        if (inputs.length >= 5) {
          depreciations.push({
            center_number: inputs[0].value,
            damaged_part: inputs[1].value,
            repair_type: inputs[2].value,
            percent: inputs[3].value,
            value: inputs[4].value
          });
        } else if (inputs.length >= 4) {
          // Fallback for older format (missing center_number)
          depreciations.push({
            center_number: '',
            damaged_part: inputs[0].value,
            repair_type: inputs[1].value,
            percent: inputs[2].value,
            value: inputs[3].value
          });
        }
      });
      
      console.log('ğŸ”„ Collected depreciation data:', depreciations);
      return depreciations;
    }
    
    // Helper function to collect damage centers data
    function collectDamageCentersData() {
      const container = document.getElementById('damageCentersContent');
      if (!container) return [];
      
      const damageCenters = [];
      container.querySelectorAll('div[class*="damage-center-card"], div[id*="damage-center-"]').forEach(card => {
        const nameInput = card.querySelector('input[id*="damage-center-name"]');
        const center = {
          name: nameInput ? nameInput.value : '',
          parts: [],
          works: [],
          repairs: []
        };
        
        // Collect parts
        card.querySelectorAll('div[id*="parts-"] input').forEach((input, index) => {
          if (index % 2 === 0) { // Name inputs
            const priceInput = card.querySelector(`div[id*="parts-"] input:nth-child(${index + 2})`);
            center.parts.push({
              name: input.value,
              price: priceInput ? priceInput.value : ''
            });
          }
        });
        
        // Collect works
        card.querySelectorAll('div[id*="works-"] input').forEach((input, index) => {
          if (index % 2 === 0) { // Name inputs
            const priceInput = card.querySelector(`div[id*="works-"] input:nth-child(${index + 2})`);
            center.works.push({
              name: input.value,
              price: priceInput ? priceInput.value : ''
            });
          }
        });
        
        // Collect repairs
        card.querySelectorAll('div[id*="repairs-"] input').forEach((input, index) => {
          if (index % 2 === 0) { // Name inputs
            const priceInput = card.querySelector(`div[id*="repairs-"] input:nth-child(${index + 2})`);
            center.repairs.push({
              name: input.value,
              price: priceInput ? priceInput.value : ''
            });
          }
        });
        
        damageCenters.push(center);
      });
      
      return damageCenters;
    }
    
    // Helper function to restore damage centers data from manual save
    function restoreDamageCentersData(damageCenters) {
      try {
        console.log('ğŸ”„ Restoring damage centers data from manual save:', damageCenters);
        
        if (!damageCenters || !Array.isArray(damageCenters)) {
          console.log('âŒ No valid damage centers data to restore');
          return;
        }
        
        const container = document.getElementById('damageCentersContent');
        if (!container) {
          console.error('âŒ Damage centers container not found');
          return;
        }
        
        // Clear existing content
        container.innerHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters"></div>';
        const editableContainer = document.getElementById('editableDamageCenters');
        
        // Restore each damage center
        damageCenters.forEach((centerData, index) => {
          // Create simplified damage center structure for restoration
          const adaptedCenter = {
            damage_center_name: centerData.name || `××•×§×“ × ×–×§ ${index + 1}`,
            damage_center_number: index + 1,
            description: '',
            parts: centerData.parts || [],
            works: centerData.works || [],
            repairs: centerData.repairs || []
          };
          
          // Use existing function to create the card
          const newCardHTML = createEditableDamageCenterCard(adaptedCenter, index);
          editableContainer.insertAdjacentHTML('beforeend', newCardHTML);
        });
        
        // Add event listeners and update calculations
        setTimeout(() => {
          addDamageCenterEventListeners();
          updateAllCostDisplays();
          // DON'T auto-update depreciation - preserve manual entries
          // updateDepreciationFromDamageCenters([]);
          // Update damage assessment totals
          updateDamageAssessmentSummary(window.helper || {});
        }, 100);
        
        
      } catch (error) {
        console.error('âŒ Error restoring damage centers data:', error);
      }
    }
    
    // Helper function to restore adjustment data to dynamic tables
    function restoreAdjustmentData(containerSelector, adjustments) {
      const container = document.querySelector(containerSelector);
      if (!container) return;
      
      // Clear existing rows
      container.innerHTML = '';
      
      // Add each adjustment
      adjustments.forEach(adj => {
        // Use existing add functions
        if (containerSelector.includes('features')) {
          addFeatureAdjustment();
        } else if (containerSelector.includes('registration')) {
          addRegistrationAdjustment();
        } else if (containerSelector.includes('allAdjustments')) {
          addFullMarketAdjustment();
        }
        
        // Fill the last added row
        const lastRow = container.querySelector('div:last-child');
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input');
          const select = lastRow.querySelector('select');
          
          if (inputs[0]) inputs[0].value = adj.description;
          if (inputs[1]) inputs[1].value = adj.percentage;
          if (inputs[2]) inputs[2].value = adj.value;
          if (select) select.value = adj.type;
        }
      });
    }
    
    // Helper function to restore depreciation data
    function restoreDepreciationData(containerSelector, depreciations) {
      try {
        console.log('ğŸ”„ Restoring depreciation data:', depreciations);
        
        const container = document.querySelector(containerSelector);
        if (!container) {
          console.error('âŒ Depreciation container not found:', containerSelector);
          return;
        }
        
        // Clear existing rows
        container.innerHTML = '';
        
        // Add each depreciation
        if (Array.isArray(depreciations)) {
          depreciations.forEach(dep => {
            console.log('ğŸ”„ Restoring depreciation item:', dep);
            addDepField(dep);
          });
        }
        
        
      } catch (error) {
        console.error('âŒ Error restoring depreciation data:', error);
      }
    }
    
    
    // Helper function to show section messages
    function showSectionMessage(sectionId, message, type) {
      const messageId = `section-message-${sectionId}`;
      let messageDiv = document.getElementById(messageId);
      
      if (!messageDiv) {
        messageDiv = document.createElement('div');
        messageDiv.id = messageId;
        messageDiv.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 10px 15px;
          border-radius: 5px;
          font-size: 14px;
          font-weight: bold;
          z-index: 9999;
          box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          transition: all 0.3s ease;
        `;
        document.body.appendChild(messageDiv);
      }
      
      // Set message style based on type
      const colors = {
        success: { bg: '#d4edda', text: '#155724', border: '#c3e6cb' },
        error: { bg: '#f8d7da', text: '#721c24', border: '#f5c6cb' },
        info: { bg: '#d1ecf1', text: '#0c5460', border: '#bee5eb' }
      };
      
      const color = colors[type] || colors.info;
      messageDiv.style.backgroundColor = color.bg;
      messageDiv.style.color = color.text;
      messageDiv.style.border = `1px solid ${color.border}`;
      messageDiv.textContent = message;
      
      // Auto-hide after 3 seconds
      setTimeout(() => {
        if (messageDiv.parentNode) {
          messageDiv.parentNode.removeChild(messageDiv);
        }
      }, 3000);
    }
    
    // Function to add Save and Refresh buttons to sections with editable fields
    function addSectionButtons() {
      // Define sections that should have save buttons with auto-refresh
      const sections = [
        { id: 'vehicle-data', selector: '#vehicleData', name: '× ×ª×•× ×™ ×”×¨×›×‘', collapsible: true },
        { id: 'contact-data', selector: '#contactData', name: '×¤×¨×˜×™ ×§×©×¨', collapsible: true },
        { id: 'damage-centers', selector: '#damageCentersSummary', name: '××¨×›×–×™ × ×–×§', collapsible: true },
        { id: 'gross-calculation', selector: '#grossCalc', name: '×—×™×©×•×‘ ××—×•×– × ×–×§ ×‘×¨×•×˜×•', collapsible: true },
        { id: 'gross-result', selector: '#grossPercentageResult', name: '×ª×•×¦××ª ×—×™×©×•×‘ ×‘×¨×•×˜×•', collapsible: true },
        { id: 'full-market-value', selector: '#fullMarketValue', name: '×—×™×©×•×‘ ×¢×¨×š ×”×©×•×§ ×”××œ×', collapsible: true },
        { id: 'depreciation', selector: '#depreciationContent', name: '×—×™×©×•×‘ ×™×¨×™×“×ª ×¢×¨×š ×œ×¤×™ ××•×§×“×™ × ×–×§', collapsible: true },
        { id: 'summary', selector: '#sumMarketValue', name: '×¡×™×›×•× ×—×•×•×ª ×”×“×¢×ª', collapsible: false },
        { id: 'notes', selector: '#additional-notes', name: '×”×¢×¨×•×ª × ×•×¡×¤×•×ª', collapsible: false },
        { id: 'legal-text', selector: '#legal-text-content', name: '×˜×§×¡×˜ ××©×¤×˜×™', collapsible: false }
      ];
      
      sections.forEach(section => {
        let sectionElement = null;
        
        // For collapsible sections, find by ID
        if (section.collapsible) {
          sectionElement = document.getElementById(section.selector.replace('#', ''));
        } else {
          // For non-collapsible sections, find by selector and get parent form-section
          const keyElement = document.querySelector(section.selector);
          if (keyElement) {
            sectionElement = keyElement.closest('.form-section');
            if (!sectionElement) {
              sectionElement = keyElement.parentElement;
              while (sectionElement && !sectionElement.classList.contains('form-section')) {
                sectionElement = sectionElement.parentElement;
              }
            }
          }
        }
        
        if (sectionElement) {
          // Check if save button already exists
          if (sectionElement.querySelector('.section-save-button')) {
            return; // Skip if button already exists
          }
          
          // Create a container for both buttons
          const buttonContainer = document.createElement('div');
          buttonContainer.style.cssText = `
            display: flex;
            gap: 10px;
            margin-top: 12px;
            margin-bottom: 8px;
            justify-content: flex-start;
            margin-left: 15px;
          `;
          
          // Create save button with auto-refresh functionality
          const saveButton = document.createElement('button');
          saveButton.className = 'btn section-save-button';
          saveButton.textContent = '×©××•×¨';
          saveButton.style.cssText = `
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            display: inline-block;
            width: auto;
            transition: background-color 0.3s;
          `;
          saveButton.onmouseover = function() { this.style.background = '#218838'; };
          saveButton.onmouseout = function() { this.style.background = '#28a745'; };
          saveButton.onclick = function() { 
            console.log('ğŸ’¾ Saving section to helper:', section.id);
            saveSectionData(section.id);
            console.log('âœ… Section saved successfully - no page refresh');
          };
          
          // Create collapse button
          const collapseButton = document.createElement('button');
          collapseButton.className = 'btn section-collapse-button';
          collapseButton.textContent = '×›×•×•×¥';
          collapseButton.style.cssText = `
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            display: inline-block;
            width: auto;
            transition: background-color 0.3s;
          `;
          collapseButton.onmouseover = function() { this.style.background = '#5a6268'; };
          collapseButton.onmouseout = function() { this.style.background = '#6c757d'; };
          collapseButton.onclick = function() {
            // Get the section ID from the selector
            let sectionToToggle = '';
            if (section.id === 'vehicle-data') {
              sectionToToggle = 'vehicleData';
            } else if (section.id === 'contact-data') {
              sectionToToggle = 'contactData';
            } else if (section.id === 'damage-centers') {
              sectionToToggle = 'damageCentersSummary';
            } else if (section.id === 'gross-calculation') {
              sectionToToggle = 'grossCalc';
            } else if (section.id === 'gross-result') {
              sectionToToggle = 'grossPercentageResult';
            } else if (section.id === 'full-market-value') {
              sectionToToggle = 'fullMarketValue';
            } else if (section.id === 'depreciation') {
              sectionToToggle = 'depreciationContent';
            }
            
            if (sectionToToggle && window.toggleSection) {
              window.toggleSection(sectionToToggle);
            }
          };
          
          // Add buttons to container
          buttonContainer.appendChild(saveButton);
          
          // Only add collapse button if the section is collapsible
          if (section.collapsible) {
            buttonContainer.appendChild(collapseButton);
          }
          
          // Add button container to section
          if (section.collapsible) {
            // For collapsible sections, add the button to the collapsible content div
            const contentDiv = sectionElement.querySelector('#damageCentersSummary, #priceData, #contactData, #grossCalc, #grossPercentageResult, #fullMarketValue');
            if (contentDiv) {
              // Special handling for damage centers - insert before summary if it exists
              if (section.id === 'damage-centers') {
                const damageCentersSubtotal = contentDiv.querySelector('#damageCentersSubtotal');
                if (damageCentersSubtotal) {
                  // Insert button before the summary section
                  damageCentersSubtotal.parentNode.insertBefore(buttonContainer, damageCentersSubtotal);
                } else {
                  const damageCentersContent = contentDiv.querySelector('#damageCentersContent');
                  if (damageCentersContent) {
                    // Insert button right after damageCentersContent if no summary exists
                    damageCentersContent.parentNode.insertBefore(buttonContainer, damageCentersContent.nextSibling);
                  } else {
                    contentDiv.appendChild(buttonContainer);
                  }
                }
              } else {
                contentDiv.appendChild(buttonContainer);
              }
            } else {
              sectionElement.appendChild(buttonContainer);
            }
          } else {
            sectionElement.appendChild(buttonContainer);
          }
          
          console.log(`âœ… Added Save button with auto-refresh to section: ${section.name} (collapsible: ${section.collapsible})`);
        }
      });
    }
    
    // Initialize section buttons when page loads
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(() => {
        addSectionButtons();
        
        // Restore damage centers section state (default collapsed)
        const damageCentersState = sessionStorage.getItem('damageCentersSection') || 'collapsed';
        const damageCentersSection = document.getElementById('damageCentersSummary');
        const damageCentersToggleBtn = document.getElementById('damageCentersToggleBtn');
        if (damageCentersSection && damageCentersToggleBtn) {
          if (damageCentersState === 'collapsed') {
            damageCentersSection.style.display = 'none';
            damageCentersToggleBtn.innerHTML = 'ğŸ”¼ ×¤×ª×—';
            damageCentersToggleBtn.style.background = '#28a745';
          } else {
            damageCentersSection.style.display = 'block';
            damageCentersToggleBtn.innerHTML = 'ğŸ”½ ×¡×’×•×¨';
            damageCentersToggleBtn.style.background = '#6c757d';
          }
          console.log(`ğŸ”„ Restored damage centers section as ${damageCentersState}`);
        }
        
        // Initialize vehicle data and depreciation sections as collapsed (using standard toggleSection logic)
        const vehicleDataSection = document.getElementById('vehicleData');
        if (vehicleDataSection) {
          vehicleDataSection.style.display = 'none';
          console.log('ğŸ”„ Vehicle data section initialized as collapsed');
        }
        
        const depreciationContentSection = document.getElementById('depreciationContent');
        if (depreciationContentSection) {
          depreciationContentSection.style.display = 'none';
          console.log('ğŸ”„ Depreciation section initialized as collapsed');
        }
      }, 1000);
    });
    
    console.log('ğŸ“„ Section Save/Refresh functionality initialized');
    
    // =========================
    // PLATE INPUT AND DOCUMENT ACTIONS FUNCTIONALITY
    // =========================
    
    // Load existing case for builder
    window.loadExistingCaseForBuilder = async function() {
      const plateNumber = document.getElementById('builderPlateInput').value.trim();
      
      if (!plateNumber) {
        alert('×× × ×”×›× ×¡ ××¡×¤×¨ ×¨×›×‘');
        return;
      }
      
      // Validate Supabase authentication
      const authData = sessionStorage.getItem("auth");
      if (!authData) {
        alert('××™×Ÿ ××™××•×ª - ×× × ×”×ª×—×‘×¨ ××—×“×©');
        window.location.href = 'index.html';
        return;
      }
      
      try {
        const auth = JSON.parse(authData);
        if (!auth.user || !auth.session) {
          alert('××™××•×ª ×œ× ×ª×§×™×Ÿ - ×× × ×”×ª×—×‘×¨ ××—×“×©');
          window.location.href = 'index.html';
          return;
        }
        console.log('âœ… Supabase auth validated for report load');
      } catch (error) {
        console.error('Error validating auth:', error);
        alert('×©×’×™××” ×‘××™××•×ª - ×× × ×”×ª×—×‘×¨ ××—×“×©');
        window.location.href = 'index.html';
        return;
      }
      
      const loadBtn = document.getElementById('builderLoadCaseBtn');
      const originalText = loadBtn.textContent;
      
      try {
        loadBtn.disabled = true;
        loadBtn.textContent = '×˜×•×¢×Ÿ ×ª×™×§...';
        
        // Check if main selection page has loaded a case
        const existingHelper = sessionStorage.getItem('helper');
        const existingPlate = sessionStorage.getItem('plate');
        
        if (existingHelper && existingPlate === plateNumber) {
          // Use existing data
          const caseData = JSON.parse(existingHelper);
          
          document.getElementById('builderPlateStatus').style.display = 'block';
          document.getElementById('builderPlateStatus').textContent = 'âœ“ × ×ª×•× ×™ ×”×¨×›×‘ × ×˜×¢× ×• ×‘×”×¦×œ×—×”';
          document.getElementById('builderPlateStatus').style.color = '#059669';
          
          // Update car details from helper
          if (caseData.car_details) {
            document.getElementById('carPlate').value = caseData.car_details.plate || caseData.meta?.plate || '';
            document.getElementById('carManufacturer').value = caseData.car_details.manufacturer || '';
            document.getElementById('carModel').value = caseData.car_details.model || '';
            document.getElementById('carYear').value = caseData.car_details.year || '';
            document.getElementById('carModelCode').value = caseData.car_details.model_code || '';
            document.getElementById('carReportDate').value = convertToDateInputFormat(caseData.car_details.report_date || '');
          }
          
          // Update page title
          // Standardize plate format
          const standardizedPlateNumber = String(plateNumber).replace(/[-\s]/g, '');
          document.getElementById('pageTitle').textContent = `×¨×›×‘ ××¡. ${standardizedPlateNumber}`;
          
          return;
        }
        
        // Make webhook call to load case
        const payload = { plate: plateNumber };
        if (password) {
          payload.password = password;
        }
        
        // Import webhook function
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('ADMIN_FETCH_CASE', payload);
        
        if (response?.success && response?.data) {
          const caseData = response.data;
          
          // Store the data
          sessionStorage.setItem('helper', JSON.stringify(caseData));
          sessionStorage.setItem('plate', plateNumber);
          sessionStorage.setItem('caseLoaded', 'true');
          
          document.getElementById('builderPlateStatus').style.display = 'block';
          document.getElementById('builderPlateStatus').textContent = 'âœ“ × ×ª×•× ×™ ×”×¨×›×‘ × ×˜×¢× ×• ×‘×”×¦×œ×—×”';
          document.getElementById('builderPlateStatus').style.color = '#059669';
          
          // Update car details from helper
          if (caseData.car_details) {
            document.getElementById('carPlate').value = caseData.car_details.plate || caseData.meta?.plate || '';
            document.getElementById('carManufacturer').value = caseData.car_details.manufacturer || '';
            document.getElementById('carModel').value = caseData.car_details.model || '';
            document.getElementById('carYear').value = caseData.car_details.year || '';
            document.getElementById('carModelCode').value = caseData.car_details.model_code || '';
            document.getElementById('carReportDate').value = convertToDateInputFormat(caseData.car_details.report_date || '');
          }
          
          // Update page title
          // Standardize plate format
          const standardizedPlateNumber = String(plateNumber).replace(/[-\s]/g, '');
          document.getElementById('pageTitle').textContent = `×¨×›×‘ ××¡. ${standardizedPlateNumber}`;
          
          // Reload data from helper
          loadDataFromHelper();
          
        } else {
          document.getElementById('builderPlateStatus').style.display = 'block';
          document.getElementById('builderPlateStatus').textContent = 'âŒ ×ª×™×§ ×œ× × ××¦× ×‘××¢×¨×›×ª';
          document.getElementById('builderPlateStatus').style.color = '#dc2626';
        }
        
      } catch (error) {
        console.error('Error loading case:', error);
        document.getElementById('builderPlateStatus').style.display = 'block';
        document.getElementById('builderPlateStatus').textContent = 'âŒ ×©×’×™××” ×‘×˜×¢×™× ×ª ×”×ª×™×§';
        document.getElementById('builderPlateStatus').style.color = '#dc2626';
      } finally {
        loadBtn.disabled = false;
        loadBtn.textContent = originalText;
      }
    };
    
    // Request expertise for builder
    window.requestExpertiseForBuilder = async function() {
      const plateNumber = document.getElementById('builderPlateInput').value.trim();
      const helper = sessionStorage.getItem('helper');
      
      if (!plateNumber) {
        alert('×× × ×”×›× ×¡ ××¡×¤×¨ ×¨×›×‘');
        return;
      }
      
      if (!helper) {
        alert('× ×ª×•× ×™ ×”×ª×™×§ ×œ× × ××¦××• ×‘××¢×¨×›×ª');
        return;
      }
      
      const requestBtn = document.getElementById('builderRequestExpertiseBtn');
      const originalText = requestBtn.textContent;
      
      try {
        requestBtn.disabled = true;
        requestBtn.textContent = '××‘×§×© ××§×¡×¤×™×¨×˜×™×–×”...';
        
        const caseData = JSON.parse(helper);
        const payload = {
          plate: plateNumber,
          case_id: caseData.meta?.case_id,
          helper: caseData
        };
        
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('CALL_EXPERTISE', payload);
        
        if (response?.success) {
          const successMessage = response.message || '×”××§×¡×¤×™×¨×˜×™×–×” × ×©×œ×—×” ×‘×”×¦×œ×—×”! ×‘×“×•×§ ××ª ×”××™××™×™×œ ×©×œ×š ×œ×§×‘×œ×ª ×”×§×•×‘×¥.';
          alert(successMessage);
          
          if (response.pdf_url) {
            showFloatingPDF(response.pdf_url, '××§×¡×¤×™×¨×˜×™×–×” PDF');
            
            // Update helper with expertise data
            // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
            if (!helper.expertise) helper.expertise = {};
            helper.expertise.document_url = response.pdf_url;
            helper.expertise.requested_at = new Date().toISOString();
            sessionStorage.setItem('helper', JSON.stringify(helper));
            
            // Update button states
            initializeExpertiseButtonState();
          }
        } else {
          alert('×©×’×™××” ×‘×©×œ×™×—×ª ×‘×§×©×” ×œ××§×¡×¤×™×¨×˜×™×–×”. ×× × × ×¡×” ×©×•×‘.');
        }
        
      } catch (error) {
        console.error('Error requesting expertise:', error);
        alert('×©×’×™××” ×‘×©×œ×™×—×ª ×‘×§×©×” ×œ××§×¡×¤×™×¨×˜×™×–×”. ×× × × ×¡×” ×©×•×‘.');
      } finally {
        requestBtn.disabled = false;
        requestBtn.textContent = originalText;
      }
    };
    
    // Fetch expertise PDF for builder
    window.fetchExpertisePDFForBuilder = async function() {
      const plateNumber = document.getElementById('builderPlateInput').value.trim();
      const helper = sessionStorage.getItem('helper');
      
      if (!plateNumber) {
        alert('×× × ×”×›× ×¡ ××¡×¤×¨ ×¨×›×‘');
        return;
      }
      
      const fetchBtn = document.getElementById('builderFetchExpertiseBtn');
      const originalText = fetchBtn.textContent;
      
      try {
        fetchBtn.disabled = true;
        fetchBtn.textContent = '×˜×•×¢×Ÿ PDF...';
        
        const caseData = helper ? JSON.parse(helper) : null;
        const payload = {
          plate: plateNumber,
          case_id: caseData?.meta?.case_id,
          document_type: 'expertise'
        };
        
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('FETCH_EXPERTISE_PDF', payload);
        
        if (response?.success && response?.pdf_url) {
          showFloatingPDF(response.pdf_url, '××§×¡×¤×™×¨×˜×™×–×” PDF');
        } else {
          alert('××§×¡×¤×™×¨×˜×™×–×” ×œ× × ××¦××” ×‘××¢×¨×›×ª ××• ×œ× ×”×•×¤×§×” ×¢×“×™×™×Ÿ');
        }
        
      } catch (error) {
        console.error('Error fetching expertise PDF:', error);
        alert('×©×’×™××” ×‘×˜×¢×™× ×ª ××§×¡×¤×™×¨×˜×™×–×” PDF');
      } finally {
        fetchBtn.disabled = false;
        fetchBtn.textContent = originalText;
      }
    };
    
    // Show floating PDF display
    function showFloatingPDF(pdfUrl, title) {
      const overlay = document.getElementById('floatingPdfOverlay');
      const titleElement = document.getElementById('floatingPdfTitle');
      const iframe = document.getElementById('pdfViewer');
      
      titleElement.textContent = title;
      
      console.log(`ğŸ” Attempting to display PDF: ${pdfUrl}`);
      
      // Try to load PDF in iframe
      iframe.src = pdfUrl;
      
      // Add error handling for iframe loading
      iframe.onload = function() {
        console.log('âœ… PDF loaded successfully in iframe');
      };
      
      iframe.onerror = function() {
        console.error('âŒ Failed to load PDF in iframe');
        // Fallback: show link to open in new tab
        iframe.style.display = 'none';
        const fallbackDiv = document.createElement('div');
        fallbackDiv.style.cssText = 'padding: 20px; text-align: center; direction: rtl;';
        fallbackDiv.innerHTML = `
          <h3 style="color: #1e3a8a; margin-bottom: 15px;">×œ× × ×™×ª×Ÿ ×œ×”×¦×™×’ ××ª ×”PDF ×‘×—×œ×•×Ÿ ×–×”</h3>
          <p style="margin-bottom: 15px;">×× × ×œ×—×¥ ×¢×œ ×”×§×™×©×•×¨ ×œ×”×¦×’×ª ×”×§×•×‘×¥:</p>
          <a href="${pdfUrl}" target="_blank" style="display: inline-block; padding: 10px 20px; background: #1e3a8a; color: white; text-decoration: none; border-radius: 6px;">
            ×¤×ª×— PDF ×‘×—×œ×•×Ÿ ×—×“×©
          </a>
        `;
        iframe.parentNode.appendChild(fallbackDiv);
      };
      
      overlay.style.display = 'flex';
      
      // Setup event listeners for controls
      setupFloatingPDFControls();
    }
    
    
    // Setup floating PDF controls with mobile optimization
    function setupFloatingPDFControls() {
      const toggleBtn = document.getElementById('togglePdfBtn');
      const closeBtn = document.getElementById('closePdfBtn');
      const content = document.getElementById('floatingPdfContent');
      const container = document.querySelector('.floating-pdf-container');
      
      // Add touch-friendly event handlers
      function addTouchFriendlyHandler(button, callback) {
        // Handle both click and touch events
        button.addEventListener('click', callback);
        button.addEventListener('touchend', function(e) {
          e.preventDefault();
          callback();
        });
        
        // Add touch visual feedback
        button.addEventListener('touchstart', function() {
          this.style.backgroundColor = 'rgba(255, 255, 255, 0.4)';
        });
        
        button.addEventListener('touchend', function() {
          this.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
        });
      }
      
      // Toggle minimize/maximize with touch support
      addTouchFriendlyHandler(toggleBtn, function() {
        content.classList.toggle('minimized');
        container.classList.toggle('minimized');
        toggleBtn.textContent = content.classList.contains('minimized') ? 'â–¡' : '_';
      });
      
      // Close PDF display with touch support
      addTouchFriendlyHandler(closeBtn, function() {
        const overlay = document.getElementById('floatingPdfOverlay');
        const iframe = document.getElementById('pdfViewer');
        overlay.style.display = 'none';
        iframe.src = '';
        
        // Reset minimize state
        content.classList.remove('minimized');
        container.classList.remove('minimized');
        toggleBtn.textContent = '_';
      });
      
      // Close on overlay click
      document.getElementById('floatingPdfOverlay').onclick = function(e) {
        if (e.target === this) {
          closeBtn.click();
        }
      };
    }
    
    // Initialize plate input and password prefill
    document.addEventListener('DOMContentLoaded', function() {
      // Prefill plate from session storage
      const existingPlate = sessionStorage.getItem('plate');
      if (existingPlate) {
        document.getElementById('builderPlateInput').value = existingPlate;
      }
      
      // Prefill password from session storage
      const prefillPassword = sessionStorage.getItem('prefillPassword') || 
                              sessionStorage.getItem('mainGatePassword') || 
                              sessionStorage.getItem('originalPassword');
      if (prefillPassword) {
        document.getElementById('builderPasswordInput').value = prefillPassword;
      }
      
      // Initialize expertise button state
      initializeExpertiseButtonState();
    });

    // Initialize expertise button state based on existing data
    function initializeExpertiseButtonState() {
      const fetchBtn = document.getElementById('builderFetchExpertiseBtn');
      const requestBtn = document.getElementById('builderRequestExpertiseBtn');
      
      if (!fetchBtn || !requestBtn) return;
      
      // Check if expertise exists in helper data
      const helper = sessionStorage.getItem('helper');
      let expertiseExists = false;
      
      if (helper) {
        try {
          const helperData = JSON.parse(helper);
          expertiseExists = helperData.expertise_data?.completed || 
                           helperData.documents?.expertise_pdf || 
                           helperData.expertise?.document_url ||
                           helperData.expertise_pdf;
        } catch (error) {
          console.error('Error parsing helper data:', error);
        }
      }
      
      // Set button states based on expertise existence
      if (expertiseExists) {
        // Enable fetch button
        fetchBtn.disabled = false;
        fetchBtn.style.opacity = '1';
        fetchBtn.style.cursor = 'pointer';
        
        // Change request button to "re-request" style
        requestBtn.textContent = '×‘×§×© ××§×¡×¤×™×¨×˜×™×–×” ××—×“×©';
        requestBtn.style.background = '#f59e0b'; // Orange for re-request
      } else {
        // Disable fetch button
        fetchBtn.disabled = true;
        fetchBtn.style.opacity = '0.5';
        fetchBtn.style.cursor = 'not-allowed';
        
        // Set request button to normal style
        requestBtn.textContent = '×‘×§×© ××§×¡×¤×™×¨×˜×™×–×”';
        requestBtn.style.background = '#059669'; // Green for new request
      }
      
      console.log('ğŸ”˜ Expertise button state initialized:', { expertiseExists });
    }
    
    // âœ… BIDIRECTIONAL INTEGRATION: Builder State Management
    // This allows validation page to read current builder state instead of helper directly
    function updateBuilderCurrentState(key, value) {
      try {
        let builderState = {};
        
        // Get existing builder state
        const existingState = sessionStorage.getItem('builderCurrentState');
        if (existingState) {
          builderState = JSON.parse(existingState);
        }
        
        // Update the specific key
        builderState[key] = value;
        builderState.last_update = new Date().toISOString();
        builderState.source = 'final-report-builder';
        
        // Save updated state
        sessionStorage.setItem('builderCurrentState', JSON.stringify(builderState));
        
        console.log(`âœ… Builder state updated: ${key}`, value);
        
        // Trigger broadcast to validation pages
        if (typeof broadcastBuilderStateUpdate === 'function') {
          broadcastBuilderStateUpdate(key, value);
        }
        
      } catch (error) {
        console.error('âŒ Error updating builder state:', error);
      }
    }
    
    // Initialize builder state when page loads
    function initializeBuilderState() {
      try {
        console.log('ğŸ“ Final Report Builder: Initializing with ENHANCED helper integration...');
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // ENHANCED: Create initial builder state from proper helper paths
        const initialState = {
          // Car details - use proper vehicle section
          plate: helper.vehicle?.plate || helper.meta?.plate,
          manufacturer: helper.vehicle?.manufacturer || helper.car_details?.manufacturer,
          model: helper.vehicle?.model || helper.car_details?.model,
          year: helper.vehicle?.year || helper.car_details?.year,
          
          // Owner details - use stakeholders section
          owner_name: helper.stakeholders?.owner?.name || helper.client?.name || helper.owner,
          owner_address: helper.stakeholders?.owner?.address,
          owner_phone: helper.stakeholders?.owner?.phone,
          insurance_company: helper.stakeholders?.insurance?.company || helper.client?.insurance_company || helper.insurance_company,
          
          // Final report data - use final report section
          final_report_type: helper.final_report?.type || helper.final_report_type,
          final_report_notes: helper.final_report?.notes || helper.final_report_notes,
          final_report_work_days: helper.final_report?.work_days || helper.final_report_work_days,
          // Legal text for final report comes from final_report object
          final_report_legal_text: helper.final_report?.legal_text || '',
          final_report_depreciation: helper.final_report?.depreciation,
          
          // Calculations
          calculations: helper.calculations,
          claims_data: helper.claims_data,
          
          // Metadata
          initialized_at: new Date().toISOString(),
          source: 'final-report-builder',
          version: '1.0'
        };
        
        sessionStorage.setItem('builderCurrentState', JSON.stringify(initialState));
        console.log('ğŸ—ï¸ Builder state initialized from helper data');
        
      } catch (error) {
        console.error('âŒ Error initializing builder state:', error);
      }
    }
    
    // Initialize builder state when page loads
    document.addEventListener('DOMContentLoaded', initializeBuilderState);
    
    
    
    // Update helper structure from contact field changes using field mapping dictionary
    function updateHelperFromContactField(element) {
      try {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        const fieldId = element.id;
        const value = element.value;
        
        console.log(`ğŸ“ Contact field change: ${fieldId} = "${value}"`);
        
        // Set nested value helper function
        const setNestedValue = (obj, path, val) => {
          const keys = path.split('.');
          let current = obj;
          for (let i = 0; i < keys.length - 1; i++) {
            const key = keys[i];
            if (!(key in current) || typeof current[key] !== 'object') {
              current[key] = {};
            }
            current = current[key];
          }
          current[keys[keys.length - 1]] = val;
        };
        
        // Map field IDs to helper structure paths using field mapping dictionary
        const fieldMappings = {
          'ownerName': 'stakeholders.owner.name',
          'ownerAddress': 'stakeholders.owner.address', 
          'ownerPhone': 'stakeholders.owner.phone',
          'insuranceCompany': 'stakeholders.insurance.company',
          'insuranceEmail': 'stakeholders.insurance.email',
          'insuranceAgent': 'stakeholders.insurance.agent.name',
          'agentPhone': 'stakeholders.insurance.agent.phone',
          'agentEmail': 'stakeholders.insurance.agent.email',
          'garageName': 'stakeholders.garage.name',
          'garagePhone': 'stakeholders.garage.phone',
          'garageEmail': 'stakeholders.garage.email',
          'carReportDate': 'case_info.issue_date'
        };
        
        // Update standardized helper structure
        if (fieldMappings[fieldId]) {
          setNestedValue(helper, fieldMappings[fieldId], value);
          console.log(`âœ… Updated ${fieldMappings[fieldId]} = "${value}"`);
        }
        
        // Also maintain legacy structure for backward compatibility
        helper.client = helper.client || {};
        helper.car_details = helper.car_details || {};
        
        const legacyMappings = {
          'ownerName': () => {
            helper.client.name = value;
            helper.car_details.owner = value;
          },
          'ownerAddress': () => {
            helper.client.address = value;
            helper.car_details.ownerAddress = value;
          },
          'ownerPhone': () => {
            helper.client.phone = value;
            helper.car_details.ownerPhone = value;
          },
          'insuranceCompany': () => {
            helper.client.insurance_company = value;
            helper.car_details.insuranceCompany = value;
          },
          'insuranceEmail': () => {
            helper.client.insurance_email = value;
          },
          'insuranceAgent': () => {
            helper.client.insurance_agent = value;
            helper.car_details.agentName = value;
          },
          'agentPhone': () => {
            helper.client.insurance_agent_phone = value;
            helper.car_details.insurance_agent_phone = value;
          },
          'agentEmail': () => {
            helper.client.insurance_agent_email = value;
            helper.car_details.insurance_agent_email = value;
          }
        };
        
        if (legacyMappings[fieldId]) {
          legacyMappings[fieldId]();
        }
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        localStorage.setItem('helper', JSON.stringify(helper));
        
        console.log(`ğŸ’¾ Helper updated for field: ${fieldId}`);
        
      } catch (error) {
        console.error('âŒ Error updating helper from contact field:', error);
      }
    }
    
    // Update helper structure from vehicle field changes using field mapping dictionary
    function updateHelperFromVehicleField(element) {
      try {
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        const fieldId = element.id;
        let value = element.value;
        
        console.log(`ğŸ“ Vehicle field change: ${fieldId} = "${value}"`);
        
        // Set nested value helper function
        const setNestedValue = (obj, path, val) => {
          const keys = path.split('.');
          let current = obj;
          for (let i = 0; i < keys.length - 1; i++) {
            const key = keys[i];
            if (!(key in current) || typeof current[key] !== 'object') {
              current[key] = {};
            }
            current = current[key];
          }
          current[keys[keys.length - 1]] = val;
        };
        
        // Process price fields - remove currency symbol and commas
        if (fieldId === 'carBasePrice' || fieldId === 'carMarketValue') {
          value = value.replace(/[â‚ª,]/g, '').trim();
          if (value && !isNaN(value)) {
            value = parseInt(value);
          }
        }
        
        // Map field IDs to helper structure paths
        const fieldMappings = {
          'carBasePrice': 'valuation.base_price',
          'carMarketValue': 'vehicle.market_value', 
          'carReportDate': 'case_info.issue_date'
        };
        
        // Update standardized helper structure
        if (fieldMappings[fieldId]) {
          setNestedValue(helper, fieldMappings[fieldId], value);
          console.log(`âœ… Updated ${fieldMappings[fieldId]} = "${value}"`);
        }
        
        // Also maintain legacy structure for backward compatibility
        helper.car_details = helper.car_details || {};
        helper.levi_report = helper.levi_report || {};
        helper.expertise = helper.expertise || {};
        helper.expertise.calculations = helper.expertise.calculations || {};
        
        const legacyMappings = {
          'carBasePrice': () => {
            helper.car_details.base_price = value;
            helper.levi_report.base_price = value;
          },
          'carMarketValue': () => {
            helper.car_details.market_value = value;
            helper.expertise.calculations.market_value = value;
          },
          'carReportDate': () => {
            helper.car_details.report_date = value;
            // Do NOT update levi_report.report_date - this is for final report only
          }
        };
        
        if (legacyMappings[fieldId]) {
          legacyMappings[fieldId]();
        }
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        localStorage.setItem('helper', JSON.stringify(helper));
        
        console.log(`ğŸ’¾ Helper updated for vehicle field: ${fieldId}`);
        
      } catch (error) {
        console.error('âŒ Error updating helper from vehicle field:', error);
      }
    }
    
    // DEPRECIATION MODULE INTEGRATION - COMPLETE DYNAMIC SYSTEM
    
    // Initialize depreciation functionality on page load
    document.addEventListener('DOMContentLoaded', function() {
      console.log('ğŸš€ Initializing complete dynamic depreciation system...');
      console.log('ğŸ”„ DOMContentLoaded event fired - about to initialize summary');
      
      // Initialize report type handler
      const reportTypeSelect = document.getElementById('reportType');
      if (reportTypeSelect) {
        reportTypeSelect.addEventListener('change', function() {
          const selectedType = this.value;
          console.log('Report type changed to:', selectedType);
          
          // Save dropdown selection to helper AND sessionStorage for persistence
          const helper = window.helper || {};
          if (!helper.final_report) helper.final_report = {};
          helper.final_report.dropdown_type = selectedType;
          window.helper = helper;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          sessionStorage.setItem('selectedReportVariant', selectedType);
          console.log('ğŸ’¾ Saved dropdown report type to helper and sessionStorage:', selectedType);
          
          updateReportType();
          loadLegalText().catch(console.error); // Update legal text when report type changes
          loadAttachmentsFromVault(); // Update attachments when report type changes
          saveAndRefreshComplete(); // Save and refresh calculations
        });
        
        // Initialize with current selection
        console.log('ğŸ”„ About to call updateSummaryVisibility() on page load');
        updateSummaryVisibility();
        console.log('âœ… updateSummaryVisibility() called on page load');
      }
      
      // Initialize company selection for VAT calculation
      const companySelect = document.getElementById('isCompanyClient');
      if (companySelect) {
        companySelect.addEventListener('change', function() {
          console.log('Company selection changed:', this.value);
          saveAndRefreshComplete();
        });
      }
      
      // Initialize global depreciation field
      const globalDep1 = document.getElementById('globalDep1');
      if (globalDep1) {
        globalDep1.addEventListener('input', function() {
          // Clean the value to allow decimal numbers
          let value = this.value;
          
          // Remove % for processing
          value = value.replace('%', '');
          
          // Allow only numbers, decimal point, and minus sign
          value = value.replace(/[^0-9.-]/g, '');
          
          // Ensure only one decimal point
          const parts = value.split('.');
          if (parts.length > 2) {
            value = parts[0] + '.' + parts.slice(1).join('');
          }
          
          // Keep as clean number during input
          this.value = value;
          
          console.log('Global depreciation changed:', this.value);
          
          // Call the functions that were in the inline handlers
          saveDepreciationData();
          updateHelperDepreciationField(this, 'global_percentage');
          
          calculateGlobalDepreciationValue();
          triggerMathCalculation();
          saveAndRefreshComplete();
        });
        
        // Allow decimal input on keypress
        globalDep1.addEventListener('keypress', function(e) {
          // Allow: numbers (0-9), decimal point (.), minus (-), navigation keys
          const allowedKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '-', 'Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab'];
          
          if (!allowedKeys.includes(e.key) && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
          }
        });
        
        // Add % sign when user finishes editing (on blur) 
        globalDep1.addEventListener('blur', function() {
          if (this.value && !this.value.includes('%') && this.value !== '') {
            const numValue = parseFloat(this.value);
            if (!isNaN(numValue)) {
              this.value = this.value + '%';
            }
          }
        });
      }
      
      // Initialize work days field
      const workDays = document.getElementById('workDays');
      if (workDays) {
        workDays.addEventListener('input', function() {
          console.log('Work days changed:', this.value);
          saveAndRefreshComplete();
        });
      }
      
      // Initialize agreement checkbox
      const isAgreement = document.getElementById('isAgreement');
      if (isAgreement) {
        isAgreement.addEventListener('change', function() {
          console.log('Agreement checkbox changed:', this.checked);
          saveAndRefreshComplete();
        });
      }
      
      // Initialize differentials checkbox
      const differentialsCheckbox = document.getElementById('hasDifferentials');
      if (differentialsCheckbox) {
        differentialsCheckbox.addEventListener('change', function() {
          console.log('Differentials checkbox changed:', this.checked);
          toggleDifferentials();
          saveAndRefreshComplete();
        });
      }
      
      // Add dynamic event listeners to all value fields that affect calculations
      const dynamicFields = [
        'saleValueDamage', 'salvageValueTotal', 'salvageValueLegal', 'storageValueTotal'
      ];
      
      dynamicFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field) {
          field.addEventListener('input', function() {
            console.log(`${fieldId} changed:`, this.value);
            calculateSubtotals();
            saveAndRefreshComplete();
          });
        }
      });
      
      // Initialize differentials display
      toggleDifferentials();
      
      // Load existing data from helper
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const dep = helper.expertise?.depreciation || {};
      
      // TEMPORARILY DISABLE loading existing differentials data to fix corruption
      // Load existing differentials data - DISABLED to clear corrupted data
      // if (dep.differentials && dep.differentials.length > 0) {
      //   renderDifferentials(dep.differentials);
      // }
      console.log('âš ï¸ Differential loading temporarily disabled to clear corrupted data');
      
      // Load existing form values
      if (dep.global_percent && globalDep1) {
        globalDep1.value = dep.global_percent;
      }
      if (dep.work_days && workDays) {
        workDays.value = dep.work_days;
      }
      if (dep.is_agreement !== undefined && isAgreement) {
        isAgreement.checked = !!dep.is_agreement;
      }
      if (dep.has_differentials !== undefined && differentialsCheckbox) {
        differentialsCheckbox.checked = !!dep.has_differentials;
      }
      
      // Load company selection
      if (helper.client?.is_company_client !== undefined && companySelect) {
        companySelect.value = helper.client.is_company_client ? 'yes' : 'no';
      }
      
      // Load report type
      if (helper.meta?.report_type_display && reportTypeSelect) {
        reportTypeSelect.value = helper.meta.report_type_display;
      }
      
      // Initial complete calculation refresh
      setTimeout(() => {
        calculateGlobalDepreciationValue();
        triggerMathCalculation();
        refreshSummary();
        console.log('âœ… Complete dynamic system initialized');
      }, 100);
    });
    
    // Update summary visibility based on report type
    function updateSummaryVisibility() {
      console.log('ğŸ”„ updateSummaryVisibility() STARTED');
      const reportTypeSelect = document.getElementById('reportType');
      const reportType = reportTypeSelect?.value || '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª';
      console.log('ğŸ“‹ Report type:', reportType);
      
      // Hide all summary sections first
      const summaryBlocks = document.querySelectorAll('.summary-block');
      summaryBlocks.forEach(block => block.style.display = 'none');
      
      // Show the correct summary section based on selected type
      let summaryId = '';
      switch(reportType) {
        case '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª':
          summaryId = 'summaryPrivate';
          break;
        case '×—×•×•×ª ×“×¢×ª ×’×œ×•×‘×œ×™×ª':
          summaryId = 'summaryGlobal';
          break;
        case '×—×•×•×ª ×“×¢×ª ××›×™×¨×” ××¦×‘×• ×”× ×™×–×•×§':
          summaryId = 'summaryDamage';
          break;
        case '×—×•×•×ª ×“×¢×ª ×˜×•×˜×œ×•×¡×˜':
          summaryId = 'summaryTotalLoss';
          break;
        case '×—×•×•×ª ×“×¢×ª ××•×‘×“×Ÿ ×œ×”×œ×›×”':
          summaryId = 'summaryLegalLoss';
          break;
        default:
          summaryId = 'summaryPrivate';
      }
      
      // Show the selected summary section
      const selectedSummary = document.getElementById(summaryId);
      console.log('ğŸ” Selected summary element:', summaryId, !!selectedSummary);
      if (selectedSummary) {
        selectedSummary.style.display = 'block';
        console.log('âœ… Summary section displayed:', summaryId);
        
        // Populate the fields with correct data mapping
        console.log('ğŸ”„ About to call refreshSummary()');
        refreshSummary();
        console.log('âœ… refreshSummary() completed');
        
        // Additional refresh for salvage sale variant to ensure calculations work
        if (summaryId === 'summaryDamage') {
          setTimeout(() => {
            console.log('ğŸ”„ Additional salvage sale variant refresh');
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = helper.calculations?.full_market_value || 0;
            
            // Ensure market value field is populated
            const damageMarketField = document.getElementById('sumMarketValueDamage');
            if (damageMarketField && marketValue > 0) {
              damageMarketField.value = `â‚ª${marketValue.toLocaleString()}`;
            }
            
            // Trigger calculation again
            const salvageSaleField = document.getElementById('saleValueDamage');
            if (salvageSaleField) {
              const salvagePrice = parseFloat(salvageSaleField.value.replace(/[â‚ª,]/g, '')) || 0;
              const salvageSaleResult = marketValue - salvagePrice;
              
              const resultField = document.getElementById('afterSaleDamage');
              if (resultField) {
                resultField.value = `â‚ª${salvageSaleResult.toLocaleString()}`;
                console.log(`ğŸ”„ Re-calculated salvage sale: ${marketValue} - ${salvagePrice} = ${salvageSaleResult}`);
              }
            }
          }, 200);
        }
        
        // Additional refresh for total loss variant to ensure calculations work
        if (summaryId === 'summaryTotalLoss') {
          // First, ensure fields are loaded from helper
          const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
          
          // Immediately load manual fields from helper
          const salvageField = document.getElementById('salvageValueTotal');
          const towingField = document.getElementById('storageValueTotal');
          
          if (salvageField && helper.final_report?.summary?.salvage_value_total) {
            salvageField.value = helper.final_report.summary.salvage_value_total;
            console.log(`ğŸ“¥ Immediately loaded salvage value: ${salvageField.value}`);
          }
          
          if (towingField && helper.final_report?.summary?.storage_towing_value_total) {
            towingField.value = helper.final_report.summary.storage_towing_value_total;
            console.log(`ğŸ“¥ Immediately loaded towing value: ${towingField.value}`);
          }
          
          // Then trigger calculation after a delay
          setTimeout(() => {
            console.log('ğŸ”„ Additional total loss variant refresh');
            const marketValue = helper.calculations?.full_market_value || 0;
            
            // Ensure market value field is populated
            const totalMarketField = document.getElementById('sumMarketValueTotal');
            if (totalMarketField && marketValue > 0) {
              totalMarketField.value = `â‚ª${marketValue.toLocaleString()}`;
            }
            
            // Trigger calculation with loaded values
            const resultField = document.getElementById('afterSaleTotal');
            
            if (resultField && marketValue > 0) {
              const salvageValue = parseFloat(salvageField?.value?.replace(/[â‚ª,]/g, '')) || 0;
              const towingValue = parseFloat(towingField?.value?.replace(/[â‚ª,]/g, '')) || 0;
              const result = marketValue - salvageValue + towingValue;
              
              resultField.value = `â‚ª${result.toLocaleString()}`;
              console.log(`ğŸ”„ Re-calculated total loss: ${marketValue} - ${salvageValue} + ${towingValue} = ${result}`);
            }
          }, 300);
          
          // Extra safety - call variant calculations after longer delay
          setTimeout(() => {
            ensureTotalLossCalculation();
            ensureLegalLossCalculation();
          }, 800);
        }
      } else {
        console.error('âŒ Summary section not found:', summaryId);
      }

      // Control depreciation section visibility
      const depreciationSection = document.getElementById('depreciationSection');
      if (depreciationSection) {
        const hideDepreciation = (reportType === '×—×•×•×ª ×“×¢×ª ×˜×•×˜×œ×•×¡×˜' || 
                                reportType === '×—×•×•×ª ×“×¢×ª ××›×™×¨×” ××¦×‘×• ×”× ×™×–×•×§' || 
                                reportType === '×—×•×•×ª ×“×¢×ª ××•×‘×“×Ÿ ×œ×”×œ×›×”');
        depreciationSection.style.display = hideDepreciation ? 'none' : 'block';
      }

      // Control differentials section visibility for special report types
      const differentialsSection = document.getElementById('differentialsSection');
      if (differentialsSection) {
        const hideDifferentials = (reportType === '×—×•×•×ª ×“×¢×ª ×˜×•×˜×œ×•×¡×˜' || 
                                 reportType === '×—×•×•×ª ×“×¢×ª ××›×™×¨×” ××¦×‘×• ×”× ×™×–×•×§' || 
                                 reportType === '×—×•×•×ª ×“×¢×ª ××•×‘×“×Ÿ ×œ×”×œ×›×”');
        if (hideDifferentials) {
          differentialsSection.style.display = 'none';
          // Also uncheck the differentials checkbox
          const differentialsCheckbox = document.getElementById('hasDifferentials');
          if (differentialsCheckbox) {
            differentialsCheckbox.checked = false;
          }
        } else {
          differentialsSection.style.display = 'block';
        }
      }
    }
    
    // Refresh summary with correct field mapping as specified
    function refreshSummary() {
      console.log('ğŸš€ refreshSummary() STARTED');
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('ğŸ“Š Helper data:', helper.calculations?.full_market_value);
      
      // Get values from YOUR specified sources - NO FALLBACKS
      const marketValue = helper.calculations?.full_market_value || 0;
      
      let totalClaim = 0;
      if (helper.claims_data?.total_claim) {
        const claimValue = helper.claims_data.total_claim;
        totalClaim = typeof claimValue === 'string' ? 
          parseFloat(claimValue.replace(/[â‚ª,]/g, '')) || 0 : 
          parseFloat(claimValue) || 0;
      }
      
      let depCompensation = 0;
      if (helper.depreciation?.globalDepValue) {
        const depValue = helper.depreciation.globalDepValue;
        depCompensation = typeof depValue === 'string' ? 
          parseFloat(depValue.replace(/[â‚ª,]/g, '')) || 0 : 
          parseFloat(depValue) || 0;
      }
      
      // Update market value fields across all variants
      const marketFields = [
        'sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 
        'sumMarketValueTotal', 'sumMarketValueLegal', 'sumMarketValuePrivate',
        'sumMarketValueDefault'
      ];
      marketFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        console.log(`ğŸ” Field ${fieldId}: exists=${!!field}, marketValue=${marketValue}`);
        if (field && marketValue > 0) {
          field.value = `â‚ª${marketValue.toLocaleString()}`;
          console.log(`âœ… Set ${fieldId} = ${field.value}`);
          
          // Add protection: re-set the field after helper system loads for all market value fields
          setTimeout(() => {
            if (field.value !== `â‚ª${marketValue.toLocaleString()}`) {
              field.value = `â‚ª${marketValue.toLocaleString()}`;
              console.log(`ğŸ”§ RESTORED ${fieldId} = ${field.value} (was cleared by helper system)`);
            }
          }, 1000); // Wait for helper system to finish
        }
      });
      
      // Update total claim fields for private and global variants
      const claimFields = [
        'sumClaim', 'sumClaimGlobal', 'sumClaimPrivate', 'sumClaimDefault'
      ];
      claimFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field && totalClaim > 0) {
          field.value = `â‚ª${totalClaim.toLocaleString()}`;
        }
      });
      
      // Update depreciation compensation fields for private and global variants
      const depFields = [
        'depCompensation', 'sumDepreciation', 'depCompensationPrivate', 'sumDepreciationDefault'
      ];
      depFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field && depCompensation > 0) {
          field.value = `â‚ª${depCompensation.toLocaleString()}`;
        }
      });
      
      // Calculate totals for private and global variants
      const privateTotal = totalClaim + depCompensation;
      const privateTotalFields = ['sumTotalPrivate', 'sumTotalDefault', 'sumTotalGlobal'];
      privateTotalFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field && privateTotal > 0) {
          field.value = `â‚ª${privateTotal.toLocaleString()}`;
        }
      });

      // TOTAL LOSS CALCULATION: Market Value - Salvage + Towing
      const salvageField = document.getElementById('salvageValueTotal');
      const towingField = document.getElementById('storageValueTotal');
      const totalLossResultField = document.getElementById('afterSaleTotal');
      
      // Load manual fields from helper if they're empty
      if (salvageField && !salvageField.value && helper.final_report?.summary?.salvage_value_total) {
        salvageField.value = helper.final_report.summary.salvage_value_total;
        console.log(`ğŸ“¥ Loaded salvage value from helper in refreshSummary: ${salvageField.value}`);
      }
      
      if (towingField && !towingField.value && helper.final_report?.summary?.storage_towing_value_total) {
        towingField.value = helper.final_report.summary.storage_towing_value_total;
        console.log(`ğŸ“¥ Loaded towing value from helper in refreshSummary: ${towingField.value}`);
      }
      
      // Always perform calculation even if some values are 0
      if (totalLossResultField && marketValue > 0) {
        const salvageValue = parseFloat(salvageField?.value.replace(/[â‚ª,]/g, '')) || 0;
        const towingValue = parseFloat(towingField?.value.replace(/[â‚ª,]/g, '')) || 0;
        const totalLossResult = marketValue - salvageValue + towingValue;
        
        totalLossResultField.value = `â‚ª${totalLossResult.toLocaleString()}`;
        console.log(`ğŸ§® Total Loss calculation: ${marketValue} - ${salvageValue} + ${towingValue} = ${totalLossResult}`);
        
        // Ensure the result persists after a delay
        setTimeout(() => {
          if (totalLossResultField.value !== `â‚ª${totalLossResult.toLocaleString()}`) {
            totalLossResultField.value = `â‚ª${totalLossResult.toLocaleString()}`;
            console.log(`ğŸ”§ Re-applied total loss result after delay`);
          }
        }, 500);
      }

      // SALVAGE SALE CALCULATION: Market Value - Salvage Price
      const salvageSaleField = document.getElementById('saleValueDamage');
      
      // Load manual field from helper if empty
      if (salvageSaleField && !salvageSaleField.value && helper.final_report?.summary?.sale_value_damaged) {
        salvageSaleField.value = helper.final_report.summary.sale_value_damaged;
        console.log(`ğŸ“¥ Loaded salvage sale value from helper in refreshSummary: ${salvageSaleField.value}`);
      }
      
      if (salvageSaleField && marketValue > 0) {
        const salvageSaleValue = parseFloat(salvageSaleField.value.replace(/[â‚ª,]/g, '')) || 0;
        const salvageSaleResult = marketValue - salvageSaleValue;
        
        // Update the result field
        const resultField = document.getElementById('afterSaleDamage');
        if (resultField) {
          resultField.value = `â‚ª${salvageSaleResult.toLocaleString()}`;
          console.log(`ğŸ§® Salvage Sale calculation: â‚ª${marketValue.toLocaleString()} - â‚ª${salvageSaleValue.toLocaleString()} = â‚ª${salvageSaleResult.toLocaleString()}`);
          
          // Save to helper
          helper.final_report = helper.final_report || {};
          helper.final_report.summary = helper.final_report.summary || {};
          helper.final_report.summary.total_after_sale_damage = resultField.value;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          // Ensure the result persists after a delay
          setTimeout(() => {
            if (resultField.value !== `â‚ª${salvageSaleResult.toLocaleString()}`) {
              resultField.value = `â‚ª${salvageSaleResult.toLocaleString()}`;
              console.log(`ğŸ”§ Re-applied salvage sale result after delay`);
            }
          }, 500);
        } else {
          console.warn('âš ï¸ Result field afterSaleDamage not found');
        }
      }

      // LEGAL LOSS CALCULATION: Market Value - Salvage Price
      const salvageLegalField = document.getElementById('salvageValueLegal');
      const legalLossResultField = document.getElementById('afterSaleLegal');
      
      // Load manual field from helper if empty
      if (salvageLegalField && !salvageLegalField.value && helper.final_report?.summary?.salvage_value_legal) {
        salvageLegalField.value = helper.final_report.summary.salvage_value_legal;
        console.log(`ğŸ“¥ Loaded salvage legal value from helper in refreshSummary: ${salvageLegalField.value}`);
      }
      
      if (legalLossResultField && marketValue > 0) {
        const salvageLegalValue = parseFloat(salvageLegalField?.value.replace(/[â‚ª,]/g, '')) || 0;
        const legalLossResult = marketValue - salvageLegalValue;
        
        legalLossResultField.value = `â‚ª${legalLossResult.toLocaleString()}`;
        console.log(`ğŸ§® Legal Loss calculation: â‚ª${marketValue.toLocaleString()} - â‚ª${salvageLegalValue.toLocaleString()} = â‚ª${legalLossResult.toLocaleString()}`);
        
        // Save to helper
        helper.final_report = helper.final_report || {};
        helper.final_report.summary = helper.final_report.summary || {};
        helper.final_report.summary.total_after_salvage_legal = legalLossResultField.value;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Ensure the result persists after a delay
        setTimeout(() => {
          if (legalLossResultField.value !== `â‚ª${legalLossResult.toLocaleString()}`) {
            legalLossResultField.value = `â‚ª${legalLossResult.toLocaleString()}`;
            console.log(`ğŸ”§ Re-applied legal loss result after delay`);
          }
        }, 500);
      }
    }
    
    // Dynamic summary content based on report type
    function updateSummaryContent(reportType) {
      const summaryContent = document.querySelector('#summaryPrivate .form-grid');
      if (!summaryContent) return;
      
      // Clear existing content
      summaryContent.innerHTML = '';
      
      // Create different summary structures based on report type
      switch(reportType) {
        case '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª':
          summaryContent.innerHTML = `
            <div><label style="color: #333;">×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘:</label><input type="text" id="sumMarketValuePrivate" style="background: white; color: #333;" readonly /></div>
            <div><label style="color: #333;">×¡×”×´×› ×ª×‘×™×¢×”:</label><input type="text" id="sumClaimPrivate" style="background: white; color: #333;" readonly /></div>
            <div><label style="color: #333;">×¤×™×¦×•×™ ×‘×’×™×Ÿ ×™×¨×™×“×ª ×¢×¨×š:</label><input type="text" id="depCompensationPrivate" style="background: white; color: #333;" readonly /></div>
            <div><label style="color: #333;">×ª×•×¡×¤×•×ª ×•×”×•×¨×“×•×ª (××™×“×¢ ×‘×œ×‘×“):</label><input type="text" id="adjustmentsInfoPrivate" style="background: #f0f0f0; color: #666;" readonly /></div>
          `;
          break;
          
        case '×—×•×•×ª ×“×¢×ª ×’×œ×•×‘×œ×™×ª':
          summaryContent.innerHTML = `
            <div><label style="color: #333;">×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘:</label><input type="text" id="sumMarketValueGlobal" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">×¡×”×´×› ×ª×‘×™×¢×”:</label><input type="text" id="sumClaimGlobal" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">×¤×™×¦×•×™ ×‘×’×™×Ÿ ×™×¨×™×“×ª ×¢×¨×š:</label><input type="text" id="sumDepreciation" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">×ª×•×¡×¤×•×ª ×•×”×•×¨×“×•×ª:</label><input type="text" id="sumAdjustments" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">×¡×”×´×› × ×›×œ×œ ×‘×—×•×•×ª ×”×“×¢×ª:</label><input type="text" id="sumTotalGlobalDynamic" style="background: white; color: #333;" /></div>
          `;
          
          // IMMEDIATE POPULATION FOR GLOBAL VARIANT - DIRECT FROM HELPER
          setTimeout(() => {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            
            // Market Value - from helper.calculations.full_market_value
            const marketValue = helper.calculations?.full_market_value || 0;
            const marketField = document.getElementById('sumMarketValueGlobal');
            if (marketField && marketValue > 0) {
              marketField.value = `â‚ª${marketValue.toLocaleString()}`;
            }
            
            // Total Claim - directly from helper.claims_data.total_claim
            let totalClaim = 0;
            if (helper.claims_data?.total_claim) {
              const claimValue = helper.claims_data.total_claim;
              if (typeof claimValue === 'string') {
                totalClaim = parseFloat(claimValue.replace(/[â‚ª,]/g, '')) || 0;
              } else {
                totalClaim = parseFloat(claimValue) || 0;
              }
            }
            const claimField = document.getElementById('sumClaimGlobal');
            if (claimField && totalClaim > 0) {
              claimField.value = `â‚ª${totalClaim.toLocaleString()}`;
            }
            
            // Depreciation - from helper.depreciation.globalDepValue
            let depCompensation = 0;
            if (helper.depreciation?.globalDepValue) {
              const depValue = helper.depreciation.globalDepValue;
              if (typeof depValue === 'string') {
                depCompensation = parseFloat(depValue.replace(/[â‚ª,]/g, '')) || 0;
              } else {
                depCompensation = parseFloat(depValue) || 0;
              }
            }
            const depField = document.getElementById('sumDepreciation');
            if (depField && depCompensation > 0) {
              depField.value = `â‚ª${depCompensation.toLocaleString()}`;
            }
          }, 0);
          break;
          
        case '×—×•×•×ª ×“×¢×ª ×˜×•×˜×œ×•×¡×˜':
          summaryContent.innerHTML = `
            <div><label style="color: #333;">×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘:</label><input type="text" id="sumMarketValueTotal" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">×¢×¨×š ×©×¨×™×“×™ ×”×¨×›×‘:</label><input type="text" id="sumScrapValue" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">×ª×•×¡×¤×ª ×‘×’×™×Ÿ ×’×¨×™×¨×” ×•××—×¡× ×”:</label><input type="text" id="sumTowingStorage" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">×¡×”×´×› ×œ××—×¨ ××›×™×¨×ª ×©×¨×™×“×™×:</label><input type="text" id="sumTotalTotalLoss" style="background: white; color: #333;" /></div>
          `;
          
          // IMMEDIATE POPULATION FOR TOTAL LOSS VARIANT
          setTimeout(() => {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = helper.calculations?.full_market_value || 0;
            const marketField = document.getElementById('sumMarketValueTotal');
            if (marketField && marketValue > 0) {
              marketField.value = `â‚ª${marketValue.toLocaleString()}`;
            }
          }, 0);
          break;
          
        case '×—×•×•×ª ×“×¢×ª ××›×™×¨×” ××¦×‘×• ×”× ×™×–×•×§':
          summaryContent.innerHTML = `
            <div><label style="color: #333;">×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘:</label><input type="text" id="sumMarketValueDamage" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">×¢×¨×š ×”××›×™×¨×” ×‘××¦×‘×• ×”× ×™×–×•×§:</label><input type="text" id="sumDamagedSaleValue" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">×©×™×˜×ª ×ª×©×œ×•×:</label><input type="text" id="paymentMethod" style="background: white; color: #333;" placeholder="××–×•××Ÿ, ×¦'×§, ×”×¢×‘×¨×” ×‘× ×§××™×ª..." /></div>
            <div><label style="color: #333;">×¡×”×´×› ×œ××—×¨ ××›×™×¨×”:</label><input type="text" id="sumTotalDamagedSale" style="background: white; color: #333;" /></div>
          `;
          
          // IMMEDIATE POPULATION FOR DAMAGED STATE VARIANT
          setTimeout(() => {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = helper.calculations?.full_market_value || 0;
            const marketField = document.getElementById('sumMarketValueDamage');
            if (marketField && marketValue > 0) {
              marketField.value = `â‚ª${marketValue.toLocaleString()}`;
              console.log(`âœ… Set sumMarketValueDamage to ${marketField.value}`);
            }
            
            // Add event listener to the newly created salvage sale input field
            const salvageSaleField = document.getElementById('sumDamagedSaleValue');
            if (salvageSaleField) {
              salvageSaleField.addEventListener('input', function() {
                console.log('ğŸ¯ Direct event listener triggered for Salvage Sale field');
                refreshSummary();
              });
              console.log('âœ… Added direct event listener to sumDamagedSaleValue field');
              
              // Immediately trigger the calculation if salvage field has a value
              const salvageValue = parseFloat(salvageSaleField.value.replace(/[â‚ª,]/g, '')) || 0;
              if (marketValue > 0) {
                const result = marketValue - salvageValue;
                const resultField = document.getElementById('sumTotalDamagedSale');
                if (resultField) {
                  resultField.value = `â‚ª${result.toLocaleString()}`;
                  console.log(`ğŸ¯ Initial salvage calculation: ${marketValue} - ${salvageValue} = ${result}`);
                }
              }
            }
            
            // Call refreshSummary after a short delay to ensure DOM is ready
            setTimeout(() => {
              console.log('ğŸ”„ Calling refreshSummary after dynamic content creation');
              refreshSummary();
            }, 100);
          }, 50);
          break;
          
        case '×—×•×•×ª ×“×¢×ª ××•×‘×“×Ÿ ×œ×”×œ×›×”':
          summaryContent.innerHTML = `
            <div><label style="color: #333;">×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘:</label><input type="text" id="sumMarketValueLegal" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">×¢×¨×š ×©×¨×™×“×™ ×”×¨×›×‘:</label><input type="text" id="sumScrapValueLegal" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">×¡×”×´×› ×œ××—×¨ ××›×™×¨×ª ×©×¨×™×“×™×:</label><input type="text" id="sumAfterScrapLegal" style="background: white; color: #333;" /></div>
          `;
          
          // IMMEDIATE POPULATION FOR LEGAL LOSS VARIANT
          setTimeout(() => {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            
            // Market Value - from helper.calculations.full_market_value
            const marketValue = helper.calculations?.full_market_value || 0;
            const marketField = document.getElementById('sumMarketValueLegal');
            if (marketField && marketValue > 0) {
              marketField.value = `â‚ª${marketValue.toLocaleString()}`;
            }
            
            // Check if we have depreciation value (158,901) which might be used as after scrap value
            let depCompensation = 0;
            if (helper.depreciation?.globalDepValue) {
              const depValue = helper.depreciation.globalDepValue;
              if (typeof depValue === 'string') {
                depCompensation = parseFloat(depValue.replace(/[â‚ª,]/g, '')) || 0;
              } else {
                depCompensation = parseFloat(depValue) || 0;
              }
            }
            
            // Fill the after scrap value field
            const afterScrapField = document.getElementById('sumAfterScrapLegal');
            if (afterScrapField && depCompensation > 0) {
              afterScrapField.value = `â‚ª${depCompensation.toLocaleString()}`;
            }
          }, 0);
          break;
          
        default:
          // Default to private report structure
          summaryContent.innerHTML = `
            <div><label style="color: #333;">×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘:</label><input type="text" id="sumMarketValueDefault" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">×¡×”×´×› ×ª×‘×™×¢×”:</label><input type="text" id="sumClaimDefault" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">×¤×™×¦×•×™ ×‘×’×™×Ÿ ×™×¨×™×“×ª ×¢×¨×š:</label><input type="text" id="sumDepreciationDefault" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">×ª×•×¡×¤×•×ª ×•×”×•×¨×“×•×ª:</label><input type="text" id="sumAdjustmentsDefault" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">×¡×”×´×› × ×›×œ×œ ×‘×—×•×•×ª ×”×“×¢×ª:</label><input type="text" id="sumTotalDefault" style="background: white; color: #333;" /></div>
          `;
      }
      
      // Load data from helper for the new summary structure IMMEDIATELY
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Populate the global claim field with the correct value
      const sumClaimGlobal = document.getElementById('sumClaimGlobal');
      if (sumClaimGlobal && totalClaim > 0) {
        sumClaimGlobal.value = `â‚ª${totalClaim.toLocaleString()}`;
      }
      
      // Also populate private claim field if it exists
      const sumClaimPrivate = document.getElementById('sumClaimPrivate');
      if (sumClaimPrivate && totalClaim > 0) {
        sumClaimPrivate.value = `â‚ª${totalClaim.toLocaleString()}`;
      }
      
      // Also populate default claim field if it exists
      const sumClaimDefault = document.getElementById('sumClaimDefault');
      if (sumClaimDefault && totalClaim > 0) {
        sumClaimDefault.value = `â‚ª${totalClaim.toLocaleString()}`;
      }
      
      // 3. AUTO-FILL DEPRECIATION - Get from helper
      let depCompensation = 0;
      if (helper.depreciation?.globalDepValue) {
        const depValue = helper.depreciation.globalDepValue;
        if (typeof depValue === 'string') {
          depCompensation = parseFloat(depValue.replace(/[â‚ª,]/g, '')) || 0;
        } else {
          depCompensation = parseFloat(depValue) || 0;
        }
      }
      
      // Populate depreciation fields
      const sumDepreciation = document.getElementById('sumDepreciation');
      if (sumDepreciation && depCompensation > 0) {
        sumDepreciation.value = `â‚ª${depCompensation.toLocaleString()}`;
      }
      
      const depCompensationPrivate = document.getElementById('depCompensationPrivate');
      if (depCompensationPrivate && depCompensation > 0) {
        depCompensationPrivate.value = `â‚ª${depCompensation.toLocaleString()}`;
      }
      
      const sumDepreciationDefault = document.getElementById('sumDepreciationDefault');
      if (sumDepreciationDefault && depCompensation > 0) {
        sumDepreciationDefault.value = `â‚ª${depCompensation.toLocaleString()}`;
      }
      
      loadSummaryFieldsFromHelper(helper);
      
      // Add event listeners immediately
      addSummaryCalculationListeners();
      
      // Calculate totals AFTER all fields are populated
      setTimeout(() => {
        calculateSummaryTotals();
      }, 100);
      
      // Re-add event listeners for newly created fields and reload values
      setTimeout(() => {
        // ENHANCED: Use targeted market value population based on current report type
        const currentReportType = document.getElementById('reportType')?.value || '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª';
        populateMarketValueForCurrentVariant(helper, currentReportType);
        
        const paymentMethodField = document.getElementById('paymentMethod');
        if (paymentMethodField) {
          // Load saved value explicitly
          const savedPayment = helper.final_report?.summary?.paymentMethod;
          if (savedPayment) {
            paymentMethodField.value = savedPayment;
          }
          
          paymentMethodField.addEventListener('input', loadLegalText);
        }
      }, 100);
    }
    
    // ENHANCED VARIANT-SPECIFIC CALCULATION ENGINE - Based on User Mappings
    function calculateSummaryTotals() {
      try {
        console.log('ğŸ§® Starting enhanced variant-specific calculations');
        const reportType = document.getElementById('reportType')?.value || '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª';
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Get market value from standardized source (helper.calculations.full_market_value)
        let marketValue = helper.calculations?.full_market_value || 0;
        
        // If not available, try to get from visible fields
        if (marketValue === 0) {
          const marketFields = ['sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 'sumMarketValueTotal', 'sumMarketValueLegal'];
          for (const fieldId of marketFields) {
            const field = document.getElementById(fieldId);
            if (field && field.value) {
              marketValue = parseFloat(field.value.replace(/[â‚ª,]/g, '')) || 0;
              break;
            }
          }
        }
        
        console.log(`ğŸ’° Market value: â‚ª${marketValue.toLocaleString()}`);
        
        // VARIANT-SPECIFIC CALCULATION LOGIC (Based on User Mappings)
        switch(reportType) {
          case '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª':
            calculatePrivateReport(helper, marketValue);
            break;
            
          case '×—×•×•×ª ×“×¢×ª ×’×œ×•×‘×œ×™×ª':  
            calculateGlobalReport(helper, marketValue);
            break;
            
          case '×—×•×•×ª ×“×¢×ª ×˜×•×˜×œ×•×¡×˜':
            calculateTotalLossReport(helper, marketValue);
            break;
            
          case '×—×•×•×ª ×“×¢×ª ××›×™×¨×” ××¦×‘×• ×”× ×™×–×•×§':
            calculateDamagedSaleReport(helper, marketValue).catch(console.error);
            break;
            
          case '×—×•×•×ª ×“×¢×ª ××•×‘×“×Ÿ ×œ×”×œ×›×”':
            calculateLegalLossReport(helper, marketValue);
            break;
            
          default:
            calculatePrivateReport(helper, marketValue); // Default to private
        }
        
        // Save calculations back to helper
        helper.final_report = helper.final_report || {};
        helper.final_report.summary = helper.final_report.summary || {};
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('âœ… Variant-specific calculations completed');
        
      } catch (error) {
        console.error('âŒ Error in calculateSummaryTotals:', error);
      }
    }
    
    // PRIVATE REPORT CALCULATION (Based on User Mapping)
    function calculatePrivateReport(helper, marketValue) {
      console.log('ğŸ“Š Calculating Private Report');
      
      // Get values - simplified calculation: only Total Claim + Depreciation
      let totalClaim = 0;
      if (helper.claims_data?.total_claim) {
        totalClaim = parseFloat(String(helper.claims_data.total_claim).replace(/[â‚ª,]/g, '')) || 0;
      }
      
      let depCompensation = 0;
      if (helper.depreciation?.globalDepValue) {
        depCompensation = parseFloat(String(helper.depreciation.globalDepValue).replace(/[â‚ª,]/g, '')) || 0;
      } else if (helper.depreciation?.globalDep1) {
        depCompensation = parseFloat(String(helper.depreciation.globalDep1).replace(/[â‚ª,%]/g, '')) || 0;
      }
      
      // Calculation: Total Claim + Depreciation Compensation ONLY
      const calculatedTotal = totalClaim + depCompensation;
      
      // Update UI fields - use the static field instead
      const totalField = document.getElementById('sumTotalBeforeDifferentials');
      if (totalField) {
        totalField.value = `â‚ª${calculatedTotal.toLocaleString()}`;
        totalField.style.backgroundColor = '#e8f5e8'; // Show it's calculated
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.summary) helper.final_report.summary = {};
        helper.final_report.summary.private_total = totalField.value;
      }
      
      console.log(`Private calculation: ${totalClaim} + ${depCompensation} = ${calculatedTotal}`);
      return calculatedTotal;
    }
    
    // GLOBAL REPORT CALCULATION (Based on User Mapping)  
    function calculateGlobalReport(helper, marketValue) {
      console.log('ğŸ“Š Calculating Global Report');
      
      // Get values using proper parsing like Private report
      let totalClaim = 0;
      if (helper.claims_data?.total_claim) {
        totalClaim = parseFloat(String(helper.claims_data.total_claim).replace(/[â‚ª,]/g, '')) || 0;
      }
      
      let depCompensation = 0;
      if (helper.depreciation?.globalDepValue) {
        depCompensation = parseFloat(String(helper.depreciation.globalDepValue).replace(/[â‚ª,]/g, '')) || 0;
      } else if (helper.depreciation?.globalDep1) {
        depCompensation = parseFloat(String(helper.depreciation.globalDep1).replace(/[â‚ª,%]/g, '')) || 0;
      }
      
      // 1. BEFORE DIFFERENTIALS: Total Claim + Depreciation Compensation (like Private)
      const beforeDifferentials = totalClaim + depCompensation;
      
      // 2. Get total differentials value from the correct source
      let totalDifferentials = 0;
      
      // Check helper.final_report.differential (where differentials are actually saved)
      if (helper.final_report?.differential?.summary?.total_amount_with_vat) {
        totalDifferentials = parseFloat(String(helper.final_report.differential.summary.total_amount_with_vat).replace(/[â‚ª,]/g, '')) || 0;
      }
      // Also check the alternative field name
      else if (helper.final_report?.differential?.summary?.total_with_vat) {
        totalDifferentials = parseFloat(String(helper.final_report.differential.summary.total_with_vat).replace(/[â‚ª,]/g, '')) || 0;
      }
      // Fallback to DOM elements if helper data not available
      else {
        const totalDiffField = document.getElementById('totalDifferentialsWithVAT');
        if (totalDiffField && totalDiffField.textContent) {
          totalDifferentials = parseFloat(String(totalDiffField.textContent).replace(/[â‚ª,]/g, '')) || 0;
        }
      }
      
      // 3. AFTER DIFFERENTIALS: Before Differentials - Total Differentials  
      const afterDifferentials = beforeDifferentials - totalDifferentials;
      
      // Update "Before Differentials" field (×œ×¤× ×™ ×”×¤×¨×©×™×)
      const beforeField = document.getElementById('sumTotalGlobal');
      if (beforeField) {
        beforeField.value = `â‚ª${beforeDifferentials.toLocaleString()}`;
        beforeField.style.backgroundColor = '#e8f5e8'; // Show it's calculated
      }
      
      
      // Update helper structure
      if (!helper.final_report) helper.final_report = {};
      if (!helper.final_report.summary) helper.final_report.summary = {};
      helper.final_report.summary.global_before_differentials = `â‚ª${beforeDifferentials.toLocaleString()}`;
      helper.final_report.summary.global_after_differentials = `â‚ª${afterDifferentials.toLocaleString()}`;
      
      console.log(`Global calculation: Before=${totalClaim} + ${depCompensation} = ${beforeDifferentials}, After=${beforeDifferentials} - ${totalDifferentials} = ${afterDifferentials}`);
      console.log(`Total differentials source: helper.final_report.differential.summary.total_with_vat = ${totalDifferentials}`);
      return { beforeDifferentials, afterDifferentials };
    }
    
    // FIELD VALUE HELPER WITH RETRY MECHANISM AND HELPER FALLBACK
    function getFieldValueWithRetry(fieldId, maxRetries = 3, delayMs = 100) {
      return new Promise((resolve) => {
        let attempts = 0;
        
        function attemptGetValue() {
          attempts++;
          console.log(`ğŸ”„ Attempt ${attempts}/${maxRetries} to get value for ${fieldId}`);
          
          const field = document.getElementById(fieldId);
          console.log(`ğŸ” Field check - exists: ${!!field}, hasValue: ${!!(field && field.value)}, value: "${field?.value}"`);
          
          if (field && field.value && field.value.trim() !== '') {
            const rawValue = field.value || '';
            const cleanValue = rawValue.replace(/[â‚ª,]/g, '');
            const parsedValue = parseFloat(cleanValue) || 0;
            if (parsedValue > 0) {
              console.log(`âœ… Successfully got ${fieldId} DOM value: ${parsedValue}`);
              resolve(parsedValue);
              return;
            }
          }
          
          if (attempts < maxRetries) {
            console.log(`â³ Retrying ${fieldId} in ${delayMs}ms...`);
            setTimeout(attemptGetValue, delayMs);
          } else {
            // Final fallback: try to get value from helper data
            console.log(`ğŸ”„ Trying helper data fallback for ${fieldId}`);
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const helperKey = getHelperMappingKey ? getHelperMappingKey(fieldId) : null;
            console.log(`ğŸ” Helper fallback - fieldId: ${fieldId}, helperKey: ${helperKey}`);
            
            if (helperKey && helper.final_report?.summary?.[helperKey]) {
              const helperRawValue = helper.final_report.summary[helperKey];
              const helperValue = String(helperRawValue).replace(/[â‚ª,]/g, '');
              const parsedHelper = parseFloat(helperValue) || 0;
              console.log(`âœ… Got ${fieldId} from helper fallback: raw="${helperRawValue}", clean="${helperValue}", parsed=${parsedHelper}`);
              resolve(parsedHelper);
            } else {
              console.warn(`âŒ Failed to get valid value for ${fieldId} after ${maxRetries} attempts and helper fallback`);
              console.log(`ğŸ” Helper debug - helperKey exists: ${!!helperKey}, helper.final_report exists: ${!!helper.final_report}, helper.final_report.summary exists: ${!!helper.final_report?.summary}`);
              if (helperKey && helper.final_report?.summary) {
                console.log(`ğŸ” Available helper keys: ${Object.keys(helper.final_report.summary)}`);
              }
              resolve(0);
            }
          }
        }
        
        attemptGetValue();
      });
    }
    
    // TEST FUNCTION FOR FIELD VALUE READING FIX
    async function testFieldValueReading() {
      console.log('ğŸ§ª Testing field value reading fix...');
      
      // Test the retry mechanism
      const testValue = await getFieldValueWithRetry('saleValueDamage');
      console.log(`ğŸ§ª Test result: saleValueDamage = ${testValue}`);
      
      // Test helper data access
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const helperValue = helper.final_report?.summary?.sale_value_damaged;
      console.log(`ğŸ§ª Helper data: helper.final_report.summary.sale_value_damaged = ${helperValue}`);
      
      // Test DOM element access
      const field = document.getElementById('saleValueDamage');
      console.log(`ğŸ§ª DOM element: exists=${!!field}, value="${field?.value}", type="${field?.type}"`);
      
      return { testValue, helperValue, domExists: !!field };
    }
    
    // Expose test function globally for debugging
    window.testFieldValueReading = testFieldValueReading;
    
    // DAMAGED SALE REPORT CALCULATION (Based on User Mapping) - ASYNC WITH RETRY
    async function calculateDamagedSaleReport(helper, marketValue) {
      console.log('ğŸ“Š Calculating Damaged Sale Report');
      
      // 1. Auto-populate market value for Damaged Sale variant
      const marketValueField = document.getElementById('sumMarketValueDamage');
      if (marketValueField) {
        marketValueField.value = `â‚ª${marketValue.toLocaleString()}`;
        marketValueField.style.backgroundColor = '#e8f5e8'; // Show it's auto-populated
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.summary) helper.final_report.summary = {};
        helper.final_report.summary.market_value_damage = marketValueField.value;
      }
      
      // 2. Get sale value from manual input with retry mechanism - ENHANCED WITH VALIDATION
      console.log('ğŸ” Starting field value retrieval for saleValueDamage');
      const saleValue = await getFieldValueWithRetry('saleValueDamage');
      console.log(`ğŸ“‹ Final sale value used in calculation: ${saleValue}`);
      
      // 3. Calculation: Market Value - Sale Value (from user mapping)
      const calculatedTotal = marketValue - saleValue;
      
      // 4. Update total field
      const totalField = document.getElementById('afterSaleDamage');
      if (totalField) {
        totalField.value = `â‚ª${calculatedTotal.toLocaleString()}`;
        totalField.style.backgroundColor = '#e8f5e8'; // Show it's calculated
        helper.final_report.summary.total_after_sale_damage = totalField.value;
      }
      
      console.log(`Damage sale calculation: Market Value=${marketValue}, Sale Value=${saleValue}, Total=${calculatedTotal}`);
      return calculatedTotal;
    }
    
    // TOTAL LOSS REPORT CALCULATION (Based on User Mapping)
    function calculateTotalLossReport(helper, marketValue) {
      console.log('ğŸ“Š Calculating Total Loss Report');
      
      // Get manual input values (user specified as manual inputs)
      const salvageField = document.getElementById('salvageValueTotal');
      const storageField = document.getElementById('storageValueTotal');
      
      const salvageValue = salvageField ? parseFloat(salvageField.value.replace(/[â‚ª,]/g, '') || '0') : 0;
      const storageValue = storageField ? parseFloat(storageField.value.replace(/[â‚ª,]/g, '') || '0') : 0;
      
      // Calculation: Market Value - Salvage + Storage/Towing (from user mapping)
      const calculatedTotal = marketValue - salvageValue + storageValue;
      
      // Update UI fields
      const totalField = document.getElementById('afterSaleTotal');
      if (totalField) {
        totalField.value = `â‚ª${calculatedTotal.toLocaleString()}`;
        helper.final_report.summary.total_after_salvage_total = totalField.value;
      }
      
      console.log(`Total loss calculation: ${marketValue} - ${salvageValue} + ${storageValue} = ${calculatedTotal}`);
    }
    
    // LEGAL LOSS REPORT CALCULATION (Based on User Mapping)
    function calculateLegalLossReport(helper, marketValue) {
      console.log('ğŸ“Š Calculating Legal Loss Report');
      
      // Load salvage field from helper if empty (same logic as refreshSummary)
      const salvageField = document.getElementById('salvageValueLegal');
      if (salvageField && !salvageField.value && helper.final_report?.summary?.salvage_value_legal) {
        salvageField.value = helper.final_report.summary.salvage_value_legal;
        console.log(`ğŸ“¥ Loaded salvage legal value from helper in calculateLegalLossReport: ${salvageField.value}`);
      }
      
      // Get salvage value from manual input (user specified as manual)
      const salvageValue = salvageField ? parseFloat(salvageField.value.replace(/[â‚ª,]/g, '') || '0') : 0;
      
      // Calculation: Market Value - Salvage Value (from user mapping)
      const calculatedTotal = marketValue - salvageValue;
      
      // Update UI fields
      const totalField = document.getElementById('afterSaleLegal');
      if (totalField) {
        totalField.value = `â‚ª${calculatedTotal.toLocaleString()}`;
        helper.final_report.summary.total_after_salvage_legal = totalField.value;
      }
      
      console.log(`ğŸ§® Legal loss calculation: â‚ª${marketValue.toLocaleString()} - â‚ª${salvageValue.toLocaleString()} = â‚ª${calculatedTotal.toLocaleString()}`);
    }
    
    // ENHANCED MANUAL INPUT FIELD LISTENERS - Real-time persistence and calculations
    function addManualInputFieldListeners() {
      console.log('ğŸ”— Setting up enhanced manual input field listeners');
      
      // Manual input fields for all 5 report variants
      const manualInputFields = [
        // Damaged Sale variant
        'saleValueDamage',
        
        // Total Loss variant
        'salvageValueTotal',
        'storageValueTotal', 
        
        // Legal Loss variant
        'salvageValueLegal',
        
        // Common fields that might be manually adjusted
        'salvageValue'
      ];
      
      // Add listeners to all manual input fields
      manualInputFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field) {
          // Input event for real-time updates
          field.addEventListener('input', function() {
            console.log(`ğŸ“ Manual field change: ${fieldId} = ${this.value}`);
            
            // Update helper immediately using comprehensive mapping
            updateHelperFromManualField(fieldId, this.value);
            
            // Trigger real-time calculations
            calculateSummaryTotals();
          });
          
          // Change event for when user finishes editing
          field.addEventListener('change', function() {
            console.log(`âœ… Manual field completed: ${fieldId} = ${this.value}`);
            
            // Save to sessionStorage
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            sessionStorage.setItem('helper', JSON.stringify(helper));
          });
          
          // Focus/blur events for user experience
          field.addEventListener('focus', function() {
            this.style.borderColor = '#007bff';
            this.style.boxShadow = '0 0 0 0.2rem rgba(0, 123, 255, 0.25)';
          });
          
          field.addEventListener('blur', function() {
            this.style.borderColor = '';
            this.style.boxShadow = '';
          });
          
          console.log(`âœ… Listeners added to manual field: ${fieldId}`);
        }
      });
    }
    
    // Update helper from manual field using comprehensive mapping
    function updateHelperFromManualField(fieldId, value) {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      helper.final_report = helper.final_report || {};
      helper.final_report.summary = helper.final_report.summary || {};
      
      // Get the helper key using our comprehensive mapping
      const mappingKey = getHelperMappingKey(fieldId);
      if (mappingKey) {
        helper.final_report.summary[mappingKey] = value;
        console.log(`ğŸ“Š Updated helper: ${mappingKey} = ${value}`);
        
        // Update window.helper for immediate access
        window.helper = helper;
      } else {
        console.warn(`âš ï¸ No mapping found for manual field: ${fieldId}`);
      }
    }
    
    // Real-time field synchronization across all variants
    function synchronizeSummaryFields() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Auto-populate fields that should sync across variants
      const marketValue = helper.calculations?.full_market_value || 0;
      if (marketValue > 0) {
        const marketValueFields = ['sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 'sumMarketValueTotal', 'sumMarketValueLegal'];
        marketValueFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field && !field.value) { // Only update if empty
            field.value = `â‚ª${marketValue.toLocaleString()}`;
          }
        });
      }
    }
    
    // CRITICAL FIX: Initialize Summary Fields and Manual Inputs
    function initializeSummaryFieldsFix() {
      console.log('ğŸš¨ CRITICAL FIX: Initializing summary fields and manual inputs');
      
      try {
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // TASK 1: Fix market value auto-population - Direct mapping from calculations.full_market_value
        const marketValue = helper.calculations?.full_market_value || 0;
        
        if (marketValue > 0) {
          console.log(`ğŸ’° Found market value: â‚ª${marketValue.toLocaleString()} (source: ${
            helper.calculations?.full_market_value ? 'calculations.full_market_value' :
            helper.valuation?.calculations?.full_price?.total ? 'valuation.calculations.full_price.total' :
            'levi_report.final_price'
          })`);
          
          // Populate ALL market value fields across variants
          const allMarketFields = [
            'sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 
            'sumMarketValueTotal', 'sumMarketValueLegal', 'sumMarketValuePrivate',
            'sumMarketValueDefault'
          ];
          
          allMarketFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
              field.value = `â‚ª${marketValue.toLocaleString()}`;
              field.style.backgroundColor = '#e8f5e8'; // Show it's auto-populated
              console.log(`âœ… Populated ${fieldId} with â‚ª${marketValue.toLocaleString()}`);
            }
          });
          
          // Update helper structure using consolidated key
          if (!helper.final_report) helper.final_report = {};
          if (!helper.final_report.summary) helper.final_report.summary = {};
          helper.final_report.summary.market_value = `â‚ª${marketValue.toLocaleString()}`;
          
        } else {
          console.warn('âš ï¸ No market value found in helper');
        }
        
        // TASK 2: Fix Total Claim field population for ALL variants
        // Extract numeric value from total_claim which may be formatted
        let totalClaim = 0;
        if (helper.claims_data?.total_claim) {
          totalClaim = parseFloat(String(helper.claims_data.total_claim).replace(/[â‚ª,]/g, '')) || 0;
        } else if (helper.damage_centers_summary?.total_cost) {
          totalClaim = parseFloat(String(helper.damage_centers_summary.total_cost).replace(/[â‚ª,]/g, '')) || 0;
        } else if (helper.calculations?.total_damage) {
          totalClaim = parseFloat(String(helper.calculations.total_damage).replace(/[â‚ª,]/g, '')) || 0;
        } else if (helper.damage_assessment?.totals?.Total_with_VAT) {
          totalClaim = parseFloat(String(helper.damage_assessment.totals.Total_with_VAT).replace(/[â‚ª,]/g, '')) || 0;
        }
        
        if (totalClaim > 0) {
          console.log(`ğŸ’° Found total claim: â‚ª${totalClaim.toLocaleString()}`);
          
          // Populate ALL total claim fields across variants  
          const allClaimFields = [
            'sumClaim',          // Static Private report
            'sumClaimPrivate',   // Dynamic Private report  
            'sumClaimGlobal',    // Dynamic Global report (FIXED)
            'sumClaimDefault'    // Dynamic Default report
          ];
          
          allClaimFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
              field.value = `â‚ª${totalClaim.toLocaleString()}`;
              field.style.backgroundColor = '#e8f5e8'; // Show it's auto-populated
              console.log(`âœ… Populated ${fieldId} with â‚ª${totalClaim.toLocaleString()}`);
            } else {
              // Field doesn't exist - this is normal for variant-specific fields
            }
          });
          
          // Update helper structure using consolidated key
          if (!helper.final_report) helper.final_report = {};
          if (!helper.final_report.summary) helper.final_report.summary = {};
          helper.final_report.summary.total_claim = `â‚ª${totalClaim.toLocaleString()}`;
          
        } else {
          console.warn('âš ï¸ No total claim found in helper');
        }
        
        // TASK 3: Fix Depreciation Compensation field population for ALL variants
        // Extract numeric value from globalDep1 which contains formatted value like "1,972â‚ª"
        let depCompensation = 0;
        if (helper.depreciation?.globalDepValue) {
          depCompensation = parseFloat(String(helper.depreciation.globalDepValue).replace(/[â‚ª,]/g, '')) || 0;
        } else if (helper.depreciation?.globalDep1) {
          depCompensation = parseFloat(String(helper.depreciation.globalDep1).replace(/[â‚ª,%]/g, '')) || 0;
        } else if (helper.depreciation?.total_compensation) {
          depCompensation = parseFloat(String(helper.depreciation.total_compensation).replace(/[â‚ª,]/g, '')) || 0;
        }
        
        if (depCompensation > 0) {
          console.log(`ğŸ’° Found depreciation compensation: â‚ª${depCompensation.toLocaleString()}`);
          
          // Populate ALL depreciation compensation fields across variants  
          const allDepFields = [
            'depCompensation',        // Static Private report
            'depCompensationPrivate', // Dynamic Private report  
            'depCompensationGlobal',  // Global report
            'sumDepreciation',        // Global dynamic report
            'sumDepreciationDefault'  // Default report
          ];
          
          allDepFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
              field.value = `â‚ª${depCompensation.toLocaleString()}`;
              field.style.backgroundColor = '#e8f5e8'; // Show it's auto-populated
              console.log(`âœ… Populated ${fieldId} with â‚ª${depCompensation.toLocaleString()}`);
            } else {
              // Field doesn't exist - this is normal for variant-specific fields
            }
          });
          
          // Update helper structure using consolidated key
          if (!helper.final_report) helper.final_report = {};
          if (!helper.final_report.summary) helper.final_report.summary = {};
          helper.final_report.summary.depreciation_compensation = `â‚ª${depCompensation.toLocaleString()}`;
          
        } else {
          console.warn('âš ï¸ No depreciation compensation found in helper');
        }
        
        // TASK 4: Ensure manual input fields are enabled and working
        const manualInputFields = [
          'saleValueDamage',    // ×¢×¨×š ×”××›×™×¨×” ×‘××¦×‘×• ×”× ×™×–×•×§
          'salvageValueTotal',  // ×¢×¨×š ×©×¨×™×“×™ ×”×¨×›×‘ (Total Loss)
          'salvageValueLegal',  // ×¢×¨×š ×©×¨×™×“×™ ×”×¨×›×‘ (Legal Loss)
          'storageValueTotal',  // ×ª×•×¡×¤×ª ×’×¨×™×¨×” ×•××—×¡× ×”
          'salvageValue'        // General salvage value
        ];
        
        manualInputFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            console.log(`ğŸ”§ Processing manual field: ${fieldId}`, field);
            
            // Remove any readonly attributes
            field.removeAttribute('readonly');
            field.removeAttribute('disabled');
            
            // Ensure the field is editable
            field.style.backgroundColor = 'white';
            field.style.color = '#333';
            field.style.cursor = 'text';
            field.contentEditable = false; // Fix: contentEditable should be false for input elements
            
            // Ensure proper input attributes
            field.type = 'text';
            field.style.pointerEvents = 'auto';
            field.readOnly = false;
            
            // Add placeholder if empty
            if (!field.placeholder) {
              field.placeholder = '×”×–×Ÿ ×¢×¨×š...';
            }
            
            // Test typing capability
            if (!field.hasAttribute('data-typing-enabled')) {
              field.setAttribute('data-typing-enabled', 'true');
              
              // Test if field accepts input
              setTimeout(() => {
                field.focus();
                field.value = 'test';
                if (field.value === 'test') {
                  field.value = ''; // Clear test
                  console.log(`âœ… ${fieldId} accepts input successfully`);
                } else {
                  console.error(`âŒ ${fieldId} CANNOT accept input - investigating...`);
                  // Force clear all potential blockers
                  field.removeAttribute('readonly');
                  field.removeAttribute('disabled'); 
                  field.readOnly = false;
                  field.disabled = false;
                  field.style.pointerEvents = 'auto';
                  field.style.userSelect = 'text';
                  field.contentEditable = false;
                }
              }, 100);
              
              // Add enhanced event listeners
              field.addEventListener('input', function(e) {
                console.log(`ğŸ“ ${fieldId} input: ${e.target.value}`);
                updateHelperFromManualField(fieldId, e.target.value);
                calculateSummaryTotals();
                
                // Trigger Damaged Sale calculation if this is the sale value field
                if (fieldId === 'saleValueDamage') {
                  const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[â‚ª,]/g, '')) || 0;
                  calculateDamagedSaleReport(helper, marketValue).catch(console.error);
                }
              });
              
              field.addEventListener('focus', function(e) {
                console.log(`ğŸ¯ ${fieldId} focused`);
                e.target.style.borderColor = '#007bff';
                e.target.style.boxShadow = '0 0 0 0.2rem rgba(0, 123, 255, 0.25)';
              });
              
              field.addEventListener('blur', function(e) {
                e.target.style.borderColor = '';
                e.target.style.boxShadow = '';
                console.log(`ğŸ’¾ ${fieldId} saved: ${e.target.value}`);
              });
              
              console.log(`âœ… Manual input field enabled: ${fieldId}`);
            }
          } else {
            // Field doesn't exist - this is normal for variant-specific fields
          }
        });
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        // Trigger calculations and private report total calculation
        setTimeout(() => {
          calculateSummaryTotals();
          
          // NOTE: Removed all duplicate calculation function calls to prevent overrides
          // All calculations are now handled centrally by calculateSummaryTotals() based on selected report type
          // This prevents race conditions and duplicate calculations that were overriding correct values
        }, 500);
        
        console.log('âœ… CRITICAL FIX: Summary fields initialization completed');
        
      } catch (error) {
        console.error('âŒ CRITICAL FIX ERROR:', error);
      }
    }
    
    // HELPER DATA PERSISTENCE SAFEGUARDS
    function initializeHelperDataSafeguards() {
      console.log('ğŸ›¡ï¸ Initializing helper data persistence safeguards');
      
      try {
        // Create backup of helper data every time it changes
        const originalSetItem = sessionStorage.setItem;
        sessionStorage.setItem = function(key, value) {
          if (key === 'helper') {
            try {
              const helperData = JSON.parse(value);
              if (helperData && Object.keys(helperData).length > 0) {
                // Create backup with timestamp
                const backupKey = `helper_backup_${Date.now()}`;
                sessionStorage.setItem(backupKey, value);
                
                // Keep only last 3 backups
                const backupKeys = [];
                for (let i = 0; i < sessionStorage.length; i++) {
                  const storageKey = sessionStorage.key(i);
                  if (storageKey && storageKey.startsWith('helper_backup_')) {
                    backupKeys.push(storageKey);
                  }
                }
                
                // Sort by timestamp and remove old backups
                backupKeys.sort().slice(0, -3).forEach(oldBackup => {
                  sessionStorage.removeItem(oldBackup);
                });
                
                console.log('ğŸ’¾ Helper backup created:', backupKey);
              }
            } catch (e) {
              console.warn('âš ï¸ Could not backup helper data:', e);
            }
          }
          
          // Call original setItem
          return originalSetItem.call(this, key, value);
        };
        
        // Recovery function
        window.recoverHelperData = function() {
          const backupKeys = [];
          for (let i = 0; i < sessionStorage.length; i++) {
            const key = sessionStorage.key(i);
            if (key && key.startsWith('helper_backup_')) {
              backupKeys.push(key);
            }
          }
          
          if (backupKeys.length > 0) {
            // Get the most recent backup
            const latestBackup = backupKeys.sort().pop();
            const backupData = sessionStorage.getItem(latestBackup);
            
            if (backupData) {
              sessionStorage.setItem('helper', backupData);
              window.helper = JSON.parse(backupData);
              console.log('ğŸ”„ Helper data recovered from backup:', latestBackup);
              
              // Refresh the page to reload the data
              if (confirm('Helper data recovered! Refresh page to see changes?')) {
                location.reload();
              }
              return true;
            }
          }
          
          console.warn('âš ï¸ No helper backup found');
          return false;
        };
        
        // Add recovery button to console
        console.log('ğŸ†˜ To recover helper data, run: window.recoverHelperData()');
        
        // Check if helper data is empty and offer recovery
        const currentHelper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        const helperKeys = Object.keys(currentHelper);
        
        if (helperKeys.length < 3) { // Helper seems empty or minimal
          console.warn('âš ï¸ Helper data appears to be cleared or minimal');
          console.log('ğŸ” Current helper keys:', helperKeys);
          
          // Try to recover automatically
          setTimeout(() => {
            if (window.recoverHelperData) {
              console.log('ğŸš¨ Attempting automatic helper data recovery...');
              window.recoverHelperData();
            }
          }, 1000);
        }
        
        console.log('âœ… Helper data safeguards initialized');
        
      } catch (error) {
        console.error('âŒ Error initializing helper safeguards:', error);
      }
    }
    
    // COMPREHENSIVE TESTING SYSTEM FOR ALL 5 REPORT VARIANTS
    function testSummaryFieldMappings() {
      console.log('ğŸ§ª Starting comprehensive summary field mapping tests...');
      
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const testResults = {
        passed: 0,
        failed: 0,
        details: []
      };
      
      // Test 1: Comprehensive Mapping Dictionary
      const mappingTest = testComprehensiveMapping();
      testResults.details.push(mappingTest);
      mappingTest.passed ? testResults.passed++ : testResults.failed++;
      
      // Test 2: Auto-population System
      const autoPopTest = testAutoPopulation();
      testResults.details.push(autoPopTest);
      autoPopTest.passed ? testResults.passed++ : testResults.failed++;
      
      // Test 3: Manual Input Persistence
      const persistenceTest = testManualInputPersistence();
      testResults.details.push(persistenceTest);
      persistenceTest.passed ? testResults.passed++ : testResults.failed++;
      
      // Test 4: Variant-specific Calculations
      const calcTest = testVariantCalculations();
      testResults.details.push(calcTest);
      calcTest.passed ? testResults.passed++ : testResults.failed++;
      
      // Test 5: Helper Structure Integrity
      const helperTest = testHelperStructure();
      testResults.details.push(helperTest);
      helperTest.passed ? testResults.passed++ : testResults.failed++;
      
      // Display results
      console.log(`ğŸ§ª Test Results: ${testResults.passed} passed, ${testResults.failed} failed`);
      testResults.details.forEach(test => {
        const icon = test.passed ? 'âœ…' : 'âŒ';
        console.log(`${icon} ${test.name}: ${test.message}`);
      });
      
      return testResults;
    }
    
    function testComprehensiveMapping() {
      const requiredFields = [
        'sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 
        'sumMarketValueTotal', 'sumMarketValueLegal', 'saleValueDamage',
        'salvageValueTotal', 'storageValueTotal', 'salvageValueLegal'
      ];
      
      const missingMappings = requiredFields.filter(fieldId => !getHelperMappingKey(fieldId));
      
      return {
        name: 'Comprehensive Mapping Dictionary',
        passed: missingMappings.length === 0,
        message: missingMappings.length === 0 ? 
          'All fields have proper mappings' : 
          `Missing mappings for: ${missingMappings.join(', ')}`
      };
    }
    
    function testAutoPopulation() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const marketValue = helper.calculations?.full_market_value || 0;
      
      if (marketValue === 0) {
        return {
          name: 'Auto-population System',
          passed: false,
          message: 'No market value found in helper.calculations.full_market_value'
        };
      }
      
      const marketFields = document.querySelectorAll('#sumMarketValue, #sumMarketValueGlobal');
      const populatedFields = Array.from(marketFields).filter(field => field.value.includes(marketValue.toLocaleString()));
      
      return {
        name: 'Auto-population System',
        passed: populatedFields.length > 0,
        message: populatedFields.length > 0 ? 
          'Market value fields are properly auto-populated' :
          'Market value auto-population failed'
      };
    }
    
    function testManualInputPersistence() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const summaryExists = helper.final_report?.summary;
      
      if (!summaryExists) {
        return {
          name: 'Manual Input Persistence',
          passed: false,
          message: 'helper.final_report.summary structure not initialized'
        };
      }
      
      // Test if manual fields have mappings in helper
      const manualFields = ['saleValueDamage', 'paymentMethod', 'salvageValueTotal', 'storageValueTotal', 'salvageValueLegal'];
      const mappedFields = manualFields.filter(fieldId => {
        const key = getHelperMappingKey(fieldId);
        return key && helper.final_report.summary.hasOwnProperty(key);
      });
      
      return {
        name: 'Manual Input Persistence',
        passed: mappedFields.length >= manualFields.length / 2,
        message: `${mappedFields.length}/${manualFields.length} manual fields properly mapped`
      };
    }
    
    function testVariantCalculations() {
      // Test calculation functions exist
      const calcFunctions = [
        'calculatePrivateReport',
        'calculateGlobalReport', 
        'calculateDamagedSaleReport',
        'calculateTotalLossReport',
        'calculateLegalLossReport'
      ];
      
      const existingFunctions = calcFunctions.filter(funcName => typeof window[funcName] === 'function');
      
      return {
        name: 'Variant-specific Calculations',
        passed: existingFunctions.length === calcFunctions.length,
        message: `${existingFunctions.length}/${calcFunctions.length} calculation functions available`
      };
    }
    
    function testHelperStructure() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      const requiredStructures = [
        'final_report',
        'final_report.summary'
      ];
      
      const existingStructures = requiredStructures.filter(path => {
        return path.split('.').reduce((obj, key) => obj && obj[key], helper) !== undefined;
      });
      
      return {
        name: 'Helper Structure Integrity',
        passed: existingStructures.length === requiredStructures.length,
        message: `${existingStructures.length}/${requiredStructures.length} required structures present`
      };
    }
    
    // Depreciation functionality 
    function addDepreciationRow() {
      alert('×”×•×¡×£ ×©×•×¨×ª ×™×¨×™×“×ª ×¢×¨×š - ×™×˜×¢×Ÿ ×¢× ××•×“×•×œ depreciation_module.js');
    }
    
    // Real differential row functionality
    // SESSION 47: SIMPLIFIED INVOICE DIFFERENTIAL ROW (NO VAT, NO DAMAGE CENTER)
    function createDifferentialRow(data = {}) {
      const div = document.createElement('div');
      div.className = 'differential-row';
      div.style.marginBottom = '20px';
      div.style.padding = '15px';
      div.style.background = '#f8fafc';
      div.style.borderRadius = '8px';
      div.style.border = '1px solid #e2e8f0';
      
      const amount = data.amount_without_vat || data.amount || 0;
      
      console.log('ğŸ” SESSION 47: Creating differential row with data:', data);

      div.innerHTML = `
        <!-- Row 1: Details (3 fields) - Responsive -->
        <div class="diff-details-row" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px;">
          <div>
            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">×—×œ×§</label>
            <select class="diff-part-dropdown" onchange="handlePartSelection(this)" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px; background: white;">
              <option value="">×‘×—×¨ ×¤×¨×™×˜ ××”×—×©×‘×•× ×™×ª ×”× ×‘×—×¨×ª...</option>
            </select>
            <input type="hidden" class="diff-part" value="${data.part || ''}">
          </div>
          <div>
            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">××”×•×ª ×”×”×¤×¨×©</label>
            <select class="diff-nature-dropdown" onchange="toggleNatureOtherField(this)" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px; margin-bottom: 5px;">
              <option value="">×‘×—×¨ ××”×•×ª</option>
              <option value="parts" ${data.nature === 'parts' ? 'selected' : ''}>×—×œ×§×™×</option>
              <option value="works" ${data.nature === 'works' ? 'selected' : ''}>×¢×‘×•×“×•×ª</option>
              <option value="repairs" ${data.nature === 'repairs' ? 'selected' : ''}>×ª×™×§×•× ×™×</option>
              <option value="other" ${data.nature && !['parts', 'works', 'repairs'].includes(data.nature) ? 'selected' : ''}>××—×¨</option>
            </select>
            <input type="text" class="diff-nature-other" placeholder="×¤×¨×˜ ××”×•×ª ××—×¨×ª" value="${data.nature && !['parts', 'works', 'repairs'].includes(data.nature) ? data.nature : ''}" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px; display: ${data.nature && !['parts', 'works', 'repairs'].includes(data.nature) ? 'block' : 'none'};">
            <input type="hidden" class="diff-nature" value="${data.nature || ''}">
          </div>
          <div>
            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">×¡×™×‘×ª ×”×”×¤×¨×©</label>
            <input type="text" class="diff-reason" placeholder="×”×–×Ÿ ×¡×™×‘×”" value="${data.reason || ''}" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px;">
          </div>
        </div>
        
        <!-- Row 2: Amount (1 field) - Responsive -->
        <div class="diff-costs-row" style="display: grid; grid-template-columns: 1fr; gap: 10px;">
          <div>
            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">×¡×›×•× (×œ×œ× ××¢×´×)</label>
            <input type="number" class="diff-amount" placeholder="0" value="${amount}" onchange="updateDifferentialsSummary()" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px;">
          </div>
        </div>
        
        <!-- Remove button -->
        <div style="text-align: center; margin-top: 15px;">
          <button type="button" class="btn-remove" style="background:#ef4444; color:white; border:none; padding:8px 16px; border-radius:6px; cursor:pointer; font-size:14px; transition: all 0.2s;">ğŸ—‘ï¸ ×”×¡×¨ ×”×¤×¨×©</button>
        </div>
        
        <!-- Mobile-specific CSS -->
        <style>
          @media (max-width: 768px) {
            .diff-details-row, .diff-costs-row {
              grid-template-columns: 1fr !important;
              gap: 15px !important;
            }
            .differential-row {
              padding: 12px !important;
              margin-bottom: 15px !important;
            }
            .diff-details-row input, .diff-costs-row input {
              padding: 12px !important;
              font-size: 16px !important; /* Prevents zoom on iOS */
            }
          }
          
          @media (max-width: 480px) {
            .diff-details-row, .diff-costs-row {
              gap: 10px !important;
            }
            .differential-row {
              padding: 10px !important;
            }
          }
        </style>
      `;
      
      // SESSION 47: Add event listeners (simplified - no VAT calculations)
      const amountInput = div.querySelector('.diff-amount');
      const removeBtn = div.querySelector('.btn-remove');
      
      amountInput.addEventListener('input', function() {
        updateDifferentialsSummary();
        setTimeout(saveDifferentialsToHelper, 100);
      });
      
      // Add auto-save to text inputs with delay to ensure data is captured
      setTimeout(() => {
        const partField = div.querySelector('.diff-part');
        const natureDropdown = div.querySelector('.diff-nature-dropdown');
        const natureOtherField = div.querySelector('.diff-nature-other');
        const reasonField = div.querySelector('.diff-reason');
        
        console.log('ğŸ”— SESSION 47: ATTACHING EVENT LISTENERS:', {
          partField: !!partField,
          natureDropdown: !!natureDropdown,
          natureOtherField: !!natureOtherField,
          reasonField: !!reasonField
        });
        
        if (partField) {
          partField.addEventListener('input', (e) => {
            console.log('ğŸ”¥ PART INPUT EVENT:', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (natureDropdown) {
          natureDropdown.addEventListener('change', (e) => {
            console.log('ğŸ”¥ NATURE DROPDOWN EVENT:', e.target.value);
            toggleNatureOtherField(e.target);
          });
        }
        
        if (natureOtherField) {
          natureOtherField.addEventListener('input', (e) => {
            console.log('ğŸ”¥ NATURE OTHER INPUT EVENT:', e.target.value);
            const hiddenField = div.querySelector('.diff-nature');
            if (hiddenField) hiddenField.value = e.target.value;
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (reasonField) {
          reasonField.addEventListener('input', (e) => {
            console.log('ğŸ”¥ REASON INPUT EVENT:', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
      }, 50);
      
      removeBtn.addEventListener('click', function() {
        div.remove();
        updateDifferentialsSummary();
        setTimeout(saveDifferentialsToHelper, 100);
      });
      
      // SESSION 88: Populate invoice lines dropdown after creating the row
      setTimeout(() => {
        populateInvoiceLinesDropdown(div);
      }, 100);
      
      return div;
    }

    // ============================================================================
    // SESSION 88: INVOICE LINES INTEGRATION FOR DIFFERENTIALS
    // ============================================================================

    /**
     * Populate invoice lines dropdown in a differential row
     */
    async function populateInvoiceLinesDropdown(rowElement) {
      try {
        const dropdown = rowElement.querySelector('.diff-invoice-line');
        if (!dropdown) return;

        console.log('ğŸ“‹ SESSION 88: Populating invoice lines dropdown...');

        // Get invoice lines from multiple sources
        const invoiceLines = await getInvoiceLinesForCase();
        
        if (!invoiceLines || invoiceLines.length === 0) {
          dropdown.innerHTML = '<option value="">××™×Ÿ ×—×©×‘×•× ×™×•×ª ×–××™× ×•×ª</option>';
          console.log('â„¹ï¸ SESSION 88: No invoice lines found');
          return;
        }

        // Build dropdown options
        let optionsHTML = '<option value="">×‘×—×¨ ×¤×¨×™×˜ ××—×©×‘×•× ×™×ª...</option>';
        
        invoiceLines.forEach((line, index) => {
          const displayText = `${line.invoice_number || '×—×©×‘×•× ×™×ª'} - ${line.description || '×¤×¨×™×˜'} (â‚ª${(line.line_total || 0).toLocaleString()})`;
          optionsHTML += `<option value="${index}" data-line='${JSON.stringify(line)}'>${displayText}</option>`;
        });

        dropdown.innerHTML = optionsHTML;
        console.log(`âœ… SESSION 88: Populated dropdown with ${invoiceLines.length} invoice lines`);

      } catch (error) {
        console.error('âŒ SESSION 88: Error populating invoice lines dropdown:', error);
        const dropdown = rowElement.querySelector('.diff-invoice-line');
        if (dropdown) {
          dropdown.innerHTML = '<option value="">×©×’×™××” ×‘×˜×¢×™× ×ª ×—×©×‘×•× ×™×•×ª</option>';
        }
      }
    }

    /**
     * Get invoice lines for the current case from applied mappings
     */
    async function getInvoiceLinesForCase() {
      try {
        const helper = window.helper || {};
        
        // Use the correct case_id path as specified in CLAUDE.md
        const caseId = helper.case_info?.supabase_case_id;
        
        console.log('ğŸ” SESSION 88 DEBUG: getInvoiceLinesForCase called');
        console.log('  case_id:', caseId);
        console.log('  window.supabase available:', !!window.supabase);
        
        if (!caseId || !window.supabase) {
          console.log('â„¹ï¸ SESSION 88: No case_id or Supabase, cannot get invoice lines');
          return [];
        }
        
        // Query invoice_damage_center_mappings to get applied mappings
        const { data: mappings, error } = await window.supabase
          .from('invoice_damage_center_mappings')
          .select(`
            *,
            invoice:invoices!inner(
              id,
              invoice_number,
              supplier_name
            ),
            invoice_line:invoice_lines!inner(*)
          `)
          .eq('case_id', caseId);
        
        if (error) {
          console.error('âŒ SESSION 88: Error querying mappings:', error);
          return [];
        }
        
        console.log('ğŸ” SESSION 88 DEBUG: Raw mappings data:', mappings);
        console.log('  Number of mappings:', mappings?.length || 0);
        
        if (!mappings || mappings.length === 0) {
          console.log('â„¹ï¸ SESSION 88: No invoice mappings found');
          return [];
        }
        
        // Debug each mapping structure
        mappings.forEach((mapping, index) => {
          console.log(`ğŸ” Mapping ${index}:`, {
            id: mapping.id,
            invoice: mapping.invoice,
            invoice_line: mapping.invoice_line,
            case_id: mapping.case_id
          });
        });
        
        // Convert mappings to invoice lines format
        const allLines = mappings.map(mapping => {
          // Check for missing invoice data
          if (!mapping.invoice) {
            console.warn('âš ï¸ SESSION 88: Missing invoice data in mapping:', mapping.id);
            return null;
          }
          
          return {
            ...mapping.invoice_line,
            invoice_id: mapping.invoice.id,
            invoice_number: mapping.invoice.invoice_number,
            supplier_name: mapping.invoice.supplier_name,
            damage_center_id: mapping.damage_center_id,
            field_type: mapping.field_type,
            mapping_id: mapping.id,
            source: 'applied_mappings'
          };
        }).filter(line => line !== null); // Remove null entries

        console.log(`ğŸ“Š SESSION 88: Found ${allLines.length} invoice lines from applied mappings`);
        return allLines;

      } catch (error) {
        console.error('âŒ SESSION 88: Error getting invoice lines:', error);
        return [];
      }
    }

    /**
     * Populate differential row fields from selected invoice line
     */
    function populateFromInvoiceLine(selectElement) {
      try {
        const selectedIndex = selectElement.value;
        if (!selectedIndex) return;

        const selectedOption = selectElement.options[selectElement.selectedIndex];
        const lineData = JSON.parse(selectedOption.getAttribute('data-line'));
        
        console.log('ğŸ“ SESSION 88: Populating row from invoice line:', lineData);

        const row = selectElement.closest('.differential-row');
        if (!row) return;

        // Populate fields
        const partField = row.querySelector('.diff-part');
        const natureDropdown = row.querySelector('.diff-nature-dropdown');
        const reasonField = row.querySelector('.diff-reason');
        const amountField = row.querySelector('.diff-amount');

        if (partField) {
          partField.value = lineData.description || lineData.part_name || '';
        }

        if (natureDropdown) {
          const category = lineData.metadata?.category || lineData.category;
          if (category === 'part') {
            natureDropdown.value = 'parts';
          } else if (category === 'work') {
            natureDropdown.value = 'works';
          } else if (category === 'repair') {
            natureDropdown.value = 'repairs';
          } else {
            natureDropdown.value = 'other';
          }
          
          // Trigger change event to handle "other" field
          toggleNatureOtherField(natureDropdown);
        }

        if (reasonField) {
          reasonField.value = `×—×©×‘×•× ×™×ª ${lineData.invoice_number} - ${lineData.supplier_name || '×¡×¤×§'}`;
        }

        if (amountField) {
          amountField.value = lineData.line_total || lineData.total_cost || 0;
        }

        // Update calculations
        updateDifferentialsSummary();
        setTimeout(saveDifferentialsToHelper, 100);

        console.log('âœ… SESSION 88: Row populated successfully from invoice line');

      } catch (error) {
        console.error('âŒ SESSION 88: Error populating from invoice line:', error);
      }
    }

    // Make function available globally
    window.populateFromInvoiceLine = populateFromInvoiceLine;
    
    // SESSION 95: Invoice lines population for differentials part dropdown
    function populatePartDropdown(dropdown) {
      dropdown.innerHTML = '<option value="">×‘×—×¨ ×¤×¨×™×˜ ××”×—×©×‘×•× ×™×ª ×”× ×‘×—×¨×ª...</option>';
      
      if (window.INVOICE_LINES && window.INVOICE_LINES.length > 0) {
        window.INVOICE_LINES.forEach((line, index) => {
          const option = document.createElement('option');
          const description = line.description || line.part_name || `×¤×¨×™×˜ ${index + 1}`;
          
          option.text = description;
          option.value = index;
          option.setAttribute('data-line', JSON.stringify(line));
          
          dropdown.appendChild(option);
        });
      }
    }
    
    function populateAllDifferentialRowsWithInvoiceLines() {
      const differentialRows = document.querySelectorAll('#differentialsRows .differential-row');
      
      differentialRows.forEach(row => {
        const dropdown = row.querySelector('.diff-part-dropdown');
        if (dropdown) {
          populatePartDropdown(dropdown);
        }
      });
      
      console.log(`âœ… Updated ${differentialRows.length} differential row part dropdowns with invoice lines`);
    }
    
    function handlePartSelection(selectElement) {
      try {
        const selectedIndex = selectElement.value;
        if (!selectedIndex) return;

        const selectedOption = selectElement.options[selectElement.selectedIndex];
        const lineData = JSON.parse(selectedOption.getAttribute('data-line'));
        
        console.log('ğŸ“ Selected invoice line for part:', lineData);

        const row = selectElement.closest('.differential-row');
        if (!row) return;

        // Update hidden part field and other fields
        const hiddenPartField = row.querySelector('.diff-part');
        const reasonField = row.querySelector('.diff-reason');
        const amountField = row.querySelector('.diff-amount');

        if (hiddenPartField) {
          hiddenPartField.value = lineData.description || lineData.part_name || '';
        }

        if (reasonField) {
          reasonField.value = `×—×©×‘×•× ×™×ª - ${lineData.supplier_name || '×¡×¤×§'}`;
        }

        if (amountField) {
          amountField.value = lineData.line_total || lineData.total_cost || 0;
        }

        // Update calculations
        updateDifferentialsSummary();
        setTimeout(saveDifferentialsToHelper, 100);

        console.log('âœ… Row populated from selected invoice line');

      } catch (error) {
        console.error('âŒ Error handling part selection:', error);
      }
    }
    
    // SESSION 95: Invoice selection for differentials  
    async function loadInvoicesForDifferentialsDropdown() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        const caseId = helper.case_info?.supabase_case_id;
        const plateNumber = helper.case_info?.plate;
        
        if (!caseId || !plateNumber) {
          console.log('âš ï¸ No case ID or plate number for loading invoices');
          return;
        }
        
        const { data: invoices, error } = await window.supabase
          .from('invoices')
          .select('*')
          .eq('case_id', caseId)
          .eq('plate', plateNumber)
          .order('created_at', { ascending: false });
        
        if (error) {
          console.error('âŒ Error loading invoices:', error);
          return;
        }
        
        console.log(`ğŸ“¦ Found ${invoices?.length || 0} invoices for differentials`);
        
        // Populate the dropdown
        const dropdown = document.getElementById('invoiceSelectionForDifferentials');
        if (dropdown && invoices && invoices.length > 0) {
          dropdown.innerHTML = '<option value="">×‘×—×™×¨×ª ×¤×¨×™×˜ ×ª××œ× ××•×˜×•××˜×™×ª ××ª ×›×œ ×”×©×“×•×ª ×‘×©×•×¨×”</option>';
          
          invoices.forEach(invoice => {
            const option = document.createElement('option');
            
            // Get invoice date
            let displayDate;
            if (invoice.invoice_date) {
              displayDate = new Date(invoice.invoice_date).toLocaleDateString('he-IL');
            } else if (invoice.ocr_structured_data && invoice.ocr_structured_data['×ª××¨×™×š']) {
              displayDate = new Date(invoice.ocr_structured_data['×ª××¨×™×š']).toLocaleDateString('he-IL');
            } else {
              displayDate = new Date(invoice.created_at).toLocaleDateString('he-IL');
            }
            
            const supplierName = invoice.supplier_name || '×œ× ×¦×•×™×Ÿ';
            option.text = `${supplierName} - ${displayDate}`;
            option.value = invoice.id;
            option.dataset.invoiceData = JSON.stringify(invoice);
            
            dropdown.appendChild(option);
          });
        }
        
      } catch (error) {
        console.error('âŒ Error in loadInvoicesForDifferentialsDropdown:', error);
      }
    }
    
    async function handleInvoiceSelectionForDifferentials(selectElement) {
      try {
        const selectedValue = selectElement.value;
        if (!selectedValue) {
          // Clear invoice lines when no invoice selected
          window.INVOICE_LINES = [];
          populateAllDifferentialRowsWithInvoiceLines();
          return;
        }
        
        const selectedOption = selectElement.options[selectElement.selectedIndex];
        const invoiceData = JSON.parse(selectedOption.dataset.invoiceData);
        
        console.log('ğŸ“‹ Selected invoice for differentials:', invoiceData.supplier_name);
        
        // Load invoice lines for this specific invoice
        const { data: lines, error } = await window.supabase
          .from('invoice_lines')
          .select('*')
          .eq('invoice_id', invoiceData.id);
        
        if (error) {
          console.error('âŒ Error loading invoice lines:', error);
          return;
        }
        
        console.log(`ğŸ“‹ Loaded ${lines?.length || 0} lines for selected invoice`);
        
        // Update global cache and refresh all differential row dropdowns
        window.INVOICE_LINES = lines || [];
        populateAllDifferentialRowsWithInvoiceLines();
        
      } catch (error) {
        console.error('âŒ Error handling invoice selection:', error);
      }
    }
    
    // Make functions available globally
    window.populatePartDropdown = populatePartDropdown;
    window.handlePartSelection = handlePartSelection;
    window.loadInvoicesForDifferentialsDropdown = loadInvoicesForDifferentialsDropdown;
    window.handleInvoiceSelectionForDifferentials = handleInvoiceSelectionForDifferentials;
    
    // SESSION 47: UPDATE ALL DIFFERENTIALS SUBTOTALS
    function updateAllDifferentialsSubtotals() {
      const breakdown = calculatePartsDifferentialsBreakdown();
      
      // SESSION 48: Calculate category differentials from ×¢×¨×š ×”×”× ×—×” (reduction amounts)
      const categoryRows = document.querySelectorAll('.category-differential-row');
      let categoryReductionTotal = 0;
      categoryRows.forEach(row => {
        const reductionValueField = row.querySelector('.category-diff-category-value');
        const reductionValueText = reductionValueField?.value || 'â‚ª0';
        const reductionValue = parseFloat(reductionValueText.replace(/[â‚ª,]/g, '')) || 0;
        categoryReductionTotal += reductionValue;
      });
      
      const invoiceRows = document.querySelectorAll('.differential-row');
      let invoiceTotal = 0;
      invoiceRows.forEach(row => {
        const amountField = row.querySelector('.diff-amount');
        const amount = parseFloat(amountField?.value) || 0;
        invoiceTotal += amount;
      });
      
      // SESSION 48: Sum of all REDUCTION amounts (not totals after reduction)
      const totalComponentDifferentials = Math.round(breakdown.totalReduction + breakdown.totalWear + categoryReductionTotal);
      const totalInvoiceDiff = Math.round(invoiceTotal);
      const grandTotalWithoutVAT = Math.round(totalComponentDifferentials + totalInvoiceDiff);
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const vatRate = parseFloat(window.helper?.calculations?.vat_rate || helper.calculations?.vat_rate || 18);
      const grandTotalVAT = Math.round(grandTotalWithoutVAT * (vatRate / 100));
      const grandTotalWithVAT = Math.round(grandTotalWithoutVAT + grandTotalVAT);
      
      const componentWearEl = document.getElementById('totalComponentWear');
      const invoiceDiffEl = document.getElementById('totalInvoiceDifferentials');
      const grandTotalWithoutVATEl = document.getElementById('grandTotalDifferentialsWithoutVAT');
      const grandTotalVATEl = document.getElementById('grandTotalDifferentialsVAT');
      const grandTotalWithVATEl = document.getElementById('grandTotalDifferentialsWithVAT');
      
      if (componentWearEl) componentWearEl.textContent = `â‚ª${totalComponentDifferentials.toLocaleString()}`;
      if (invoiceDiffEl) invoiceDiffEl.textContent = `â‚ª${totalInvoiceDiff.toLocaleString()}`;
      if (grandTotalWithoutVATEl) grandTotalWithoutVATEl.textContent = `â‚ª${grandTotalWithoutVAT.toLocaleString()}`;
      if (grandTotalVATEl) grandTotalVATEl.textContent = `â‚ª${grandTotalVAT.toLocaleString()}`;
      if (grandTotalWithVATEl) grandTotalWithVATEl.textContent = `â‚ª${grandTotalWithVAT.toLocaleString()}`;
      
      console.log('ğŸ“Š SESSION 47: Updated subtotals - Component: â‚ª', totalComponentDifferentials, ', Invoice: â‚ª', totalInvoiceDiff, ', Grand (no VAT): â‚ª', grandTotalWithoutVAT, ', VAT: â‚ª', grandTotalVAT, ', Grand (with VAT): â‚ª', grandTotalWithVAT);
    }
    
    function toggleDifferentialsTable() {
      console.log('ğŸ”„ SESSION 47: TOGGLE DIFFERENTIALS TABLE CALLED');
      const checkbox = document.getElementById('hasDifferentials');
      const mainContainer = document.getElementById('differentialsMainContainer');
      
      console.log('ğŸ“‹ Checkbox state:', checkbox?.checked);
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (!helper.final_report) helper.final_report = {};
      if (!helper.final_report.differential) helper.final_report.differential = {};
      
      helper.final_report.differential.has_differentials = checkbox?.checked || false;
      sessionStorage.setItem('helper', JSON.stringify(helper));
      console.log('ğŸ’¾ Updated helper.final_report.differential.has_differentials =', checkbox?.checked);
      
      if (checkbox?.checked) {
        if (mainContainer) mainContainer.style.display = 'block';
        
        renderPartsReductionsSection();
        renderPartsWearSection();
        updateAllDifferentialsSubtotals();
        
        // SESSION 95: Load invoices and invoice lines when differentials are enabled
        setTimeout(async () => {
          try {
            console.log('ğŸ”„ Loading invoices for differentials dropdown...');
            await loadInvoicesForDifferentialsDropdown();
            await loadInvoiceLinesForDropdown();
            populateAllDifferentialRowsWithInvoiceLines();
          } catch (error) {
            console.error('âŒ Error loading invoice data for differentials:', error);
          }
        }, 100);
      } else {
        if (mainContainer) mainContainer.style.display = 'none';
        // Clear all differential rows when hiding
        const container = document.getElementById('differentialsRows');
        if (container) {
          container.innerHTML = '';
          updateDifferentialsSummary();
        }
        // CLEAR DIFFERENTIAL DATA when unchecked
        console.log('ğŸ—‘ï¸ CLEARING DIFFERENTIAL DATA - checkbox unchecked');
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (!helper.final_report) helper.final_report = {};
        helper.final_report.differential = {
          has_differentials: false,
          items: [],
          summary: {
            total_amount_without_vat: 0,
            total_vat: 0,
            total_amount_with_vat: 0,
            currency: 'â‚ª'
          },
          last_updated: new Date().toISOString()
        };
        sessionStorage.setItem('helper', JSON.stringify(helper));
        console.log('ğŸ’¾ Saved unchecked differential state');
      }
      
      // Refresh container layout after toggle
      setTimeout(refreshDamageCentersContainerLayout, 200);
    }
    
    // Alias for toggleDifferentialsTable to match HTML onclick
    function toggleDifferentials() {
      return toggleDifferentialsTable();
    }
    
    
    function addDifferentialRow() {
      const container = document.getElementById('differentialsRows');
      if (container) {
        const newRow = createDifferentialRow();
        container.appendChild(newRow);
        console.log('âœ… Added new differential row');
        
        // SESSION 95: Populate part dropdown for the new row
        const partDropdown = newRow.querySelector('.diff-part-dropdown');
        if (partDropdown) {
          populatePartDropdown(partDropdown);
        }
        
        updateDifferentialsSummary();
        setTimeout(saveDifferentialsToHelper, 100);
        
        // Force reattach event listeners to all existing rows
        setTimeout(reattachDifferentialEventListeners, 100);
      }
    }
    
    // Force reattach event listeners to all differential rows
    function reattachDifferentialEventListeners() {
      console.log('ğŸ”— REATTACHING ALL DIFFERENTIAL EVENT LISTENERS');
      const rows = document.querySelectorAll('#differentialsRows .differential-row');
      
      rows.forEach((row, index) => {
        const partField = row.querySelector('.diff-part');
        const damageCenterDropdown = row.querySelector('.diff-damage-center');
        const natureDropdown = row.querySelector('.diff-nature-dropdown');
        const natureOtherField = row.querySelector('.diff-nature-other');
        const reasonField = row.querySelector('.diff-reason');
        
        console.log(`ğŸ”— Row ${index} - Reattaching to:`, {
          partField: !!partField,
          damageCenterDropdown: !!damageCenterDropdown,
          natureDropdown: !!natureDropdown,
          natureOtherField: !!natureOtherField,
          reasonField: !!reasonField
        });
        
        // Remove existing listeners and add new ones
        if (partField) {
          partField.replaceWith(partField.cloneNode(true));
          const newPartField = row.querySelector('.diff-part');
          newPartField.addEventListener('input', (e) => {
            console.log('ğŸ”¥ PART INPUT (REATTACHED):', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (damageCenterDropdown) {
          damageCenterDropdown.replaceWith(damageCenterDropdown.cloneNode(true));
          const newDamageCenterDropdown = row.querySelector('.diff-damage-center');
          newDamageCenterDropdown.addEventListener('change', (e) => {
            console.log('ğŸ”¥ DAMAGE CENTER DROPDOWN (REATTACHED):', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (natureDropdown) {
          natureDropdown.replaceWith(natureDropdown.cloneNode(true));
          const newNatureDropdown = row.querySelector('.diff-nature-dropdown');
          newNatureDropdown.addEventListener('change', (e) => {
            console.log('ğŸ”¥ NATURE DROPDOWN (REATTACHED):', e.target.value);
            toggleNatureOtherField(e.target);
          });
        }
        
        if (natureOtherField) {
          natureOtherField.replaceWith(natureOtherField.cloneNode(true));
          const newNatureOtherField = row.querySelector('.diff-nature-other');
          newNatureOtherField.addEventListener('input', (e) => {
            console.log('ğŸ”¥ NATURE OTHER INPUT (REATTACHED):', e.target.value);
            const hiddenField = row.querySelector('.diff-nature');
            if (hiddenField) hiddenField.value = e.target.value;
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (reasonField) {
          reasonField.replaceWith(reasonField.cloneNode(true));
          const newReasonField = row.querySelector('.diff-reason');
          newReasonField.addEventListener('input', (e) => {
            console.log('ğŸ”¥ REASON INPUT (REATTACHED):', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
      });
    }
    
    // SESSION 47: Auto-save differential data to helper (ENHANCED)
    function saveDifferentialsToHelper() {
      console.log('ğŸš€ SESSION 47: SAVE DIFFERENTIALS FUNCTION CALLED!');
      const rows = document.querySelectorAll('#differentialsRows .differential-row');
      const differentialsData = [];
      let totalAmount = 0;
      let totalVat = 0;
      let totalWithVat = 0;
      
      console.log('ğŸ” DEBUG: Found', rows.length, 'invoice differential rows to save');
      
      rows.forEach((row, index) => {
        const partField = row.querySelector('.diff-part');
        const natureField = row.querySelector('.diff-nature');
        const reasonField = row.querySelector('.diff-reason');
        const amountField = row.querySelector('.diff-amount');
        
        const part = partField?.value || '';
        const nature = natureField?.value || '';
        const reason = reasonField?.value || '';
        const amount = parseFloat(amountField?.value) || 0;
        
        differentialsData.push({
          id: index + 1,
          part: part,
          nature: nature,
          reason: reason,
          amount_without_vat: amount
        });
        
        totalAmount += amount;
      });
      
      // SESSION 48: Collect category differentials with DETAILED logging
      const categoryDiffRows = document.querySelectorAll('.category-differential-row');
      const categoryDifferentials = [];
      
      console.log('ğŸ” SESSION 48: Searching for category differential rows...');
      console.log('   Found', categoryDiffRows.length, 'rows with class .category-differential-row');
      
      categoryDiffRows.forEach((row, index) => {
        const typeEl = row.querySelector('.category-diff-type');
        const percentageEl = row.querySelector('.category-diff-percentage');
        const categoryValueEl = row.querySelector('.category-diff-category-value');
        const amountEl = row.querySelector('.category-diff-amount');
        
        const type = typeEl?.value || '';
        const percentage = percentageEl?.value || '0%';
        const categoryValue = categoryValueEl?.value || 'â‚ª0';
        const amountRaw = amountEl?.value;
        const amount = parseFloat(amountRaw) || 0;
        
        console.log(`   Row ${index}: RAW VALUES from DOM:`);
        console.log(`      type raw="${typeEl?.value}", final="${type}"`);
        console.log(`      amount raw="${amountRaw}", parsed=${amount}`);
        console.log(`      percentage raw="${percentageEl?.value}", final="${percentage}"`);
        console.log(`      categoryValue raw="${categoryValueEl?.value}", final="${categoryValue}"`);
        console.log(`   Elements exist: type=${!!typeEl}, percentage=${!!percentageEl}, categoryValue=${!!categoryValueEl}, amount=${!!amountEl}`);
        
        // SESSION 48: Save ALL rows, not just ones with amount > 0
        if (type) {
          categoryDifferentials.push({
            id: index + 1,
            type: type,
            percentage: percentage,
            category_value: categoryValue,
            amount: amount
          });
          console.log(`   âœ… Saved row ${index} to categoryDifferentials`);
        } else {
          console.log(`   âš ï¸ Skipped row ${index} - no category type selected`);
        }
      });
      
      console.log('ğŸ“Š SESSION 48: Total category differentials to save:', categoryDifferentials.length);
      console.log('ğŸ“Š Category differentials data:', categoryDifferentials);
      
      // Save to helper.final_report.differential
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (!helper.final_report) helper.final_report = {};
      
      const breakdown = calculatePartsDifferentialsBreakdown();
      const vatRate = parseFloat(window.helper?.calculations?.vat_rate || helper.calculations?.vat_rate || 18);
      
      // SESSION 48: Sum category_value (×¢×¨×š ×”×”× ×—×”) not amount (×¡×›×•×)
      const categoryReductionTotal = categoryDifferentials.reduce((sum, item) => {
        const reductionValue = parseFloat(String(item.category_value).replace(/[â‚ª,]/g, '')) || 0;
        return sum + reductionValue;
      }, 0);
      
      const grandTotalWithoutVAT = totalAmount + breakdown.totalReduction + breakdown.totalWear + categoryReductionTotal;
      const grandTotalVAT = Math.round(grandTotalWithoutVAT * (vatRate / 100));
      const grandTotalWithVAT = Math.round(grandTotalWithoutVAT + grandTotalVAT);
      
      console.log('ğŸ“Š SESSION 47: VAT Rate used for differentials:', vatRate, '% (from window.helper.calculations.vat_rate:', window.helper?.calculations?.vat_rate, ', helper.calculations.vat_rate:', helper.calculations?.vat_rate, ')');
      
      // SESSION 48: REBUILD - Capture ALL sections with complete field data
      helper.final_report.differential = {
        has_differentials: document.getElementById('hasDifferentials')?.checked || false,
        
        // SECTION 1: ×”× ×—×ª ×¨×›×™×‘ (Parts Reductions) - Auto-imported
        parts_reductions: {
          items: breakdown.reductions.map(item => ({
            damage_center: item.centerName,
            part_name: item.partName,
            percentage: item.percentage,
            amount: item.amount
          })),
          total: breakdown.totalReduction
        },
        
        // SECTION 2: ×‘×œ××™ ×¨×›×™×‘ (Parts Wear) - Auto-imported
        parts_wear: {
          items: breakdown.wear.map(item => ({
            damage_center: item.centerName,
            part_name: item.partName,
            percentage: item.percentage,
            amount: item.amount
          })),
          total: breakdown.totalWear
        },
        
        // SECTION 3: ×”×¤×¨×©×™ ×§×˜×’×•×¨×™×” (Category Differentials) - Manual entry
        category_differentials: {
          items: categoryDifferentials.map(item => ({
            category_type: item.type,
            category_value: item.category_value,
            percentage: item.percentage,
            amount: item.amount
          })),
          total: categoryReductionTotal
        },
        
        // SECTION 4: ×”×¤×¨×©×™ ×—×©×‘×•× ×™×•×ª (Invoice Differentials) - Manual entry
        invoice_differentials: {
          items: differentialsData.map(item => ({
            part: item.part,
            nature: item.nature,
            reason: item.reason,
            amount_without_vat: item.amount_without_vat
          })),
          total: totalAmount
        },
        
        // SUBTOTALS & SUMMARY
        subtotals: {
          component_differentials_total: Math.round(breakdown.totalReduction + breakdown.totalWear + categoryReductionTotal),
          invoice_total: Math.round(totalAmount)
        },
        
        grand_total: {
          without_vat: Math.round(grandTotalWithoutVAT),
          vat_amount: grandTotalVAT,
          with_vat: grandTotalWithVAT,
          vat_rate: vatRate,
          currency: 'â‚ª'
        },
        
        last_updated: new Date().toISOString()
      };
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // CRITICAL FIX: Also update window.helper to prevent broadcastHelperUpdate from overwriting
      if (window.helper) {
        if (!window.helper.final_report) window.helper.final_report = {};
        window.helper.final_report.differential = helper.final_report.differential;
        console.log('ğŸ”„ Updated window.helper.final_report.differential to prevent broadcast overwrite');
      }
      
      console.log('ğŸ’¾ Auto-saved differentials to helper:', helper.final_report.differential);
      
      // Trigger Global report recalculation if Global report is active
      setTimeout(() => {
        const sumTotalGlobalField = document.getElementById('sumTotalGlobal');
        if (sumTotalGlobalField && sumTotalGlobalField.offsetParent !== null) { // Check if visible
          const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[â‚ª,]/g, '')) || 0;
          calculateGlobalReport(helper, marketValue);
          console.log('ğŸ”„ Triggered Global report recalculation due to differentials change');
        }
      }, 100);
      
      // Refresh damage centers container layout after differential changes
      setTimeout(refreshDamageCentersContainerLayout, 300);
    }
    
    function updateDifferentialsSummary() {
      console.log('ğŸ”„ SESSION 47: updateDifferentialsSummary called');
      
      updateAllDifferentialsSubtotals();
      
      updateDifferentialCalculations();
    }
    
    // NEW: Update differential calculations per damage center
    function updateDifferentialCalculations() {
      try {
        const helper = window.helper || {};
        const originalTotals = helper.damage_assessment?.totals || {};
        const damageCenters = helper.centers || [];
        
        // Initialize totals_after_differentials with original values
        if (!helper.damage_assessment) helper.damage_assessment = {};
        helper.damage_assessment.totals_after_differentials = {
          'Total parts': parseInt(originalTotals['Total parts'] || 0),
          'Total works': parseInt(originalTotals['Total works'] || 0),
          'Total repairs': parseInt(originalTotals['Total repairs'] || 0),
          'Other': 0,
          'Total with VAT': parseInt(originalTotals['Total with VAT'] || 0)
        };
        
        // Process each differential row
        const rows = document.querySelectorAll('#differentialsRows .differential-row');
        rows.forEach(row => {
          const damageCenterSelect = row.querySelector('.diff-damage-center');
          const natureSelect = row.querySelector('.diff-nature-dropdown');
          const amountInput = row.querySelector('.diff-amount');
          
          if (damageCenterSelect && natureSelect && amountInput) {
            const selectedCenter = damageCenterSelect.value;
            const nature = natureSelect.value;
            const amount = parseFloat(amountInput.value) || 0;
            
            if (selectedCenter && nature && amount !== 0) {
              // Apply differential to specific category
              const vatRate = getVatRate();
              const amountWithVat = Math.round(amount * (1 + vatRate));
              
              switch(nature) {
                case 'parts':
                  helper.damage_assessment.totals_after_differentials['Total parts'] += amount;
                  break;
                case 'works':
                  helper.damage_assessment.totals_after_differentials['Total works'] += amount;
                  break;
                case 'repairs':
                  helper.damage_assessment.totals_after_differentials['Total repairs'] += amount;
                  break;
                case 'other':
                  helper.damage_assessment.totals_after_differentials['Other'] += amount;
                  break;
              }
              
              // Update total with VAT
              if (nature !== 'other') {
                helper.damage_assessment.totals_after_differentials['Total with VAT'] += amountWithVat;
              } else {
                helper.damage_assessment.totals_after_differentials['Total with VAT'] += amount;
              }
            }
          }
        });
        
        // Update session storage and window.helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        // Refresh damage centers container layout
        setTimeout(refreshDamageCentersContainerLayout, 100);
        
        console.log('ğŸ”„ Updated differential calculations:', helper.damage_assessment.totals_after_differentials);
        
      } catch (error) {
        console.error('Error updating differential calculations:', error);
      }
    }
    
    // Save differentials data with user feedback
    // SESSION 48: Redirect to comprehensive save function
    function saveDifferentials() {
      console.log('ğŸ’¾ SAVE DIFFERENTIALS BUTTON CLICKED - Calling saveDifferentialsToHelper()');
      const saveButton = document.querySelector('button[onclick="saveDifferentials()"]');
      
      // Show visual feedback
      if (saveButton) {
        saveButton.style.background = '#17a2b8';
        saveButton.innerHTML = 'â³ ×©×•××¨ ×”×¤×¨×©×™×...';
        saveButton.disabled = true;
      }
      
      // Call the comprehensive save function
      saveDifferentialsToHelper();
      
      // Show success message
      setTimeout(() => {
        if (saveButton) {
          saveButton.style.background = '#28a745';
          saveButton.innerHTML = 'âœ… × ×©××¨ ×”×¤×¨×©×™×!';
          setTimeout(() => {
            saveButton.innerHTML = '×©××•×¨ ×”×¤×¨×©×™×';
            saveButton.style.background = '#28a745';
            saveButton.disabled = false;
          }, 1500);
        }
      }, 100);
    }
    
    // Update final report fields (agreement status and company report)
    function updateFinalReportField(fieldName, value) {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (!helper.final_report) helper.final_report = {};
        
        helper.final_report[fieldName] = value;
        
        // Save to both storage locations
        sessionStorage.setItem('helper', JSON.stringify(helper));
        localStorage.setItem('helper', JSON.stringify(helper));
        
        // Update global helper directly to avoid setNestedValue error
        if (window.helper) {
          if (!window.helper.final_report) window.helper.final_report = {};
          window.helper.final_report[fieldName] = value;
        }
        
        console.log(`âœ… Final report field updated: ${fieldName} = ${value}`);
      } catch (error) {
        console.error('âŒ Error updating final report field:', error);
      }
    }
    
    // Save final report configuration function
    function saveFinalReportConfiguration() {
      try {
        // Collect current form values
        const reportType = document.getElementById('reportType')?.value;
        const isCompanyClient = document.getElementById('isCompanyClient')?.value;
        const inAgreement = document.getElementById('inAgreement')?.value;
        
        // Update helper with current values - SIMPLIFIED TO AVOID setNestedValue ERROR
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (!helper.final_report) helper.final_report = {};
        
        if (reportType) helper.final_report.report_type = reportType;
        if (isCompanyClient !== undefined) helper.final_report.report_for_company = (isCompanyClient === 'yes');
        if (inAgreement !== undefined) helper.final_report.in_agreement = (inAgreement === 'yes');
        
        // Save to storage locations directly (avoid helper.js updateHelper to prevent error)
        sessionStorage.setItem('helper', JSON.stringify(helper));
        localStorage.setItem('helper', JSON.stringify(helper));
        
        // Update global helper if available (direct assignment, no updateHelper)
        if (window.helper) {
          window.helper.final_report = helper.final_report;
        }
        
        // Show success feedback
        const button = document.querySelector('button[onclick="saveFinalReportConfiguration()"]');
        const originalText = button.textContent;
        button.textContent = 'âœ… × ×©××¨';
        button.style.background = '#28a745';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = '#28a745';
        }, 2000);
        
        console.log('âœ… Final report configuration saved:', {
          report_type: helper.final_report.report_type,
          report_for_company: helper.final_report.report_for_company,
          in_agreement: helper.final_report.in_agreement
        });
      } catch (error) {
        console.error('âŒ Error saving final report configuration:', error);
        alert('×©×’×™××” ×‘×©××™×¨×ª ×”×’×“×¨×•×ª ×”×“×•"×—');
      }
    }
    
    // Load differential data from helper on page load
    function loadDifferentialData() {
      // Prevent multiple loads
      if (window.differentialDataLoaded) {
        console.log('âš ï¸ Differential data already loaded, skipping...');
        return;
      }
      
      try {
        console.log('ğŸ“– LOADING DIFFERENTIAL DATA FROM HELPER...');
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        console.log('ğŸ” Checking for differential data in helper.final_report:', helper.final_report);
        const differentialData = helper.final_report?.differential;
        
        if (!differentialData) {
          console.log('ğŸ“ No differential data found in helper.final_report.differential');
          return;
        }
        
        if (!differentialData.has_differentials) {
          console.log('ğŸ“ Differential data exists but has_differentials is false:', differentialData);
          return;
        }
        
        console.log('ğŸ“– Loading differential data from helper:', differentialData);
        
        // Check the "has differentials" checkbox
        const hasDiffCheckbox = document.getElementById('hasDifferentials');
        if (hasDiffCheckbox) {
          hasDiffCheckbox.checked = differentialData.has_differentials;
          
          // SESSION 47: Use new main container
          const mainContainer = document.getElementById('differentialsMainContainer');
          
          if (differentialData.has_differentials && mainContainer) {
            mainContainer.style.display = 'block';
            
            // Render auto-imported sections
            renderPartsReductionsSection();
            renderPartsWearSection();
          }
          
          console.log('âœ… Checkbox set to:', differentialData.has_differentials, 'without triggering toggle');
        }
        
        // SESSION 48: Load category differential items (NEW STRUCTURE)
        const categoryContainer = document.getElementById('categoryDifferentialsList');
        const categoryItems = differentialData.category_differentials?.items || [];
        if (categoryContainer && categoryItems.length > 0) {
          console.log('ğŸ“‹ SESSION 48: Loading', categoryItems.length, 'category differential items');
          
          categoryContainer.innerHTML = '';
          
          categoryItems.forEach((item) => {
            addCategoryDifferentialRow();
            const rows = document.querySelectorAll('.category-differential-row');
            const lastRow = rows[rows.length - 1];
            
            if (lastRow) {
              const typeSelect = lastRow.querySelector('.category-diff-type');
              const percentageInput = lastRow.querySelector('.category-diff-percentage');
              const categoryValueInput = lastRow.querySelector('.category-diff-category-value');
              const amountInput = lastRow.querySelector('.category-diff-amount');
              
              // SESSION 48: Load ALL saved values including calculated ones
              if (typeSelect) typeSelect.value = item.category_type || '';
              if (percentageInput) percentageInput.value = item.percentage || '0%';
              if (categoryValueInput) categoryValueInput.value = item.category_value || 'â‚ª0';
              if (amountInput) amountInput.value = item.amount || 0;
            }
          });
          
          // SESSION 48: Don't recalculate - use saved values
          updateAllDifferentialsSubtotals();
        }
        
        // SESSION 48: Load invoice differential items (NEW STRUCTURE)
        const invoiceContainer = document.getElementById('differentialsRows');
        const invoiceItems = differentialData.invoice_differentials?.items || [];
        if (invoiceContainer && invoiceItems.length > 0) {
          console.log('ğŸ“‹ SESSION 48: Loading', invoiceItems.length, 'invoice differential items');
          
          invoiceContainer.innerHTML = '';
          
          invoiceItems.forEach((item) => {
            const row = createDifferentialRow({
              part: item.part || '',
              nature: item.nature || '',
              reason: item.reason || '',
              amount: item.amount_without_vat || 0
            });
            invoiceContainer.appendChild(row);
          });
          
          // CRITICAL FIX: Reattach event listeners to loaded rows
          setTimeout(reattachDifferentialEventListeners, 200);
          
          // SESSION 95: Load invoice lines and populate dropdowns for loaded rows
          setTimeout(async () => {
            try {
              await loadInvoiceLinesForDropdown();
              populateAllDifferentialRowsWithInvoiceLines();
            } catch (error) {
              console.error('âŒ Error loading invoice lines for differential rows:', error);
            }
          }, 300);
        }
        
        // Update all subtotals
        updateAllDifferentialsSubtotals();
        
        // Mark as loaded to prevent multiple loads
        window.differentialDataLoaded = true;
        console.log('âœ… Differential data loaded successfully');
      } catch (error) {
        console.error('âŒ Error loading differential data:', error);
      }
    }
    
    

    // Get VAT rate based on company selection
    function getVatRate() {
      const isCompanyClient = document.getElementById('isCompanyClient')?.value;
      return (isCompanyClient === 'yes') ? 0 : ((window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100); // 0% for companies, admin rate for private
    }

    // Toggle differentials display
    function toggleDifferentials() {
      const checkbox = document.getElementById('hasDifferentials');
      const table = document.getElementById('differentialsTable');
      const summary = document.getElementById('differentialsSummary');
      
      if (!checkbox) return;
      
      const show = checkbox.checked;
      console.log('Toggling differentials:', show);
      
      if (table) table.style.display = show ? 'block' : 'none';
      if (summary) summary.style.display = show ? 'block' : 'none';
      
      // Add initial row if showing for first time
      if (show && document.getElementById('differentialsRows') && document.getElementById('differentialsRows').children.length === 0) {
        addDifferentialRow();
      }
      
      // Update calculations
      if (show) {
        updateDifferentialsSummary();
      } else {
        // Clear all differentials when unchecked
        const rows = document.querySelectorAll('#differentialsRows .differential-row');
        rows.forEach(row => row.remove());
        updateDifferentialsSummary();
      }
    }

    // Save and refresh calculations
    function saveAndRefresh() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Collect differentials data
      const differentialsData = {
        has_differentials: document.getElementById('hasDifferentials')?.checked || false,
        differentials: collectDifferentials()
      };
      
      // Update helper
      if (!helper.expertise) helper.expertise = {};
      if (!helper.expertise.depreciation) helper.expertise.depreciation = {};
      
      helper.expertise.depreciation.has_differentials = differentialsData.has_differentials;
      helper.expertise.depreciation.differentials = differentialsData.differentials;
      
      // Save to storage
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Refresh calculations
      refreshSummary();
    }

    // Collect differentials data
    function collectDifferentials() {
      return Array.from(document.querySelectorAll('#differentialsRows .differential-row')).map(row => {
        const amount = parseFloat(row.querySelector('.diff-amount')?.value || '0') || 0;
        const vat = parseFloat(row.querySelector('.diff-vat')?.value || '0') || 0;
        const total = parseFloat(row.querySelector('.diff-total')?.value || '0') || 0;
        const part = row.querySelector('.diff-part')?.value?.trim() || '';
        const nature = row.querySelector('.diff-nature')?.value?.trim() || '';
        const reason = row.querySelector('.diff-reason')?.value?.trim() || '';
        
        return {
          part: part,
          nature: nature,
          reason: reason,
          amount: amount,
          vat: vat,
          total_with_vat: total
        };
      });
    }

    // Refresh summary calculations - COMPLETE DYNAMIC SYSTEM
    // DISABLED: Second refreshSummary function with wrong data sources
    // This function was overriding the correct refreshSummary and using wrong mappings:
    // - Used levi.final_price instead of calculations.full_market_value  
    // - Used calc.total_damage instead of claims_data.total_claim
    // - Used dep.global_amount instead of depreciation.globalDepValue
    /*
    function refreshSummary() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const calc = helper.expertise?.calculations || {};
      const dep = helper.expertise?.depreciation || {};
      const levi = helper.expertise?.levi_report || {};
      
      // Get base values
      const marketValue = parseFloat(levi.final_price) || 0;
      const totalClaim = parseFloat(calc.total_damage) || 0;
      const depCompensation = parseFloat(dep.global_amount) || 0;
      
      // Update all summary fields across all report types
      const summaryFields = [
        'sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 
        'sumMarketValueTotal', 'sumMarketValueLegal'
      ];
      summaryFields.forEach(id => {
        const field = document.getElementById(id);
        if (field) field.value = marketValue ? `â‚ª${marketValue.toLocaleString()}` : '';
      });
      
      const claimFields = [
        'sumClaim', 'sumClaimGlobal'
      ];
      claimFields.forEach(id => {
        const field = document.getElementById(id);
        if (field) field.value = totalClaim ? `â‚ª${totalClaim.toLocaleString()}` : '';
      });
      
      // Update main totalClaim field with formatting
      const totalClaimDiv = document.getElementById('totalClaim');
      if (totalClaimDiv) {
        totalClaimDiv.innerText = totalClaim ? `â‚ª${totalClaim.toLocaleString()}` : '';
      }
      
      const depFields = [
        'depCompensation', 'depCompensationGlobal'
      ];
      depFields.forEach(id => {
        const field = document.getElementById(id);
        if (field) field.value = depCompensation ? `â‚ª${depCompensation.toLocaleString()}` : '';
      });
      
      // Calculate subtotals including ×ª×•×¡×¤×•×ª ×•×”×•×¨×“×•×ª for each report type
      calculateSubtotals();
      
      // Specific fields for different report types
      const saleValueDamage = document.getElementById('saleValueDamage');
      if (saleValueDamage) saleValueDamage.value = calc.sale_value_damaged || '';
      
      const salvageValueTotal = document.getElementById('salvageValueTotal');
      if (salvageValueTotal) salvageValueTotal.value = calc.salvage_value || '';
      
      const salvageValueLegal = document.getElementById('salvageValueLegal');
      if (salvageValueLegal) salvageValueLegal.value = calc.salvage_value || '';
      
      const storageValueTotal = document.getElementById('storageValueTotal');
      if (storageValueTotal) storageValueTotal.value = calc.storage_value || '';
      
      // Populate ×ª×•×¡×¤×•×ª ×•×”×•×¨×“×•×ª from levi adjustments
      populateAdditionsFromLevi();
      
      // Update differentials summary
      updateDifferentialsSummary();
    }
    */

    // Calculate subtotals including ×ª×•×¡×¤×•×ª ×•×”×•×¨×“×•×ª for each report type
    function calculateSubtotals() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const calc = helper.expertise?.calculations || {};
      const dep = helper.expertise?.depreciation || {};
      const levi = helper.expertise?.levi_report || {};
      
      // Get base values
      const marketValue = parseFloat(levi.final_price) || 0;
      const totalClaim = parseFloat(calc.total_damage) || 0;
      const depCompensation = parseFloat(dep.global_amount) || 0;
      
      // Calculate additions/deductions for each report type
      const reportTypes = [
        { summaryType: 'summaryPrivate', totalField: 'sumTotal' },
        { summaryType: 'summaryGlobal', totalField: 'sumTotalGlobal' },
        { summaryType: 'summaryDamage', totalField: 'afterSaleDamage' },
        { summaryType: 'summaryTotalLoss', totalField: 'afterSaleTotal' },
        { summaryType: 'summaryLegalLoss', totalField: 'afterSaleLegal' }
      ];
      
      reportTypes.forEach(({ summaryType, totalField }) => {
        const additionsTotal = calculateAdditionsTotal(summaryType);
        let subtotal = 0;
        
        // Different calculation logic for different report types
        if (summaryType === 'summaryPrivate' || summaryType === 'summaryGlobal') {
          // For private/global: market value + total claim + depreciation compensation + additions
          subtotal = marketValue + totalClaim + depCompensation + additionsTotal;
        } else if (summaryType === 'summaryDamage') {
          // For damaged state: market value - sale value + additions
          const saleValue = parseFloat(document.getElementById('saleValueDamage')?.value?.replace(/[^\d.-]/g, '')) || 0;
          subtotal = marketValue - saleValue + additionsTotal;
        } else if (summaryType === 'summaryTotalLoss') {
          // For total loss: market value - salvage value + storage + additions
          const salvageValue = parseFloat(document.getElementById('salvageValueTotal')?.value?.replace(/[^\d.-]/g, '')) || 0;
          const storageValue = parseFloat(document.getElementById('storageValueTotal')?.value?.replace(/[^\d.-]/g, '')) || 0;
          subtotal = marketValue - salvageValue + storageValue + additionsTotal;
        } else if (summaryType === 'summaryLegalLoss') {
          // For legal loss: market value - salvage value + additions
          const salvageValue = parseFloat(document.getElementById('salvageValueLegal')?.value?.replace(/[^\d.-]/g, '')) || 0;
          subtotal = marketValue - salvageValue + additionsTotal;
        }
        
        // Update the total field
        const totalFieldElement = document.getElementById(totalField);
        if (totalFieldElement) {
          totalFieldElement.value = `â‚ª${Math.max(0, subtotal).toLocaleString()}`;
        }
      });
    }

    // Calculate total of additions/deductions for a specific report type
    function calculateAdditionsTotal(summaryType) {
      let total = 0;
      
      // Calculate additions from custom fields using exact container mapping
      const gridMapping = {
        'summaryPrivate': 'sumAdditionsGrid',
        'summaryGlobal': 'sumAdditionsGridGlobal', 
        'summaryDamage': 'sumAdditionsGridDamage',
        'summaryTotalLoss': 'sumAdditionsGridTotalLoss',
        'summaryLegalLoss': 'sumAdditionsGridLegalLoss'
      };
      
      const gridId = gridMapping[summaryType];
      const customGrid = document.getElementById(gridId);
      if (customGrid) {
        const customRows = customGrid.querySelectorAll('.custom-summary-row');
        customRows.forEach(row => {
          const value = parseFloat(row.querySelector('.custom-field-value')?.value?.replace(/[^\d.-]/g, '')) || 0;
          total += value;
        });
      }
      
      // Calculate Levi adjustments
      total += calculateLeviAdjustmentsTotal(summaryType);
      
      return total;
    }

    // Calculate total of Levi adjustments for a specific report type
    function calculateLeviAdjustmentsTotal(summaryType) {
      let total = 0;
      
      // Map summary types to Levi adjustment container IDs
      const leviMapping = {
        'summaryPrivate': 'leviAdjustmentsRows-private',
        'summaryGlobal': 'leviAdjustmentsRows-global',
        'summaryDamage': 'leviAdjustmentsRows-damage',
        'summaryTotalLoss': 'leviAdjustmentsRows-totalLoss',
        'summaryLegalLoss': 'leviAdjustmentsRows-legalLoss'
      };
      
      const leviId = leviMapping[summaryType];
      const leviContainer = document.getElementById(leviId);
      if (leviContainer) {
        const leviRows = leviContainer.querySelectorAll('.levi-adjustment-row');
        leviRows.forEach(row => {
          const value = parseFloat(row.querySelector('.levi-adjustment-value')?.value?.replace(/[^\d.-]/g, '')) || 0;
          total += value;
        });
      }
      
      return total;
    }

    // Populate ×ª×•×¡×¤×•×ª ×•×”×•×¨×“×•×ª from levi adjustments
    function populateAdditionsFromLevi() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const levi = helper.expertise?.levi_report || {};
      
      if (!levi.adjustments || !Array.isArray(levi.adjustments)) return;
      
      // Map summary types to Levi adjustment container IDs
      const leviMapping = {
        'summaryPrivate': 'leviAdjustmentsRows-private',
        'summaryGlobal': 'leviAdjustmentsRows-global',
        'summaryDamage': 'leviAdjustmentsRows-damage',
        'summaryTotalLoss': 'leviAdjustmentsRows-totalLoss',
        'summaryLegalLoss': 'leviAdjustmentsRows-legalLoss'
      };
      
      // Populate for each summary type
      Object.keys(leviMapping).forEach(summaryType => {
        const containerId = leviMapping[summaryType];
        const container = document.getElementById(containerId);
        if (!container) return;
        
        // Clear existing rows
        container.innerHTML = '';
        
        // Add Levi adjustments
        levi.adjustments.forEach(adjustment => {
          if (adjustment.name && adjustment.value) {
            const row = createLeviAdjustmentRow(adjustment.name, adjustment.value);
            container.appendChild(row);
          }
        });
      });
      
      console.log('âœ… Levi adjustments populated across all summary types');
    }

    // Render existing differentials from data
    function renderDifferentials(list) {
      const container = document.getElementById('differentialsRows');
      if (!container) return;
      
      container.innerHTML = '';
      console.log('ğŸ” Loading differentials data:', list);
      
      if (list && list.length > 0) {
        // FILTER OUT CORRUPTED DATA - only load properly structured differential data
        const validDifferentials = list.filter(item => {
          return item && typeof item === 'object' && (item.part || item.nature || item.reason || item.amount);
        });
        
        console.log('âœ… Valid differentials after filter:', validDifferentials);
        
        validDifferentials.forEach(item => {
          const row = createDifferentialRow(item);
          container.appendChild(row);
        });
      }
      updateDifferentialsSummary();
    }

    // ========================================
    // SESSION 62: CASE REDUCTION FUNCTIONS (×”× ×—×ª ×ª×™×§)
    // ========================================
    
    // Toggle Case Reduction Section
    function toggleCaseReductionTable() {
      const checkbox = document.getElementById('hasCaseReduction');
      const container = document.getElementById('caseReductionContainer');
      
      if (!checkbox || !container) {
        console.warn('âš ï¸ SESSION 62: Case reduction elements not found');
        return;
      }
      
      if (checkbox.checked) {
        container.style.display = 'block';
        
        // Initialize helper structure if needed
        if (!window.helper.final_report) window.helper.final_report = {};
        if (!window.helper.final_report.total_case_reduction) {
          window.helper.final_report.total_case_reduction = {
            enabled: true,
            percentage: 0,
            original_sum: 0,
            discount_value: 0,
            total_after_discount: 0,
            total_claim: 0
          };
        } else {
          window.helper.final_report.total_case_reduction.enabled = true;
        }
        
        // Load existing values if present
        const savedPercentage = window.helper.final_report.total_case_reduction.percentage || 0;
        document.getElementById('caseReductionPercentage').value = savedPercentage;
        
        // Calculate initial values
        calculateCaseReduction();
        
        console.log('âœ… SESSION 62: Case reduction enabled');
      } else {
        container.style.display = 'none';
        if (window.helper.final_report?.total_case_reduction) {
          window.helper.final_report.total_case_reduction.enabled = false;
        }
        
        // Auto-save to sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(window.helper));
        
        console.log('âŒ SESSION 62: Case reduction disabled');
      }
    }
    
    // Calculate Case Reduction Values
    function calculateCaseReduction() {
      // Get percentage input
      const percentageInput = document.getElementById('caseReductionPercentage');
      if (!percentageInput) {
        console.warn('âš ï¸ SESSION 62: Percentage input not found');
        return;
      }
      
      const percentage = parseFloat(percentageInput.value) || 0;
      
      // Validate percentage (0-100)
      if (percentage < 0) {
        percentageInput.value = 0;
        return;
      }
      if (percentage > 100) {
        percentageInput.value = 100;
        return;
      }
      
      // Get original sum from damage_assessment.totals
      const originalSum = window.helper?.damage_assessment?.totals?.["Total without VAT"] || 0;
      
      // Get VAT rate (NEVER hardcode!)
      let vatRate = window.helper?.calculations?.vat_rate;
      
      // If vat_rate is stored as percentage (e.g., 17), convert to decimal (0.17)
      if (vatRate > 1) {
        vatRate = vatRate / 100;
      }
      
      // Fallback to 0.17 if not found
      if (!vatRate) {
        vatRate = 0.17;
      }
      
      console.log('ğŸ” VAT Rate:', vatRate, 'from helper:', window.helper?.calculations?.vat_rate);
      
      // Calculate values (SESSION 62: Round all to whole numbers)
      const discountValue = Math.round(originalSum * (percentage / 100));
      const totalAfterDiscount = Math.round(originalSum - discountValue);
      const vatAmount = Math.round(totalAfterDiscount * vatRate);
      const totalWithVAT = totalAfterDiscount + vatAmount;
      
      console.log('ğŸ” Calculations:', { originalSum, discountValue, totalAfterDiscount, vatAmount, totalWithVAT });
      
      // Update UI display fields
      const caseOriginalSum = document.getElementById('caseOriginalSum');
      const caseDiscountValue = document.getElementById('caseDiscountValue');
      const caseTotalAfter = document.getElementById('caseTotalAfter');
      const caseTotalWithVAT = document.getElementById('caseTotalWithVAT');
      
      if (caseOriginalSum) caseOriginalSum.textContent = formatCurrency(originalSum);
      if (caseDiscountValue) caseDiscountValue.textContent = formatCurrency(discountValue);
      if (caseTotalAfter) caseTotalAfter.textContent = formatCurrency(totalAfterDiscount);
      if (caseTotalWithVAT) caseTotalWithVAT.textContent = formatCurrency(totalWithVAT);
      
      // Update helper.final_report.total_case_reduction
      if (!window.helper.final_report) window.helper.final_report = {};
      window.helper.final_report.total_case_reduction = {
        enabled: document.getElementById('hasCaseReduction')?.checked || false,
        percentage: percentage,
        original_sum: originalSum,
        discount_value: discountValue,
        total_after_discount: totalAfterDiscount,
        total_claim: totalWithVAT
      };
      
      // â­ SESSION 62: Also update helper.claims_data.total_claim_after_case_reduction
      if (!window.helper.claims_data) window.helper.claims_data = {};
      window.helper.claims_data.total_claim_after_case_reduction = totalWithVAT;
      
      // Auto-save to sessionStorage
      sessionStorage.setItem('helper', JSON.stringify(window.helper));
      
      console.log('âœ… SESSION 62: Case reduction calculated and saved:', {
        percentage: percentage + '%',
        original: originalSum,
        discount: discountValue,
        final: totalWithVAT,
        saved_to_final_report: window.helper.final_report.total_case_reduction.total_claim,
        saved_to_claims_data: window.helper.claims_data.total_claim_after_case_reduction
      });
    }
    
    // Helper function for currency formatting (using existing pattern)
    function formatCurrency(value) {
      if (typeof value !== 'number') value = parseFloat(value) || 0;
      return 'â‚ª' + Math.round(value).toLocaleString('he-IL', {
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
      });
    }
    
    // Load Case Reduction from Helper
    function loadCaseReductionFromHelper() {
      if (!window.helper?.final_report?.total_case_reduction) {
        console.log('â„¹ï¸ SESSION 62: No saved case reduction data found');
        return;
      }
      
      const data = window.helper.final_report.total_case_reduction;
      const checkbox = document.getElementById('hasCaseReduction');
      const percentageInput = document.getElementById('caseReductionPercentage');
      
      if (checkbox && data.enabled) {
        checkbox.checked = true;
        toggleCaseReductionTable();
      }
      
      if (percentageInput && data.percentage) {
        percentageInput.value = data.percentage;
        calculateCaseReduction();
      }
      
      console.log('âœ… SESSION 62: Loaded case reduction from helper:', data);
    }
    
    // ========================================
    // END SESSION 62 CASE REDUCTION FUNCTIONS
    // ========================================

    // Create Levi adjustment row
    function createLeviAdjustmentRow(name, value) {
      const row = document.createElement('div');
      row.className = 'levi-adjustment-row';
      row.style.display = 'grid';
      row.style.gridTemplateColumns = '1fr 120px 80px';
      row.style.gap = '10px';
      row.style.marginBottom = '8px';
      row.style.alignItems = 'center';
      
      row.innerHTML = `
        <div>
          <input type="text" class="levi-adjustment-name" value="${name}" readonly style="width:100%; padding:6px; border:1px solid #ccc; background:#f8f9fa; border-radius:4px;">
        </div>
        <div>
          <input type="number" class="levi-adjustment-value" value="${value}" style="width:100%; padding:6px; border:1px solid #ccc; border-radius:4px;">
        </div>
        <div>
          <button type="button" class="btn-remove" style="background:#dc3545; color:white; border:none; padding:6px 10px; border-radius:4px; cursor:pointer;">âœ•</button>
        </div>
      `;
      
      // Add event listeners
      const valueInput = row.querySelector('.levi-adjustment-value');
      const removeBtn = row.querySelector('.btn-remove');
      
      valueInput.addEventListener('input', function() {
        calculateSubtotals();
        saveAndRefresh();
      });
      
      removeBtn.addEventListener('click', function() {
        row.remove();
        calculateSubtotals();
        saveAndRefresh();
      });
      
      return row;
    }

    // Global depreciation calculation
    function calculateGlobalDepreciationValue() {
      const globalDep1 = document.getElementById('globalDep1');
      if (!globalDep1) return;
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Try multiple sources for market value
      let marketValue = 0;
      
      // First try the summary market value field (most reliable)
      const sumMarketValueField = document.getElementById('sumMarketValue');
      if (sumMarketValueField && sumMarketValueField.value) {
        const sumMarketStr = sumMarketValueField.value.replace(/[â‚ª,]/g, '') || '0';
        marketValue = parseFloat(sumMarketStr) || 0;
      }
      
      // Fallback to helper data
      if (!marketValue) {
        marketValue = helper.calculations?.market_value || 
                     helper.expertise?.levi_report?.final_price || 
                     helper.calculations?.vehicle_value_gross || 0;
      }
      // Clean the percentage value properly to handle decimals like 2.5%
      const cleanedValue = globalDep1.value.replace('%', '').replace(/[^0-9.-]/g, '');
      const depPercent = parseFloat(cleanedValue) || 0;
      
      const globalAmount = Math.round(marketValue * (depPercent / 100));
      
      // Update helper data
      if (!helper.expertise) helper.expertise = {};
      if (!helper.expertise.depreciation) helper.expertise.depreciation = {};
      helper.expertise.depreciation.global_percent = depPercent;
      helper.expertise.depreciation.global_amount = globalAmount;
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Update display - target the correct field: globalDepValue
      const globalDepValueField = document.getElementById('globalDepValue');
      if (globalDepValueField) {
        globalDepValueField.value = `â‚ª${globalAmount.toLocaleString()}`;
      }
      
    }

    // Trigger MathEngine calculation
    function triggerMathCalculation() {
      if (typeof MathEngine !== 'undefined' && MathEngine.calculateAll) {
        try {
          // Gather required data for calculation
          const helper = window.helper || {};
          const baseDamage = helper.damage_assessment?.totals?.base_damage || 0;
          const depreciation = helper.depreciation?.total_value || 0;
          const fees = helper.fees?.total || 0;
          const marketValue = helper.vehicle?.market_value || 0;
          const vehicleValueGross = helper.vehicle?.gross_value || marketValue;
          const shavehPercent = helper.calculations?.shaveh_percent || 0;
          const vatRate = helper.calculations?.vat_rate || 18;
          
          const calculationData = {
            baseDamage,
            depreciation,
            fees,
            marketValue,
            vehicleValueGross,
            shavehPercent,
            vatRate
          };
          
          MathEngine.calculateAll(calculationData);
          console.log('âœ… MathEngine calculation triggered with data:', calculationData);
        } catch (error) {
          console.error('âŒ Error triggering MathEngine calculation:', error);
        }
      }
    }

    // Enhanced saveAndRefresh with complete data collection
    function saveAndRefreshComplete() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Ensure structure exists
      if (!helper.expertise) helper.expertise = {};
      if (!helper.expertise.depreciation) helper.expertise.depreciation = {};
      
      // Collect all form data
      const reportType = document.getElementById('reportType')?.value;
      const isCompanyClient = document.getElementById('isCompanyClient')?.value;
      const globalDep1 = document.getElementById('globalDep1')?.value;
      const workDays = document.getElementById('workDays')?.value;
      const isAgreement = document.getElementById('isAgreement')?.checked;
      const hasDifferentials = document.getElementById('hasDifferentials')?.checked;
      
      // Update helper with form data
      if (reportType) helper.meta = { ...helper.meta, report_type_display: reportType };
      if (isCompanyClient) helper.client = { ...helper.client, is_company_client: isCompanyClient === 'yes' };
      if (globalDep1) helper.expertise.depreciation.global_percent = parseFloat(globalDep1);
      if (workDays) helper.expertise.depreciation.work_days = parseInt(workDays);
      helper.expertise.depreciation.is_agreement = !!isAgreement;
      helper.expertise.depreciation.has_differentials = !!hasDifferentials;
      
      // Collect differentials
      if (hasDifferentials) {
        helper.expertise.depreciation.differentials = collectDifferentials();
      }
      
      // Save to storage
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Trigger calculations
      calculateGlobalDepreciationValue();
      triggerMathCalculation();
      refreshSummary();
      
      console.log('ğŸ’¾ Complete data saved and calculations refreshed');
    }

    // Add custom summary field - EXACT COPY FROM WORKING DEPRECIATION MODULE
    function addCustomSummaryField(summaryType) {
      const gridMapping = {
        'summaryPrivate': 'sumAdditionsGrid',
        'summaryGlobal': 'sumAdditionsGridGlobal', 
        'summaryDamage': 'sumAdditionsGridDamage',
        'summaryTotalLoss': 'sumAdditionsGridTotalLoss',
        'summaryLegalLoss': 'sumAdditionsGridLegalLoss'
      };
      
      const gridId = gridMapping[summaryType];
      const grid = document.getElementById(gridId);
      
      if (!grid) {
        console.warn('Grid not found for summary type:', summaryType);
        return;
      }
      
      const row = document.createElement('div');
      row.className = 'custom-summary-row';
      row.style.display = 'grid';
      row.style.gridTemplateColumns = '1fr 1fr 80px';
      row.style.gap = '10px';
      row.style.marginBottom = '10px';
      
      row.innerHTML = `
        <div>
          <input type="text" class="custom-field-name" placeholder="×©× ×”×©×“×”" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc;">
        </div>
        <div>
          <input type="text" class="custom-field-value" placeholder="×¢×¨×š" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc;">
        </div>
        <div>
          <button type="button" class="btn remove" style="background:#dc3545; padding:8px 12px; margin-top:0; font-size: 14px;">âœ•</button>
        </div>
      `;
      
      // Add event listeners
      row.querySelector('.remove').addEventListener('click', () => {
        row.remove();
        calculateSubtotals();
        saveAndRefreshComplete();
      });
      
      row.querySelector('.custom-field-name').addEventListener('input', () => {
        calculateSubtotals();
        saveAndRefreshComplete();
      });
      
      row.querySelector('.custom-field-value').addEventListener('input', () => {
        calculateSubtotals();
        saveAndRefreshComplete();
      });
      
      grid.appendChild(row);
      console.log(`âœ… Custom field added to ${summaryType}`);
    }

    // NEW: Handle final report date completely separate from everything else
    function updateFinalReportDate(element) {
      console.log('ğŸš€ updateFinalReportDate called! Element:', element.id, 'Value:', element.value);
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const value = element.value;
      
      // Create final report section if it doesn't exist
      if (!helper.final_report) helper.final_report = {};
      
      // Store ONLY in final report - NO connection to Levi or car details
      helper.final_report.report_date = value;
      helper.final_report.generated_date = new Date().toISOString();
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      console.log('ğŸ’¾ Saved to helper.final_report.report_date:', value);
      
      // Sync both final report date fields
      const topField = document.getElementById('finalReportDate');
      const summaryField = document.getElementById('finalReportDateSummary');
      if (topField && element.id !== 'finalReportDate') topField.value = value;
      if (summaryField && element.id !== 'finalReportDateSummary') summaryField.value = value;
      
      console.log('âœ… Final report date updated (separate from Levi):', value);
    }

    // Alias for the same function
    function updateFinalReportDateField(element) {
      console.log('ğŸ” updateFinalReportDateField called with element:', element.id, 'value:', element.value);
      updateFinalReportDate(element);
      
      // Additional verification log
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('ğŸ” After save - final_report.report_date:', helper.final_report?.report_date);
    }

    // New workflow functions
    // REMOVED - Duplicate function that was saving to wrong location
    
    function continueToValidation() {
      // Save all current data before proceeding
      saveDepreciationData();
      
      // Set workflow state
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (!helper.workflow) helper.workflow = {};
      helper.workflow.current_stage = 'fee_calculation';
      helper.workflow.from_builder = true;
      helper.workflow.report_type = document.getElementById('reportType')?.value || '×—×•×•×ª ×“×¢×ª ×¤×¨×˜×™×ª';
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Navigate to fee module
      window.location.href = 'fee-module.html';
    }

    // Function to ensure salvage sale calculation works properly
    function ensureSalvageSaleCalculation() {
      const reportType = document.getElementById('reportType')?.value;
      if (reportType === '×—×•×•×ª ×“×¢×ª ××›×™×¨×” ××¦×‘×• ×”× ×™×–×•×§') {
        console.log('ğŸ”„ Ensuring salvage sale calculation');
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        const marketValue = helper.calculations?.full_market_value || 0;
        
        // Update market value field
        const marketField = document.getElementById('sumMarketValueDamage');
        if (marketField && marketValue > 0) {
          marketField.value = `â‚ª${marketValue.toLocaleString()}`;
        }
        
        // Perform calculation
        const salvageSaleField = document.getElementById('saleValueDamage');
        if (salvageSaleField) {
          const salvagePrice = parseFloat(salvageSaleField.value.replace(/[â‚ª,]/g, '')) || 0;
          const result = marketValue - salvagePrice;
          
          const resultField = document.getElementById('afterSaleDamage');
          if (resultField) {
            resultField.value = `â‚ª${result.toLocaleString()}`;
            console.log(`âœ… Salvage sale calculation ensured: ${marketValue} - ${salvagePrice} = ${result}`);
          }
        }
      }
    }
    
    // Function to ensure total loss calculation works properly with retry mechanism
    function ensureTotalLossCalculation(retryCount = 0) {
      const reportType = document.getElementById('reportType')?.value;
      if (reportType === '×—×•×•×ª ×“×¢×ª ×˜×•×˜×œ×•×¡×˜') {
        console.log(`ğŸ”„ Ensuring total loss calculation (attempt ${retryCount + 1})`);
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        const marketValue = helper.calculations?.full_market_value || 0;
        
        // Update market value field
        const marketField = document.getElementById('sumMarketValueTotal');
        if (marketField && marketValue > 0) {
          marketField.value = `â‚ª${marketValue.toLocaleString()}`;
        }
        
        // Get field elements
        const salvageField = document.getElementById('salvageValueTotal');
        const towingField = document.getElementById('storageValueTotal');
        const resultField = document.getElementById('afterSaleTotal');
        
        // Check if fields are populated
        const fieldsReady = salvageField && towingField && 
                           (salvageField.value || towingField.value || 
                            helper.final_report?.summary?.salvage_value_total || 
                            helper.final_report?.summary?.storage_towing_value_total);
        
        if (!fieldsReady && retryCount < 5) {
          // Fields not ready, retry after delay
          console.log(`â³ Fields not ready, retrying in 500ms...`);
          setTimeout(() => {
            ensureTotalLossCalculation(retryCount + 1);
          }, 500);
          return;
        }
        
        // Load manual fields from helper if empty
        if (salvageField && !salvageField.value) {
          const savedSalvage = helper.final_report?.summary?.salvage_value_total || '';
          if (savedSalvage) {
            salvageField.value = savedSalvage;
            console.log(`ğŸ“¥ Loaded salvage value from helper: ${salvageField.value}`);
          }
        }
        
        if (towingField && !towingField.value) {
          const savedTowing = helper.final_report?.summary?.storage_towing_value_total || '';
          if (savedTowing) {
            towingField.value = savedTowing;
            console.log(`ğŸ“¥ Loaded towing value from helper: ${towingField.value}`);
          }
        }
        
        // Perform calculation with current values
        if (resultField && marketValue > 0) {
          const salvageValue = parseFloat(salvageField?.value?.replace(/[â‚ª,]/g, '')) || 0;
          const towingValue = parseFloat(towingField?.value?.replace(/[â‚ª,]/g, '')) || 0;
          const result = marketValue - salvageValue + towingValue;
          
          resultField.value = `â‚ª${result.toLocaleString()}`;
          console.log(`âœ… Total loss calculation: ${marketValue} - ${salvageValue} + ${towingValue} = ${result}`);
          
          // Double-check after delay to ensure it sticks
          setTimeout(() => {
            const currentValue = resultField.value;
            const expectedValue = `â‚ª${result.toLocaleString()}`;
            if (currentValue !== expectedValue) {
              resultField.value = expectedValue;
              console.log(`ğŸ”§ Re-applied total loss result: ${expectedValue}`);
            }
          }, 1000);
        }
      }
    }
    
    // Debug function to check Total Loss field values
    function debugTotalLossFields() {
      console.log('ğŸ› DEBUG: Total Loss Fields Status');
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      console.log('Helper values:', {
        marketValue: helper.calculations?.full_market_value,
        salvageInHelper: helper.final_report?.summary?.salvage_value_total,
        towingInHelper: helper.final_report?.summary?.storage_towing_value_total
      });
      
      const salvageField = document.getElementById('salvageValueTotal');
      const towingField = document.getElementById('storageValueTotal');
      const resultField = document.getElementById('afterSaleTotal');
      
      console.log('DOM field values:', {
        salvageField: salvageField?.value,
        towingField: towingField?.value,
        resultField: resultField?.value
      });
      
      console.log('Field elements exist:', {
        salvageField: !!salvageField,
        towingField: !!towingField,
        resultField: !!resultField
      });
    }
    
    // Make functions globally available
    window.updateSummaryVisibility = updateSummaryVisibility;
    window.ensureSalvageSaleCalculation = ensureSalvageSaleCalculation;
    window.ensureTotalLossCalculation = ensureTotalLossCalculation;
    window.debugTotalLossFields = debugTotalLossFields;
    
    // Initialize summary after helper system is ready
    function initializeSummaryWhenReady() {
      // Check both window.helper and sessionStorage for helper data
      const helperFromWindow = window.helper;
      const helperFromSession = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const helper = helperFromWindow || helperFromSession;
      
      // Ensure window.helper is set
      if (!window.helper) {
        window.helper = helper;
      }
      
      // Wait for market value to be available
      const marketValue = helper?.calculations?.full_market_value || 0;
      console.log(`ğŸ” Checking helper readiness - Market value: ${marketValue}`);
      
      if (helper && marketValue > 0) {
        console.log('ğŸ”„ Helper data is ready with market value, initializing summary...');
        
        // Restore the saved report type from helper or sessionStorage
        const reportTypeSelect = document.getElementById('reportType');
        const savedVariant = sessionStorage.getItem('selectedReportVariant') || helper.final_report?.dropdown_type;
        if (reportTypeSelect && savedVariant) {
          reportTypeSelect.value = savedVariant;
          console.log('âœ… Restored report type:', savedVariant);
          
          // Ensure helper is updated with the restored value
          if (!helper.final_report) helper.final_report = {};
          helper.final_report.dropdown_type = savedVariant;
          window.helper = helper;
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        
        // First load all summary fields from helper
        loadSummaryFieldsFromHelper(helper);
        console.log('âœ… Loaded summary fields from helper');
        
        console.log('ğŸ”„ About to call updateSummaryVisibility()');
        updateSummaryVisibility();
        console.log('âœ… updateSummaryVisibility() called');
        
        // Additional safety: refresh summary after a short delay to ensure DOM is ready
        setTimeout(() => {
          console.log('ğŸ”„ Safety refresh of summary after DOM stabilization');
          refreshSummary();
          ensureSalvageSaleCalculation();
          ensureTotalLossCalculation();
          ensureLegalLossCalculation();
        }, 500);
        
        // Extra safety for Total Loss variant - ensure fields are populated before calculation
        if (savedVariant === '×—×•×•×ª ×“×¢×ª ×˜×•×˜×œ×•×¡×˜') {
          setTimeout(() => {
            console.log('ğŸ”„ Extra safety refresh for Total Loss variant');
            ensureTotalLossCalculation();
          }, 1000);
        }
        
        // Extra safety for Legal Loss variant - ensure fields are populated before calculation
        if (savedVariant === '×—×•×•×ª ×“×¢×ª ××•×‘×“×Ÿ ×œ×”×œ×›×”') {
          setTimeout(() => {
            console.log('ğŸ”„ Extra safety refresh for Legal Loss variant');
            ensureLegalLossCalculation();
          }, 1000);
        }
      } else {
        console.log('â³ Helper data not ready yet (market value missing), waiting 500ms...');
        setTimeout(initializeSummaryWhenReady, 500);
      }
    }
    
    // Add event listeners for Total Loss and Salvage Sale calculations
    function setupTotalLossCalculation() {
      // Total Loss fields
      const salvageFieldTotal = document.getElementById('salvageValueTotal');
      const towingFieldTotal = document.getElementById('storageValueTotal');
      
      // Salvage Sale field
      const salvageSaleField = document.getElementById('saleValueDamage');
      
      // Legal Loss field
      const salvageLegalField = document.getElementById('salvageValueLegal');
      
      if (salvageFieldTotal) {
        salvageFieldTotal.addEventListener('input', refreshSummary);
      }
      if (towingFieldTotal) {
        towingFieldTotal.addEventListener('input', refreshSummary);
      }
      if (salvageSaleField) {
        salvageSaleField.addEventListener('input', refreshSummary);
      }
      if (salvageLegalField) {
        salvageLegalField.addEventListener('input', refreshSummary);
      }
      
      // Add event delegation for dynamically created fields
      document.addEventListener('input', function(event) {
        const fieldId = event.target.id;
        if (fieldId === 'saleValueDamage' || fieldId === 'sumDamagedSaleValue' || 
            fieldId === 'salvageValueTotal' || fieldId === 'storageValueTotal' ||
            fieldId === 'salvageValueLegal') {
          console.log(`ğŸ¯ Field input detected via event delegation: ${fieldId}`);
          refreshSummary();
        }
      });
    }

    // ENSURE LEGAL LOSS CALCULATION - Retry mechanism for page refresh timing issues
    function ensureLegalLossCalculation(retryCount = 0) {
      const reportType = document.getElementById('reportType')?.value;
      if (reportType === '×—×•×•×ª ×“×¢×ª ××•×‘×“×Ÿ ×œ×”×œ×›×”') {
        console.log(`ğŸ”„ Ensuring legal loss calculation (attempt ${retryCount + 1})`);
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        const marketValue = helper.calculations?.full_market_value || 0;
        
        // Update market value field
        const marketField = document.getElementById('sumMarketValueLegal');
        if (marketField && marketValue > 0) {
          marketField.value = `â‚ª${marketValue.toLocaleString()}`;
        }
        
        // Get field elements
        const salvageField = document.getElementById('salvageValueLegal');
        const resultField = document.getElementById('afterSaleLegal');
        
        // Check if fields are populated
        const fieldsReady = salvageField && 
                           (salvageField.value || 
                            helper.final_report?.summary?.salvage_value_legal);
        
        if (!fieldsReady && retryCount < 5) {
          // Fields not ready, retry after delay
          console.log(`â³ Legal loss fields not ready, retrying in 500ms...`);
          setTimeout(() => {
            ensureLegalLossCalculation(retryCount + 1);
          }, 500);
          return;
        }
        
        // Load manual fields from helper if they're empty
        if (salvageField && !salvageField.value) {
          const savedSalvage = helper.final_report?.summary?.salvage_value_legal || '';
          if (savedSalvage) {
            salvageField.value = savedSalvage;
            console.log(`ğŸ“¥ Loaded legal loss salvage value: ${salvageField.value}`);
          }
        }
        
        // Perform calculation
        if (resultField && marketValue > 0) {
          const salvageValue = parseFloat(salvageField?.value.replace(/[â‚ª,]/g, '')) || 0;
          const legalLossResult = marketValue - salvageValue;
          
          resultField.value = `â‚ª${legalLossResult.toLocaleString()}`;
          console.log(`ğŸ§® Legal Loss retry calculation: â‚ª${marketValue.toLocaleString()} - â‚ª${salvageValue.toLocaleString()} = â‚ª${legalLossResult.toLocaleString()}`);
          
          // Save to helper
          helper.final_report = helper.final_report || {};
          helper.final_report.summary = helper.final_report.summary || {};
          helper.final_report.summary.total_after_salvage_legal = resultField.value;
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
      }
    }
    
    // Setup Total Loss calculation and start checking for helper readiness
    setupTotalLossCalculation();
    initializeSummaryWhenReady();
    
    // Additional safeguard on window load
    window.addEventListener('load', function() {
      setTimeout(() => {
        console.log('ğŸ”„ Window load - ensuring variant calculations');
        ensureSalvageSaleCalculation();
        ensureTotalLossCalculation();
        ensureLegalLossCalculation();
      }, 1000);
    });
    window.addDepreciationRow = addDepreciationRow;
    window.addDifferentialRow = addDifferentialRow;
    window.updateDifferentialsSummary = updateDifferentialsSummary;
    window.refreshDamageCentersContainerLayout = refreshDamageCentersContainerLayout;
    window.toggleNatureOtherField = toggleNatureOtherField;
    window.toggleDifferentials = toggleDifferentials;
    window.toggleDifferentialsTable = toggleDifferentialsTable;
    window.updateFinalReportDate = updateFinalReportDate;
    
    // Test function accessibility
    console.log('ğŸ§ª updateFinalReportDate function available:', typeof window.updateFinalReportDate);
    
    // Add event listeners programmatically as backup
    document.addEventListener('DOMContentLoaded', function() {
      const topField = document.getElementById('finalReportDate');
      const summaryField = document.getElementById('finalReportDateSummary');
      
      if (topField) {
        console.log('ğŸ”§ Adding event listener to finalReportDate');
        topField.addEventListener('change', function() {
          console.log('ğŸ“… finalReportDate changed programmatically to:', this.value);
          updateFinalReportDate(this);
        });
      }
      
      if (summaryField) {
        console.log('ğŸ”§ Adding event listener to finalReportDateSummary');
        summaryField.addEventListener('change', function() {
          console.log('ğŸ“… finalReportDateSummary changed programmatically to:', this.value);
          updateFinalReportDate(this);
        });
      }
    });
    window.saveDepreciationData = saveDepreciationData;
    window.continueToValidation = continueToValidation;
    window.saveAndRefresh = saveAndRefresh;
    window.saveAndRefreshComplete = saveAndRefreshComplete;
    window.refreshSummary = refreshSummary;
    window.calculateSubtotals = calculateSubtotals;
    window.calculateSummaryTotals = calculateSummaryTotals;
    window.calculateAdditionsTotal = calculateAdditionsTotal;
    window.calculateLeviAdjustmentsTotal = calculateLeviAdjustmentsTotal;
    window.populateAdditionsFromLevi = populateAdditionsFromLevi;
    window.collectDifferentials = collectDifferentials;
    window.getVatRate = getVatRate;
    window.renderDifferentials = renderDifferentials;
    window.saveDifferentials = saveDifferentials;
    window.updateFinalReportField = updateFinalReportField;
    window.loadDifferentialData = loadDifferentialData;
    window.reattachDifferentialEventListeners = reattachDifferentialEventListeners;
    window.saveDifferentials = saveDifferentials;
    window.saveDifferentialsToHelper = saveDifferentialsToHelper;
    window.addDifferentialRow = addDifferentialRow;
    window.toggleDifferentialsTable = toggleDifferentialsTable;
    window.testDifferentialSave = () => {
      console.log('ğŸ§ª MANUAL TEST: Reattaching listeners and saving...');
      reattachDifferentialEventListeners();
      setTimeout(saveDifferentialsToHelper, 200);
    };
    
    window.debugDifferentialData = () => {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('ğŸ” CURRENT HELPER DIFFERENTIAL DATA:', {
        exists: !!helper.final_report?.differential,
        has_differentials: helper.final_report?.differential?.has_differentials,
        items_count: helper.final_report?.differential?.items?.length || 0,
        items: helper.final_report?.differential?.items,
        full_structure: helper.final_report?.differential
      });
    };
    
    window.forceLoadDifferentials = () => {
      window.differentialDataLoaded = false;
      loadDifferentialData();
    };
    window.createLeviAdjustmentRow = createLeviAdjustmentRow;
    window.calculateGlobalDepreciationValue = calculateGlobalDepreciationValue;
    window.triggerMathCalculation = triggerMathCalculation;
    window.addCustomSummaryField = addCustomSummaryField;

    // Document Operations Functions
    window.returnToSelection = function() {
      if (confirm('×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×—×–×•×¨ ×œ×“×£ ×”×‘×—×™×¨×”? ×”×©×™× ×•×™×™× ×©×œ× × ×©××¨×• ×™××‘×“×•.')) {
        window.location.href = 'selection.html';
      }
    };

    window.saveData = function() {
      saveFinalReport();
    };

    // Preview final report with all filled data
    window.previewFinalReport = function() {
      try {
        console.log('ğŸ” Opening final report template preview in PiP...');
        
        // Save current data first
        saveDepreciationData();
        
        // Get all the data from helper
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Set a flag to indicate we're in preview mode
        helper.preview_mode = true;
        helper.preview_timestamp = new Date().toISOString();
        
        // Make sure all the latest data is in the helper
        helper.final_report = helper.final_report || {};
        helper.final_report.generated_date = new Date().toLocaleDateString('he-IL');
        helper.final_report.preview = true;
        
        // Save the helper with preview flag
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Create preview modal if it doesn't exist
        let previewModal = document.getElementById('reportPreviewModal');
        if (!previewModal) {
          previewModal = createPreviewModal();
          document.body.appendChild(previewModal);
        }
        
        // Show the modal
        previewModal.style.display = 'block';
        
        // Load the report template in the iframe and populate tables after load
        const iframe = document.getElementById('reportPreviewFrame');
        
        // Use the exact same approach that works in template-builder
        iframe.onload = function() {
          console.log('ğŸ“„ Template iframe loaded, waiting for initialization...');
          
          // Wait for the template to fully initialize
          setTimeout(() => {
            try {
              const iframeWindow = iframe.contentWindow;
              const iframeDocument = iframe.contentDocument;
              
              // Ensure sessionStorage data is available in iframe
              const helperData = sessionStorage.getItem('helper');
              const metaData = sessionStorage.getItem('meta');
              if (helperData) iframeWindow.sessionStorage.setItem('helper', helperData);
              if (metaData) iframeWindow.sessionStorage.setItem('meta', metaData);
              
              // Multiple retry attempts to ensure functions are loaded and execute
              let attempts = 0;
              const populateTables = () => {
                attempts++;
                if (iframeWindow && iframeWindow.populateNewAdjustmentsTable) {
                  console.log('âœ… Populating iframe tables...');
                  iframeWindow.populateNewAdjustmentsTable();
                  iframeWindow.populateGrossDamageTable();
                  iframeWindow.formatDamagePercent();
                  console.log('âœ… Preview tables populated successfully');
                } else if (attempts < 15) {
                  console.log(`â³ Waiting for iframe functions... attempt ${attempts}`);
                  setTimeout(populateTables, 500);
                } else {
                  console.log('âŒ Failed to find iframe functions after 15 attempts');
                }
              };
              
              populateTables();
            } catch (e) {
              console.error('Error populating preview tables:', e);
            }
          }, 3000); // Longer initial wait
        };
        
        iframe.src = 'final-report-template-builder.html';
        
        // Remove preview flag after a short delay
        setTimeout(() => {
          const updatedHelper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          delete updatedHelper.preview_mode;
          delete updatedHelper.preview_timestamp;
          if (updatedHelper.final_report) {
            delete updatedHelper.final_report.preview;
          }
          sessionStorage.setItem('helper', JSON.stringify(updatedHelper));
        }, 2000);
        
        console.log('âœ… Final report preview opened in PiP');
        
      } catch (error) {
        console.error('âŒ Error opening preview:', error);
        alert('×©×’×™××” ×‘×¤×ª×™×—×ª ×ª×¦×•×’×” ××§×“×™××”');
      }
    };
    
    // Create the preview modal structure
    function createPreviewModal() {
      const modal = document.createElement('div');
      modal.id = 'reportPreviewModal';
      
      // Get viewport dimensions for responsive sizing
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const isMobile = viewportWidth <= 768;
      
      // Calculate responsive dimensions and center positioning
      const width = isMobile ? Math.min(viewportWidth - 20, 350) : Math.min(800, viewportWidth - 100);
      const height = isMobile ? Math.min(viewportHeight - 100, 500) : Math.min(viewportHeight * 0.8, 600);
      const top = Math.max(10, (viewportHeight - height) / 2);
      const left = Math.max(10, (viewportWidth - width) / 2);
      
      modal.style.cssText = `
        display: none;
        position: fixed;
        top: ${top}px;
        left: ${left}px;
        width: ${width}px;
        height: ${height}px;
        background: white;
        border: 2px solid #333;
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        z-index: 10000;
        resize: ${isMobile ? 'none' : 'both'};
        overflow: auto;
        min-width: ${isMobile ? '300px' : '400px'};
        min-height: ${isMobile ? '250px' : '300px'};
        max-width: 95vw;
        max-height: 95vh;
      `;
      
      // Create header
      const header = document.createElement('div');
      header.style.cssText = `
        background: #1e40af;
        color: white;
        padding: ${isMobile ? '8px 12px' : '12px 20px'};
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: move;
        user-select: none;
        border-radius: 10px 10px 0 0;
        min-height: ${isMobile ? '40px' : '48px'};
        box-sizing: border-box;
      `;
      header.innerHTML = `
        <h3 style="margin: 0; font-size: ${isMobile ? '14px' : '18px'}; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">×ª×¦×•×’×” ××§×“×™××” - ×—×•×•×ª ×“×¢×ª</h3>
        <div style="display: flex; gap: ${isMobile ? '5px' : '10px'}; flex-shrink: 0;">
          <button onclick="minimizePreview()" style="background: none; border: none; color: white; font-size: ${isMobile ? '16px' : '20px'}; cursor: pointer; width: ${isMobile ? '32px' : '24px'}; height: ${isMobile ? '32px' : '24px'}; touch-action: manipulation;" title="××–×¢×¨">_</button>
          <button onclick="maximizePreview()" style="background: none; border: none; color: white; font-size: ${isMobile ? '16px' : '20px'}; cursor: pointer; width: ${isMobile ? '32px' : '24px'}; height: ${isMobile ? '32px' : '24px'}; touch-action: manipulation;" title="×”×’×“×œ">â–¡</button>
          <button onclick="closePreview()" style="background: none; border: none; color: white; font-size: ${isMobile ? '20px' : '24px'}; cursor: pointer; width: ${isMobile ? '32px' : '24px'}; height: ${isMobile ? '32px' : '24px'}; touch-action: manipulation;" title="×¡×’×•×¨">Ã—</button>
        </div>
      `;
      
      // Create iframe container
      const iframeContainer = document.createElement('div');
      iframeContainer.style.cssText = `
        width: 100%;
        height: calc(100% - 50px);
        overflow: hidden;
      `;
      
      // Create iframe
      const iframe = document.createElement('iframe');
      iframe.id = 'reportPreviewFrame';
      iframe.style.cssText = `
        width: 100%;
        height: 100%;
        border: none;
      `;
      
      iframeContainer.appendChild(iframe);
      modal.appendChild(header);
      modal.appendChild(iframeContainer);
      
      // Make the modal draggable
      makeDraggable(modal, header);
      
      return modal;
    }
    
    // Make element draggable
    function makeDraggable(element, handle) {
      let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
      handle.onmousedown = dragMouseDown;
      
      function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
      }
      
      function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
        element.style.right = "auto";
      }
      
      function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
      }
    }
    
    // Preview control functions
    window.closePreview = function() {
      const modal = document.getElementById('reportPreviewModal');
      if (modal) {
        modal.style.display = 'none';
        const iframe = document.getElementById('reportPreviewFrame');
        if (iframe) iframe.src = '';
      }
    };
    
    window.minimizePreview = function() {
      const modal = document.getElementById('reportPreviewModal');
      if (modal) {
        modal.style.width = '400px';
        modal.style.height = '300px';
      }
    };
    
    window.maximizePreview = function() {
      const modal = document.getElementById('reportPreviewModal');
      if (modal) {
        modal.style.width = '90vw';
        modal.style.height = '90vh';
        modal.style.top = '5vh';
        modal.style.left = '5vw';
      }
    };


    // Functions for renamed buttons (former final report functions)
    window.fetchFinalReportPDF = function() {
      // Redirect to preview final report functionality
      previewFinalReport();
    };

    window.requestFinalReport = function() {
      // Redirect to generate final report functionality  
      generateFinalReport();
    };

    // EXPERTISE FETCH FUNCTION - Uses input field for flexibility
    window.fetchExpertisePDF = async function() {
      // FETCH functions use input field for flexibility (can load any case)
      const plateInput = document.getElementById('builderPlateInput');
      const plateNumber = plateInput ? plateInput.value.trim() : '';
      
      if (!plateNumber) {
        alert('×× × ×”×›× ×¡ ××¡×¤×¨ ×¨×›×‘ ×‘×©×“×” "×˜×¢×Ÿ ×ª×™×§ ×§×™×™×"');
        return;
      }
      
      const fetchBtn = document.getElementById('fetchExpertiseBtn');
      const originalText = fetchBtn.textContent;
      
      try {
        fetchBtn.disabled = true;
        fetchBtn.textContent = '×˜×•×¢×Ÿ PDF...';
        
        const helper = sessionStorage.getItem('helper');
        const caseData = helper ? JSON.parse(helper) : null;
        const payload = {
          plate: plateNumber,
          case_id: caseData?.meta?.case_id,
          document_type: 'expertise'
        };
        
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('FETCH_EXPERTISE_PDF', payload);
        
        if (response?.success && response?.pdf_url) {
          showFloatingPDF(response.pdf_url, '××§×¡×¤×™×¨×˜×™×–×” PDF');
        } else {
          alert('××§×¡×¤×™×¨×˜×™×–×” ×œ× × ××¦××” ×‘××¢×¨×›×ª ××• ×œ× ×”×•×¤×§×” ×¢×“×™×™×Ÿ');
        }
        
      } catch (error) {
        console.error('Error fetching expertise PDF:', error);
        alert('×©×’×™××” ×‘×˜×¢×™× ×ª ××§×¡×¤×™×¨×˜×™×–×” PDF');
      } finally {
        fetchBtn.disabled = false;
        fetchBtn.textContent = originalText;
      }
    };

    // ESTIMATE FUNCTIONS - NEW ADDITION
    window.fetchEstimatePDF = async function() {
      // FETCH functions use input field for flexibility (can load any case)
      const plateInput = document.getElementById('builderPlateInput');
      const plateNumber = plateInput ? plateInput.value.trim() : '';
      
      if (!plateNumber) {
        alert('×× × ×”×›× ×¡ ××¡×¤×¨ ×¨×›×‘ ×‘×©×“×” "×˜×¢×Ÿ ×ª×™×§ ×§×™×™×"');
        return;
      }
      
      const fetchBtn = document.getElementById('fetchEstimateBtn');
      const originalText = fetchBtn.textContent;
      
      try {
        fetchBtn.disabled = true;
        fetchBtn.textContent = '×˜×•×¢×Ÿ PDF...';
        
        const payload = {
          plate: plateNumber,
          case_id: helperData?.meta?.case_id,
          document_type: 'estimate'
        };
        
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('FETCH_ESTIMATE_PDF', payload);
        
        if (response?.success && response?.pdf_url) {
          showFloatingPDF(response.pdf_url, '××•××“×Ÿ ×¨××©×•× ×™ PDF');
        } else {
          alert('××•××“×Ÿ ×¨××©×•× ×™ ×œ× × ××¦× ×‘××¢×¨×›×ª ××• ×œ× ×”×•×¤×§ ×¢×“×™×™×Ÿ');
        }
        
      } catch (error) {
        console.error('Error fetching estimate PDF:', error);
        alert('×©×’×™××” ×‘×˜×¢×™× ×ª ××•××“×Ÿ ×¨××©×•× ×™ PDF');
      } finally {
        fetchBtn.disabled = false;
        fetchBtn.textContent = originalText;
      }
    };



    window.exitSystem = function() {
      if (confirm('×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×¦××ª ××”××¢×¨×›×ª? ×”×©×™× ×•×™×™× ×©×œ× × ×©××¨×• ×™××‘×“×•.')) {
        // Clear session data
        sessionStorage.clear();
        window.location.href = 'index.html';
      }
    };

    // ğŸ›ï¸ VAT RATE MANAGEMENT FUNCTIONS
    
    // Initialize VAT rate display
    window.initVatDisplay = async function() {
      try {
        // Try to get actual VAT rate from admin hub via MathEngine
        let adminVatRate = null;
        let vatSource = 'default';
        
        if (typeof MathEngine !== 'undefined' && MathEngine.loadAdminHubVatRate) {
          try {
            adminVatRate = await MathEngine.loadAdminHubVatRate();
            if (adminVatRate !== null) {
              vatSource = 'admin_hub';
              console.log('âœ… Loaded VAT rate from admin hub:', adminVatRate + '%');
            }
          } catch (e) {
            console.warn('âš ï¸ Could not load VAT rate from admin hub:', e);
          }
        }
        
        // Fallback to helper or default
        if (adminVatRate === null) {
          adminVatRate = window.getHelperVatRate ? window.getHelperVatRate() : 18;
          vatSource = window.helper?.calculations?.vat_rate ? 'helper' : 'default';
        }
        
        // Update MathEngine with admin rate
        if (typeof MathEngine !== 'undefined' && MathEngine.setVatRate && vatSource === 'admin_hub') {
          MathEngine.setVatRate(adminVatRate);
        }
        
        // Update display
        const vatInput = document.getElementById('vat-rate-input');
        const sourceDisplay = document.getElementById('vat-source-display');
        const updatedDisplay = document.getElementById('vat-updated-display');
        
        if (vatInput) vatInput.value = adminVatRate;
        if (sourceDisplay) {
          sourceDisplay.textContent = vatSource === 'admin_hub' ? '×× ×”×œ ××¢×¨×›×ª' : 
                                      vatSource === 'helper' ? '× ×ª×•× ×™ ××¢×¨×›×ª' : '×‘×¨×™×¨×ª ××—×“×œ';
        }
        if (updatedDisplay) {
          updatedDisplay.textContent = vatSource === 'admin_hub' ? 
            new Date().toLocaleString('he-IL') : '×œ× ×¢×•×“×›×Ÿ ×××“××™×Ÿ';
        }
        
        console.log(`ğŸ“Š VAT display initialized: ${adminVatRate}% (${vatSource})`);
        
      } catch (e) {
        console.warn('âš ï¸ Could not initialize VAT display:', e);
        // Fallback initialization
        const vatInput = document.getElementById('vat-rate-input');
        if (vatInput) vatInput.value = 18;
      }
    };
    
    // Update VAT rate manually (DIRECT UPDATE TO calculations.vat_rate)
    window.updateVatRate = function() {
      const input = document.getElementById('vat-rate-input');
      const newRate = parseFloat(input.value);
      
      if (isNaN(newRate) || newRate < 0 || newRate > 100) {
        alert('×× × ×”×–×Ÿ ×©×™×¢×•×¨ ××¢"× ×—×•×§×™ (0-100)');
        return;
      }
      
      // DIRECT UPDATE: Write directly to calculations.vat_rate (where all calculations read from)
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (!helper.calculations) helper.calculations = {};
      
      const oldRate = helper.calculations.vat_rate;
      
      // Set protection flags to ignore admin hub updates for 10 seconds
      window.lastManualVatUpdate = Date.now();
      window.ignoreAdminVatUntil = Date.now() + 10000; // 10 seconds protection
      console.log('ğŸ›¡ï¸ Manual VAT override protection activated for 10 seconds (final-report)');
      
      // CRITICAL: Create SESSION-ONLY override (NEVER touch admin hub)
      // 1. Update helper.calculations.vat_rate (session override)
      helper.calculations.vat_rate = newRate;
      helper.calculations.vat_rate_source = 'manual_session_override';
      helper.calculations.vat_rate_updated = new Date().toISOString();
      
      // 2. Update MathEngine with session override (DO NOT update admin hub core rate)
      if (typeof MathEngine !== 'undefined' && MathEngine.setSessionVatRate) {
        MathEngine.setSessionVatRate(newRate);
        console.log('SESSION OVERRIDE: MathEngine now uses:', newRate + '% (admin hub core rate preserved)');
      } else if (typeof MathEngine !== 'undefined') {
        // Fallback: direct update without admin hub communication
        sessionStorage.setItem('globalVAT', newRate);
        console.log('SESSION OVERRIDE: VAT rate stored in session, admin hub core rate preserved');
      }
      
      // Update window.helper in memory AND sessionStorage
      window.helper = helper;
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      console.log(`âœ… DUAL VAT UPDATE: helper.calculations.vat_rate AND MathEngine changed to ${newRate}%`);
      console.log('Current helper.calculations.vat_rate:', helper.calculations.vat_rate);
      
      alert(`×©×™×¢×•×¨ ×”××¢"× ×¢×•×“×›×Ÿ ×œ-${newRate}%`);
      window.initVatDisplay(); // Refresh display
      
      // Trigger calculations refresh
      if (typeof refreshAllCalculations === 'function') {
        refreshAllCalculations();
      }
    };
    
    // Reset VAT rate to admin hub value (DIRECT IMPLEMENTATION)
    window.resetVatRateFromAdmin = function() {
      if (confirm('×”×× ×œ××¤×¡ ××ª ×©×™×¢×•×¨ ×”××¢"× ×œ×¢×¨×š ×× ×”×œ ×”××¢×¨×›×ª?')) {
        
        // DIRECT ADMIN RATE RETRIEVAL (same as working estimate builder)
        console.log('DEBUGGING VAT SOURCES FOR RESET (FINAL REPORT):');
        console.log('- sessionStorage globalVAT:', sessionStorage.getItem('globalVAT'));
        console.log('- localStorage globalVAT:', localStorage.getItem('globalVAT'));
        console.log('- MathEngine available:', typeof MathEngine !== 'undefined');
        if (typeof MathEngine !== 'undefined' && MathEngine.getVatRate) {
          console.log('- MathEngine.getVatRate():', MathEngine.getVatRate());
        }
        
        // Get TRUE admin rate (NEVER from MathEngine - it has session overrides)
        let adminRate = 18; // TRUE admin hub default
        
        // Try to get the ORIGINAL admin rate from storage (if available)
        const originalAdminVat = localStorage.getItem('originalAdminVAT') || sessionStorage.getItem('originalAdminVAT');
        if (originalAdminVat && !isNaN(originalAdminVat)) {
          adminRate = parseFloat(originalAdminVat);
          console.log('Got ORIGINAL admin VAT from storage:', adminRate + '%');
        } else {
          // Fallback to known admin rate (should be 18% based on your setup)
          console.log('Using KNOWN admin hub rate (18%) - MathEngine has session overrides');
          adminRate = 18; // TRUE admin hub rate
        }
        
        console.log('ADMIN RATE FOR RESET (FINAL REPORT):', adminRate + '%');
        
        // DIRECTLY UPDATE BOTH SYSTEMS
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (!helper.calculations) helper.calculations = {};
        
        const oldRate = helper.calculations.vat_rate;
        const oldSource = helper.calculations.vat_rate_source;
        
        // RESTORE BOTH SYSTEMS to true admin rate
        // 1. Clear session override in helper
        helper.calculations.vat_rate = adminRate;
        helper.calculations.vat_rate_source = 'admin_hub_restored';
        helper.calculations.vat_rate_updated = new Date().toISOString();
        
        // Update window.helper and save
        window.helper = helper;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // 2. RESTORE MathEngine to true admin rate (clear session override)
        if (typeof MathEngine !== 'undefined') {
          console.log('BEFORE RESET: MathEngine had session override:', MathEngine.getVatRate ? MathEngine.getVatRate() : 'unknown');
          
          if (MathEngine.setVatRate) {
            MathEngine.setVatRate(adminRate);
            console.log('RESTORED: MathEngine back to admin rate:', adminRate + '%');
          }
          
          // Verify the restore worked
          setTimeout(() => {
            console.log('AFTER RESET: MathEngine now uses admin rate:', MathEngine.getVatRate ? MathEngine.getVatRate() : 'unknown');
          }, 100);
        }
        
        console.log('FINAL REPORT RESET COMPLETE: ' + oldRate + '% (' + oldSource + ') -> ' + adminRate + '% (admin_hub)');
        
        // Update display
        document.getElementById('vat-rate-input').value = adminRate;
        window.initVatDisplay();
        alert(`×©×™×¢×•×¨ ×”××¢"× ××•×¤×¡ ×œ×¢×¨×š ×× ×”×œ ×”××¢×¨×›×ª: ${adminRate}%`);
        
        // Trigger calculations refresh
        if (typeof refreshAllCalculations === 'function') {
          refreshAllCalculations();
        }
      }
    };
    
    // ğŸ”§ DEBUG: Test admin hub connection
    window.testAdminHubConnection = function() {
      console.log('ğŸ” Testing admin hub connection...');
      
      if (window.parent && window.parent !== window) {
        console.log('âœ… Parent frame detected - we are in an iframe');
        
        // Test VAT rate request
        const timeout = setTimeout(() => {
          console.log('âŒ Timeout: Admin hub did not respond');
          alert('âŒ ×œ× ×”×ª×§×‘×œ×” ×ª×©×•×‘×” ×××“××™×Ÿ ×‘×–××Ÿ - ×™×™×ª×›×Ÿ ×©×”×—×™×‘×•×¨ ×œ× ×¤×¢×™×œ');
        }, 3000);
        
        const messageHandler = (event) => {
          if (event.data && event.data.type === 'VAT_RATE_RESPONSE') {
            clearTimeout(timeout);
            window.removeEventListener('message', messageHandler);
            console.log('âœ… Admin hub responded with VAT rate:', event.data.vatRate + '%');
            alert(`âœ… ×—×™×‘×•×¨ ×œ××“××™×Ÿ ×¤×¢×™×œ! ×©×™×¢×•×¨ ××¢"× × ×•×›×—×™: ${event.data.vatRate}%`);
          }
        };
        
        window.addEventListener('message', messageHandler);
        window.parent.postMessage({ type: 'GET_VAT_RATE' }, '*');
        
      } else {
        console.log('âŒ No parent frame - not running in admin hub');
        alert('âŒ ×œ× ×¨×¥ ×‘×ª×•×š ×× ×”×œ ×”××¢×¨×›×ª - ×¤×ª×— ×“×¨×š ×”×¤×•×¨×˜×œ');
      }
    };
    
    // ğŸ” VERIFY: Check if admin hub functions are loaded
    window.verifyAdminHubFunctions = function() {
      const functions = [
        'initVatDisplay',
        'updateVatRate', 
        'resetVatRateFromAdmin',
        'testAdminHubConnection',
        'getHelperVatRate',
        'refreshHelperVatRate'
      ];
      
      console.log('ğŸ” Checking admin hub function availability:');
      functions.forEach(funcName => {
        const available = typeof window[funcName] === 'function';
        console.log(`${available ? 'âœ…' : 'âŒ'} ${funcName}: ${available ? 'Available' : 'Not found'}`);
      });
      
      // Check MathEngine availability
      const mathEngineAvailable = typeof MathEngine !== 'undefined';
      console.log(`${mathEngineAvailable ? 'âœ…' : 'âŒ'} MathEngine: ${mathEngineAvailable ? 'Available' : 'Not found'}`);
      
      if (mathEngineAvailable) {
        console.log(`ğŸ“Š Current VAT rate from MathEngine: ${MathEngine.getVatRate()}%`);
      }
      
      return {
        functions: functions.reduce((acc, func) => ({ ...acc, [func]: typeof window[func] === 'function' }), {}),
        mathEngine: mathEngineAvailable,
        currentVat: mathEngineAvailable ? MathEngine.getVatRate() : null
      };
    };
    
    // ENSURE DATA FLOW: Update dependent fields when source data changes
    function refreshAllCalculations() {
      try {
        console.log('ğŸ”„ Starting calculation refresh...');
        
        // 0. Ensure basic price is populated from helper if empty
        ensureBasicPriceFromHelper();
        
        // 1. Update total claim from damage centers
        const totalClaim = calculateTotalClaimFromDamageCenters();
        const totalClaimField = document.getElementById('totalClaim');
        if (totalClaimField) {
          totalClaimField.value = totalClaim ? `â‚ª${totalClaim.toLocaleString()}` : 'â‚ª0';
          console.log(`ğŸ’° Updated totalClaim: ${totalClaim}`);
        }
        
        // 2. Update gross market value from basic price + adjustments
        // Only if helper data has been loaded (to avoid overriding helper data)
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        if (helper && Object.keys(helper).length > 0 && typeof updateGrossMarketValueCalculation === 'function') {
          updateGrossMarketValueCalculation();
          console.log('ğŸ“Š Updated gross market value');
        }
        
        // 3. Update damage percentage: totalClaim / grossMarketValue * 100
        if (typeof updateGrossPercentageField === 'function') {
          updateGrossPercentageField();
          console.log('ğŸ“ˆ Updated damage percentage');
        }
        
        // 4. Update full market value from basic price + all adjustments
        if (typeof calculateFullMarketValue === 'function') {
          calculateFullMarketValue();
          console.log('ğŸª Updated full market value');
        }
        
        console.log('âœ… All calculations refreshed');
      } catch (error) {
        console.error('âŒ Error refreshing calculations:', error);
      }
    }
    
    // Ensure basic price field is populated from helper data
    function ensureBasicPriceFromHelper() {
      try {
        const basicPriceField = document.getElementById('basicPrice');
        if (!basicPriceField) return;
        
        // Only update if field is empty
        if (basicPriceField.value && basicPriceField.value.trim() !== '') return;
        
        // ğŸ”§ PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        let basePrice = 0;
        
        // Try multiple helper paths for base price
        if (helper.valuation?.base_price) {
          basePrice = parseFloat(helper.valuation.base_price.toString().replace(/[â‚ª,]/g, ''));
        } else if (helper.levi_report?.base_price) {
          basePrice = parseFloat(helper.levi_report.base_price);
        } else if (helper.expertise?.levi_report?.base_price) {
          basePrice = parseFloat(helper.expertise.levi_report.base_price);
        } else if (helper.car_details?.base_price) {
          basePrice = parseFloat(helper.car_details.base_price.toString().replace(/[â‚ª,]/g, ''));
        }
        
        if (basePrice > 0) {
          basicPriceField.value = `â‚ª${basePrice.toLocaleString()}`;
          console.log(`ğŸ’µ Populated basicPrice from helper: ${basePrice}`);
        }
      } catch (error) {
        console.error('âŒ Error ensuring basic price from helper:', error);
      }
    }
    
    // Expose refresh function globally
    window.refreshAllCalculations = refreshAllCalculations;
    
    // NUCLEAR FIX FOR ALL MANUAL INPUT FIELDS
    function forceManualFieldsEditable() {
      const fieldsToFix = [
        {
          id: 'saleValueDamage',
          placeholder: '×”×–×Ÿ ×¢×¨×š ×”××›×™×¨×”...',
          label: 'Sale Value Damage',
          callback: function() {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[â‚ª,]/g, '')) || 0;
            calculateDamagedSaleReport(helper, marketValue).catch(console.error);
          }
        },
        {
          id: 'salvageValueTotal',
          placeholder: '×”×–×Ÿ ×¢×¨×š ×©×¨×™×“×™×...',
          label: 'Salvage Value Total',
          callback: function() {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[â‚ª,]/g, '')) || 0;
            calculateTotalLossReport(helper, marketValue);
          }
        },
        {
          id: 'storageValueTotal',
          placeholder: '×”×–×Ÿ ×¢×œ×•×ª ×’×¨×™×¨×” ×•××—×¡× ×”...',
          label: 'Storage Value Total',
          callback: function() {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[â‚ª,]/g, '')) || 0;
            calculateTotalLossReport(helper, marketValue);
          }
        },
        {
          id: 'salvageValueLegal',
          placeholder: '×”×–×Ÿ ×¢×¨×š ×©×¨×™×“×™×...',
          label: 'Salvage Value Legal',
          callback: function() {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[â‚ª,]/g, '')) || 0;
            calculateLegalLossReport(helper, marketValue);
          }
        }
      ];

      fieldsToFix.forEach(fieldConfig => {
        const field = document.getElementById(fieldConfig.id);
        if (field) {
          console.log(`ğŸš¨ FORCING ${fieldConfig.id} to be editable...`);
          
          // Nuclear option - completely reset the field
          const parent = field.parentNode;
          const newField = document.createElement('input');
          newField.type = 'text';
          newField.id = fieldConfig.id;
          newField.placeholder = fieldConfig.placeholder;
          newField.style.cssText = 'width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; background: white; color: #333;';
          
          // LOAD SAVED VALUE FROM HELPER
          const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
          const helperKey = getHelperMappingKey(fieldConfig.id);
          if (helperKey && helper.final_report?.summary?.[helperKey]) {
            newField.value = helper.final_report.summary[helperKey];
            console.log(`ğŸ“– Restored ${fieldConfig.id} value: ${newField.value}`);
          }
          
          // Add event listener with specific callback AND persistence
          newField.addEventListener('input', function(e) {
            console.log(`ğŸ’° ${fieldConfig.label} changed:`, e.target.value);
            
            // Save to helper immediately
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            if (!helper.final_report) helper.final_report = {};
            if (!helper.final_report.summary) helper.final_report.summary = {};
            
            const helperKey = getHelperMappingKey(fieldConfig.id);
            if (helperKey) {
              helper.final_report.summary[helperKey] = e.target.value;
              sessionStorage.setItem('helper', JSON.stringify(helper));
              window.helper = helper;
              console.log(`ğŸ’¾ Saved ${fieldConfig.id} to helper.final_report.summary.${helperKey}`);
            }
            
            // Trigger calculation
            if (fieldConfig.callback) {
              fieldConfig.callback();
            }
          });
          
          // Replace the problematic field
          parent.replaceChild(newField, field);
          console.log(`âœ… ${fieldConfig.id} field replaced with editable version`);
        }
      });
    }

    // Load differential data on page load
    document.addEventListener('DOMContentLoaded', function() {
      console.log('ğŸ“– Loading saved differential data...');
      setTimeout(loadDifferentialData, 1000); // Increased delay to ensure all other loading is complete
      
      // SESSION 62: Load case reduction data
      console.log('ğŸ“– Loading saved case reduction data...');
      setTimeout(loadCaseReductionFromHelper, 1000);
      
      // Initialize differential fields visibility based on checkbox state
      setTimeout(() => {
        toggleDifferentialsTable(); // This will properly show/hide the "×œ××—×¨ ×”×¤×¨×©×™×" fields
        console.log('âœ… Initialized differential fields visibility');
      }, 1200);
      
      // Fix all manual input fields
      setTimeout(forceManualFieldsEditable, 1500);
    });
    
    // Also try loading after the main data loading is complete
    window.addEventListener('load', function() {
      console.log('ğŸ“– Loading differential data after full page load...');
      setTimeout(loadDifferentialData, 500);
      
      // SESSION 62: Also load case reduction after full page load
      console.log('ğŸ“– Loading case reduction data after full page load...');
      setTimeout(loadCaseReductionFromHelper, 500);
    });
    
    // Auto-trigger calculation refresh when key data changes
    document.addEventListener('DOMContentLoaded', function() {
      console.log('ğŸš€ Setting up data flow observers...');
      
      // Refresh calculations when damage centers are updated
      const damageCentersElement = document.getElementById('damageCentersContent');
      if (damageCentersElement) {
        const observer = new MutationObserver(function(mutations) {
          console.log('ğŸ‘€ Damage centers changed, refreshing calculations...');
          setTimeout(refreshAllCalculations, 300);
        });
        observer.observe(damageCentersElement, { childList: true, subtree: true });
        console.log('ğŸ‘€ Damage centers observer set up');
      }
      
      // Refresh calculations when basicPrice field changes
      const basicPriceField = document.getElementById('basicPrice');
      if (basicPriceField) {
        basicPriceField.addEventListener('input', function() {
          console.log('ğŸ’µ Basic price changed, refreshing calculations...');
          setTimeout(refreshAllCalculations, 100);
        });
        console.log('ğŸ’µ BasicPrice observer set up');
      }
      
      // Initialize VAT display on page load
      setTimeout(function() {
        if (typeof window.initVatDisplay === 'function') {
          window.initVatDisplay();
          console.log('ğŸ›ï¸ VAT display initialized');
        }
      }, 1000);
      
      // Initial calculation refresh on page load (delayed to allow helper data to load first)
      // TEMPORARILY DISABLED to check if this is causing configuration issues
      // setTimeout(refreshAllCalculations, 2000);
    });
    
  </script>
  
  <script type="module">
    // Import and make MathEngine globally available
    import { MathEngine } from './math.js';
    import { caseOwnershipService } from './services/caseOwnershipService.js';
    
    // Make MathEngine available globally for other scripts
    window.MathEngine = MathEngine;
    
    // Log that MathEngine is now available
    console.log('âœ… MathEngine loaded and available globally');
    
    // Dispatch event to notify other scripts MathEngine is ready
    window.dispatchEvent(new CustomEvent('mathEngineReady', { 
      detail: { MathEngine: MathEngine } 
    }));
    
    // Phase 6: Case ownership check
    (async () => {
      const plateNumber = window.helper?.plate || sessionStorage.getItem('currentPlate');
      
      if (plateNumber) {
        const ownershipCheck = await caseOwnershipService.canEditCase(plateNumber);
        
        if (!ownershipCheck.canEdit) {
          alert(ownershipCheck.reason || '××™×Ÿ ×œ×š ×”×¨×©××” ×œ×¢×¨×•×š ×ª×™×§ ×–×”.\n\n×¨×§ ×”×‘×¢×œ×™×, ×× ×”×œ ××• ××¤×ª×— ×™×›×•×œ×™× ×œ×¢×¨×•×š.');
          window.location.href = 'selection.html';
          return;
        }
        
        console.log('âœ… Case ownership verified - user can edit final report');
      }
    })();
  </script>
  
  <script>
    // ğŸ”§ IMMEDIATE FUNCTIONS - Available right away for testing
    window.quickVatTest = function() {
      console.log('ğŸ” Quick VAT Test:');
      console.log('MathEngine available:', typeof MathEngine !== 'undefined');
      console.log('Helper VAT function:', typeof window.getHelperVatRate === 'function');
      console.log('Current VAT:', window.getHelperVatRate ? window.getHelperVatRate() : 'Not available');
      console.log('Parent frame detected:', window.parent !== window);
      
      // Test admin hub connection immediately
      if (window.parent && window.parent !== window) {
        console.log('ğŸ“¡ Sending test message to admin hub...');
        window.parent.postMessage({ type: 'GET_VAT_RATE' }, '*');
        
        // Listen for response
        const responseListener = (event) => {
          if (event.data && event.data.type === 'VAT_RATE_RESPONSE') {
            window.removeEventListener('message', responseListener);
            console.log('âœ… Admin hub responded with VAT:', event.data.vatRate + '%');
          }
        };
        window.addEventListener('message', responseListener);
        
        // Timeout if no response
        setTimeout(() => {
          window.removeEventListener('message', responseListener);
          console.log('â° No response from admin hub after 2 seconds');
        }, 2000);
      }
    };
    
    // Make it available immediately
    console.log('ğŸš€ Quick test available: quickVatTest()');
    
    // SESSION 94: Simple function to reload dropdown data and test
    window.reloadAndTestDropdown = async function() {
      console.log('ğŸ”„ SESSION 94: Reloading dropdown data...');
      
      // Clear cached data
      window.INVOICE_LINES = null;
      window.PARTS_CATALOG = null;
      
      try {
        await loadCatalogItems();
        await loadInvoiceLinesForDropdown();
        console.log('âœ… Data reloaded successfully');
        
        // Test the dropdown
        const allParts = getCombinedDropdownData('');
        const layerBreakdown = {
          1: allParts.filter(p => p.layer === 1).length,
          2: allParts.filter(p => p.layer === 2).length,  
          3: allParts.filter(p => p.layer === 3).length,
          4: allParts.filter(p => p.layer === 4).length
        };
        
        console.log('ğŸ“Š SESSION 94: Dropdown test results:');
        console.log('  Total parts:', allParts.length);
        console.log('  Layer 1 (Invoice Lines):', layerBreakdown[1]);
        console.log('  Layer 2 (Selected Parts):', layerBreakdown[2]);
        console.log('  Layer 3 (Catalog Items):', layerBreakdown[3]);
        console.log('  Layer 4 (Parts Bank):', layerBreakdown[4]);
        
        return {
          success: allParts.length > 0,
          totalParts: allParts.length,
          layerBreakdown,
          invoicesWorking: layerBreakdown[1] > 0,
          catalogWorking: layerBreakdown[3] > 0
        };
      } catch (err) {
        console.error('âŒ Error reloading data:', err);
        return { success: false, error: err.message };
      }
    };
    
    console.log('ğŸ§ª SESSION 94: Test functions available: reloadAndTestDropdown()');
    
    
    // PICTURE-IN-PICTURE OVERLAY FUNCTION
    function openInPiP(url, title) {
      console.log('ğŸ–¼ï¸ Creating PiP overlay for:', url);
      
      // Remove any existing PiP windows
      const existingPiP = document.getElementById('pipOverlay');
      if (existingPiP) {
        existingPiP.remove();
      }
      
      // Create overlay container
      const overlay = document.createElement('div');
      overlay.id = 'pipOverlay';
      
      // Get viewport dimensions for responsive sizing
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const isMobile = viewportWidth <= 768;
      
      // Calculate responsive dimensions and center positioning
      const width = isMobile ? Math.min(viewportWidth - 20, 350) : Math.min(800, viewportWidth - 100);
      const height = isMobile ? Math.min(viewportHeight - 100, 500) : Math.min(600, viewportHeight - 100);
      const top = Math.max(10, (viewportHeight - height) / 2);
      const left = Math.max(10, (viewportWidth - width) / 2);
      
      overlay.style.cssText = `
        position: fixed;
        top: ${top}px;
        left: ${left}px;
        width: ${width}px;
        height: ${height}px;
        background: white;
        border: 2px solid #1e3a8a;
        border-radius: 12px;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        z-index: 10000;
        display: flex;
        flex-direction: column;
        resize: ${isMobile ? 'none' : 'both'};
        overflow: hidden;
        font-family: inherit;
        max-width: 95vw;
        max-height: 95vh;
      `;
      
      // Create header with title and controls
      const header = document.createElement('div');
      header.style.cssText = `
        background: #1e3a8a;
        color: white;
        padding: ${isMobile ? '8px 12px' : '12px 16px'};
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: move;
        border-radius: 10px 10px 0 0;
        font-size: ${isMobile ? '12px' : '14px'};
        font-weight: bold;
        min-height: ${isMobile ? '40px' : '48px'};
        box-sizing: border-box;
      `;
      header.innerHTML = `
        <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${title}</span>
        <button onclick="document.getElementById('pipOverlay').remove()" style="
          background: none;
          border: none;
          color: white;
          font-size: ${isMobile ? '20px' : '18px'};
          cursor: pointer;
          padding: 0;
          width: ${isMobile ? '32px' : '24px'};
          height: ${isMobile ? '32px' : '24px'};
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          flex-shrink: 0;
          touch-action: manipulation;
        " onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='none'" ontouchstart="this.style.background='rgba(255,255,255,0.2)'" ontouchend="this.style.background='none'">Ã—</button>
      `;
      
      // Create iframe container
      const iframeContainer = document.createElement('div');
      iframeContainer.style.cssText = `
        flex: 1;
        overflow: hidden;
        position: relative;
      `;
      
      // Create iframe
      const iframe = document.createElement('iframe');
      iframe.src = url;
      iframe.style.cssText = `
        width: 100%;
        height: 100%;
        border: none;
        background: white;
      `;
      iframe.onload = function() {
        console.log('âœ… PiP iframe loaded successfully');
      };
      iframe.onerror = function() {
        console.error('âŒ PiP iframe failed to load');
        iframeContainer.innerHTML = `
          <div style="padding: 20px; text-align: center; color: #666;">
            <p>×©×’×™××” ×‘×˜×¢×™× ×ª ×”×ª×•×›×Ÿ</p>
            <button onclick="window.open('${url}', '_blank')" style="
              background: #1e3a8a;
              color: white;
              border: none;
              padding: 10px 20px;
              border-radius: 6px;
              cursor: pointer;
              margin-top: 10px;
            ">×¤×ª×— ×‘×—×œ×•×Ÿ ×—×“×©</button>
          </div>
        `;
      };
      
      // Assemble the PiP window
      iframeContainer.appendChild(iframe);
      overlay.appendChild(header);
      overlay.appendChild(iframeContainer);
      document.body.appendChild(overlay);
      
      // Make draggable
      let isDragging = false;
      let startX, startY, initialX, initialY;
      
      header.addEventListener('mousedown', function(e) {
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        initialX = overlay.offsetLeft;
        initialY = overlay.offsetTop;
        overlay.style.cursor = 'grabbing';
      });
      
      document.addEventListener('mousemove', function(e) {
        if (isDragging) {
          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;
          overlay.style.left = (initialX + deltaX) + 'px';
          overlay.style.top = (initialY + deltaY) + 'px';
        }
      });
      
      document.addEventListener('mouseup', function() {
        isDragging = false;
        overlay.style.cursor = 'default';
      });
      
      console.log('âœ… PiP overlay created successfully');
      
      // Add window resize listener to maintain responsiveness
      window.addEventListener('resize', function() {
        const currentOverlay = document.getElementById('pipOverlay');
        if (currentOverlay) {
          const newViewportWidth = window.innerWidth;
          const newViewportHeight = window.innerHeight;
          const newIsMobile = newViewportWidth <= 768;
          
          // Update dimensions and center on resize
          const newWidth = newIsMobile ? Math.min(newViewportWidth - 20, 350) : Math.min(800, newViewportWidth - 100);
          const newHeight = newIsMobile ? Math.min(newViewportHeight - 100, 500) : Math.min(600, newViewportHeight - 100);
          const newTop = Math.max(10, (newViewportHeight - newHeight) / 2);
          const newLeft = Math.max(10, (newViewportWidth - newWidth) / 2);
          
          currentOverlay.style.width = newWidth + 'px';
          currentOverlay.style.height = newHeight + 'px';
          currentOverlay.style.top = newTop + 'px';
          currentOverlay.style.left = newLeft + 'px';
          currentOverlay.style.right = 'auto';
          currentOverlay.style.resize = newIsMobile ? 'none' : 'both';
          currentOverlay.style.maxWidth = '95vw';
          currentOverlay.style.maxHeight = '95vh';
        }
      });
    }

    // LOCAL GENERATION FUNCTIONS - No webhooks needed, skip validation
    window.generateEstimateReport = function() {
      console.log('ğŸ”§ Generating estimate report locally...');
      console.log('âœ… GenerateEstimateReport function called successfully!');
      
      // Get current helper data or plate from input
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const plateInput = document.getElementById('builderPlateInput');
      const currentPlate = helper.plate || helper.××¡×¤×¨_×¨×›×‘ || helper['××¡ ×¨×›×‘'] || (plateInput ? plateInput.value.trim() : '');
      
      console.log('ğŸ“‹ Current plate for estimate:', currentPlate);
      console.log('ğŸ“Š Current helper data:', helper);
      
      // If no plate in helper but there's one in input, create minimal helper structure
      if (!currentPlate && plateInput && plateInput.value.trim()) {
        const plateValue = plateInput.value.trim();
        console.log('ğŸ“ Creating minimal helper structure with plate:', plateValue);
        
        // Create basic helper structure with plate
        const minimalHelper = {
          plate: plateValue,
          ××¡×¤×¨_×¨×›×‘: plateValue,
          meta: {
            case_id: `case_${plateValue}_${Date.now()}`,
            created_at: new Date().toISOString()
          }
        };
        
        // Merge with existing helper if any
        const updatedHelper = { ...helper, ...minimalHelper };
        sessionStorage.setItem('helper', JSON.stringify(updatedHelper));
        window.helper = updatedHelper;
      }
      
      // Skip saving final report data for direct report generation (avoids validation)
      console.log('â­ï¸ Skipping final report save for direct report generation...');
      
      // Set multiple flags to ensure estimate builder skips validation
      const reportConfig = {
        selectedReportType: 'estimate',
        skipValidation: true,
        autoSelectReportType: 'estimate',
        skipReportTypeDialog: true,
        directGeneration: true,
        fromFinalReportBuilder: 'true',
        reportTypeSelected: true,
        timestamp: new Date().toISOString()
      };
      
      // Set individual items including the bypass flag
      Object.keys(reportConfig).forEach(key => {
        sessionStorage.setItem(key, String(reportConfig[key]));
      });
      
      // Also set as complete config object
      sessionStorage.setItem('reportConfig', JSON.stringify(reportConfig));
      
      console.log('ğŸš€ Navigating directly to estimate builder...');
      console.log('ğŸ“‹ Report configuration set:', reportConfig);
      
      // Navigate directly to estimate builder, bypassing fee-module and report selection
      setTimeout(() => {
        const finalPlate = helper.plate || helper.××¡×¤×¨_×¨×›×‘ || helper['××¡ ×¨×›×‘'] || (plateInput ? plateInput.value.trim() : '');
        const urlWithParams = `estimate-report-builder.html?plate=${encodeURIComponent(finalPlate)}&skipValidation=true&fromFinalReportBuilder=true`;
        console.log('ğŸ¯ Direct navigation to estimate report builder:', urlWithParams);
        
        try {
          // Create a proper PiP window using iframe approach
          openInPiP(urlWithParams, 'Estimate Report Builder');
        } catch (error) {
          console.warn('âš ï¸ PiP opening failed, trying fallback navigation:', error);
          window.location.href = 'estimate-report-builder.html?skipValidation=true&fromFinalReportBuilder=true';
        }
      }, 100);
    };
    
    window.generateExpertiseReport = function() {
      console.log('ğŸ”§ Generating expertise report locally...');
      console.log('âœ… GenerateExpertiseReport function called successfully!');
      
      // Get current helper data or plate from input  
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const plateInput = document.getElementById('builderPlateInput');
      const currentPlate = helper.plate || helper.××¡×¤×¨_×¨×›×‘ || helper['××¡ ×¨×›×‘'] || (plateInput ? plateInput.value.trim() : '');
      
      console.log('ğŸ“‹ Current plate for expertise:', currentPlate);
      console.log('ğŸ“Š Current helper data:', helper);
      
      // If no plate in helper but there's one in input, create minimal helper structure
      if (!currentPlate && plateInput && plateInput.value.trim()) {
        const plateValue = plateInput.value.trim();
        console.log('ğŸ“ Creating minimal helper structure with plate:', plateValue);
        
        // Create basic helper structure with plate
        const minimalHelper = {
          plate: plateValue,
          ××¡×¤×¨_×¨×›×‘: plateValue,
          meta: {
            case_id: `case_${plateValue}_${Date.now()}`,
            created_at: new Date().toISOString()
          }
        };
        
        // Merge with existing helper if any
        const updatedHelper = { ...helper, ...minimalHelper };
        sessionStorage.setItem('helper', JSON.stringify(updatedHelper));
        window.helper = updatedHelper;
      }
      
      // Skip saving final report data for direct report generation (avoids validation)
      console.log('â­ï¸ Skipping final report save for direct report generation...');
      
      // Set multiple flags to ensure fee module gets the message
      const reportConfig = {
        selectedReportType: 'expertise',
        skipValidation: true,
        autoSelectReportType: 'expertise',
        skipReportTypeDialog: true,
        directGeneration: true,
        fromFinalReportBuilder: true,
        reportTypeSelected: true,
        timestamp: new Date().toISOString()
      };
      
      // Set individual items
      Object.keys(reportConfig).forEach(key => {
        sessionStorage.setItem(key, String(reportConfig[key]));
      });
      
      // Also set as complete config object
      sessionStorage.setItem('reportConfig', JSON.stringify(reportConfig));
      
      console.log('ğŸš€ Navigating directly to expertise builder...');
      console.log('ğŸ“‹ Report configuration set:', reportConfig);
      
      // Navigate directly to expertise builder, bypassing fee-module and report selection
      setTimeout(() => {
        const finalPlate = helper.plate || helper.××¡×¤×¨_×¨×›×‘ || helper['××¡ ×¨×›×‘'] || (plateInput ? plateInput.value.trim() : '');
        const urlWithParams = `expertise builder.html?plate=${encodeURIComponent(finalPlate)}&skipValidation=true&fromFinalReportBuilder=true`;
        console.log('ğŸ¯ Direct navigation to expertise builder:', urlWithParams);
        
        try {
          // Create a proper PiP window using iframe approach
          openInPiP(urlWithParams, 'Expertise Builder');
        } catch (error) {
          console.warn('âš ï¸ PiP opening failed, trying fallback navigation:', error);
          window.location.href = 'expertise builder.html?skipValidation=true&fromFinalReportBuilder=true';
        }
      }, 100);
    };
    
    console.log('âœ… Local generation functions defined:', {
      generateEstimateReport: typeof window.generateEstimateReport,
      generateExpertiseReport: typeof window.generateExpertiseReport
    });
    
    // FORCE PLATE INPUT TO BE PLAIN TEXT - Keep password type for autofill but prevent dots
    window.forcePlateInputAsText = function() {
      const plateInput = document.getElementById('builderPlateInput');
      if (plateInput) {
        // Keep type as password for autofill, but override the visual display
        plateInput.style.webkitTextSecurity = 'none';
        plateInput.style.textSecurity = 'none';
        plateInput.style.fontFamily = 'inherit';
        plateInput.style.letterSpacing = 'normal';
        plateInput.style.fontSize = '16px';
        
        // Additional CSS to prevent password styling
        plateInput.style.setProperty('-webkit-text-security', 'none', 'important');
        plateInput.style.setProperty('text-security', 'none', 'important');
        
        console.log('ğŸ”¢ Plate input configured for autofill with plain text display');
      }
    };
    
    // Apply the fix immediately and on DOM ready
    setTimeout(window.forcePlateInputAsText, 100);
    document.addEventListener('DOMContentLoaded', window.forcePlateInputAsText);
    
    // Enhanced event listeners to maintain plain text display
    document.addEventListener('DOMContentLoaded', function() {
      const plateInput = document.getElementById('builderPlateInput');
      if (plateInput) {
        // Apply fixes on various events
        plateInput.addEventListener('focus', window.forcePlateInputAsText);
        plateInput.addEventListener('input', window.forcePlateInputAsText);
        plateInput.addEventListener('change', window.forcePlateInputAsText);
        plateInput.addEventListener('keyup', window.forcePlateInputAsText);
        plateInput.addEventListener('blur', window.forcePlateInputAsText);
        
        // SESSION 52 FIX: Monitor for autofill but stop after 20 checks (10 seconds)
        let autofillCheckCount = 0;
        const autofillInterval = setInterval(function() {
          autofillCheckCount++;
          
          if (plateInput.value && plateInput.style.webkitTextSecurity !== 'none') {
            window.forcePlateInputAsText();
          }
          
          // Stop checking after 20 attempts (10 seconds) or if field is properly configured
          if (autofillCheckCount >= 20 || (plateInput.style.webkitTextSecurity === 'none' && plateInput.type === 'text')) {
            clearInterval(autofillInterval);
            console.log('âœ… Plate input autofill monitoring stopped after', autofillCheckCount, 'checks');
          }
        }, 500);
        
        console.log('âœ… Enhanced plate input event listeners configured');
      }
    });
    
    // Test MathEngine loading
    window.testMathEngineLoading = function() {
      console.log('ğŸ§ª Testing MathEngine loading status...');
      console.log('MathEngine available:', typeof MathEngine !== 'undefined');
      console.log('MathEngine.getVatRate available:', typeof MathEngine?.getVatRate === 'function');
      
      if (typeof MathEngine !== 'undefined' && MathEngine.getVatRate) {
        console.log('âœ… MathEngine VAT rate:', MathEngine.getVatRate() + '%');
      } else {
        console.log('âš ï¸ MathEngine not fully loaded yet');
      }
      
      // Test helper fallback
      if (typeof window.getHelperVatRate === 'function') {
        console.log('âœ… Helper VAT rate:', window.getHelperVatRate() + '%');
      }
    };
    
    // Test admin VAT change simulation
    window.simulateAdminVatChange = function(newVatRate = 19) {
      console.log(`ğŸ§ª Simulating admin VAT change to ${newVatRate}%...`);
      console.log('ğŸ“Š BEFORE - helper.calculations.vat_rate:', window.helper?.calculations?.vat_rate);
      
      // Simulate the message that admin hub would send
      const simulatedMessage = {
        data: {
          type: 'VAT_RATE_UPDATED',
          vatRate: newVatRate,
          timestamp: Date.now()
        },
        origin: '*',
        source: window
      };
      
      // Trigger the message handler manually
      window.dispatchEvent(new MessageEvent('message', simulatedMessage));
      
      // Check result after a short delay
      setTimeout(() => {
        console.log('ğŸ“Š AFTER - helper.calculations.vat_rate:', window.helper?.calculations?.vat_rate);
        console.log('ğŸ“Š AFTER - getHelperVatRate():', window.getHelperVatRate ? window.getHelperVatRate() : 'function not available');
      }, 200);
    };
  </script>
  <script type="module" src="./helper-events.js"></script>
  <!-- TEMPORARILY DISABLED - conflicts with differential structure -->
  <!-- <script type="module" src="./depreciation_module.js"></script> -->
  
  <!-- Floating PDF Display Component -->
  <div id="floatingPdfOverlay" class="floating-pdf-overlay" style="display: none;">
    <div class="floating-pdf-container">
      <div class="floating-pdf-header">
        <h3 id="floatingPdfTitle">××¦×™×’ PDF</h3>
        <div class="floating-pdf-controls">
          <button id="togglePdfBtn" class="toggle-btn">_</button>
          <button id="closePdfBtn" class="close-btn">Ã—</button>
        </div>
      </div>
      <div id="floatingPdfContent" class="floating-pdf-content">
        <iframe id="pdfViewer" src="" width="100%" height="100%" frameborder="0"></iframe>
      </div>
    </div>
  </div>
  
  <script type="module" src="auth.js"></script>
  <script src="helper.js" type="module"></script>
  
  <script>
    // ğŸ›ï¸ INITIALIZE ADMIN HUB COMMUNICATION AFTER ALL MODULES LOADED
    window.addEventListener('load', function() {
      // Wait a bit more for modules to finish loading
      setTimeout(() => {
        console.log('ğŸ”Œ Now initializing admin hub communication after all modules loaded...');
        
        // Check if helper VAT function is available
        if (typeof window.setHelperVatRateFromAdmin === 'function') {
          console.log('âœ… setHelperVatRateFromAdmin function is available');
        } else {
          console.log('âŒ setHelperVatRateFromAdmin function NOT available');
        }
        
        // Initialize admin hub communication
        if (typeof initAdminHubCommunication === 'function') {
          initAdminHubCommunication();
        }
        
        // Initialize VAT display
        if (typeof window.initVatDisplay === 'function') {
          window.initVatDisplay();
        }
        
        console.log('ğŸ¯ Admin hub communication initialized. Testing functions available:');
        console.log('- simulateAdminVatChange(19) - Test admin VAT change');
        console.log('- testMathEngineLoading() - Test MathEngine status');
        console.log('- testCompleteVatFlow() - Test entire VAT flow');
        
        // Create comprehensive VAT flow test
        window.testCompleteVatFlow = function() {
          console.log('ğŸ§ª Testing complete VAT flow: Admin â†’ Helper â†’ All UI');
          console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
          
          // Step 1: Check current state
          console.log('ğŸ“Š STEP 1: Current VAT State');
          console.log('helper.calculations.vat_rate:', window.helper?.calculations?.vat_rate);
          console.log('getHelperVatRate():', window.getHelperVatRate ? window.getHelperVatRate() : 'N/A');
          console.log('MathEngine.getVatRate():', typeof MathEngine !== 'undefined' ? MathEngine.getVatRate() : 'N/A');
          
          // Step 2: Test helper function availability
          console.log('ğŸ“Š STEP 2: Function Availability');
          console.log('setHelperVatRateFromAdmin:', typeof window.setHelperVatRateFromAdmin === 'function');
          console.log('getHelperVatRate:', typeof window.getHelperVatRate === 'function');
          console.log('initVatDisplay:', typeof window.initVatDisplay === 'function');
          
          // Step 3: Test admin â†’ helper flow
          console.log('ğŸ“Š STEP 3: Testing Admin â†’ Helper Flow');
          if (typeof window.setHelperVatRateFromAdmin === 'function') {
            const testRate = 19;
            console.log(`Setting helper VAT to ${testRate}% directly...`);
            const success = window.setHelperVatRateFromAdmin(testRate, 'test_admin');
            console.log('Helper update success:', success);
            
            setTimeout(() => {
              console.log('ğŸ“Š STEP 4: Verification');
              console.log('helper.calculations.vat_rate after update:', window.helper?.calculations?.vat_rate);
              console.log('getHelperVatRate() after update:', window.getHelperVatRate());
              
              // Step 5: Test if UI updates
              console.log('ğŸ“Š STEP 5: UI Update Test');
              const vatInput = document.getElementById('vat-rate-input');
              if (vatInput) {
                console.log('VAT input field value:', vatInput.value);
                console.log('Expected:', testRate, 'Actual:', parseFloat(vatInput.value));
                console.log('UI updated correctly:', parseFloat(vatInput.value) === testRate);
              } else {
                console.log('VAT input field not found');
              }
              
              console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
              console.log('âœ… VAT flow test completed');
            }, 200);
          } else {
            console.log('âŒ Cannot test - setHelperVatRateFromAdmin not available');
          }
        };
        
      }, 500);
    });
  </script>

  <!-- GENERATION BUTTONS - Static at bottom -->
  <div style="margin: 30px auto; max-width: 800px; padding: 20px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
    <div style="text-align: center; font-weight: bold; color: #1e3a8a; margin-bottom: 15px; font-size: 16px;">
      ğŸš€ ×”×¤×§×ª ××¡××›×™× ×¢×œ ×‘×¡×™×¡ ×”×ª×™×§ ×”× ×•×›×—×™
    </div>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; max-width: 500px; margin: 0 auto;">
      <button class="nav-btn" id="generateEstimateBtn" onclick="generateEstimateReport()" style="background: #ea580c; color: white; font-size: 14px; padding: 12px; border-radius: 6px;">
        ×¦×•×¨ ××•××“×Ÿ ×¨××©×•× ×™
      </button>
      <button class="nav-btn" id="generateExpertiseBtn" onclick="generateExpertiseReport()" style="background: #059669; color: white; font-size: 14px; padding: 12px; border-radius: 6px;">
        ×¦×•×¨ ××§×¡×¤×™×¨×˜×™×–×”
      </button>
    </div>
    <div style="font-size: 12px; color: #6b7280; text-align: center; margin-top: 10px;">
      ×œ× × ×“×¨×© ×”×›× ×¡×ª ××¡×¤×¨ ×¨×›×‘ × ×•×¡×£ - ×¢×•×‘×“ ×¢×œ ×‘×¡×™×¡ ×”× ×ª×•× ×™× ×”×§×™×™××™×
    </div>
  </div>

  <!-- SESSION 74: Invoice Mapping Modal -->
  <div id="invoice-mapping-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.5); z-index: 10000; justify-content: center; align-items: center;">
    <div style="background: white; border-radius: 12px; padding: 24px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; direction: rtl;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h3 style="margin: 0; color: #1e3a8a; font-size: 20px;">××™×¤×•×™ ×¤×¨×™×˜×™× ××”×—×©×‘×•× ×™×ª</h3>
        <button onclick="closeInvoiceMappingModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">Ã—</button>
      </div>
      <div id="invoice-mapping-field-info" style="background: #f3f4f6; padding: 12px; border-radius: 8px; margin-bottom: 16px; font-size: 14px;">
        <div style="font-weight: 600; margin-bottom: 4px;">×©×“×” × ×‘×—×¨:</div>
        <div id="field-info-text" style="color: #666;">...</div>
      </div>
      <div id="invoice-items-dropdown-container"></div>
      <div style="margin-top: 16px; display: flex; gap: 8px; justify-content: flex-end;">
        <button onclick="closeInvoiceMappingModal()" style="padding: 8px 16px; background: #e5e7eb; border: none; border-radius: 6px; cursor: pointer;">×‘×™×˜×•×œ</button>
      </div>
    </div>
  </div>

  <script src="internal-browser.js"></script>
  <script src="levi-floating.js"></script>
  <script src="car-details-floating.js"></script>
  <script src="invoice-details-floating.js"></script>
  <script src="parts-search-results-floating.js"></script>
  <script src="password-prefill.js"></script>
  <script src="services/damage-center-mapper.js"></script>
  <script src="components/invoice-parts-dropdown.js"></script>
  <script src="parts.js" type="module"></script>
  <script type="module">
    // Make PARTS_BANK available globally for dropdown system
    import { PARTS_BANK } from './parts.js';
    window.PARTS_BANK = PARTS_BANK;
    console.log('âœ… PARTS_BANK loaded for dropdowns:', Object.keys(PARTS_BANK).length, 'categories');
  </script>
  <script src="final_report.js" type="module"></script>

  <!-- SESSION 74: Invoice Mapping Integration -->
  <script>
    // Invoice mapping state
    let invoiceMappingState = {
      damageCenterId: null,
      fieldType: null,
      fieldIndex: null,
      caseId: null,
      invoiceId: null,
      dropdown: null
    };

    // Initialize invoice mapping on page load
    document.addEventListener('DOMContentLoaded', async () => {
      // Get case ID from sessionStorage
      const caseId = sessionStorage.getItem('currentCaseId');
      if (caseId) {
        invoiceMappingState.caseId = caseId;
        console.log('ğŸ—ºï¸ Invoice mapping initialized for case:', caseId);
        
        // Initialize mapper
        if (window.damageCenterMapper) {
          await window.damageCenterMapper.initialize(caseId);
        }
      }

      // Listen for messages from damage center iframes or floating screens
      window.addEventListener('message', handleDamageCenterMessage);
    });

    // Handle messages from damage center iframes
    function handleDamageCenterMessage(event) {
      // Check if message is about field click
      if (event.data && event.data.type === 'DAMAGE_CENTER_FIELD_CLICKED') {
        const { centerId, fieldType, fieldIndex, currentValue } = event.data;
        console.log('ğŸ“ Field clicked:', { centerId, fieldType, fieldIndex });
        
        // Show invoice mapping modal
        showInvoiceMappingModal(centerId, fieldType, fieldIndex, currentValue);
      }
    }

    // Show invoice mapping modal
    async function showInvoiceMappingModal(centerId, fieldType, fieldIndex, currentValue = null) {
      try {
        // Get invoice ID from helper (most recent invoice)
        let invoiceId = null;
        if (window.helper && window.helper.financials && window.helper.financials.invoices && window.helper.financials.invoices.length > 0) {
          invoiceId = window.helper.financials.invoices[0].id;
        }

        if (!invoiceId) {
          alert('×œ× × ××¦××” ×—×©×‘×•× ×™×ª ×œ×ª×™×§ ×–×”. ×× × ×”×¢×œ×” ×—×©×‘×•× ×™×ª ×ª×—×™×œ×”.');
          return;
        }

        // Store state
        invoiceMappingState.damageCenterId = centerId;
        invoiceMappingState.fieldType = fieldType;
        invoiceMappingState.fieldIndex = fieldIndex;
        invoiceMappingState.invoiceId = invoiceId;

        // Update field info display
        const fieldTypeLabels = {
          'work': '×¢×‘×•×“×”',
          'part': '×—×œ×§',
          'repair': '×ª×™×§×•×Ÿ'
        };
        const fieldLabel = fieldTypeLabels[fieldType] || fieldType;
        document.getElementById('field-info-text').textContent = 
          `${fieldLabel} #${fieldIndex + 1} ×‘××¨×›×– × ×–×§×™× ${centerId}${currentValue ? ' - ×¢×¨×š × ×•×›×—×™: ' + currentValue : ''}`;

        // Show modal
        const modal = document.getElementById('invoice-mapping-modal');
        modal.style.display = 'flex';

        // Initialize dropdown
        if (!invoiceMappingState.dropdown) {
          invoiceMappingState.dropdown = new InvoicePartsDropdown();
        }

        // Load dropdown items
        const success = await invoiceMappingState.dropdown.init({
          fieldType: fieldType,
          caseId: invoiceMappingState.caseId,
          invoiceId: invoiceId,
          containerId: 'invoice-items-dropdown-container',
          onSelect: handleInvoiceItemSelected
        });

        if (!success) {
          alert('×©×’×™××” ×‘×˜×¢×™× ×ª ×¤×¨×™×˜×™× ××”×—×©×‘×•× ×™×ª');
          closeInvoiceMappingModal();
        }
      } catch (error) {
        console.error('âŒ Error showing mapping modal:', error);
        alert('×©×’×™××” ×‘×˜×¢×™× ×ª ××™×¤×•×™ ×—×©×‘×•× ×™×ª: ' + error.message);
      }
    }

    // Handle invoice item selection
    async function handleInvoiceItemSelected(item) {
      try {
        console.log('âœ… Item selected for mapping:', item);

        const mappingData = {
          invoiceId: invoiceMappingState.invoiceId,
          invoiceLineId: item.invoice_line_id || null,
          caseId: invoiceMappingState.caseId,
          damageCenterId: invoiceMappingState.damageCenterId,
          fieldType: invoiceMappingState.fieldType,
          fieldIndex: invoiceMappingState.fieldIndex,
          itemData: item
        };

        // Create mapping using damage-center-mapper
        if (window.damageCenterMapper) {
          const mappingId = await window.damageCenterMapper.mapItemToField(mappingData);
          console.log('âœ… Mapping created:', mappingId);

          // Notify user
          alert('×”×¤×¨×™×˜ ××•×¤×” ×‘×”×¦×œ×—×” ×œ×©×“×”!');

          // Notify iframe if present
          window.damageCenterMapper.notifyIframeOfMappingChange(
            invoiceMappingState.damageCenterId,
            invoiceMappingState.fieldType,
            invoiceMappingState.fieldIndex,
            {
              name: item.name,
              costWithoutVat: item.price || item.total || 0
            }
          );

          // Close modal
          closeInvoiceMappingModal();
        } else {
          throw new Error('Damage center mapper not initialized');
        }
      } catch (error) {
        console.error('âŒ Error creating mapping:', error);
        alert('×©×’×™××” ×‘×™×¦×™×¨×ª ××™×¤×•×™: ' + error.message);
      }
    }

    // Close invoice mapping modal
    function closeInvoiceMappingModal() {
      const modal = document.getElementById('invoice-mapping-modal');
      modal.style.display = 'none';

      // Cleanup dropdown
      if (invoiceMappingState.dropdown) {
        invoiceMappingState.dropdown.destroy();
        invoiceMappingState.dropdown = null;
      }

      // Clear state
      invoiceMappingState.damageCenterId = null;
      invoiceMappingState.fieldType = null;
      invoiceMappingState.fieldIndex = null;
    }

    // Global function for testing
    window.testInvoiceMapping = function() {
      showInvoiceMappingModal('center_1', 'work', 0, 'Test Work');
    };

    // SESSION 91 GLOBAL: Clear centers archive
    window.clearCentersArchive = function() {
      console.log('ğŸ§¹ SESSION 91: Manually clearing centers_archive');
      const helper = window.helper || {};
      
      if (!helper.centers_archive) {
        console.log('â„¹ï¸ No archive exists to clear');
        return { message: 'No archive exists' };
      }
      
      console.log('ğŸ“‹ Before clearing:');
      console.log('  - Archive had', helper.centers_archive.length, 'centers');
      console.log('  - Archive metadata:', helper.centers_archive_meta);
      
      // Delete archive and its metadata
      delete helper.centers_archive;
      delete helper.centers_archive_meta;
      
      // Save changes
      sessionStorage.setItem('helper', JSON.stringify(helper));
      window.helper = helper;
      
      console.log('âœ… Archive cleared successfully');
      console.log('â„¹ï¸ System is now in no-invoice state');
      
      // Refresh UI to reflect changes
      if (typeof loadDamageCentersFromHelper === 'function') {
        loadDamageCentersFromHelper(helper);
      }
      
      return {
        success: true,
        message: 'Archive cleared - system in no-invoice state'
      };
    };

    // SESSION 91 GLOBAL: Debug invoice dropdown data
    window.debugInvoiceDropdown = function() {
      console.log('ğŸ” SESSION 91: Debugging invoice dropdown data');
      const helper = window.helper || {};
      
      console.log('ğŸ“‹ Helper invoices:', helper.invoices);
      console.log('ğŸ“‹ Window invoiceDataForDropdowns:', window.invoiceDataForDropdowns);
      
      // Test getCombinedDropdownData
      let layer1ItemsCount = 0;
      if (typeof getCombinedDropdownData === 'function') {
        try {
          const dropdownData = getCombinedDropdownData('');
          const layer1Items = dropdownData.filter(item => item.layer === 1);
          layer1ItemsCount = layer1Items.length;
          console.log('ğŸ“‹ Layer 1 items found:', layer1Items.length);
          console.log('ğŸ“‹ Sample Layer 1 items:', layer1Items.slice(0, 3));
        } catch (err) {
          console.error('âŒ Error getting dropdown data:', err);
        }
      }
      
      // Check invoice lines structure
      if (window.invoiceDataForDropdowns?.invoice_lines?.length > 0) {
        console.log('ğŸ“‹ Sample invoice line structure:', window.invoiceDataForDropdowns.invoice_lines[0]);
      }
      
      return {
        helperInvoices: helper.invoices?.length || 0,
        invoiceDataForDropdowns: !!window.invoiceDataForDropdowns,
        mappingsCount: window.invoiceDataForDropdowns?.mappings?.length || 0,
        invoiceLinesCount: window.invoiceDataForDropdowns?.invoice_lines?.length || 0,
        layer1ItemsCount: layer1ItemsCount
      };
    };
    
    // SESSION 91 GLOBAL: Manually load invoice lines
    window.loadInvoiceLines = async function(invoiceId) {
      console.log('ğŸ“‹ SESSION 91: Manually loading invoice lines for invoice:', invoiceId);
      
      if (!window.supabase) {
        console.error('âŒ Supabase not available');
        return;
      }
      
      const { data: lines, error } = await window.supabase
        .from('invoice_lines')
        .select('*')
        .eq('invoice_id', invoiceId);
        
      if (error) {
        console.error('âŒ Error loading invoice lines:', error);
        return;
      }
      
      console.log('âœ… Found', lines?.length || 0, 'invoice lines');
      console.log('ğŸ“‹ Invoice lines:', lines);
      
      // Add to helper.invoices
      const helper = window.helper || {};
      if (!helper.invoices) helper.invoices = [];
      
      const invoice = helper.invoices.find(inv => inv.id === invoiceId);
      if (invoice) {
        invoice.line_items = lines;
        console.log('âœ… Added lines to existing invoice in helper');
      } else {
        // Fetch the invoice details
        const { data: invoiceData } = await window.supabase
          .from('invoices')
          .select('*')
          .eq('id', invoiceId)
          .single();
          
        if (invoiceData) {
          helper.invoices.push({
            ...invoiceData,
            line_items: lines
          });
          console.log('âœ… Added new invoice with lines to helper');
        }
      }
      
      // Save helper
      sessionStorage.setItem('helper', JSON.stringify(helper));
      window.helper = helper;
      
      console.log('ğŸ“‹ Updated helper.invoices:', helper.invoices);
      
      return {
        invoiceId: invoiceId,
        linesCount: lines?.length || 0,
        lines: lines
      };
    };

    // SESSION 91 GLOBAL: Clear centers completely
    window.clearCenters = function() {
      console.log('ğŸ§¹ SESSION 91: Clearing helper.centers');
      const helper = window.helper || {};
      
      console.log('ğŸ“‹ Before clearing:');
      console.log('  - centers length:', helper.centers?.length || 0);
      console.log('  - centers_archive length:', helper.centers_archive?.length || 0);
      
      // Clear centers array
      helper.centers = [];
      
      // Save changes
      sessionStorage.setItem('helper', JSON.stringify(helper));
      window.helper = helper;
      
      console.log('âœ… Centers cleared');
      console.log('â„¹ï¸ You can now create new damage centers in the wizard');
      
      // Refresh UI
      if (typeof loadDamageCentersFromHelper === 'function') {
        loadDamageCentersFromHelper(helper);
      }
      
      return {
        success: true,
        message: 'Centers cleared - ready for wizard'
      };
    };

    console.log('âœ… Invoice mapping integration loaded');
    
    // ============================================================================
    // SESSION 94: DEBUG 4-LAYER DROPDOWN SYSTEM
    // ============================================================================
    
    // SESSION 94: Quick invoice data inspector
    window.inspectInvoiceData = function() {
      console.log('ğŸ” SESSION 94: DIRECT INVOICE INSPECTION');
      console.log('ğŸ“‹ window.helper:', !!window.helper);
      console.log('ğŸ“‹ window.helper.invoices:', window.helper?.invoices);
      
      if (window.helper?.invoices) {
        console.log('ğŸ“‹ invoices length:', window.helper.invoices.length);
        window.helper.invoices.forEach((invoice, i) => {
          console.log(`ğŸ“‹ Invoice ${i}:`, invoice);
        });
      }
      
      return window.helper?.invoices;
    };

    window.debugDropdownSystem = function() {
      console.log('ğŸ” SESSION 94: Enhanced 4-Layer Dropdown Debug:', {
        'hasInvoiceAssignments': hasInvoiceAssignments(),
        'helper.invoices': window.helper?.invoices?.length || 0,
        'global invoices': window.invoiceDataForDropdowns?.invoice_lines?.length || 0,
        'selected parts': window.helper?.parts_search?.selected_parts?.length || 0,
        'damage centers parts': window.helper?.centers?.reduce((sum, c) => sum + (c.parts?.length || 0), 0) || 0,
        'centers_after_invoice': window.helper?.centers_after_invoice?.length || 0,
        'parts bank available': !!window.PARTS_BANK,
        'parts bank type': typeof window.PARTS_BANK,
        'parts bank keys/categories': window.PARTS_BANK ? Object.keys(window.PARTS_BANK).length : 0
      });
      
      // SESSION 94 DEEP DEBUG: Inspect actual invoice data structure
      console.log('ğŸ” SESSION 94: Checking window.helper.invoices...');
      console.log('ğŸ“‹ window.helper exists:', !!window.helper);
      console.log('ğŸ“‹ window.helper.invoices exists:', !!window.helper?.invoices);
      console.log('ğŸ“‹ window.helper.invoices length:', window.helper?.invoices?.length || 0);
      
      if (window.helper?.invoices) {
        console.log('ğŸ” SESSION 94: DEEP INVOICE DEBUG - FULL STRUCTURE');
        console.log('ğŸ“‹ helper.invoices:', window.helper.invoices);
        
        if (Array.isArray(window.helper.invoices) && window.helper.invoices.length > 0) {
          console.log('ğŸ“‹ First invoice FULL:', window.helper.invoices[0]);
          console.log('ğŸ“‹ Invoice keys:', Object.keys(window.helper.invoices[0]));
          
          window.helper.invoices.forEach((invoice, idx) => {
            console.log(`ğŸ“‹ Invoice ${idx} analysis:`, {
              'invoice_number': invoice.invoice_number || invoice.number,
              'line_items exists': !!invoice.line_items,
              'line_items type': typeof invoice.line_items,
              'line_items length': invoice.line_items?.length || 0,
              'lines exists': !!invoice.lines,
              'lines type': typeof invoice.lines,
              'lines length': invoice.lines?.length || 0,
              'items exists': !!invoice.items,
              'items type': typeof invoice.items,
              'items length': invoice.items?.length || 0,
              'raw_data exists': !!invoice.raw_data,
              'invoice_data exists': !!invoice.invoice_data,
              'all keys': Object.keys(invoice)
            });
            
            // Check all possible line item locations
            ['line_items', 'lines', 'items', 'raw_data', 'invoice_data'].forEach(field => {
              if (invoice[field]) {
                console.log(`ğŸ“‹ Invoice ${idx} ${field}:`, invoice[field]);
                if (Array.isArray(invoice[field]) && invoice[field].length > 0) {
                  console.log(`ğŸ“‹ Sample ${field} item:`, invoice[field][0]);
                  console.log(`ğŸ“‹ ${field} item keys:`, Object.keys(invoice[field][0]));
                }
              }
            });
          });
        } else {
          console.log('âŒ helper.invoices is not a valid array or is empty');
        }
      } else {
        console.log('âŒ No invoice data found in window.helper.invoices');
      }
      
      const testData = getCombinedDropdownData('');
      console.log('ğŸ“Š SESSION 94: 4-Layer Data:', testData.length, 'total items');
      
      const layerCounts = {
        'Layer 1 (Invoice)': testData.filter(p => p.layer === 1).length,
        'Layer 2 (Selected)': testData.filter(p => p.layer === 2).length,
        'Layer 3 (Catalog)': testData.filter(p => p.layer === 3).length,
        'Layer 4 (Bank)': testData.filter(p => p.layer === 4).length
      };
      
      console.log('ğŸ“Š SESSION 94: By Layer:', layerCounts);
      
      // Enhanced layer analysis
      console.log('ğŸ” SESSION 94: Layer 1 (Invoice) sample:', testData.filter(p => p.layer === 1).slice(0, 3));
      console.log('ğŸ” SESSION 94: Layer 2 (Selected) sample:', testData.filter(p => p.layer === 2).slice(0, 3));
      console.log('ğŸ” SESSION 94: Layer 3 (Catalog) sample:', testData.filter(p => p.layer === 3).slice(0, 3));
      console.log('ğŸ” SESSION 94: Layer 4 (Bank) sample:', testData.filter(p => p.layer === 4).slice(0, 3));
      
      // Test specific query
      const queryTest = getCombinedDropdownData('×˜××¡×”');
      console.log('ğŸ” SESSION 94: Query test "×˜××¡×”":', queryTest.length, 'results');
      console.log('ğŸ” Query results by layer:', {
        'Layer 1': queryTest.filter(p => p.layer === 1).length,
        'Layer 2': queryTest.filter(p => p.layer === 2).length,
        'Layer 3': queryTest.filter(p => p.layer === 3).length,
        'Layer 4': queryTest.filter(p => p.layer === 4).length
      });
      
      return {
        success: true,
        timestamp: new Date().toISOString(),
        totalParts: testData.length,
        byLayer: layerCounts,
        hasInvoices: hasInvoiceAssignments(),
        dataStructure: {
          helper_invoices: !!window.helper?.invoices?.length,
          global_invoices: !!window.invoiceDataForDropdowns?.invoice_lines?.length,
          centers_after_invoice: !!window.helper?.centers_after_invoice?.length,
          parts_bank: typeof window.PARTS_BANK,
          parts_bank_categories: window.PARTS_BANK ? Object.keys(window.PARTS_BANK).length : 0
        },
        fixes_applied: [
          'PARTS_BANK structure compatibility (object â†’ array conversion)',
          'Enhanced invoice detection (5 detection methods)',
          'Forced 4-layer system usage (no fallback to legacy)',
          'New functions: show4LayerPartSuggestions, showAll4LayerParts'
        ]
      };
    };
    
  </script>
</body>
</html>