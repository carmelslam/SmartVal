<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <title>אשף חוות הדעת - ירון כיוף</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp" type="image/webp">
  <style>
    body {
      font-family: sans-serif;
      background: #f3f6fb;
      margin: 0;
      min-height: 100vh;
      padding: 0;
      padding-top: 90px;
      overflow-x: hidden;
    }
    .container {
      width: 100%;
      max-width: 820px;
      min-width: 320px;
      background: #fff;
      padding: 32px 24px 24px 24px;
      border-radius: 16px;
      box-shadow: 0 0 20px rgba(0,0,0,0.08);
      margin: 32px auto 32px auto;
      box-sizing: border-box;
    }
    .logo {
      display: flex;
      justify-content: center;
      margin-bottom: 8px;
    }
    .logo img {
      width: 112px;
      height: auto;
      display: block;
    }
    .title { font-size: 27px; font-weight: bold; text-align: center; margin-bottom: 2px; font-weight: 900;}
    .subtitle { font-size: 23px; color: #666; text-align: center; margin-bottom: 10px;}
    h1, h2 { color: #1e3a8a; font-size: 25px; text-align: center; margin: 15px 0 8px 0; font-weight: 600;}
    h3 { color: #1e3a8a; font-size: 24px; margin: 22px 0 12px 0; text-align: right; font-weight: 900;}
    .form-section {
      width: 100%;
      max-width: 100%;
      margin-bottom: 20px;
      background: #fafbfe;
      border-radius: 12px;
      padding: 17px 15px 12px 15px;
      box-sizing: border-box;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      overflow: hidden;
    }
    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px 18px;
      width: 100%;
    }
    @media (max-width: 600px) {
      .form-grid { grid-template-columns: 1fr; }
      .container {
        width: 98vw;
        max-width: 98vw;
        min-width: 0;
        padding: 14px 2vw 20px 2vw;
      }
    }
    
    /* Mobile viewport fixes */
    @media (max-width: 768px) {
      body {
        width: 100vw;
        overflow-x: hidden !important;
        position: relative;
      }
      
      html {
        width: 100vw;
        overflow-x: hidden !important;
      }
      
      .container {
        width: 95vw;
        max-width: 95vw;
        margin: 32px 2.5vw 32px 2.5vw;
      }
    }
    
    /* Desktop constraint fix */
    @media (min-width: 769px) {
      .container {
        width: 100%;
        max-width: 820px !important;
        margin: 32px auto !important;
      }
    }
    
    /* Summary container constraint fix */
    .summary-container {
      max-width: 820px;
      margin: 0 auto;
      width: 100%;
      box-sizing: border-box;
    }
    
    @media (min-width: 769px) {
      .summary-container {
        max-width: 820px;
        width: 820px;
      }
    }
    
    /* Summary block styling within container */
    .summary-block {
      width: 100% !important;
      box-sizing: border-box !important;
      margin-bottom: 20px;
    }
    label {
      font-size: 18px;
      margin-bottom: 4px;
      display: block;
      text-align: right;
    }
    input, select, textarea {
      width: 100%;
      font-size: 16px;
      border-radius: 8px;
      border: 1px solid #ccc;
      margin-bottom: 0px;
      padding: 8px 9px;
      box-sizing: border-box;
      text-align: right !important;
      background: #f9f9f9;
      transition: border .15s;
      outline: none;
    }
    input:focus, select:focus, textarea:focus {
      border-color: #3b82f6;
    }
    .readonly-box {
      background: #f4f6fa;
      border-radius: 6px;
      border: 1px solid #eee;
      padding: 7px 8px;
      min-height: 20px;
      font-size: 16px;
      color: #333;
      text-align: right !important;
    }
    .btn {
      background: #007bff;
      color: white;
      border: none;
      padding: 12px 15px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      display: block;
    }
    
    /* FLOATING SCREENS STYLING - COPIED FROM DEPRECIATION */
    .floating-toggles-top {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.95);
      padding: 8px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .toggle-square {
      width: 80px;
      height: 70px;
      background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      color: white;
      text-align: center;
      border: 2px solid transparent;
    }

    .toggle-square:hover {
      background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
    }

    .toggle-square.active {
      border-color: #fbbf24;
      box-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
    }

    .toggle-icon {
      font-size: 18px;
      margin-bottom: 2px;
    }

    .toggle-text {
      font-size: 10px;
      font-weight: 600;
      line-height: 1.1;
    }
    
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .section-header h3 {
      margin: 0;
    }
    @media (max-width: 768px) {
      .floating-toggles-top {
        top: 5px;
        gap: 4px;
        padding: 6px;
      }
      .toggle-square {
        width: 65px;
        height: 60px;
      }
      .toggle-icon {
        font-size: 16px;
      }
      .toggle-text {
        font-size: 9px;
      }
      
      /* Mobile fixes for depreciation table */
      #depreciationBulkTable .dep-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #depreciationBulkTable .dep-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #depreciationBulkTable .dep-row > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(1)::before {
        content: "מס' מוקד:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(2)::before {
        content: "החלק הניזוק:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(3)::before {
        content: "מהות התיקון:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(4)::before {
        content: "% ירידת ערך:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(5)::before {
        content: "ערך ב-₪:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(6)::before {
        content: "פעולות:";
      }
      
      /* Hide table headers on mobile */
      #depreciationSection > div:first-child {
        display: none !important;
      }
      
      /* Mobile fixes for Full Market Adjustments table */
      #allAdjustmentsList .adjustment-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #allAdjustmentsList .adjustment-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #allAdjustmentsList .adjustment-row > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
        display: block;
        margin-bottom: 4px;
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(1)::before {
        content: "תיאור:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(2)::before {
        content: "סוג:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(3)::before {
        content: "אחוז:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(4)::before {
        content: "ערך:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(5)::before {
        content: "פעולות:";
      }
      
      /* Hide Full Market Adjustments table headers on mobile */
      #allAdjustments > div:first-child {
        display: none !important;
      }
      
      /* Mobile fixes for damage center part rows */
      .part-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa !important;
        padding: 12px !important;
        border-radius: 8px !important;
        margin-bottom: 12px !important;
        border: 1px solid #e9ecef !important;
      }
      
      .part-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .part-row > div:nth-child(1) label::after {
        content: " (שם החלק)";
      }
      
      .part-row > div:nth-child(2) label::after {
        content: " (תיאור)";
      }
      
      .part-row > div:nth-child(3) label::after {
        content: " (עלות)";
      }
      
      /* Mobile fixes for damage center work rows */
      .work-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa !important;
        padding: 12px !important;
        border-radius: 8px !important;
        margin-bottom: 12px !important;
        border: 1px solid #e9ecef !important;
      }
      
      .work-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .work-row > div:nth-child(1) label::after {
        content: " (סוג עבודה)";
      }
      
      .work-row > div:nth-child(2) label::after {
        content: " (הערות)";
      }
      
      .work-row > div:nth-child(3) label::after {
        content: " (עלות)";
      }
      
      /* Mobile fixes for damage center repair rows */
      .repair-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa !important;
        padding: 12px !important;
        border-radius: 8px !important;
        margin-bottom: 12px !important;
        border: 1px solid #e9ecef !important;
      }
      
      .repair-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .repair-row > div:nth-child(1) label::after {
        content: " (תיאור תיקון)";
      }
      
      .repair-row > div:nth-child(2) label::after {
        content: " (הערות)";
      }
      
      .repair-row > div:nth-child(3) label::after {
        content: " (עלות)";
      }
      
      /* Mobile fixes for Features Adjustments section */
      #featuresAdjustments > div:first-child {
        display: none !important;
      }
      
      #featuresAdjustmentsList > div {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #featuresAdjustmentsList > div > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #featuresAdjustmentsList > div > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
        display: block;
        margin-bottom: 4px;
      }
      
      #featuresAdjustmentsList > div > div:nth-child(1)::before {
        content: "תיאור:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(2)::before {
        content: "סוג:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(3)::before {
        content: "אחוז:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(4)::before {
        content: "ערך:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(5)::before {
        content: "פעולות:";
      }
      
      /* Mobile fixes for Registration Adjustments section */
      #registrationAdjustments > div:first-child {
        display: none !important;
      }
      
      #registrationAdjustmentsList > div {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #registrationAdjustmentsList > div > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #registrationAdjustmentsList > div > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
        display: block;
        margin-bottom: 4px;
      }
      
      #registrationAdjustmentsList > div > div:nth-child(1)::before {
        content: "תיאור:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(2)::before {
        content: "סוג:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(3)::before {
        content: "אחוז:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(4)::before {
        content: "ערך:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(5)::before {
        content: "פעולות:";
      }
      
      
      /* Fix button spacing on mobile */
      .btn.add {
        width: 100% !important;
        margin-top: 8px !important;
      }
      
      /* Navigation buttons mobile responsive */
      .nav-btn {
        font-size: 14px !important;
        padding: 10px 8px !important;
        min-height: 44px !important;
      }
      
      /* Damage centers mobile responsive */
      #damageCentersContent > div > div > div:nth-child(n+1) {
        grid-template-columns: 1fr 1fr !important;
        gap: 4px !important;
      }
      
      /* Levi adjustments mobile responsive */
      .levi-adjustments-grid {
        grid-template-columns: 1fr !important;
        gap: 4px !important;
      }
      
      .levi-adjustment-row {
        grid-template-columns: 1fr !important;
        gap: 4px !important;
        padding: 8px !important;
      }
      
      .levi-adjustment-row > div {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 4px 0;
      }
      
      .levi-adjustment-row > div:nth-child(1)::after {
        content: "";
      }
      
      .levi-adjustment-row > div:nth-child(2)::before {
        content: "אחוז: ";
        font-weight: bold;
        color: #495057;
      }
      
      .levi-adjustment-row > div:nth-child(3)::before {
        content: "ערך: ";
        font-weight: bold;
        color: #495057;
      }
      
      /* Custom summary rows mobile responsive */
      .custom-summary-row {
        grid-template-columns: 1fr !important;
        gap: 8px !important;
      }
      
      .custom-summary-row > input {
        margin-bottom: 4px;
      }
    }
    
    .collapsible-btn {
      background: #e0e7f1;
      font-family: sans-serif;
      color: #1e3a8a;
      border: none;
      padding: 7px 18px;
      border-radius: 7px;
      margin-bottom: 8px;
      margin-top: 2px;
      cursor: pointer;
      font-weight: 600;
      font-size: 16px;
      text-align: right;
      width: auto;
      display: inline-block;
    }

    .collapsible-btn:hover {
      background: #d1d9e6;
    }

    .btn.add {
      background: #28a745;
      margin-top: 7px;
      margin-bottom: 0;
      width: auto;
      padding: 8px 18px;
      font-size: 16px;
      display: block;
    }

    /* Navigation Buttons Styling */
    .nav-btn {
      padding: 12px 16px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      min-height: 48px;
    }

    .save-btn {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
    }
    .save-btn:hover {
      background: linear-gradient(135deg, #218838 0%, #1ea085 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
    }

    .preview-btn {
      background: linear-gradient(135deg, #17a2b8 0%, #20c997 100%);
    }
    .preview-btn:hover {
      background: linear-gradient(135deg, #138496 0%, #1ea085 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(23, 162, 184, 0.3);
    }

    .generate-btn {
      background: linear-gradient(135deg, #007bff 0%, #6610f2 100%);
    }
    .generate-btn:hover {
      background: linear-gradient(135deg, #0056b3 0%, #520dc2 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
    }

    .back-btn {
      background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
    }
    .back-btn:hover {
      background: linear-gradient(135deg, #545b62 0%, #3d4142 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
    }
    
    .footer {
      margin-top: 40px;
      font-size: 12px;
      color: #aaa;
      text-align: center;
    }
    
    /* Floating PDF Display Styles */
    .floating-pdf-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 0;
      margin: 0;
      box-sizing: border-box;
    }
    
    .floating-pdf-container {
      background: white;
      border-radius: 12px;
      width: 90%;
      max-width: 900px;
      height: 90%;
      max-height: 700px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }
    
    /* Mobile optimization for floating PDF - Complete rewrite */
    @media (max-width: 768px) {
      .floating-pdf-overlay {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100% !important;
        height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        background: rgba(0, 0, 0, 0.8) !important;
        z-index: 999999 !important;
        overflow: hidden !important;
      }
      
      .floating-pdf-container {
        position: fixed !important;
        top: 20px !important;
        left: 10px !important;
        right: 10px !important;
        bottom: 20px !important;
        width: auto !important;
        height: auto !important;
        max-width: none !important;
        max-height: none !important;
        margin: 0 !important;
        border-radius: 10px !important;
        background: white !important;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5) !important;
        overflow: hidden !important;
      }
      
      .floating-pdf-header {
        position: relative !important;
        background: #1e3a8a !important;
        color: white !important;
        padding: 15px !important;
        border-radius: 10px 10px 0 0 !important;
        display: flex !important;
        justify-content: space-between !important;
        align-items: center !important;
        min-height: 60px !important;
        box-sizing: border-box !important;
      }
      
      .floating-pdf-header h3 {
        font-size: 18px !important;
        margin: 0 !important;
        flex: 1 !important;
        text-align: right !important;
      }
      
      .floating-pdf-controls {
        display: flex !important;
        gap: 10px !important;
        flex-shrink: 0 !important;
      }
      
      .toggle-btn, .close-btn {
        width: 44px !important;
        height: 44px !important;
        font-size: 22px !important;
        background: rgba(255,255,255,0.2) !important;
        border: none !important;
        color: white !important;
        border-radius: 8px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        touch-action: manipulation !important;
        -webkit-tap-highlight-color: transparent !important;
      }
      
      .floating-pdf-content {
        position: absolute !important;
        top: 60px !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        overflow: hidden !important;
      }
      
      .floating-pdf-content iframe {
        width: 100% !important;
        height: 100% !important;
        border: none !important;
      }
    }
    
    /* Extra small mobile devices */
    @media (max-width: 480px) {
      .floating-pdf-container {
        top: 10px !important;
        left: 5px !important;
        right: 5px !important;
        bottom: 10px !important;
      }
      
      .floating-pdf-header {
        padding: 12px !important;
        min-height: 50px !important;
      }
      
      .floating-pdf-header h3 {
        font-size: 16px !important;
      }
      
      .toggle-btn, .close-btn {
        width: 40px !important;
        height: 40px !important;
        font-size: 20px !important;
      }
    }
    
    .floating-pdf-header {
      background: #1e3a8a;
      color: white;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 12px 12px 0 0;
    }
    
    .floating-pdf-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    
    .floating-pdf-controls {
      display: flex;
      gap: 10px;
    }
    
    .toggle-btn, .close-btn {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 35px;
      height: 35px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.3s ease;
    }
    
    .toggle-btn:hover, .close-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }
    
    .floating-pdf-content {
      flex: 1;
      padding: 0;
      overflow: hidden;
    }
    
    .floating-pdf-content.minimized {
      display: none;
    }
    
    .floating-pdf-container.minimized {
      height: auto;
      max-height: none;
    }
    
    /* Plate and document actions section styles */
    .plate-actions-section {
      background: #f8fafc;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 25px;
    }
    
    .plate-actions-section label {
      font-size: 16px;
      font-weight: 600;
      color: #1e3a8a;
      margin-bottom: 10px;
      text-align: right;
    }
    
    .plate-actions-section input {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #cbd5e1;
      border-radius: 6px;
      text-align: center;
      box-sizing: border-box;
    }
    
    .load-case-btn {
      padding: 10px 20px;
      background: #1e3a8a;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
    }
    
    .load-case-btn:hover {
      background: #3b82f6;
    }
    
    .document-actions-section {
      margin-top: 20px;
      padding: 15px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
    }
    
    .document-actions-section .nav-btn {
      flex: 1;
      padding: 12px;
      font-size: 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      color: white;
    }
    
    /* Summary block styling to work with inline gradients */
    .summary-block {
      position: relative;
      max-width: 100% !important;
      width: 100% !important;
      box-sizing: border-box !important;
      /* Enhanced with inline gradient backgrounds */
    }
    
    .summary-block h3 {
      color: white !important;
      font-size: 26px !important;
      text-align: center !important;
      margin-bottom: 20px !important;
      font-weight: 900 !important;
    }
    
    /* Ensure all form sections stay within container bounds - merged with existing definition */
    
    /* Force container children to stay within bounds */
    .container > * {
      max-width: 100% !important;
      box-sizing: border-box !important;
    }
    
    /* Mobile fixes for summary date field */
    @media (max-width: 768px) {
      /* Reduce the overall summary block padding on mobile */
      .summary-block {
        padding: 15px 6px !important;
      }
      
      .summary-block > div {
        margin-left: 0 !important;
        margin-right: 0 !important;
        padding-left: 0 !important;
        padding-right: 0 !important;
      }
      
      /* Fix date input container specifically */
      .summary-block input[type="date"] {
        width: calc(100% - 4px) !important;
        box-sizing: border-box !important;
        max-width: calc(100% - 4px) !important;
        margin: 2px !important;
        padding: 6px 4px !important;
        font-size: 13px !important;
      }
      
      /* More specific targeting for the summary date field */
      #finalReportDateSummary {
        width: calc(100% - 10px) !important;
        box-sizing: border-box !important;
        max-width: calc(100% - 10px) !important;
        margin: 5px !important;
        padding: 4px 2px !important;
        font-size: 12px !important;
      }
      
      /* Ensure date container doesn't overflow */
      .summary-block > div[style*="text-align: center"] {
        padding: 2px !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
        box-sizing: border-box !important;
      }
    }
    
    /* Override for parts search modal width */
    #partsSearchResultsModal {
      max-width: 750px !important;
      width: 80vw !important;
    }
  </style>
</head>
<body>
  <!-- FLOATING SCREEN TOGGLES - TOP OF PAGE -->
  <div class="floating-toggles-top">
    <div class="toggle-square" onclick="toggleFloatingScreen('leviReport')">
      <div class="toggle-icon">📊</div>
      <div class="toggle-text">דו"ח לוי יצחק</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('carDetails')">
      <div class="toggle-icon">🚗</div>
      <div class="toggle-text">פרטי רכב</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('invoiceDetails')">
      <div class="toggle-icon">🧾</div>
      <div class="toggle-text">פרטי חשבוניות</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('internalBrowser')">
      <div class="toggle-icon">🌐</div>
      <div class="toggle-text">דפדפן פנימי</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('partsSearchResults')">
      <div class="toggle-icon">🔧</div>
      <div class="toggle-text">תוצאות חלקים</div>
    </div>
  </div>

  <div class="container">
    <div class="logo"><img src="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp" alt="Logo"></div>
    <div class="title">ירון כיוף שמאות - פורטל</div>
    <div class="subtitle">שמאות והערכת נזקי רכב ורכוש</div>
    
    <!-- Plate Input and Document Actions Section -->
    <div class="plate-actions-section">
      <!-- Separate the plate input from password to prevent browser interference -->
      <div style="margin-bottom: 15px;">
        <div style="display: inline-block; margin-left: 15px;">
          <label for="builderPlateInput" style="display: block; margin-bottom: 5px;">מספר רכב:</label>
          <input type="text" id="builderPlateInput" placeholder="הכנס מספר רכב" required autocomplete="off" autocapitalize="none" spellcheck="false" inputmode="numeric" data-plate-field="true">
        </div>
      </div>
      
      <form id="builderLoadCaseForm" onsubmit="event.preventDefault(); const plateInput = document.getElementById('builderPlateInput'); if (plateInput && typeof loadExistingCaseForBuilder === 'function') { loadExistingCaseForBuilder(); }" autocomplete="off">
        
        <!-- Password field removed - using Supabase auth instead -->
        
        <div style="text-align:center; margin-bottom:15px;">
          <button type="submit" id="builderLoadCaseBtn" class="load-case-btn">
            טען תיק קיים
          </button>
        </div>
      </form>
      
      <div style="margin-top:10px; font-size:12px; color:#6b7280; text-align:center;">
        💡 הזן מספר רכב - סיסמת העמוד מתמלאת אוטומטית מהכניסה למערכת
      </div>
      
      <div id="builderPlateStatus" style="margin-top:10px; font-size:14px; color:#059669; display:none; text-align:right;">
        ✓ נתוני הרכב נטענו בהצלחה
      </div>
      
      <!-- Document Actions Section -->
    <div id="documentActionsSection" style="margin-top: 20px; padding: 15px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
      <div style="font-size: 16px; font-weight: 600; color: #1e3a8a; margin-bottom: 15px; text-align: center;">
        פעולות מסמכים
      </div>
      <!-- FETCH BUTTONS - View existing documents (require plate input) -->
      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 10px;">
        <button class="nav-btn" id="fetchEstimateBtn" onclick="fetchEstimatePDF()" style="background: #dc2626; color: white;">
          הצג אומדן ראשוני PDF
        </button>
        <button class="nav-btn" id="fetchExpertiseBtn" onclick="fetchExpertisePDF()" style="background: #8b5cf6; color: white;">
          הצג אקספירטיזה PDF
        </button>
        <button class="nav-btn" id="fetchFinalReportBtn" onclick="fetchFinalReportPDF()" style="background: #06b6d4; color: white;">
          הצג חוות דעת PDF
        </button>
      </div>
      <div style="margin-top: 10px; padding: 10px; background: #e0f2fe; border-radius: 6px; font-size: 14px; text-align: center; color: #0277bd;">
        📁 הכנס מספר רכב וטען תיק כדי לצפות במסמכים קיימים<br>
        כפתורי הפקה של מסמכים חדשים נמצאים בתחתית העמוד 🚀
      </div>
    </div>
    
    <h1>אשף חוות הדעת - מודול ירידת ערך מתקדם</h1> 
    <h2 id="pageTitle">רכב מס. ...</h2>

    <!-- DEPRECIATION REPORT TYPE SELECTION -->
    <div class="form-section">
      <h3>בניית חוות דעת</h3>
      <div class="form-grid">
        <div>
          <label for="reportType">בחר סוג חוות דעת:</label>
          <select id="reportType" onchange="updateSummaryVisibility(); loadLegalText(); saveLegalTextAfterChange();">
            <option>חוות דעת פרטית</option>
            <option>חוות דעת גלובלית</option>
            <option>חוות דעת מכירה מצבו הניזוק</option>
            <option>חוות דעת טוטלוסט</option>
            <option>חוות דעת אובדן להלכה</option>
          </select>
        </div>
        <div>
          <label for="isCompanyClient">דו"ח לחברה:</label>
          <select id="isCompanyClient" onchange="updateFinalReportField('report_for_company', this.value === 'yes')">
            <option value="no">לא</option>
            <option value="yes">כן</option>
          </select>
        </div>
        <div>
          <label for="inAgreement">סטטוס הסדר:</label>
          <select id="inAgreement" onchange="updateFinalReportField('in_agreement', this.value === 'yes')">
            <option value="yes">בהסדר</option>
            <option value="no">לא בהסדר</option>
          </select>
        </div>
        
        <div style="text-align: center; margin-top: 15px;">
          <button type="button" onclick="saveFinalReportConfiguration()" class="nav-btn" style="background: #28a745; color: white; font-size: 14px;">
            💾 שמור הגדרות
          </button>
        </div>
      </div>
    </div>

    <!-- VEHICLE DATA - EDITABLE FROM HELPER -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('vehicleData')">נתוני רכב (הצג/הסתר)</button>
      <div id="vehicleData" style="display:none;">
        <div class="form-grid">
          <div><label>מספר רכב:</label><input type="text" id="carPlate" onchange="updateHelperFromField(event);" /></div>
          <div><label>תוצרת:</label><input type="text" id="carManufacturer" onchange="updateHelperFromField(event);" /></div>
          <div><label>דגם:</label><input type="text" id="carModel" onchange="updateHelperFromField(event);" /></div>
          <div><label>שנת ייצור:</label><input type="text" id="carYear" onchange="updateHelperFromField(event);" /></div>
          <div><label>קוד דגם:</label><input type="text" id="carModelCode" onchange="updateHelperFromField(event);" /></div>
          <div><label>מחיר בסיס:</label><input type="text" id="carBasePrice" onchange="updateHelperFromVehicleField(this);" /></div>
          <div><label>ערך השוק של הרכב:</label><input type="text" id="carMarketValue" onchange="updateHelperFromVehicleField(this);" /></div>
          <div><label>תאריך חוות הדעת (דוח סופי):</label><input type="date" id="finalReportDate" onchange="updateHelperFromField(event);" /></div>
        </div>
      </div>
    </div>


    <!-- COLLAPSIBLE CONTACT DATA -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('contactData')">נתוני התקשרות (הצג/הסתר)</button>
      <div id="contactData" style="display:none;">
        <div class="form-grid">
          <div><label>שם בעל הרכב:</label><input type="text" id="ownerName" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>כתובת בעל הרכב:</label><input type="text" id="ownerAddress" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>טלפון בעל הרכב:</label><input type="text" id="ownerPhone" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>חברת ביטוח:</label><input type="text" id="insuranceCompany" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>אימייל חברת ביטוח:</label><input type="text" id="insuranceEmail" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>סוכן ביטוח:</label><input type="text" id="insuranceAgent" onchange="updateHelperFromContactField(this); triggerFloatingScreenRefresh();" /></div>
          <div><label>טלפון סוכן ביטוח:</label><input type="text" id="agentPhone" onchange="updateHelperFromContactField(this); triggerFloatingScreenRefresh();" /></div>
          <div><label>אימייל סוכן ביטוח:</label><input type="text" id="agentEmail" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>שם מוסך:</label><input type="text" id="garageName" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>טלפון מוסך:</label><input type="text" id="garagePhone" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>אימייל מוסך:</label><input type="text" id="garageEmail" onchange="updateHelperFromContactField(this);" /></div>
        </div>
      </div>
    </div>

    <!-- DAMAGE CENTERS SUMMARY SECTION - EDITABLE -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('damageCentersSummary')">סיכום מוקדי נזק (הצג/הסתר)</button>
      <div id="damageCentersSummary" style="display:none;">
        <h3>סיכום מוקדי נזק (ניתן לעריכה) </h3>
        
        <!-- SESSION 88: Invoice Assignment Banner -->
        <div id="invoiceAssignmentBanner" style="display: none; margin-bottom: 15px;">
          <div style="
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border: 2px solid #2196f3;
            border-radius: 8px;
            padding: 15px;
            position: relative;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
          ">
            <div style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              margin-bottom: 10px;
            ">
              <div style="
                display: flex;
                align-items: center;
                gap: 10px;
              ">
                <span style="font-size: 20px;">📄</span>
                <span style="
                  font-weight: 600;
                  color: #1565c0;
                  font-size: 16px;
                ">זמינות חשבוניות להקצאה</span>
              </div>
              <button id="dismissInvoiceBanner" onclick="dismissInvoiceAssignmentBanner()" style="
                background: none;
                border: none;
                font-size: 18px;
                cursor: pointer;
                color: #666;
                padding: 0;
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
              ">×</button>
            </div>
            
            <div id="invoiceAssignmentContent" style="
              background: white;
              border-radius: 6px;
              padding: 12px;
              margin-bottom: 10px;
            ">
              <div style="color: #666; text-align: center;">
                טוען חשבוניות זמינות...
              </div>
            </div>
            
            <div style="
              display: flex;
              gap: 10px;
              justify-content: flex-end;
            ">
              <button id="acceptInvoiceAssignment" onclick="acceptInvoiceAssignment()" style="
                background: #4caf50;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                font-weight: 500;
              ">אשר הקצאת חשבוניות</button>
            </div>
          </div>
        </div>
        
        <div style="background: #f8f9fa; border-radius: 6px; padding: 15px; min-height: 50px;" id="damageCentersContent">
          <div style="color: #666; text-align: center;">טוען נתוני מוקדי נזק...</div>
        </div>
        <button type="button" class="btn add" onclick="addNewDamageCenter()" style="margin-top: 10px;">הוסף מוקד נזק חדש</button>
      </div>
    </div>

    <!-- GROSS DAMAGE PERCENTAGE CALCULATION -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('grossCalc')">  ערך הרכב לנזק גולמי - מאפיינים ועליה לכביש בלבד (הצג/הסתר)</button>
      <div id="grossCalc" style="display:none;">
        <div class="form-grid">
          <div><label>ערך הרכב ע"פ מחירון כולל מע"מ:</label><input type="text" id="basicPrice" placeholder="₪" onchange="updateHelperFromField(event); updateGrossMarketValueCalculation(); updateHelperFromAdjustments();" /></div>
          <div></div>
        </div>
        <div style="margin-top: 10px; text-align: right;">
          <button type="button" onclick="reloadGrossAdjustments()" style="background: #ff9500; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600;">טען התאמות לוי יצחק</button>
        </div>
        
        <!-- Features Adjustments -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">תוספות מאפיינים (תכונות הרכב):</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            🏗️ תוספות הקשורות לתכונות פיזיות של הרכב עצמו
          </div>
          <div id="featuresAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="featuresAdjustmentsList"></div>
            <div id="grossFeaturesCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ערך לאחר תוספות מאפיינים: <span style="color: #28a745;">₪0</span>
            </div>
            <button class="btn add" type="button" onclick="addFeatureAdjustment()">הוסף תוספת מאפיין</button>
          </div>
        </div>
        
        <!-- Registration Adjustments -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">עליה לכביש (תאריך רישום):</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            📅 התאמות בגין תאריך רישום הרכב (מאפיין קבוע של הרכב)
          </div>
          <div id="registrationAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="registrationAdjustmentsList"></div>
            <div id="grossRegistrationCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ערך לאחר עליה לכביש: <span style="color: #28a745;">₪0</span>
            </div>
            <button class="btn add" type="button" onclick="addRegistrationAdjustment()">הוסף תוספת עליה לכביש</button>
          </div>
        </div>
        
        <!-- Gross Market Value Result -->
        <div style="margin-top: 20px; padding: 15px; background: #f0f8ff; border-radius: 8px; border: 2px solid #4a90e2;">
          <div class="form-grid">
            <div><label><strong>ערך הרכב לנזק גולמי כולל מע"מ:</strong></label><input type="text" id="grossMarketValueResult" style="background: #f8f9fa; font-weight: bold;" readonly /></div>
            <div></div>
          </div>
        </div>
      </div>
    </div>

    <!-- FINAL REPORT ADJUSTMENTS SECTION -->

    <!-- GROSS DAMAGE PERCENTAGE RESULT -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('grossPercentageResult')">אחוז הנזק הגולמי - בסיס הרכב בלבד (הצג/הסתר)</button>
      <div id="grossPercentageResult" style="display:none;">
        <div class="form-grid">
          <div><label>סה״כ עלות נזקים: <span style="color: #dc3545; font-size: 11px;">(לפי חשבונית/הערכה)</span></label><input type="text" id="totalClaimGross" style="background: #f8f9fa;" readonly /></div>
          <div><label>ערך הרכב לנזק גולמי:</label><input type="text" id="leviPriceList" style="background: #f8f9fa;" readonly /></div>
        </div>
        
        <!-- Additional Claims Data -->
        <div style="margin-top: 20px;">
          <div class="form-grid">
            <div><label>סה"כ תביעה (מאושר):</label><input type="text" id="authorizedClaim" onchange="updateAuthorizedClaim(this); updateGrossPercentageField();" style="direction: ltr; text-align: right;" /></div>
            <div></div>
          </div>
        </div>
        
        <!-- Gross Percentage Result -->
        <div style="margin-top: 15px; padding: 15px; background: #f0f8ff; border-radius: 8px; border: 2px solid #e74c3c;">
          <div class="form-grid">
            <div><label><strong>אחוז הנזק הגולמי:</strong></label><input type="text" id="grossPercent" style="background: #f8f9fa; font-weight: bold; color: #e74c3c;" readonly /></div>
            <div></div>
          </div>
          <div style="margin-top: 10px; font-size: 14px; color: #666;">
            <strong>חישוב:</strong> סה״כ תביעה (מאושר) ÷ ערך הרכב לנזק גולמי × 100
          </div>
        </div>
      </div>
    </div>

    <!-- FULL MARKET VALUE CALCULATION -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('fullMarketValue')">ערך השוק המלא - כולל גורמי שימוש (הצג/הסתר)</button>
      <div id="fullMarketValue" style="display:none;">
        <div class="form-grid">
          <div><label>ערך הרכב ע"פ מחירון כולל מע"מ:</label><input type="text" id="fullBasicPrice" placeholder="₪" readonly style="background: #f8f9fa;" /></div>
          <div></div>
        </div>
        <div style="margin-top: 10px; text-align: right;">
          <button type="button" onclick="reloadFullMarketAdjustments()" style="background: #ff9500; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600;">טען התאמות לוי יצחק</button>
        </div>
        
        <!-- Features Adjustments (תוספות מאפיינים) -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">תוספות מאפיינים (תכונות הרכב):</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            🏗️ תוספות הקשורות לתכונות פיזיות של הרכב עצמו
          </div>
          <div id="fullFeaturesAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="fullFeaturesAdjustmentsList"></div>
            <div id="featuresCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ערך לאחר תוספות מאפיינים: <span style="color: #28a745;">₪118,000</span>
            </div>
            <button class="btn add" type="button" onclick="addFullMarketFeatureAdjustment()">הוסף תוספת מאפיין</button>
          </div>
        </div>
        
        <!-- Registration Adjustments (עליה לכביש) -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">עליה לכביש (תאריך רישום):</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            📅 התאמות בגין תאריך רישום הרכב (מאפיין קבוע של הרכב)
          </div>
          <div id="fullRegistrationAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="fullRegistrationAdjustmentsList"></div>
            <div id="registrationCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ערך לאחר עליה לכביש: <span style="color: #28a745;">₪118,000</span>
            </div>
            <button class="btn add" type="button" onclick="addFullMarketRegistrationAdjustment()">הוסף תוספת עליה לכביש</button>
          </div>
        </div>
        
        <!-- Mileage Adjustments (מס ק"מ) -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">מס ק"מ:</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            🚗 התאמות בגין ק"מ של הרכב
          </div>
          <div id="mileageAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="mileageAdjustmentsList"></div>
            <div id="mileageCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ערך לאחר מס ק"מ: <span style="color: #dc3545;">₪86,312</span>
            </div>
            <button class="btn add" type="button" onclick="addMileageAdjustment()">הוסף התאמת מס ק"מ</button>
          </div>
        </div>
        
        <!-- Ownership Type Adjustments (סוג בעלות) -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">סוג בעלות:</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            🏢 התאמות בגין סוג בעלות (פרטי, חברה, ליסינג)
          </div>
          <div id="ownershipAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="ownershipAdjustmentsList"></div>
            <div id="ownershipCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ערך לאחר סוג בעלות: <span style="color: #dc3545;">₪84,586</span>
            </div>
            <button class="btn add" type="button" onclick="addOwnershipAdjustment()">הוסף התאמת סוג בעלות</button>
          </div>
        </div>
        
        <!-- Number of Owners Adjustments (מספר בעלים) -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">מספר בעלים:</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            👥 התאמות בגין מספר בעלים קודמים
          </div>
          <div id="ownersAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="ownersAdjustmentsList"></div>
            <div id="ownersCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ערך לאחר מספר בעלים: <span style="color: #dc3545;">₪70,206</span>
            </div>
            <button class="btn add" type="button" onclick="addOwnersAdjustment()">הוסף התאמת מספר בעלים</button>
          </div>
        </div>
        
        <!-- Additional Market Adjustments -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">התאמות שוק נוספות:</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            💡 התאמות נוספות בגין שווי שוק
          </div>
          <div id="allAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="allAdjustmentsList">
              <!-- This will be populated from helper data -->
            </div>
            <button class="btn add" type="button" onclick="addFullMarketAdjustment()">הוסף התאמה נוספת</button>
          </div>
        </div>
        
        <!-- Full Market Value Result -->
        <div style="margin-top: 20px; padding: 15px; background: #f0f8ff; border-radius: 8px; border: 2px solid #28a745;">
          <div class="form-grid">
            <div><label><strong>ערך השוק המלא של הרכב כולל מע"מ:</strong></label><input type="text" id="fullMarketValueResult" style="background: #f8f9fa; font-weight: bold; color: #28a745;" readonly /></div>
            <div></div>
          </div>
          <div style="margin-top: 10px; font-size: 14px; color: #666;">
            <strong>חישוב:</strong> (מחיר בסיס + התאמות רכב) + התאמות שימוש
          </div>
        </div>
      </div>
    </div>


    <!-- DEPRECIATION CALCULATION SECTION -->
    <div class="form-section" id="depreciationSection">
      <button class="collapsible-btn" type="button" onclick="toggleSection('depreciationContent')">חישוב ירידת ערך לפי מוקדי נזק (הצג/הסתר)</button>
      <div id="depreciationContent" style="display: none;">
        <h3>חישוב ירידת ערך לפי מוקדי נזק</h3>
        <div style="display:grid; grid-template-columns:70px 2fr 2fr 80px 90px 80px; gap:14px; margin-bottom:10px;">
        <div><label>מס' מוקד:</label></div>
        <div><label>החלק הניזוק:</label></div>
        <div><label>מהות התיקון:</label></div>
        <div><label>% ירידת ערך:</label></div>
        <div><label>ערך ב-₪:</label></div>
        <div><label>פעולות:</label></div>
      </div>
      <div id="depreciationBulkTable"></div>
      <button class="btn add" type="button" onclick="addDepField()">הוסף שדה</button>
      <div style="margin-top:14px;">
        <label>ירידת ערך גלובלי:</label>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:14px;">
          <input type="text" id="globalDep1" placeholder="ירידת ערך" style="direction: ltr; text-align: right;" />
          <input type="text" id="globalDepValue" placeholder="ערך ב-₪" readonly style="background:#f4f6fa;" />
        </div>
      </div>
      <div style="margin-top:14px;">
        <label>ימי מוסך משוערים:</label>
        <input type="number" id="garageDays" placeholder="מספר ימי עבודה" style="width: 200px;" onchange="updateHelperDepreciationField(this, 'work_days_impact');" />
      </div>
      <br><br>
  </div>
    </div>
    </div> <!-- Close depreciationContent -->
    <br><br>

    <!-- SESSION 62: Case Reduction Section Placeholder -->
    <div id="caseReductionPlaceholder"></div>

    <!-- COLLAPSIBLE PRICE DATA -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('priceData')">נתוני תביעה (הצג/הסתר)</button>
      <div id="priceData" style="display:none;">
        <div class="form-grid">
          <div>
            <label>סה״כ תביעה (סכום מוקדי נזק):</label>
            <div class="readonly-box" id="totalClaim">0</div>
          </div>
          <div>
            <label>חישוב הערך לנזק גולמי:</label>
            <div class="readonly-box" id="grossDamageValue">יחושב אוטומטית מהתאמות לוי</div>
          </div>
          <div>
            <label>חישוב האחוז הגולמי:</label>
            <div class="readonly-box" id="grossPercentage">יחושב אוטומטית</div>
          </div>
          <div>
            <label>מחיר שוק (בסיס + התאמות):</label>
            <div class="readonly-box" id="marketPriceCalculated">יחושב אוטומטית</div>
          </div>
          <div>
            <label>ערך השוק של הרכב (לפי דו״ח לוי יצחק): </label>
            <div class="readonly-box" id="finalMarketValue">יחושב מהתאמות לוי</div>
          </div>
          <div>
            <label>אישור חברת ביטוח (אופציונלי):</label>
            <input type="text" id="insuranceAuthorization" placeholder="₪" onchange="updateClaimsDataFromField(this, 'authorized_claim');" style="direction: ltr; text-align: right;" />
          </div>
        </div>
      </div>
    </div>

    <!-- SUMMARY SECTIONS CONTAINER -->
    <div style="text-align: center; margin: 20px 0;">
      <button onclick="location.reload()" style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 14px; cursor: pointer; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">🔄 רענן דף</button>
    </div>
    <div class="summary-container">
    
    <!-- SUMMARY SECTION - PROPER FINAL REPORT VERSION -->
    <div class="form-section summary-block" id="summaryPrivate" style="background: linear-gradient(135deg, #0346a4 0%, #042676 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">סיכום - חוות דעת פרטית</h3>
      
      <!-- Final Report Date Section -->
      <div style="background: rgba(255,255,255,0.9); color: #333; border-radius: 8px; padding: 12px; margin-bottom: 15px; text-align: center;">
        <div style="margin-bottom: 8px;">
          <label style="color: #1e3a8a; font-weight: bold; font-size: 14px;">תאריך חוות הדעת:</label>
        </div>
        <div>
          <input type="date" id="finalReportDateSummary" onchange="updateHelperFromField(event);" style="background: white; color: #333; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px;" />
        </div>
      </div>
      <div style="background: rgba(255,255,255,0.95); color: #333; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
        <div class="form-grid">
        <div>
          <label style="color: #333;">ערך השוק של הרכב:</label>
          <input type="text" id="sumMarketValue" style="background: white; color: #333;" value="₪158,901" />
        </div>
        <div>
          <label style="color: #333;">סה״כ תביעה:</label>
          <input type="text" id="sumClaim" style="background: white; color: #333;" />
        </div>
        <div>
          <label style="color: #333;">פיצוי בגין ירידת ערך:</label>
          <input type="text" id="depCompensation" style="background: white; color: #333;" />
        </div>
        <div>
          <label style="color: #333;">תוספות והורדות (מידע בלבד):</label>
          <input type="text" id="adjustmentsInfo" style="background: #f0f0f0; color: #666;" readonly />
        </div>
        </div>
      </div>
      <div style="background: rgba(255,255,255,0.95); color: #333; border-radius: 8px; padding: 15px;">
        <div class="form-grid">
          <div>
            <label style="color: #333;">סה״כ נכלל בחוות הדעת:</label>
            <input type="text" id="sumTotalBeforeDifferentials" style="background: white; color: #333;" />
          </div>
        </div>
      </div>
    </div>

    <div class="form-section summary-block" id="summaryGlobal" style="display:none; background: linear-gradient(135deg, #0346a4 0%, #042676 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">סיכום - חוות דעת גלובלית</h3>
      <div class="form-grid">
        <div>
          <label>ערך השוק של הרכב:</label>
          <input type="text" id="sumMarketValueGlobal" />
        </div>
        <div>
          <label>סה״כ תביעה:</label>
          <input type="text" id="sumClaimGlobal" />
        </div>
        <div>
          <label>פיצוי בגין ירידת ערך:</label>
          <input type="text" id="depCompensationGlobal" />
        </div>
      </div>
      <div class="form-grid" style="margin-top:16px;">
        <div>
          <label>סה״כ נכלל בחוות הדעת:</label>
          <input type="text" id="sumTotalGlobal" />
        </div>
      </div>
    </div>

    <div class="form-section summary-block" id="summaryDamage" style="display:none; background: linear-gradient(135deg, #0346a4 0%, #042676 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">סיכום - מצבו הניזוק</h3>
      <div class="form-grid">
        <div>
          <label>ערך השוק של הרכב:</label>
          <input type="text" id="sumMarketValueDamage" />
        </div>
        <div>
          <label>ערך המכירה במצבו הניזוק:</label>
          <input type="text" id="saleValueDamage" />
        </div>
        <div>
          <label>שיטת תשלום:</label>
          <input type="text" id="paymentMethod" placeholder="מזומן, צ'ק, העברה בנקאית..." />
        </div>
      </div>
      <div class="form-grid" style="margin-top:16px;">
        <div>
          <label>סה״כ לאחר מכירה:</label>
          <input type="text" id="afterSaleDamage" />
        </div>
      </div>
    </div>

    <div class="form-section summary-block" id="summaryTotalLoss" style="display:none; background: linear-gradient(135deg, #0346a4 0%, #042676 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">סיכום - טוטלוסט</h3>
      <div class="form-grid">
        <div>
          <label>ערך השוק של הרכב:</label>
          <input type="text" id="sumMarketValueTotal" />
        </div>
        <div>
          <label>ערך שרידי הרכב:</label>
          <input type="text" id="salvageValueTotal" />
        </div>
        <div>
          <label>תוספת גרירה ואחסנה:</label>
          <input type="text" id="storageValueTotal" />
        </div>
      </div>
      <div class="form-grid" style="margin-top:16px;">
        <div>
          <label>סה״כ לאחר מכירת שרידים:</label>
          <input type="text" id="afterSaleTotal" style="background: white; color: #333;" />
        </div>
      </div>
    </div>

    <div class="form-section summary-block" id="summaryLegalLoss" style="display:none; background: linear-gradient(135deg, #0346a4 0%, #042676 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">סיכום - אובדן להלכה</h3>
      <div class="form-grid">
        <div>
          <label>ערך השוק של הרכב:</label>
          <input type="text" id="sumMarketValueLegal" />
        </div>
        <div>
          <label>ערך שרידי הרכב:</label>
          <input type="text" id="salvageValueLegal" />
        </div>
      </div>
      <div class="form-grid" style="margin-top:16px;">
        <div>
          <label>סה״כ לאחר מכירת שרידים:</label>
          <input type="text" id="afterSaleLegal" style="background: white; color: #333;" />
        </div>
      </div>
    </div>

    <!-- ADDITIONAL NOTES -->
    <div class="form-section">
      <h3>הערות נוספות לחוות דעת</h3>
      <textarea id="additional-notes" placeholder="הוסף הערות, המלצות או מידע נוסף לחוות דעת..." style="min-height: 80px; font-family: sans-serif; font-size: 16px;" onchange="updateHelperFromField(event);"></textarea>
    </div>

    <!-- LEGAL TEXT SECTION - EDITABLE (MOVED BEFORE NAVIGATION) -->
    <div class="form-section" id="legal-text">
      <h3>טקסט משפטי לחוות דעת</h3>
      <div style="margin-bottom: 10px;">
        <button type="button" onclick="loadLegalTextFromVault()" style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-left: 10px;">טען מהכספת</button>
        <button type="button" onclick="resetLegalText()" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">איפוס טקסט</button>
      </div>
      <textarea id="legal-text-content" style="width: 100%; min-height: 200px; padding: 15px; border: 1px solid #e2e8f0; border-radius: 6px; background: #f8f9fa; line-height: 1.6; font-family: inherit; resize: vertical; box-sizing: border-box;" placeholder="הטקסט המשפטי יטען כאן עם הנתונים המעודכנים..." onchange="updateHelperFromField(event);"></textarea>
      <div style="margin-top: 8px; font-size: 14px; color: #666;">
        💡 הטקסט ניתן לעריכה לצורך התאמה לדוח הספציפי. השינויים לא ישפיעו על הכספת המקורית.
      </div>
    </div>

    <!-- VAT RATE SETTINGS -->
    <div class="form-section" id="vat-settings" style="background: #fff3cd; border-left: 4px solid #ffc107;">
      <h3 style="color: #856404;">🏛️ הגדרות מע"מ</h3>
      <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px;">
        <div style="font-size: 14px; color: #495057; margin-bottom: 10px;">
          <strong>מקור שיעור מע"מ נוכחי:</strong> <span id="vat-source-display">טוען...</span><br>
          <strong>עדכון אחרון:</strong> <span id="vat-updated-display">טוען...</span>
        </div>
        <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
          <label style="font-weight: bold; color: #495057;">שיעור מע"מ (%):</label>
          <input type="number" id="vat-rate-input" min="0" max="100" step="0.1" 
                 style="width: 80px; padding: 6px; border: 1px solid #ced4da; border-radius: 4px;" 
                 value="" placeholder="18">
          <button type="button" onclick="updateVatRate()" 
                  style="background: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">
            עדכן מע"מ
          </button>
          <button type="button" onclick="resetVatRateFromAdmin()" 
                  style="background: #6c757d; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">
            אפס לערך מנהל
          </button>
        </div>
        <div style="font-size: 12px; color: #6c757d; margin-top: 8px;">
          💡 שינוי שיעור המע"מ ישפיע על כל החישובים בדו"ח זה. השינוי לא ישפיע על המקרים האחרים.
        </div>
      </div>
    </div>

    <!-- ATTACHMENTS SECTION - EDITABLE -->
    <div class="form-section" id="attachments-section">
      <h3>רשימת נספחים</h3>
      <div style="margin-bottom: 10px;">
        <button type="button" onclick="loadAttachmentsFromVault()" style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-left: 10px;">טען מהכספת</button>
        <button type="button" onclick="resetAttachments()" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">איפוס רשימה</button>
      </div>
      <textarea id="attachments-content" style="width: 100%; min-height: 120px; padding: 15px; border: 1px solid #e2e8f0; border-radius: 6px; background: #f8f9fa; line-height: 1.6; font-family: inherit; resize: vertical; box-sizing: border-box;" placeholder="רשימת הנספחים תטען כאן..."><strong>לוטה</strong>
תצלומי הרכב הניזוק
חשבוניות תיקון
ערך רכב ממוחשב
צילום רישיון הרכב
חשכ"ט</textarea>
      <div style="margin-top: 8px; font-size: 14px; color: #666;">
        💡 הרשימה ניתנת לעריכה לצורך התאמה לדוח הספציפי. השינויים לא ישפיעו על הכספת המקורית.
      </div>
    </div>

    <!-- Navigation Buttons -->
    <div class="form-section">
      <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px;">
        <button type="button" class="nav-btn save-btn" onclick="saveDepreciationData()">שמור נתונים</button>
        <button type="button" class="nav-btn" style="background: #1e40af;" onclick="previewFinalReport()">
          <span style="margin-left: 5px;">👁️</span>
          תצוגה מקדימה לחוו״ד
        </button>
        <button type="button" class="nav-btn" style="background: #059669;" onclick="continueToValidation()">
          <span style="margin-left: 5px;">✅</span>
          המשך לשכר טרחה
        </button>
        <button type="button" class="nav-btn back-btn" onclick="window.location.href='selection.html'">חזור לדף הבחירה</button>
      </div>
    </div>

    </div> <!-- Close summary-container -->

    <div class="footer"> Carmel Cayouf 2025 © All rights reserved. SmartVal Pro System by Evalix. </div>
  </div>
</div>

  
  <!-- Load Legal Text Engine -->
  <script src="legal-text-engine.js"></script>
  
  <script>
    // 🔒 CRITICAL: Block any redirects to index.html IMMEDIATELY on page load
    (function() {
      console.log('🔒 Installing redirect blocker...');
      
      // Monitor for navigation attempts
      window.addEventListener('beforeunload', function(e) {
        console.error('🚫 PAGE UNLOAD DETECTED');
        console.trace('Unload from:');
      });
      
      // Intercept location.replace
      const originalReplace = window.location.replace;
      window.location.replace = function(url) {
        if (url && (url.includes('index.html') || url.includes('/index.html'))) {
          console.error('🚫 BLOCKED: location.replace() to:', url);
          console.trace('Replace blocked from:');
          return;
        }
        return originalReplace.call(window.location, url);
      };
      
      // Intercept location.assign
      const originalAssign = window.location.assign;
      window.location.assign = function(url) {
        if (url && (url.includes('index.html') || url.includes('/index.html'))) {
          console.error('🚫 BLOCKED: location.assign() to:', url);
          console.trace('Assign blocked from:');
          return;
        }
        return originalAssign.call(window.location, url);
      };
      
      console.log('✅ Redirect blocker installed');
    })();

    // GROSS SECTION IMPORT STATE TRACKING
    let grossSectionImportState = {
      hasImportedOnce: false,
      userHasManagedData: false,
      featuresImported: false,
      registrationImported: false
    };

    // IMMEDIATE FUNCTION DEFINITIONS - MUST BE AVAILABLE BEFORE DOM LOADS
    
    // Helper function to safely parse amounts and prevent NaN
    function safeParseAmount(value) {
      if (!value || value === '') return 0;
      
      // Convert to string if not already
      const strValue = String(value);
      
      // Remove currency symbols (₪ and ש), commas, and spaces
      const cleanedValue = strValue.replace(/[₪ש,\s]/g, '');
      
      // Parse the cleaned value
      const parsed = parseFloat(cleanedValue);
      
      // Return 0 if parsing resulted in NaN, otherwise round to whole number
      return isNaN(parsed) ? 0 : Math.round(parsed);
    }
    
    // Helper function to check if a type is a reduction/minus type
    function isReductionType(type) {
      return type === 'minus' || type === 'הפחתה' || type === 'הפחתה (-)' || type === 'הורדה';
    }
    window.toggleFloatingScreen = function(screenType) {
      
      const screens = {
        leviReport: () => {
          if (window.toggleLeviReport) {
            window.toggleLeviReport();
          } else {
          }
        },
        carDetails: () => {
          if (window.toggleCarDetails) {
            window.toggleCarDetails();
          } else {
          }
        },
        internalBrowser: () => {
          if (window.showBrowserMenu) {
            showBrowserMenuUnderToggle();
          } else {
          }
        },
        invoiceDetails: () => {
          if (window.toggleInvoiceDetails) {
            window.toggleInvoiceDetails();
          } else {
            alert('מסך פרטי חשבוניות יהיה זמין בקרוב\nInvoice details screen coming soon');
          }
        },
        partsSearchResults: () => {
          if (window.togglePartsSearchResults) {
            window.togglePartsSearchResults();
          } else {
            console.log('Parts search results floating screen not available');
          }
        }
      };
      
      if (screens[screenType]) {
        screens[screenType]();
      } else {
      }
    };
    
    window.toggleSection = function(sectionId) {
      
      const section = document.getElementById(sectionId);
      if (section) {
        const isVisible = section.style.display !== 'none';
        section.style.display = isVisible ? 'none' : 'block';
      } else {
      }
    };
    // Authentication check - Supabase compatible
    const authData = sessionStorage.getItem("auth");
    if (!authData) {
      alert("הגישה חסומה - אנא התחבר דרך דף הבית");
      window.location.href = "index.html";
    } else {
      try {
        const auth = JSON.parse(authData);
        if (auth.user && auth.session) {
          console.log('✅ Valid Supabase session for:', auth.user.email);
          
          // CRITICAL: Prevent any unauthorized redirects after this point
          window.__finalReportBuilderAuthVerified = true;
          console.log('🔒 Page lock engaged - redirects blocked');
        } else {
          console.log('⚠️ Using legacy auth system');
        }
      } catch (e) {
        console.log('⚠️ Using legacy auth system (non-JSON)');
      }
    }
    
    // CRITICAL: Monitor for redirect attempts with beforeunload
    window.addEventListener('beforeunload', function(e) {
      if (window.__finalReportBuilderAuthVerified) {
        console.error('🚫 PAGE UNLOAD DETECTED - Something is trying to leave final-report-builder');
        console.trace('Unload triggered from:');
        // This won't prevent unload but will show us what's happening
      }
    });
    
    // Intercept navigation by wrapping window.location.replace and window.location.assign
    const originalReplace = window.location.replace;
    const originalAssign = window.location.assign;
    
    window.location.replace = function(url) {
      if (window.__finalReportBuilderAuthVerified && url && url.includes('index.html')) {
        console.error('🚫 BLOCKED: location.replace() to index.html');
        console.trace('Replace blocked from:');
        return;
      }
      return originalReplace.call(window.location, url);
    };
    
    window.location.assign = function(url) {
      if (window.__finalReportBuilderAuthVerified && url && url.includes('index.html')) {
        console.error('🚫 BLOCKED: location.assign() to index.html');
        console.trace('Assign blocked from:');
        return;
      }
      return originalAssign.call(window.location, url);
    };

    // FLOATING SCREENS TOGGLE FUNCTION - COPIED FROM DEPRECIATION MODULE

    // CUSTOM BROWSER MENU - COPIED FROM DEPRECIATION MODULE
    function showBrowserMenuUnderToggle() {
      const menu = document.createElement('div');
      menu.style.cssText = `
        position: fixed;
        top: 90px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 20px;
        z-index: 99999;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        font-family: sans-serif;
        direction: rtl;
        min-width: 280px;
      `;
      
      menu.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 15px; color: #2c3e50; font-size: 16px;">בחר אתר לפתיחה:</div>
        <button onclick="window.openInternalBrowser('car-part.co.il'); this.parentElement.remove();" style="width: 100%; padding: 12px; margin-bottom: 8px; border: none; background: #28a745; color: white; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: 500;">
          🔧 Car Part - חלקי רכב
        </button>
        <button onclick="window.openInternalBrowser('portal.levi-itzhak.co.il'); this.parentElement.remove();" style="width: 100%; padding: 12px; margin-bottom: 8px; border: none; background: #007bff; color: white; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: 500;">
          📊 פורטל לוי יצחק
        </button>
        <button onclick="this.parentElement.remove();" style="width: 100%; padding: 10px; border: 1px solid #ccc; background: white; color: #666; border-radius: 6px; cursor: pointer; font-size: 14px;">
          ביטול
        </button>
      `;
      
      document.body.appendChild(menu);
      
      // Remove menu when clicking outside
      setTimeout(() => {
        document.addEventListener('click', function removeMenu(e) {
          if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', removeMenu);
          }
        });
      }, 100);
    }

    // COLLAPSIBLE SECTION TOGGLE
    function toggleSection(sectionId) {
      const section = document.getElementById(sectionId);
      if (section) {
        section.style.display = section.style.display === 'none' ? 'block' : 'none';
        
        // Save state to sessionStorage
        const isVisible = section.style.display !== 'none';
        sessionStorage.setItem(`section-${sectionId}`, isVisible ? 'expanded' : 'collapsed');
      } else {
      }
    }

    // DAMAGE CENTERS SECTION TOGGLE
    function toggleDamageCentersSection() {
      const section = document.getElementById('damageCentersSummary');
      const toggleBtn = document.getElementById('damageCentersToggleBtn');
      
      if (section && toggleBtn) {
        const isVisible = section.style.display !== 'none';
        
        if (isVisible) {
          // Hide section
          section.style.display = 'none';
          toggleBtn.innerHTML = '🔼 פתח';
          toggleBtn.style.background = '#28a745';
        } else {
          // Show section
          section.style.display = 'block';
          toggleBtn.innerHTML = '🔽 סגור';
          toggleBtn.style.background = '#6c757d';
        }
        
        // Save state to sessionStorage
        sessionStorage.setItem('damageCentersSection', isVisible ? 'collapsed' : 'expanded');
      }
    }

    
    // ADD DEPRECIATION FIELD FUNCTION
    function addDepField(data = {}) {
      const container = document.getElementById('depreciationBulkTable');
      if (!container) {
        return;
      }
      
      const rowId = 'depRow_' + Date.now();
      const newRow = `
        <div id="${rowId}" class="dep-row" style="display:grid; grid-template-columns:70px 2fr 2fr 80px 90px 80px; gap:10px; margin-bottom:8px;">
          <div><input type="text" placeholder="מס' מוקד" value="${data.center_number || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" style="text-align: center;" title="${data.center_number || ''}" /></div>
          <div><input type="text" placeholder="החלק הניזוק" value="${data.damaged_part || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="${data.damaged_part || ''}" /></div>
          <div><input type="text" placeholder="מהות התיקון" value="${data.repair_type || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="${data.repair_type || ''}" /></div>
          <div><input type="text" placeholder="ירידת ערך (מספר)" value="${data.percent || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="${data.percent || ''}" style="direction: ltr; text-align: right;" /></div>
          <div><input type="text" placeholder="ערך ב-₪" value="${data.value || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="₪${data.value || ''}" /></div>
          <div><button class="btn remove" onclick="removeDepField('${rowId}')">מחק</button></div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      
      // Add auto-calculation functionality to the percentage field
      const row = document.getElementById(rowId);
      
      // Add tooltip update listeners to all input fields
      const inputs = row.querySelectorAll('input');
      inputs.forEach(input => {
        input.addEventListener('input', function() {
          this.title = this.value;
        });
      });
      const percentInput = row.querySelector('input[placeholder="ירידת ערך (מספר)"]');
      const valueInput = row.querySelector('input[placeholder="ערך ב-₪"]');
      
      percentInput.addEventListener('input', function() {
        // Clean the value to extract the numeric part for calculation only
        const cleanValue = this.value.replace('%', '').replace(/[^0-9.-]/g, '');
        let percent = parseFloat(cleanValue) || 0;
        
        // Don't modify the input value - keep it as the user entered it
        
        // Calculate value from market price automatically
        const marketValueField = document.getElementById('carMarketValue') || document.getElementById('sumMarketValue');
        const marketValueStr = marketValueField?.value.replace(/[₪,]/g, '') || '0';
        const marketValue = parseFloat(marketValueStr) || 0;
        
        const calculatedValue = (marketValue * percent) / 100;
        valueInput.value = calculatedValue ? `₪${Math.round(calculatedValue).toLocaleString()}` : '';
        
        // Save data after calculation
        saveDepreciationData();
      });
    }

    // ✅ REAL-TIME 2-WAY DATA FLOW: Update helper.depreciation immediately when UI fields change
    function updateHelperDepreciationField(element, fieldName) {
      try {
        const helper = window.helper || {};
        if (!helper.depreciation) helper.depreciation = {};
        
        let value = element.value;
        
        // Handle different field types
        switch(fieldName) {
          case 'global_percentage':
            // Clean the value: remove % sign and handle decimal values correctly
            const cleanValue = value.replace('%', '').replace(/[^0-9.-]/g, '');
            helper.depreciation.global_percentage = parseFloat(cleanValue) || 0;
            // Also trigger the calculation
            calculateGlobalDepreciationValue();
            break;
          case 'work_days_impact':
            helper.depreciation.work_days_impact = parseInt(value) || 0;
            break;
          default:
            helper.depreciation[fieldName] = value;
        }
        
        helper.depreciation.last_updated = new Date().toISOString();
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        
        // Trigger helper update broadcast
        if (typeof broadcastHelperUpdate === 'function') {
          broadcastHelperUpdate(['depreciation'], 'depreciation_field_update');
        }
      } catch (error) {
      }
    }
    
    // REMOVE DEPRECIATION FIELD FUNCTION
    function removeDepField(rowId) {
      const row = document.getElementById(rowId);
      if (row) {
        row.remove();
        // Save after removal
        saveDepreciationData();
      }
    }

    // NEW CLEAN SAVE FUNCTION - ONLY SAVES ADJUSTMENTS DATA
    function saveAdjustmentsData() {
      console.log('💾 SAVE ADJUSTMENTS BUTTON CLICKED!');
      const button = document.querySelector('.save-btn');
      
      // Show visual feedback
      if (button) {
        button.style.background = '#059669';
        button.innerHTML = '⏳ שומר התאמות...';
        button.disabled = true;
      }
      
      // Phase 6: Capture user ID for tracking
      let userId = null;
      let userName = null;
      try {
        const authData = sessionStorage.getItem('auth');
        if (authData) {
          const auth = JSON.parse(authData);
          userId = auth?.user?.id;
          userName = auth?.profile?.name;
        }
      } catch (e) {
        console.warn('Could not extract user ID:', e);
      }
      
      try {
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // CRITICAL: Only save adjustments data using syncAdjustmentToHelper pattern
        // This preserves user edits without triggering competing functions
        
        console.log('🔄 Saving adjustments data using syncAdjustmentToHelper pattern...');
        
        // FIRST: Save depreciation data (same as old button)
        const globalPercent = document.getElementById('globalDep1')?.value || '';
        const globalValue = document.getElementById('globalDepValue')?.value || '';
        
        const depreciationData = {
          global_percent: globalPercent,
          global_value: globalValue,
          bulk_items: []
        };
        
        // Collect depreciation rows
        const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
        depRows.forEach((row, index) => {
          const inputs = row.querySelectorAll('input');
          if (inputs.length >= 5) {
            depreciationData.bulk_items.push({
              center_number: inputs[0].value,
              damaged_part: inputs[1].value,
              repair_type: inputs[2].value,
              percent: inputs[3].value,
              value: inputs[4].value
            });
          }
        });
        
        // Save depreciation data to helper (same structure as old button)
        if (!helper.depreciation) helper.depreciation = {};
        helper.depreciation = {
          global_percentage: parseFloat(String(globalPercent).replace('%', '').replace(/[^0-9.-]/g, '')) || 0,
          global_amount: parseFloat(String(globalValue).replace(/[₪,]/g, '')) || 0,
          work_days_impact: parseInt(document.getElementById('garageDays')?.value) || 0,
          bulk_items: depreciationData.bulk_items,
          last_updated: new Date().toISOString(),
          source: 'final_report_builder'
        };
        
        if (!helper.final_report) helper.final_report = {};
        helper.final_report.depreciation = helper.depreciation;
        
        console.log('✅ Depreciation data saved');
        
        // SECOND: Save all adjustment categories using the proven syncAdjustmentToHelper logic
        const categories = [
          { category: 'features', containerId: 'featuresAdjustmentsList' },
          { category: 'features', containerId: 'fullFeaturesAdjustmentsList' },
          { category: 'registration', containerId: 'registrationAdjustmentsList' }, 
          { category: 'registration', containerId: 'fullRegistrationAdjustmentsList' },
          { category: 'mileage', containerId: 'mileageAdjustmentsList' },
          { category: 'ownership_type', containerId: 'ownershipAdjustmentsList' },
          { category: 'ownership_history', containerId: 'ownersAdjustmentsList' },
          { category: 'additional', containerId: 'allAdjustmentsList' }
        ];
        
        categories.forEach(({ category, containerId }) => {
          const container = document.getElementById(containerId);
          if (container && container.children.length > 0) {
            // Trigger syncAdjustmentToHelper for each category to save current UI state
            const firstInput = container.children[0].querySelector('input');
            if (firstInput) {
              console.log(`💾 Saving ${category} from ${containerId}`);
              syncAdjustmentToHelper(firstInput, category);
            }
          }
        });
        
        // Save updated helper to sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper; // Update window.helper too
        
        console.log('✅ ADJUSTMENTS DATA SAVED SUCCESSFULLY!');
        
        // Show success feedback
        if (button) {
          button.style.background = '#16a34a';
          button.innerHTML = '✅ נשמר!';
          setTimeout(() => {
            button.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
            button.innerHTML = 'שמור התאמות';
            button.disabled = false;
          }, 2000);
        }
        
      } catch (error) {
        console.error('❌ Error saving adjustments data:', error);
        
        // Show error feedback
        if (button) {
          button.style.background = '#dc3545';
          button.innerHTML = '❌ שגיאה';
          setTimeout(() => {
            button.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
            button.innerHTML = 'שמור התאמות';
            button.disabled = false;
          }, 3000);
        }
      }
    }

    // OLD DEPRECIATION SAVE FUNCTION - KEEP FOR OTHER FUNCTIONALITY
    function saveDepreciationData() {
      console.log('💾 SAVE DATA BUTTON CLICKED!');
      const button = document.querySelector('.save-btn');
      
      // Show visual feedback
      if (button) {
        button.style.background = '#059669';
        button.innerHTML = '⏳ שומר...';
        button.disabled = true;
      }
      
      // Phase 6: Capture user ID for tracking
      let userId = null;
      let userName = null;
      try {
        const authData = sessionStorage.getItem('auth');
        if (authData) {
          const auth = JSON.parse(authData);
          userId = auth?.user?.id;
          userName = auth?.profile?.name;
        }
      } catch (e) {
        console.warn('Could not extract user ID:', e);
      }
      
      try {
        // Get helper data from sessionStorage (single source of truth) to ensure consistency
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Get global depreciation values
        const globalPercent = document.getElementById('globalDep1')?.value || '';
        const globalValue = document.getElementById('globalDepValue')?.value || '';
        
        
        // Collect depreciation data
        const depreciationData = {
          global_percent: globalPercent,
          global_value: globalValue,
          bulk_items: []
        };
        
        // Collect data from all depreciation rows
        const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
        console.log('💾 Collecting data from', depRows.length, 'depreciation rows');
        
        depRows.forEach((row, index) => {
          const inputs = row.querySelectorAll('input');
          if (inputs.length >= 5) {
            const item = {
              center_number: inputs[0].value,
              damaged_part: inputs[1].value,
              repair_type: inputs[2].value,
              // Keep percent value as entered by user
              percent: inputs[3].value,
              value: inputs[4].value
            };
            console.log(`  Row ${index + 1}:`, item);
            depreciationData.bulk_items.push(item);
          }
        });
        
        // ✅ CORRECT 2-WAY DATA FLOW: Save to main helper.depreciation structure
        if (!helper.depreciation) helper.depreciation = {};
        
        
        // Save to main depreciation section (single source of truth) with COMPLETE structure
        try {
          
          helper.depreciation = {
            // Form field names (for direct loading) - keep the value as entered by user
            globalDep1: globalPercent,
            globalDepValue: globalValue,
            garageDays: document.getElementById('garageDays')?.value || '',
            
            // Processed values (for calculations)  
            global_percentage: parseFloat(String(globalPercent).replace('%', '').replace(/[^0-9.-]/g, '')) || 0,
            global_amount: parseFloat(String(globalValue).replace(/[₪,]/g, '')) || 0,
            work_days_impact: parseInt(document.getElementById('garageDays')?.value) || 0,
            
            // Array data (single array, no duplication)
            bulk_items: depreciationData.bulk_items,
            
            // Metadata
            last_updated: new Date().toISOString(),
            lastSaved: new Date().toISOString(),
            source: 'final_report_builder',
            isManualSave: true
          };
          
        } catch (error) {
        }
        
        // Also maintain final_report reference for compatibility
        if (!helper.final_report) helper.final_report = {};
        helper.final_report.depreciation = helper.depreciation;
        
        // Initialize adjustments structure mirroring estimate.adjustments
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // ✅ REMOVED: No longer saving to manual_depreciation - everything is in helper.depreciation
        
        // Phase 6: Add user tracking to meta
        if (!helper.meta) helper.meta = {};
        helper.meta.updated_by = userId;
        helper.meta.updated_by_name = userName;
        helper.meta.last_updated = new Date().toISOString();
        
        // ✅ CRITICAL FIX: Update BOTH sessionStorage AND in-memory window.helper to prevent populateAllForms overwrite
        sessionStorage.setItem('helper', JSON.stringify(helper));
        if (window.helper) {
          window.helper.depreciation = helper.depreciation;
          window.helper.final_report = helper.final_report;
          window.helper.meta = helper.meta;
        }
        
        console.log('✅ Depreciation data saved successfully:', helper.depreciation);
        console.log('✅ Updated window.helper:', window.helper);
        
        // Trigger helper update broadcast for real-time sync
        if (typeof broadcastHelperUpdate === 'function') {
          broadcastHelperUpdate(['depreciation'], 'depreciation_update');
        }
        
        console.log('✅ DATA SAVED SUCCESSFULLY!');
        
        // Show success message using the standard message system
        showSectionMessage('depreciation', '✅ נתוני ירידת ערך נשמרו בהצלחה', 'success');
        
        // Show success feedback on button
        if (button) {
          button.style.background = '#16a34a';
          button.innerHTML = '✅ נשמר!';
          setTimeout(() => {
            button.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
            button.innerHTML = 'שמור נתונים';
            button.disabled = false;
          }, 2000);
        }
        
      } catch (error) {
        console.error('❌ SAVE ERROR:', error);
        
        // Show error feedback
        if (button) {
          button.style.background = '#dc2626';
          button.innerHTML = '❌ שגיאה';
          setTimeout(() => {
            button.style.background = '#ef4444';
            button.innerHTML = 'שמור נתונים';
            button.disabled = false;
          }, 2000);
        }
      }
    }

    // ADD AUTO-CALCULATION TO EXISTING ROWS
    function addAutoCalculationToExistingRows() {
      const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
      depRows.forEach(row => {
        const percentInput = row.querySelector('input[placeholder="ירידת ערך (מספר)"]');
        const valueInput = row.querySelector('input[placeholder="ערך ב-₪"]');
        
        if (percentInput && valueInput) {
          // Remove any existing event listeners first
          percentInput.removeEventListener('input', percentInput.autoCalcHandler);
          
          // Create the auto-calculation handler
          const autoCalcHandler = function() {
            // Clean the value to extract the numeric part
            const cleanValue = this.value.replace('%', '').replace(/[^0-9.-]/g, '');
            let percent = parseFloat(cleanValue) || 0;
            
            // Keep value as clean decimal number without % sign
            this.value = cleanValue;
            
            // Calculate value from market price automatically
            const marketValueField = document.getElementById('carMarketValue') || document.getElementById('sumMarketValue');
            const marketValueStr = marketValueField?.value.replace(/[₪,]/g, '') || '0';
            const marketValue = parseFloat(marketValueStr) || 0;
            
            const calculatedValue = (marketValue * percent) / 100;
            valueInput.value = calculatedValue ? `₪${Math.round(calculatedValue).toLocaleString()}` : '';
            
            // Save data after calculation
            saveDepreciationData();
          };
          
          // Store the handler reference for potential removal
          percentInput.autoCalcHandler = autoCalcHandler;
          
          // Add the event listener
          percentInput.addEventListener('input', autoCalcHandler);
          
          // Trigger calculation for existing values
          if (percentInput.value) {
            autoCalcHandler.call(percentInput);
          }
        }
      });
    }

    // MAKE FUNCTIONS GLOBALLY ACCESSIBLE
    window.toggleSection = toggleSection;
    window.toggleDamageCentersSection = toggleDamageCentersSection;
    window.addDepField = addDepField;
    window.removeDepField = removeDepField;
    window.saveDepreciationData = saveDepreciationData;

    // BUTTON FUNCTIONS - NO DEBUG ALERTS
    window.saveFinalReport = function() {
      const selectedTypeElement = document.querySelector('input[name="final-report-type"]:checked');
      if (!selectedTypeElement) {
        alert('אנא בחר סוג חוות דעת');
        return;
      }
      
      const selectedType = selectedTypeElement.value;
      const additionalNotes = document.getElementById('additional-notes')?.value || '';
      const garageDays = document.getElementById('garageDays')?.value || '';
      
      // Get summary data
      const summaryData = {
        market_value: document.getElementById('sumMarketValue')?.value || '',
        total_claim: document.getElementById('sumClaim')?.value || '',
        vat: document.getElementById('sumVAT')?.value || '',
        total_with_vat: document.getElementById('sumTotalClaim')?.value || '',
        dep_compensation: document.getElementById('depCompensation')?.value || '',
        salvage_value: document.getElementById('salvageValue')?.value || ''
      };
      
      // Get depreciation data
      const depreciationData = {
        global_percent: document.getElementById('globalDep1')?.value || '',
        global_value: document.getElementById('globalDepValue')?.value || '',
        bulk_items: []
      };
      
      // Collect depreciation bulk items
      const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
      depRows.forEach(row => {
        const inputs = row.querySelectorAll('input');
        if (inputs.length >= 5) {
          depreciationData.bulk_items.push({
            center_number: inputs[0].value,
            damaged_part: inputs[1].value,
            repair_type: inputs[2].value,
            // Clean percent value to remove % and handle decimals properly
            percent: inputs[3].value.replace('%', '').replace(/[^0-9.-]/g, ''),
            value: inputs[4].value
          });
        }
      });
      
      // Collect adjustment data and save to helper.final_report.adjustments
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Initialize final_report.adjustments if not exists
      if (!helper.final_report) helper.final_report = {};
      if (!helper.final_report.adjustments) {
        helper.final_report.adjustments = {
          features: [],
          registration: [],
          mileage: [],
          ownership_type: [],
          ownership_history: [],
          usage: [],
          additional: []
        };
      }

      // Define adjustment mapping for all categories
      const adjustmentMappings = [
        { category: 'features', containerId: 'featuresAdjustmentsList' },
        { category: 'registration', containerId: 'registrationAdjustmentsList' },
        { category: 'features', containerId: 'fullFeaturesAdjustmentsList' }, // Full market features
        { category: 'registration', containerId: 'fullRegistrationAdjustmentsList' }, // Full market registration
        { category: 'mileage', containerId: 'mileageAdjustmentsList' },
        { category: 'ownership_type', containerId: 'ownershipAdjustmentsList' },
        { category: 'ownership_history', containerId: 'ownersAdjustmentsList' },
        { category: 'usage', containerId: 'usageAdjustmentsList' },
        { category: 'additional', containerId: 'allAdjustmentsList' }
      ];

      // Clear all categories in final_report.adjustments
      Object.keys(helper.final_report.adjustments).forEach(key => {
        helper.final_report.adjustments[key] = [];
      });

      // Collect adjustments from all containers
      adjustmentMappings.forEach(({ category, containerId }) => {
        const container = document.getElementById(containerId);
        if (container) {
          // Try different row selectors based on container structure
          let rows = container.querySelectorAll('div.adjustment-row');
          if (rows.length === 0) {
            // Fallback for containers that use direct child divs
            rows = container.children;
          }
          
          Array.from(rows).forEach(row => {
            const inputs = row.querySelectorAll('input, select');
            
            if (inputs.length >= 4) {
              const adjustmentItem = {
                value: inputs[0].value || '', // Field mapping: תיאור → value
                type: inputs[1].value || 'plus', // Field mapping: סוג → type
                percent: parseFloat(inputs[2].value) || 0, // Field mapping: אחוז → percent
                percentage: parseFloat(inputs[2].value) || 0, // Backward compatibility
                amount: safeParseAmount(inputs[3].value),
                amount_display: inputs[3].value || '',
                source: 'final_report',
                timestamp: new Date().toISOString()
              };

              // Apply proper sign based on type
              if (adjustmentItem.type === 'minus') {
                adjustmentItem.percent = -Math.abs(adjustmentItem.percent);
                adjustmentItem.percentage = -Math.abs(adjustmentItem.percentage);
                adjustmentItem.amount = -Math.abs(adjustmentItem.amount);
              }

              helper.final_report.adjustments[category].push(adjustmentItem);
            }
          });
        }
      });

      // Update valuation.adjustments with original items only (first item of each category)
      if (!helper.valuation) helper.valuation = {};
      if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
      
      Object.keys(helper.final_report.adjustments).forEach(category => {
        const items = helper.final_report.adjustments[category];
        if (items.length > 0 && items[0].source !== 'final_report') {
          // Only update valuation if the first item is from original estimate data
          helper.valuation.adjustments[category] = items[0];
        }
      });

      // Legacy format for compatibility
      const adjustmentsData = {
        features: helper.final_report.adjustments.features,
        registration: helper.final_report.adjustments.registration,
        full_market: helper.final_report.adjustments.additional
      };
      
      // Collect legal text
      const legalText = document.getElementById('legal-text-content')?.value || '';
      
      // Save to helper using proper function
      const finalReportData = {
        type: selectedType,
        notes: additionalNotes,
        work_days: garageDays,
        summary: summaryData,
        depreciation: depreciationData,
        adjustments: adjustmentsData,
        legal_text: legalText
      };
      
      // Save the helper object with updated adjustments
      sessionStorage.setItem('helper', JSON.stringify(helper));
      if (window.helper) {
        window.helper = helper;
      }

      if (typeof updateHelper === 'function') {
        updateHelper('final_report', finalReportData, 'final_report_builder_save');
      } else {
        // Fallback for compatibility - already updated helper above
        Object.assign(helper.final_report, finalReportData);
        sessionStorage.setItem('helper', JSON.stringify(helper));
      }
      
      // ✅ BIDIRECTIONAL INTEGRATION: Update builder current state with all final report data
      updateBuilderCurrentState('final_report.type', selectedType);
      updateBuilderCurrentState('final_report.notes', additionalNotes);
      updateBuilderCurrentState('final_report.work_days', garageDays);
      updateBuilderCurrentState('final_report.summary', summaryData);
      updateBuilderCurrentState('final_report.depreciation', depreciationData);
      // Removed: updateBuilderCurrentState('final_report.adjustments', adjustmentsData); - using valuation.adjustments instead
      updateBuilderCurrentState('final_report.legal_text', legalText);
      
      alert('חוות דעת סופית נשמרה בהצלחה');
    };

    window.previewFinalReport = function() {
      // First save all data
      window.saveFinalReport();
      
      // Set report type and navigate
      sessionStorage.setItem('selectedReportType', 'final-report');
      window.location.href = 'final-report-validation.html';
    };

    window.generateFinalReport = function() {
      // First save all data
      window.saveFinalReport();
      
      // Set report type and navigate to fee module
      sessionStorage.setItem('selectedReportType', 'final-report');
      window.location.href = 'fee-module.html';
    };

    // Convert various date formats to YYYY-MM-DD for date input
    function convertToDateInputFormat(dateString) {
      if (!dateString) return '';
      
      try {
        // Handle various date formats
        let date;
        
        // If already in YYYY-MM-DD format, return as is
        if (/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
          return dateString;
        }
        
        // Handle DD/MM/YYYY format
        if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateString)) {
          const parts = dateString.split('/');
          const day = parts[0].padStart(2, '0');
          const month = parts[1].padStart(2, '0');
          const year = parts[2];
          return `${year}-${month}-${day}`;
        }
        
        // Handle DD-MM-YYYY format
        if (/^\d{1,2}-\d{1,2}-\d{4}$/.test(dateString)) {
          const parts = dateString.split('-');
          const day = parts[0].padStart(2, '0');
          const month = parts[1].padStart(2, '0');
          const year = parts[2];
          return `${year}-${month}-${day}`;
        }
        
        // Handle DD.MM.YYYY format
        if (/^\d{1,2}\.\d{1,2}\.\d{4}$/.test(dateString)) {
          const parts = dateString.split('.');
          const day = parts[0].padStart(2, '0');
          const month = parts[1].padStart(2, '0');
          const year = parts[2];
          return `${year}-${month}-${day}`;
        }
        
        // Try to parse as a general date
        date = new Date(dateString);
        if (!isNaN(date.getTime())) {
          return date.toISOString().split('T')[0];
        }
        
        return '';
      } catch (error) {
        return '';
      }
    }

    // LOAD DATA FROM HELPER
    function loadDataFromHelper() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Clean up redundant duplicate damage_assessment.centers section on page load
        if (helper.damage_assessment?.centers) {
          delete helper.damage_assessment.centers;
          if (Object.keys(helper.damage_assessment).length === 0) {
            delete helper.damage_assessment;
          }
          // Save cleaned helper
          sessionStorage.setItem('helper', JSON.stringify(helper));
          window.helper = helper;
        }
        
        // Helper function to get nested values
        const getNestedValue = (obj, path, defaultValue = '') => {
          const keys = path.split('.');
          let current = obj;
          for (const key of keys) {
            if (current && typeof current === 'object' && key in current) {
              current = current[key];
            } else {
              return defaultValue;
            }
          }
          return current || defaultValue;
        };
        
        // Load car details (now editable) and sync vehicle structure
        if (helper.car_details || helper.meta) {
          document.getElementById('carPlate').value = helper.meta?.plate || helper.car_details?.plate || '';
          document.getElementById('carManufacturer').value = helper.car_details?.manufacturer || '';
          document.getElementById('carModel').value = helper.car_details?.model || '';
          document.getElementById('carYear').value = helper.car_details?.year || '';
          document.getElementById('carModelCode').value = helper.car_details?.model_code || helper.vehicle?.model_code || '';
          // Base price from standardized valuation structure (with legacy fallback)
          const rawBasePrice = helper.valuation?.base_price || helper.car_details?.base_price || helper.levi_report?.base_price;
          // Clean any existing currency symbols and parse as number
          const basePrice = rawBasePrice ? parseFloat(String(rawBasePrice).replace(/[₪,]/g, '')) : null;
          document.getElementById('carBasePrice').value = basePrice ? `₪${basePrice.toLocaleString()}` : '';
          
          // Also populate the basicPrice field (marked price field) with levi base price
          const basicPriceField = document.getElementById('basicPrice');
          if (basicPriceField && basePrice) {
            basicPriceField.value = `₪${basePrice.toLocaleString()}`;
          }
          // Market value from standardized vehicle structure (with legacy fallback) 
          const rawMarketValue = helper.calculations?.full_market_value || helper.vehicle?.market_value || helper.valuation?.market_value;
          
          // DEBUG: Track where 80487 comes from
          if (helper.vehicle?.market_value) {
          }
          if (helper.calculations?.full_market_value) {
          }
          if (helper.valuation?.market_value) {
          }
          
          // Clean any existing currency symbols and parse as number
          const marketValue = rawMarketValue ? parseFloat(String(rawMarketValue).replace(/[₪,]/g, '')) : null;
          
          // Debug market value loading
          if (marketValue && marketValue > 0) {
          } else {
          }
          
          document.getElementById('carMarketValue').value = marketValue ? `₪${marketValue.toLocaleString()}` : '';
          // Load finalReportDate from car_details like other fields
          const finalReportDateValue = helper.car_details?.final_report_date || new Date().toISOString().split('T')[0];
          const topDateField = document.getElementById('finalReportDate');
          const summaryDateField = document.getElementById('finalReportDateSummary');
          
          if (topDateField) topDateField.value = convertToDateInputFormat(finalReportDateValue);
          if (summaryDateField) summaryDateField.value = convertToDateInputFormat(finalReportDateValue);
          
          // Load saved full market value from helper if it exists
          const savedFullMarketValue = helper.calculations?.full_market_value;
          if (savedFullMarketValue) {
            const fullMarketValueField = document.getElementById('fullMarketValueResult');
            if (fullMarketValueField) {
              fullMarketValueField.value = `₪${savedFullMarketValue.toLocaleString()}`;
            }
          }
          
          // Ensure vehicle structure is populated on load
          helper.vehicle = helper.vehicle || {};
          helper.vehicle.manufacturer = helper.car_details?.manufacturer || helper.vehicle.manufacturer || '';
          helper.vehicle.model = helper.car_details?.model || helper.vehicle.model || '';
          helper.vehicle.year = helper.car_details?.year || helper.vehicle.year || '';
          helper.vehicle.model_code = helper.car_details?.model_code || helper.vehicle.model_code || '';
          helper.vehicle.plate_number = helper.meta?.plate || helper.car_details?.plate || helper.vehicle.plate_number || '';
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        
        // Load claims data section fields - מיפוי נתוני תביעה
        const calc = helper.expertise?.calculations || {};
        const claimsData = helper.claims_data || {};
        const leviData = helper.levi_report || helper.levisummary || {};
        
        // 1. סה״כ תביעה (סכום מוקדי נזק) - Total Claim from damage centers
        const totalClaimDiv = document.getElementById('totalClaim');
        const formattedClaim = claimsData.total_claim || 
          (calc.total_damage ? `₪${calc.total_damage.toLocaleString()}` : '') ||
          (helper.damage_centers_summary?.total_cost ? `₪${helper.damage_centers_summary.total_cost.toLocaleString()}` : '');
        if (totalClaimDiv) {
          totalClaimDiv.innerText = formattedClaim;
        }
        
        // Load totalClaimGross field from damage_assessment.totals["Total with VAT"] 
        const totalClaimGrossField = document.getElementById('totalClaimGross');
        let totalClaimGrossValue = helper.damage_assessment?.totals?.["Total with VAT"] || 0;
        
        if (totalClaimGrossField) {
          totalClaimGrossField.value = totalClaimGrossValue ? `₪${totalClaimGrossValue.toLocaleString()}` : '';
        }
        
        // Load authorizedClaim field - SAME source as totalClaimGross (NO fallback)
        const authorizedClaimField = document.getElementById('authorizedClaim');
        if (authorizedClaimField) {
          const useValue = totalClaimGrossValue ? `₪${totalClaimGrossValue.toLocaleString()}` : '';
          const numericValue = totalClaimGrossValue;
          
          authorizedClaimField.value = useValue;
          
          // Ensure both storage locations are updated
          if (!helper.claims_data) helper.claims_data = {};
          if (!helper.calculations) helper.calculations = {};
          helper.claims_data.total_claim = useValue;
          helper.calculations.total_damage = numericValue;
        }
        
        
        // 2. חישוב הערך לנזק גולמי - Gross damage value (from Levi adjustments)
        const grossDamageValueDiv = document.getElementById('grossDamageValue');
        const grossValue = helper.calculations?.vehicle_value_gross || 
          leviData.final_price || 
          (helper.valuation?.calculations?.gross_price?.total) || 0;
        if (grossDamageValueDiv && grossValue > 0) {
          grossDamageValueDiv.innerText = `₪${grossValue.toLocaleString()}`;
        }
        
        // 3. חישוב האחוז הגולמי - Gross percentage calculation
        const grossPercentageDiv = document.getElementById('grossPercentage');
        const grossPercent = claimsData.gross_percent || 
          (helper.calculations?.damage_percent ? `${helper.calculations.damage_percent}%` : '') ||
          (calc.damage_percent ? `${calc.damage_percent}%` : '');
        if (grossPercentageDiv) {
          grossPercentageDiv.innerText = grossPercent;
        }
        
        // 4. מחיר שוק (בסיס + התאמות) - Market price CORRECTED MAPPING
        const marketPriceDiv = document.getElementById('marketPriceCalculated');
        let marketPrice = helper.calculations?.full_market_value || 
                         helper.expertise?.calculations?.market_value || 
                         helper.vehicle?.market_value || 
                         helper.valuation?.market_value || 0;
        
        // DEBUG: Check what's in helper for market value
        console.log('🔍 Market value debug:', {
          'helper.calculations': helper.calculations,
          'helper.calculations.full_market_value': helper.calculations?.full_market_value,
          'helper.expertise?.calculations?.market_value': helper.expertise?.calculations?.market_value,
          'helper.vehicle?.market_value': helper.vehicle?.market_value,
          'marketPrice': marketPrice
        });
        
        // Handle string values that need parsing
        if (typeof marketPrice === 'string') {
          marketPrice = parseFloat(marketPrice.replace(/[₪,]/g, '')) || 0;
        }
        
        if (marketPriceDiv && marketPrice > 0) {
          marketPriceDiv.innerText = `₪${marketPrice.toLocaleString()}`;
        } else if (marketPriceDiv) {
          marketPriceDiv.innerText = 'לא זמין';
        }
        
        // 5. ערך השוק של הרכב (לפי דו״ח לוי יצחק) - Final market value from Levi report
        const finalMarketValueDiv = document.getElementById('finalMarketValue');
        let finalMarketVal = helper.levisummary?.final_price || 
                            helper.levi_report?.final_price || 
                            helper.expertise?.levi_report?.final_price || 0;
        
        // DEBUG: Check what's in helper for Levi data
        
        // Handle string values that need parsing
        if (typeof finalMarketVal === 'string') {
          finalMarketVal = parseFloat(finalMarketVal.replace(/[₪,]/g, '')) || 0;
        }
        
        if (finalMarketValueDiv && finalMarketVal > 0) {
          finalMarketValueDiv.innerText = `₪${finalMarketVal.toLocaleString()}`;
        } else if (finalMarketValueDiv) {
          finalMarketValueDiv.innerText = 'לא זמין';
        }
        
        // Legacy field mappings for backward compatibility
        const leviPriceListField = document.getElementById('leviPriceList');
        if (leviPriceListField) {
          leviPriceListField.value = grossValue > 0 ? `₪${grossValue.toLocaleString()}` : '';
        }
        
        const grossPercentField = document.getElementById('grossPercent');
        if (grossPercentField) {
          grossPercentField.value = grossPercent;
        }
        
          
        console.log('💰 נתוני תביעה mapped successfully:', { 
          totalClaim: formattedClaim,
          grossDamageValue: grossValue,
          grossPercentage: grossPercent,
          marketPrice: marketPrice,
          finalMarketValue: finalMarketVal
        });
        
        // Update gross market value field with calculated value
        updateGrossMarketValueField();
        
        // Force refresh of all cost displays and calculations
        setTimeout(() => {
          updateAllCostDisplays();
          updateSummaryTotalsFromDamageCenters();
          // loadGrossCalculationData(); // DISABLED - causes duplicate Levi data, loadGrossAdjustments() already handles this
        }, 200);
        
        // Load contact data using standardized helper structure - Populate ALL fields from standardized helper structure paths (with legacy fallback)
        document.getElementById('ownerName').value = getNestedValue(helper, 'stakeholders.owner.name') || helper.client?.name || '';
        document.getElementById('ownerAddress').value = getNestedValue(helper, 'stakeholders.owner.address') || helper.client?.address || '';  
        document.getElementById('ownerPhone').value = getNestedValue(helper, 'stakeholders.owner.phone') || helper.client?.phone || '';
        document.getElementById('insuranceCompany').value = getNestedValue(helper, 'stakeholders.insurance.company') || helper.client?.insurance_company || '';
        document.getElementById('insuranceEmail').value = getNestedValue(helper, 'stakeholders.insurance.email') || helper.client?.insurance_email || '';
        document.getElementById('insuranceAgent').value = getNestedValue(helper, 'stakeholders.insurance.agent.name') || helper.client?.insurance_agent || '';
        document.getElementById('agentPhone').value = getNestedValue(helper, 'stakeholders.insurance.agent.phone') || helper.client?.insurance_agent_phone || '';
        document.getElementById('agentEmail').value = getNestedValue(helper, 'stakeholders.insurance.agent.email') || helper.client?.insurance_agent_email || '';
        
        // Load garage data from stakeholders helper
        document.getElementById('garageName').value = getNestedValue(helper, 'stakeholders.garage.name') || helper.garage?.name || '';
        document.getElementById('garagePhone').value = getNestedValue(helper, 'stakeholders.garage.phone') || helper.garage?.phone || '';
        document.getElementById('garageEmail').value = getNestedValue(helper, 'stakeholders.garage.email') || helper.garage?.email || '';
        
          
        // Sync data to both standardized and legacy structures for compatibility
        helper.car_details = helper.car_details || {};
        helper.car_details.owner = getNestedValue(helper, 'stakeholders.owner.name') || helper.client?.name || '';
        helper.car_details.ownerAddress = getNestedValue(helper, 'stakeholders.owner.address') || helper.client?.address || '';
        helper.car_details.ownerPhone = getNestedValue(helper, 'stakeholders.owner.phone') || helper.client?.phone || '';
        helper.car_details.insuranceCompany = getNestedValue(helper, 'stakeholders.insurance.company') || helper.client?.insurance_company || '';
        helper.car_details.agentName = getNestedValue(helper, 'stakeholders.insurance.agent.name') || helper.client?.insurance_agent || '';
        helper.car_details.insurance_agent_phone = getNestedValue(helper, 'stakeholders.insurance.agent.phone') || helper.client?.insurance_agent_phone || '';
        helper.car_details.insurance_agent_email = getNestedValue(helper, 'stakeholders.insurance.agent.email') || helper.client?.insurance_agent_email || '';
          
          // Note: garageName and garagePhone are not in the builder, so they'll remain empty
          helper.car_details.garageName = helper.car_details.garageName || '';
          helper.car_details.garagePhone = helper.car_details.garagePhone || '';
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Update page title with plate
        // Standardize plate format
        const rawPlate = helper.meta?.plate || helper.car_details?.plate || '...';
        const standardizedPlate = rawPlate !== '...' ? String(rawPlate).replace(/[-\s]/g, '') : rawPlate;
        document.getElementById('pageTitle').textContent = `רכב מס. ${standardizedPlate}`;
        
        // Load summary data
        loadSummaryData(helper);
        
        // Load depreciation data
        loadDepreciationData(helper);
        
        // Load garage days data
        if (helper.final_report?.work_days || helper.expertise?.depreciation?.work_days) {
          document.getElementById('garageDays').value = helper.final_report?.work_days || helper.expertise?.depreciation?.work_days || '';
        }
        
        // Load damage centers summary
        loadDamageCentersSummary(helper);
        
        // Load features and registration adjustments for gross calculation
        loadGrossAdjustments(helper);
        
        // DISABLED: loadAllAdjustments - causes override of final_report data
        // loadAllAdjustments(helper);
        
        // Load Total Value Section adjustments from final_report.adjustments
        loadTotalValueSectionAdjustments(helper);
        
        // Set flag to prevent sync during page load before calculations
        window.pageLoadInProgress = true;
        
        // Trigger calculations after data is loaded
        setTimeout(() => {
          updateGrossMarketValueCalculation();
          
          // CRITICAL FIX: Allow more time for DOM updates before reading dropdown states
          setTimeout(() => {
            updateFullMarketValueCalculation();
            
            // CRITICAL: Save all adjustment data including added rows after calculations
            updateFullMarketValueToFinalReportAndValuation(helper);
            
            // CRITICAL: Trigger all change events to ensure formatAdjustmentDisplay runs
            triggerAllAdjustmentChangeEvents();
          }, 50);  // Additional delay to ensure dropdown states are ready
          
          // Save formatted state back to sessionStorage so refresh loads correct data  
          setTimeout(() => {
            // REMOVED: updateHelperFromAdjustments() to prevent overwriting calculated amounts on page load
            const updatedHelper = window.helper || {};
            sessionStorage.setItem('helper', JSON.stringify(updatedHelper));
            console.log('💾 Saved formatted helper state to sessionStorage after load with change events');
          }, 100);
        }, 150);
        
        
        // Note: addFieldChangeListeners() is called in DOMContentLoaded event
        
      } catch (error) {
        console.error('Error loading data from helper:', error);
      }
    }

    // POPULATE MARKET VALUE FOR CURRENT VARIANT - TARGETED APPROACH
    function populateMarketValueForCurrentVariant(helper, reportType) {
      try {
        // Handle different value formats (string, number, formatted)
        let marketValue = helper.calculations?.full_market_value || 0;
        
        if (typeof marketValue === 'string') {
          marketValue = parseFloat(marketValue.replace(/[₪,\s]/g, '')) || 0;
        } else if (typeof marketValue === 'number') {
          marketValue = marketValue || 0;
        }
        
        console.log('🔍 Market value population - Type:', reportType, 'Value:', marketValue);
        
        if (marketValue <= 0) {
          console.log('❌ No valid market value found');
          return;
        }
        
        // Target the correct field ID based on report type
        let targetFieldId = '';
        switch(reportType) {
          case 'חוות דעת פרטית':
            targetFieldId = 'sumMarketValuePrivate';
            break;
          case 'חוות דעת גלובלית':
            targetFieldId = 'sumMarketValueGlobal';
            break;
          case 'חוות דעת טוטלוסט':
            targetFieldId = 'sumMarketValueTotal';
            break;
          case 'חוות דעת מכירה מצבו הניזוק':
            targetFieldId = 'sumMarketValueDamage';
            break;
          case 'חוות דעת אובדן להלכה':
            targetFieldId = 'sumMarketValueLegal';
            break;
          default:
            targetFieldId = 'sumMarketValueDefault';
        }
        
        // Populate the target field
        const targetField = document.getElementById(targetFieldId);
        if (targetField) {
          const formattedValue = `₪${marketValue.toLocaleString()}`;
          targetField.value = formattedValue;
          console.log(`✅ Set ${targetFieldId} = ${formattedValue}`);
        } else {
          console.log(`❌ Field ${targetFieldId} not found`);
        }
        
      } catch (error) {
        console.error('Error populating market value:', error);
      }
    }

    // LOAD SUMMARY FIELDS FROM HELPER - ENHANCED FOR ALL 5 REPORT VARIANTS
    function loadSummaryFieldsFromHelper(helper) {
      try {
        
        // ENSURE HELPER STRUCTURE EXISTS FOR ALL VARIANTS
        helper.final_report = helper.final_report || {};
        helper.final_report.summary = helper.final_report.summary || {};
        
        // AUTO-POPULATED FIELDS (COMMON ACROSS VARIANTS)
        
        // SIMPLE DIRECT MAPPING - NO COMPLICATIONS
        
        // 1. Market Value - ONLY from calculations.full_market_value
        const marketValue = helper.calculations?.full_market_value || 0;
        
        // Set market value for ALL variant fields immediately
        ['sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 'sumMarketValueTotal', 'sumMarketValueLegal', 'sumMarketValuePrivate'].forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.value = marketValue > 0 ? `₪${marketValue.toLocaleString()}` : '';
          }
        });
        
        // 2. Total Claim - from helper.claims_data.total_claim
        let totalClaim = 0;
        
        // Parse from claims_data.total_claim (may be formatted string)
        if (helper.claims_data?.total_claim) {
          const claimValue = helper.claims_data.total_claim;
          if (typeof claimValue === 'string') {
            totalClaim = parseFloat(claimValue.replace(/[₪,]/g, '')) || 0;
          } else {
            totalClaim = parseFloat(claimValue) || 0;
          }
        } 
        // Fallback to damage_centers_summary.total_cost
        else if (helper.damage_centers_summary?.total_cost) {
          totalClaim = parseFloat(helper.damage_centers_summary.total_cost) || 0;
        }
        
        // Populate all total claim fields across ALL variants
        const allClaimFields = ['sumClaim', 'sumClaimGlobal', 'sumClaimPrivate', 'sumClaimDefault'];
        allClaimFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            const formattedClaim = totalClaim > 0 ? `₪${totalClaim.toLocaleString()}` : '';
            field.value = formattedClaim;
            helper.final_report.summary.total_claim = formattedClaim;
          }
        });
        
        // 3. Depreciation Compensation - from helper.depreciation.globalDepValue
        let depCompensation = 0;
        
        // Parse from globalDepValue (preferred)
        if (helper.depreciation?.globalDepValue) {
          const depValue = helper.depreciation.globalDepValue;
          if (typeof depValue === 'string') {
            depCompensation = parseFloat(depValue.replace(/[₪,]/g, '')) || 0;
          } else {
            depCompensation = parseFloat(depValue) || 0;
          }
        }
        // Fallback to globalDep1 (may contain formatted string like "1,972₪")
        else if (helper.depreciation?.globalDep1) {
          const dep1Value = helper.depreciation.globalDep1;
          if (typeof dep1Value === 'string') {
            depCompensation = parseFloat(dep1Value.replace(/[₪,%]/g, '')) || 0;
          } else {
            depCompensation = parseFloat(dep1Value) || 0;
          }
        }
        // Final fallback to total_compensation
        else if (helper.depreciation?.total_compensation) {
          depCompensation = parseFloat(helper.depreciation.total_compensation) || 0;
        }
        
        // Populate all depreciation compensation fields across ALL variants
        const allDepFields = ['depCompensation', 'depCompensationGlobal', 'depCompensationPrivate', 'sumDepreciation', 'sumDepreciationDefault'];
        allDepFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            const formattedDepValue = depCompensation > 0 ? `₪${depCompensation.toLocaleString()}` : '';
            field.value = formattedDepValue;
            helper.final_report.summary.dep_compensation = formattedDepValue;
          }
        });
        
        // 4. Adjustments Info - informative field only (not for calculations)
        const adjustmentsValue = helper.calculations?.final_adjustments_value || 0;
        const adjustmentsInfoField = document.getElementById('adjustmentsInfo');
        const adjustmentsInfoPrivateField = document.getElementById('adjustmentsInfoPrivate');
        
        const formattedAdjValue = adjustmentsValue !== 0 ? `₪${adjustmentsValue.toLocaleString()}` : '₪0';
        
        // Populate both static and dynamic private fields
        if (adjustmentsInfoField) {
          adjustmentsInfoField.value = formattedAdjValue;
        }
        
        if (adjustmentsInfoPrivateField) {
          adjustmentsInfoPrivateField.value = formattedAdjValue;
        }
        
        if (!adjustmentsInfoField && !adjustmentsInfoPrivateField) {
        }
        helper.final_report.summary.adjustments_value = adjustmentsValue;
        
        // MANUAL INPUT FIELDS (VARIANT-SPECIFIC)
        
        // Load existing manual input values from helper structure
        const manualFields = [
          // Damaged Sale variant
          { fieldId: 'saleValueDamage', helperKey: 'sale_value_damaged' },
          { fieldId: 'paymentMethod', helperKey: 'paymentMethod' },
          { fieldId: 'afterSaleDamage', helperKey: 'total_after_sale_damage' },
          
          // Total Loss variant  
          { fieldId: 'salvageValueTotal', helperKey: 'salvage_value_total' },
          { fieldId: 'storageValueTotal', helperKey: 'storage_towing_value_total' },
          { fieldId: 'afterSaleTotal', helperKey: 'total_after_salvage_total' },
          
          // Legal Loss variant
          { fieldId: 'salvageValueLegal', helperKey: 'salvage_value_legal' },
          { fieldId: 'afterSaleLegal', helperKey: 'total_after_salvage_legal' },
          
          // Legacy fields
          { fieldId: 'salvageValue', helperKey: 'salvage_value' }
        ];
        
        // Load manual input fields and ensure they exist in helper structure
        manualFields.forEach(({ fieldId, helperKey }) => {
          const field = document.getElementById(fieldId);
          const savedValue = helper.final_report.summary[helperKey];
          
          if (field) {
            // ENHANCED PROTECTION: Don't overwrite calculated fields if they have calculated values
            const isCalculatedField = ['afterSaleDamage', 'afterSaleTotal', 'afterSaleLegal'].includes(fieldId);
            const hasValue = field.value && field.value.trim() !== '';
            const marketValue = helper.calculations?.full_market_value || 0;
            const isNotMarketValue = field.value !== `₪${marketValue.toLocaleString()}`;
            
            if (isCalculatedField && hasValue && isNotMarketValue) {
              console.log(`🔒 ENHANCED PROTECTION: Preserving calculated field ${fieldId} = ${field.value} (blocked override with ${savedValue})`);
              // Also ensure the helper has the correct calculated value
              if (savedValue !== field.value) {
                helper.final_report.summary[helperKey] = field.value;
                sessionStorage.setItem('helper', JSON.stringify(helper));
                console.log(`🔄 Updated helper with preserved calculation: ${helperKey} = ${field.value}`);
              }
              return; // Skip this field to preserve calculation
            }
            // Load saved value if exists
            field.value = savedValue || '';
          }
          
          // Ensure field exists in helper structure (initialize if missing)
          if (!helper.final_report.summary.hasOwnProperty(helperKey)) {
            helper.final_report.summary[helperKey] = '';
          }
        });
        
        // Save updated helper structure
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Calculate totals based on loaded fields
        setTimeout(() => {
          calculateSummaryTotals();
        }, 100);
        
        
      } catch (error) {
        console.error('❌ Error loading enhanced summary fields:', error);
      }
    }
    
    // CONSOLIDATED FIELD MAPPING - ELIMINATES DUPLICATES
    function getHelperMappingKey(fieldId) {
      const consolidatedMapping = {
        // UNIVERSAL FIELDS - ALL VARIANTS USE SAME KEY
        // Market Value - all variants write to same key
        'sumMarketValue': 'market_value',
        'sumMarketValueGlobal': 'market_value',
        'sumMarketValueDamage': 'market_value', 
        'sumMarketValueTotal': 'market_value',
        'sumMarketValueLegal': 'market_value',
        'sumMarketValuePrivate': 'market_value',
        
        // Total Claim - all variants write to same key
        'sumClaim': 'total_claim',
        'sumClaimPrivate': 'total_claim',
        'sumClaimGlobal': 'total_claim',
        
        // Depreciation Compensation - all variants write to same key
        'depCompensation': 'depreciation_compensation',
        'depCompensationPrivate': 'depreciation_compensation',
        'depCompensationGlobal': 'depreciation_compensation',
        'sumDepreciation': 'depreciation_compensation',
        
        // VARIANT-SPECIFIC FIELDS - UNIQUE VALUES
        // Private Report
        'sumTotalBeforeDifferentials': 'private_before_differentials',
        'sumTotalFinal': 'private_after_differentials',
        
        // Global Report  
        'sumTotalGlobal': 'global_before_differentials',
        // Damaged Sale Report
        'saleValueDamage': 'sale_value_damaged',
        'afterSaleDamage': 'damage_total_before_differentials',
        
        // Total Loss Report
        'salvageValueTotal': 'salvage_value_total_loss',
        'storageValueTotal': 'storage_towing_costs',
        'afterSaleTotal': 'total_loss_before_differentials',
        
        // Legal Loss Report
        'salvageValueLegal': 'salvage_value_legal_loss',
        'afterSaleLegal': 'legal_loss_before_differentials',
        
        // General fields
        'finalReportDateSummary': 'report_date'
      };
      return consolidatedMapping[fieldId] || null;
    }

    // LOAD ADDITIONAL NOTES FIELD
    function loadAdditionalNotesField() {
      try {
        const helper = window.helper || {};
        const additionalNotesField = document.getElementById('additional-notes');
        
        if (additionalNotesField) {
          // Check both 'notes' (from save) and 'comments' (from real-time save)
          const savedNotes = helper.final_report?.notes || helper.final_report?.comments || '';
          
          console.log('🔍 Loading additional notes field:', {
            fieldExists: true,
            notes: helper.final_report?.notes,
            comments: helper.final_report?.comments,
            savedNotes: savedNotes,
            currentValue: additionalNotesField.value
          });
          
          if (savedNotes) {
            additionalNotesField.value = savedNotes;
            console.log('✅ Additional notes loaded successfully:', savedNotes.substring(0, 50) + '...');
          } else {
            console.log('⚠️ No saved notes found in helper');
          }
        } else {
          console.log('❌ Additional notes field not found in DOM');
        }
      } catch (error) {
        console.error('❌ Error loading additional notes:', error);
      }
    }

    // LOAD SUMMARY DATA AND CALCULATIONS - ENHANCED FOR AUTO-POPULATION
    function loadSummaryData(helper) {
      try {
        console.log('📊 Loading summary data with enhanced auto-population');
        
        // DISABLED: Conflicting code that overrides saved dropdown selection
        // const selectedType = document.querySelector('input[name="final-report-type"]:checked')?.value || 'אובדן_להלכה';
        // const reportTypeText = selectedType === 'אובדן_להלכה' ? 'חוות דעת אובדן להלכה' : 'חוות דעת טוטלוסט';
        // document.getElementById('reportType').value = reportTypeText;
        console.log('📋 Skipping report type override - using saved dropdown selection');
        
        // ENHANCED AUTO-POPULATION SYSTEM
        
        // 1. Market Value Auto-Population (from mapping analysis)
        const marketValue = helper.calculations?.full_market_value || 0;
        if (marketValue > 0) {
          console.log(`💰 Auto-populating market value: ₪${marketValue.toLocaleString()}`);
          
          // Auto-populate all market value fields using comprehensive mapping
          const marketValueFields = ['sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 'sumMarketValueTotal', 'sumMarketValueLegal'];
          marketValueFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
              field.value = `₪${marketValue.toLocaleString()}`;
              // Update helper using comprehensive mapping
              const mappingKey = getHelperMappingKey(fieldId);
              if (mappingKey) {
                helper.final_report.summary[mappingKey] = field.value;
              }
            }
          });
        }
        
        // 2. Total Claim Auto-Population (from mapping analysis)  
        const totalClaim = helper.claims_data?.total_claim || 0;
        if (totalClaim > 0) {
          console.log(`💰 Auto-populating total claim: ₪${totalClaim.toLocaleString()}`);
          const sumClaimField = document.getElementById('sumClaim');
          if (sumClaimField) {
            sumClaimField.value = `₪${totalClaim.toLocaleString()}`;
            helper.final_report.summary.total_claim = sumClaimField.value;
          }
        }
        
        // 3. Depreciation Compensation Auto-Population (from mapping analysis)
        const depCompensation = helper.depreciation?.globalDepValue || 0;
        if (depCompensation > 0) {
          console.log(`💰 Auto-populating depreciation compensation: ₪${depCompensation.toLocaleString()}`);
          const depCompensationField = document.getElementById('depCompensation');
          if (depCompensationField) {
            depCompensationField.value = `₪${depCompensation.toLocaleString()}`;
            helper.final_report.summary.dep_compensation = depCompensationField.value;
          }
        }
        
        // 4. Adjustments Value Auto-Population (from mapping analysis)
        const adjustmentsValue = helper.calculations?.final_adjustments_value || 0;
        if (adjustmentsValue !== 0) {
          console.log(`💰 Auto-populating adjustments value: ₪${adjustmentsValue.toLocaleString()}`);
          helper.final_report.summary.adjustments_value = adjustmentsValue;
        }
        
        // Load all summary fields using enhanced loader IMMEDIATELY
        loadSummaryFieldsFromHelper(helper);
        
        // Calculate VAT and totals if we have claim data
        if (totalClaim > 0) {
          const vatRate = getVatRate();
          const vat = totalClaim * vatRate;
          
          const vatField = document.getElementById('sumVAT');
          if (vatField) {
            vatField.value = `₪${Math.round(vat).toLocaleString()}`;
          }
          
          const totalWithVAT = totalClaim + vat;
          const totalClaimField = document.getElementById('sumTotalClaim');
          if (totalClaimField) {
            totalClaimField.value = `₪${Math.round(totalWithVAT).toLocaleString()}`;
          }
        }
        
        // Load saved final report notes if available
        // Check both 'notes' (from save) and 'comments' (from real-time save)
        const additionalNotesField = document.getElementById('additional-notes');
        if (additionalNotesField) {
          const savedNotes = helper.final_report?.notes || helper.final_report?.comments || '';
          console.log('🔍 Checking for additional notes:', {
            notes: helper.final_report?.notes,
            comments: helper.final_report?.comments,
            savedNotes: savedNotes
          });
          
          if (savedNotes) {
            additionalNotesField.value = savedNotes;
            console.log('✅ Loaded additional notes from helper:', savedNotes.substring(0, 50) + '...');
          } else {
            console.log('⚠️ No saved notes found in helper');
          }
        } else {
          console.log('❌ Additional notes field not found in DOM');
        }
        
        // Add event listeners for real-time calculations
        addSummaryCalculationListeners();
        
        // TRIGGER INITIAL AUTO-FILL FOR SUMMARY FIELDS
        setTimeout(() => {
          if (window.addSummaryCalculationListeners) {
            const calculateEvent = new Event('input', { bubbles: true });
            
            // Trigger auto-fill from totalClaim to sumClaim
            const totalClaimField = document.getElementById('totalClaim');
            if (totalClaimField && totalClaimField.value) {
              totalClaimField.dispatchEvent(calculateEvent);
            }
            
            // Trigger auto-fill from globalDepValue to depCompensation
            const globalDepField = document.getElementById('globalDepValue');
            if (globalDepField && globalDepField.value) {
              globalDepField.dispatchEvent(calculateEvent);
            }
          }
        }, 200);
        
      } catch (error) {
        console.error('Error loading summary data:', error);
      }
    }

    // ADD CALCULATION LISTENERS FOR SUMMARY WITH MATH.JS - CORRECTED LOGIC
    function addSummaryCalculationListeners() {
      const sumMarketValueInput = document.getElementById('sumMarketValue');
      const sumClaimInput = document.getElementById('sumClaim');
      const depCompensationInput = document.getElementById('depCompensation');
      const sumVATInput = document.getElementById('sumVAT');
      const sumTotalInput = document.getElementById('sumTotalClaim');

      function calculateSummaryTotals() {
        try {
          // Skip auto-fill for private summary - handled by refreshSummary() 
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          const helperMarketValue = helper.calculations?.full_market_value || 0;
          // Don't auto-fill private summary field - let refreshSummary() handle it
          
          // Also auto-fill global variant market value field if it exists
          const sumMarketValueGlobal = document.getElementById('sumMarketValueGlobal');
          if (helperMarketValue && helperMarketValue > 0 && sumMarketValueGlobal) {
            sumMarketValueGlobal.value = `₪${helperMarketValue.toLocaleString()}`;
          }
          
          // AUTO-FILL SUMMARY CLAIM FROM CLAIMS SECTION
          const totalClaimValue = document.getElementById('totalClaim')?.value;
          if (totalClaimValue && sumClaimInput) {
            sumClaimInput.value = totalClaimValue;
          }
          
          // AUTO-FILL DEPRECIATION COMPENSATION FROM GLOBAL DEPRECIATION VALUE
          const globalDepValue = document.getElementById('globalDepValue')?.value;
          if (globalDepValue && depCompensationInput) {
            depCompensationInput.value = globalDepValue;
          }
          
          // Ensure all variant fields are populated
          const updatedHelper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
          loadSummaryFieldsFromHelper(updatedHelper);
          
          // Get values - market price + claim + compensation - salvage = total
          const marketValue = parseFloat(sumMarketValueInput?.value.replace(/[₪,]/g, '') || '0') || 0;
          const claimValue = parseFloat(sumClaimInput?.value.replace(/[₪,]/g, '') || '0') || 0;
          const depValue = parseFloat(depCompensationInput?.value.replace(/[₪,]/g, '') || '0') || 0;
          const salvageValue = parseFloat(document.getElementById('salvageValue')?.value.replace(/[₪,]/g, '') || '0') || 0;
          
          // Calculate subtotal: claim + compensation - salvage value = subtotal (market price is separate)
          const subtotal = claimValue + depValue - salvageValue;
          
          // Automatic calculation with math.js - Calculate VAT (admin rate on subtotal)
          const vatRate = (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100;
          const vat = Math.round(subtotal * vatRate);
          
          // Calculate final total (subtotal + VAT) - automatic calculation with math.js
          const total = subtotal + vat;
          
          // Update readonly fields with formatted values - auto-filled from relevant fields
          if (sumVATInput) {
            sumVATInput.value = vat ? `₪${vat.toLocaleString()}` : '';
            sumVATInput.readOnly = true;
            sumVATInput.style.background = '#f4f6fa';
          }
          
          if (sumTotalInput) {
            sumTotalInput.value = total ? `₪${total.toLocaleString()}` : '';
            sumTotalInput.readOnly = true;
            sumTotalInput.style.background = '#e8f5e8';
          }
          
        } catch (error) {
          console.error('Error in summary calculations:', error);
        }
      }

      // Add listeners to trigger calculations for all relevant fields
      // Disabled - private summary handled by refreshSummary()
      // if (sumMarketValueInput) {
      //   sumMarketValueInput.addEventListener('input', calculateSummaryTotals);
      // }
      if (sumClaimInput) {
        sumClaimInput.addEventListener('input', calculateSummaryTotals);
      }
      if (depCompensationInput) {
        depCompensationInput.addEventListener('input', calculateSummaryTotals);
      }
      
      // Auto-update when car market value changes
      const carMarketValueInput = document.getElementById('carMarketValue');
      if (carMarketValueInput) {
        carMarketValueInput.addEventListener('input', () => {
          calculateSummaryTotals();
          triggerGlobalDepreciationCalc(); // Recalculate global depreciation when market value changes
        });
      }
      
      // Disabled - private summary handled by refreshSummary()
      // Auto-update when summary market value changes
      // if (sumMarketValueInput) {
      //   sumMarketValueInput.addEventListener('input', () => {
      //     calculateSummaryTotals();
      //     triggerGlobalDepreciationCalc(); // Recalculate global depreciation when market value changes
      //   });
      // }
      
      // ADD EVENT LISTENERS FOR SOURCE FIELDS TO AUTO-UPDATE SUMMARY
      const totalClaimInput = document.getElementById('totalClaim');
      if (totalClaimInput) {
        totalClaimInput.addEventListener('input', calculateSummaryTotals);
      }
      
      const globalDepValueInput = document.getElementById('globalDepValue');
      if (globalDepValueInput) {
        globalDepValueInput.addEventListener('input', calculateSummaryTotals);
      }
      
      // ADD EVENT LISTENER FOR SALVAGE VALUE TO TRIGGER RECALCULATION
      const salvageValueInput = document.getElementById('salvageValue');
      if (salvageValueInput) {
        salvageValueInput.addEventListener('input', calculateSummaryTotals);
      }
      
      // ENHANCED MANUAL INPUT FIELD LISTENERS - For All 5 Report Variants
      addManualInputFieldListeners();
      
      // Add listeners for custom additions if they exist
      function addCustomFieldListeners() {
        const customFields = document.querySelectorAll('#sumAdditionsGridFinalReport input');
        customFields.forEach(field => {
          field.addEventListener('input', calculateSummaryTotals);
        });
      }
      
      // Initial calculation and setup
      calculateSummaryTotals();
      addCustomFieldListeners();
      
      // Re-add listeners when custom fields are added
      const originalAddField = window.addCustomSummaryField;
      window.addCustomSummaryField = function(summaryType) {
        originalAddField(summaryType);
        setTimeout(addCustomFieldListeners, 100);
      };
    }

    // LOAD DEPRECIATION DATA
    function loadDepreciationData(helper) {
      try {
        console.log('🔄 Loading depreciation data, helper:', helper);
        console.log('🔍 helper.centers:', helper.centers);
        console.log('🔍 helper.depreciation:', helper.depreciation);
        console.log('🔍 helper.final_report?.depreciation:', helper.final_report?.depreciation);
        
        // ✅ 2-WAY DATA FLOW: Check both locations for depreciation data
        // The save function writes to both helper.depreciation AND helper.final_report.depreciation
        const depreciationData = helper.final_report?.depreciation || helper.depreciation || null;
        
        console.log('📊 Depreciation data found:', depreciationData);
        console.log('📊 Bulk items:', depreciationData?.bulk_items);
        
        if (depreciationData) {
          
          // Load global depreciation fields from helper.depreciation (single source)
          // Format global depreciation with % symbol if numeric
          const globalPercent = depreciationData.globalDep1 || depreciationData.global_percent || '';
          // Keep the value as is - don't add % if it's already there
          document.getElementById('globalDep1').value = globalPercent;
          document.getElementById('globalDepValue').value = depreciationData.globalDepValue || 
                                                           depreciationData.global_value || '';
          document.getElementById('garageDays').value = depreciationData.garageDays || 
                                                       depreciationData.work_days_impact || '';
          
          // Load bulk depreciation table
          if (depreciationData.bulk_items && Array.isArray(depreciationData.bulk_items)) {
            // Check if we need to update the mapping
            let needsUpdate = false;
            
            // If we have damage centers, check if the saved data needs updating
            if (helper.centers && helper.centers.length > 0) {
              // Check if any saved item has old format (center_number is not just a number)
              needsUpdate = depreciationData.bulk_items.some(item => 
                item.center_number && (item.center_number.includes('מוקד') || isNaN(item.center_number))
              );
            }
            
            if (needsUpdate) {
              // Don't regenerate - just load the existing data even if format is old
              console.log('⚠️ Old format detected but preserving existing manual data');
            }
            
            // Always load existing saved data
            if (depreciationData.bulk_items.length > 0) {
              // Load existing data
              const depreciationContainer = document.getElementById('depreciationBulkTable');
              if (depreciationContainer) {
                depreciationContainer.innerHTML = '';
              }
              
              console.log('📋 Loading bulk items:', depreciationData.bulk_items);
              depreciationData.bulk_items.forEach((item, index) => {
                console.log(`  Item ${index + 1}:`, item);
                addDepField(item);
              });
              
              // Add auto-calculation to all existing rows after loading
              setTimeout(() => {
                addAutoCalculationToExistingRows();
              }, 100);
            }
          }
          
        }
        
        // ALWAYS check and auto-populate from damage centers if table is empty
        // BUT ONLY if there's no saved depreciation data
        if (helper.centers && helper.centers.length > 0) {
          const existingRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
          const hasDepreciationData = depreciationData && depreciationData.bulk_items && depreciationData.bulk_items.length > 0;
          
          if (existingRows.length === 0 && !hasDepreciationData) {
            console.log('🔄 Auto-populating depreciation from damage centers (no saved data found)...');
            updateDepreciationFromDamageCenters([]);
          }
        }
      } catch (error) {
        console.error('Error loading depreciation data:', error);
      }
    }

    // LOAD DAMAGE CENTERS SUMMARY - EDITABLE CARDS
    function loadDamageCentersSummary(helper) {
      try {
        const damageCentersContent = document.getElementById('damageCentersContent');
        
        // Load from damage centers helper (primary source) with fallbacks
        // NOTE: Removed damage_assessment.centers - using only helper.centers as source of truth
        const damageCenters = helper.centers || 
                             helper.damage_centers || 
                             helper.expertise?.damage_blocks || [];
        
        if (damageCenters && damageCenters.length > 0) {
          let summaryHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters">';
          
          damageCenters.forEach((center, index) => {
            // Adapt centers data structure to damage block structure for compatibility
            const adaptedCenter = adaptCenterToBlock(center, index);
            summaryHTML += createEditableDamageCenterCard(adaptedCenter, index);
          });
          
          summaryHTML += '</div>';
          damageCentersContent.innerHTML = summaryHTML;
          
          // Add event listeners after HTML is created
          setTimeout(addDamageCenterEventListeners, 100);
          
          // Reposition save button if subtotal exists
          setTimeout(repositionDamageCentersSaveButton, 150);
          
        } else {
          damageCentersContent.innerHTML = '<div style="color: #666; text-align: center;">לא נמצאו נתוני מוקדי נזק - לחץ "הוסף מוקד נזק חדש" כדי להתחיל</div>';
        }
      } catch (error) {
        console.error('Error loading damage centers summary:', error);
        document.getElementById('damageCentersContent').innerHTML = '<div style="color: #dc3545; text-align: center;">שגיאה בטעינת נתוני מוקדי נזק</div>';
      }
    }

    // Adapt centers data structure to damage block structure for compatibility
    function adaptCenterToBlock(center, index) {
      
      // Centers structure (from wizard) vs damage_blocks structure (from expertise)
      const adaptedBlock = {
        Id: center.Id || center.id || center.code || center.damage_center_code || '',
        damage_center_name: center.Location || center.damage_center_name || `מוקד נזק ${index + 1}`,
        // Extract just the number if it contains the full text
        damage_center_number: (() => {
          const num = center["Damage center Number"] || center.damage_center_number || (index + 1);
          // If it's a string that contains "מוקד נזק מס'", extract just the number
          if (typeof num === 'string' && num.includes('מוקד')) {
            const match = num.match(/\d+$/);
            return match ? match[0] : String(index + 1);
          }
          return num;
        })(),
        description: center.Description || center.description || '',
        // CORRECT MAPPING: RepairNature data from helper.centers
        RepairNature: center.RepairNature || center.repair_nature || '',
        // CORRECT MAPPING: Works data structure from helper.centers
        works: center.Works?.works || center.works || [],
        // CORRECT MAPPING: Parts data is in center.Parts.parts_required for helper.centers
        parts: center.Parts?.parts_required || center.Parts?.parts || center.parts_required || center.parts || center.Parts || [],
        // CORRECT MAPPING: Repairs data structure from helper.centers
        repairs: center.Repairs?.repairs || center.repairs || [],
        works_meta: center.Works?.works_meta || center.works_meta || { total_cost: 0 },
        parts_meta: center.Parts?.parts_meta || center.parts_meta || { total_cost: 0 },
        repairs_meta: center.Repairs?.repairs_meta || center.repairs_meta || { total_cost: 0 },
        total_cost: center.Summary?.["Total with VAT"] || center.total_cost || 0
      };
      
      // Additional normalization for different data structures
      if (Array.isArray(center.Works) && adaptedBlock.works.length === 0) {
        adaptedBlock.works = center.Works;
      }
      if (Array.isArray(center.Parts) && adaptedBlock.parts.length === 0) {
        adaptedBlock.parts = center.Parts;
      }
      if (Array.isArray(center.Repairs) && adaptedBlock.repairs.length === 0) {
        adaptedBlock.repairs = center.Repairs;
      }
      
      console.log(`✅ SESSION 56: Adapted block ${index}:`, adaptedBlock);
      console.log(`  📋 Parts found: ${adaptedBlock.parts.length}, Works found: ${adaptedBlock.works.length}`);
      console.log(`  🆔 ID preserved: ${adaptedBlock.Id || 'MISSING!'}`);
      
      if (!adaptedBlock.Id) {
        console.warn(`⚠️ SESSION 56: Center ${index} has NO ID after adaptation!`);
        console.warn('  Original center object:', center);
      }
      
      return adaptedBlock;
    }

    // CREATE EDITABLE DAMAGE CENTER CARD
    function createEditableDamageCenterCard(block, index) {
      
      const centerNum = block.damage_center_number || (index + 1);
      const centerLocation = block.damage_center_name || block.Location || `מוקד נזק ${centerNum}`;
      const workCosts = block.work_cost || 0;
      const partsCosts = block.parts_cost || 0;
      const repairsCosts = workCosts + partsCosts;
      const totalWithVAT = repairsCosts * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100);
      
      const centerId = block.Id || block.id || block.code || block.damage_center_code || '';
      console.log(`🆔 SESSION 56: Creating card ${index} with ID: ${centerId}`);
      
      // Get existing parts, works, repairs from block
      const parts = block.parts || [];
      const works = block.works || [];
      const repairs = block.repairs || [];
      
      console.log(`🔧 Card ${index} data - Parts: ${parts.length}, Works: ${works.length}, Repairs: ${repairs.length}`);
      console.log(`📋 Parts content:`, parts);
      console.log(`🔨 Works content:`, works);
      
      return `
        <div class="editable-damage-card" data-center-index="${index}" data-center-id="${centerId}" style="background: white; border-radius: 8px; padding: 15px; border: 1px solid #e2e8f0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <!-- Card Header -->
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="font-weight: bold; color: #1e3a8a; font-size: 16px;">מוקד נזק מס'</span>
              <input type="text" value="${centerNum}" class="damage-center-number" style="font-weight: bold; color: #1e3a8a; font-size: 16px; border: 1px solid #ddd; padding: 8px; border-radius: 4px; width: 50px; text-align: center;" />
            </div>
            <button onclick="removeDamageCenter(${index})" style="background: #dc3545; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">מחק</button>
          </div>
          
          <!-- Damage Center Location Field -->
          <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #1e3a8a;">שם מוקד הנזק:</label>
            <input type="text" class="damage-center-location" style="width: 100%; border: 1px solid #ddd; padding: 8px; border-radius: 4px; font-size: 14px;" placeholder="הזן שם/איזור מוקד הנזק (לדוגמה: פגוש קדמי, דלת נהג, וכו')" value="${centerLocation}" />
          </div>
          
          <!-- Damage Description Field -->
          <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #1e3a8a;">תיאור הנזק:</label>
            <textarea class="damage-center-description" style="width: 100%; min-height: 60px; border: 1px solid #ddd; padding: 8px; border-radius: 4px; font-size: 14px; font-family: inherit; resize: vertical;" placeholder="הזן תיאור מפורט של הנזק במוקד זה...">${block.description || ''}</textarea>
          </div>

          <!-- RepairNature Field -->
          <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #1e3a8a;">מהות התיקון:</label>
            <input class="damage-center-repair-nature" style="width: 100%; border: 1px solid #ddd; padding: 8px; border-radius: 4px; font-size: 14px;" placeholder="הזן את מהות התיקון..." value="${block.RepairNature || block.repair_nature || ''}" />
          </div>

          <!-- Parts Section (Full Width Row) -->
          <div style="border: 1px solid #e2e8f0; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
            <h4 style="margin: 0 0 10px 0; color: #1e3a8a;">חלקים נדרשים:</h4>
            <div class="parts-list" data-center="${index}">
              ${parts.map((part, partIndex) => createEditablePartRow(part, index, partIndex)).join('')}
            </div>
            <button onclick="addPartRow(${index})" class="btn" style="background: #28a745; color: white; padding: 6px 12px; margin-top: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">הוסף חלק</button>
          </div>

          <!-- Works Section (Full Width Row) -->
          <div style="border: 1px solid #e2e8f0; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
            <h4 style="margin: 0 0 10px 0; color: #1e3a8a;">עבודות נדרשות:</h4>
            <div class="works-list" data-center="${index}">
              ${works.map((work, workIndex) => createEditableWorkRow(work, index, workIndex)).join('')}
            </div>
            <button onclick="addWorkRow(${index})" class="btn" style="background: #17a2b8; color: white; padding: 6px 12px; margin-top: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">הוסף עבודה</button>
          </div>

          <!-- Repairs Section (Full Width Row) -->
          <div style="border: 1px solid #e2e8f0; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
            <h4 style="margin: 0 0 10px 0; color: #1e3a8a;">תיקונים נדרשים:</h4>
            <div class="repairs-list" data-center="${index}">
              ${repairs.map((repair, repairIndex) => createEditableRepairRow(repair, index, repairIndex)).join('')}
            </div>
            <button onclick="addRepairRow(${index})" class="btn" style="background: #ffc107; color: #212529; padding: 6px 12px; margin-top: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">הוסף תיקון</button>
          </div>

          <!-- Cost Summary (Auto-calculated) -->
          <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; border: 1px solid #e2e8f0;">
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; font-size: 14px;">
              <div><strong>עבודות:</strong> <span class="work-costs-display">₪${workCosts.toLocaleString()}</span></div>
              <div><strong>חלפים:</strong> <span class="parts-costs-display">₪${partsCosts.toLocaleString()}</span></div>
              <div><strong>תיקונים:</strong> <span class="repairs-costs-display">₪${repairsCosts.toLocaleString()}</span></div>
              <div><strong>כולל מע"מ:</strong> <span class="total-with-vat-display">₪${Math.round(totalWithVAT).toLocaleString()}</span></div>
            </div>
          </div>
        </div>
      `;
    }

    // CREATE EDITABLE PART ROW WITH SEARCH DROPDOWN - SESSION: Updated structure with 7 fields + mobile responsive
    function createEditablePartRow(part, centerIndex, partIndex) {
      // Extract data with NEW field structure (Session 40 compatibility)
      const partName = part?.name || part?.part_name || '';
      const partDesc = part?.desc || part?.description || part?.תיאור || '';
      const pricePerUnit = parseFloat(part?.price_per_unit || part?.unit_price || part?.price || 0);
      const reduction = parseFloat(part?.reduction_percentage || part?.reduction || 0);
      const wear = parseFloat(part?.wear_percentage || part?.wear || 0);
      const quantity = parseInt(part?.quantity || part?.כמות || 1);
      const updatedPrice = Math.round(parseFloat(part?.updated_price || pricePerUnit));
      const totalCost = Math.round(parseFloat(part?.total_cost || (updatedPrice * quantity)));
      const partSource = part?.source || part?.מקור || '';
      const catalogCode = part?.catalog_code || part?.pcode || part?.part_number || '';
      
      // 🔍 SESSION 61 FIX: Generate UUID if missing - don't leave empty!
      let rowUuid = part?.row_uuid;
      if (!rowUuid || rowUuid === '') {
        rowUuid = crypto.randomUUID();
        console.warn(`⚠️ SESSION 61 FINAL-REPORT: Part "${partName}" has NO row_uuid! Generated new: ${rowUuid}`);
        if (part) {
          part.row_uuid = rowUuid;
        }
      } else {
        console.log(`✅ SESSION 61 FINAL-REPORT: Part "${partName}" has row_uuid: ${rowUuid}`);
      }
      
      return `
        <div class="part-row" data-center="${centerIndex}" data-part="${partIndex}" data-row-uuid="${rowUuid}" 
             style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; padding: 12px; background: #f9f9f9; border-radius: 6px; border: 1px solid #e0e0e0;">
          
          <!-- Row 1: Catalog Number + Part Name (Responsive Grid) -->
          <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 8px;">
            <div>
              <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block; font-weight: 600;">מס. קטלוגי:</label>
              <input type="text" value="${catalogCode}" placeholder="מס. קטלוגי" class="part-catalog-code-visible" 
                     style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
                     oninput="autoSaveDamageCenterChanges()" />
            </div>
            <div style="position: relative;">
              <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block; font-weight: 600;">שם החלק:</label>
              <input type="text" value="${partName}" placeholder="שם החלק" class="part-name" 
                     style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
                     onkeyup="showPartSuggestions(this, ${centerIndex}, ${partIndex})" 
                     oninput="autoSaveDamageCenterChanges()" />
              <div class="part-suggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ddd; border-top: none; border-radius: 0 0 4px 4px; display: none; z-index: 1000; max-height: 200px; overflow-y: auto;"></div>
            </div>
          </div>
          
          <!-- Row 2: Price Fields (Responsive Grid) -->
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 6px;">
            <div>
              <label style="font-size: 11px; color: #666; margin-bottom: 2px; display: block;">מחיר:</label>
              <input type="number" value="${pricePerUnit}" placeholder="0" class="part-price-per-unit" 
                     style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" 
                     min="0" step="0.01" 
                     oninput="calculatePartPriceFields(this.closest('.part-row'))" />
            </div>
            <div>
              <label style="font-size: 11px; color: #666; margin-bottom: 2px; display: block;">הנחה%:</label>
              <input type="number" value="${reduction}" placeholder="0" class="part-reduction" 
                     style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" 
                     min="0" max="100" step="0.1" 
                     oninput="calculatePartPriceFields(this.closest('.part-row'))" />
            </div>
            <div>
              <label style="font-size: 11px; color: #666; margin-bottom: 2px; display: block;">בלאי%:</label>
              <input type="number" value="${wear}" placeholder="0" class="part-wear" 
                     style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" 
                     min="0" max="100" step="0.1" 
                     oninput="calculatePartPriceFields(this.closest('.part-row'))" />
            </div>
            <div>
              <label style="font-size: 11px; color: #666; margin-bottom: 2px; display: block;">כמות:</label>
              <input type="number" value="${quantity}" placeholder="1" class="part-quantity" 
                     style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; text-align: center;" 
                     min="1" step="1" 
                     oninput="calculatePartPriceFields(this.closest('.part-row'))" />
            </div>
            <div>
              <label style="font-size: 11px; color: #666; margin-bottom: 2px; display: block;">סה"כ:</label>
              <input type="text" value="₪${totalCost.toLocaleString()}" placeholder="₪0" class="part-total-cost" 
                     style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; background: #e8f5e9; font-weight: 600;" 
                     readonly />
            </div>
          </div>
          
          <!-- Row 3: Delete Button (Bottom Right) -->
          <div style="display: flex; justify-content: flex-end; margin-top: 4px;">
            <button onclick="removePartRow(${centerIndex}, ${partIndex})" 
                    style="background: #dc3545; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">
              מחק
            </button>
          </div>
          
          <!-- Hidden Fields for Data Integrity -->
          <input type="hidden" value="${partSource}" class="part-source" />
          <input type="hidden" value="${partDesc}" class="part-description" />
          <input type="hidden" value="${updatedPrice}" class="part-updated-price" />
        </div>
      `;
    }

    // CREATE EDITABLE WORK ROW WITH DROPDOWN
    function createEditableWorkRow(work, centerIndex, workIndex) {
      const workTypes = [
        'כל עבודות הפחחות כולל פירוקים והרכבות','עבודות צבע', 'עבודות חשמל', 'עבודות מכונאות', 
        'עבודות מזגן', 'עבודות ריפוד', 'עבודות זגגות',
        'איטום וזיפות', 'בדיקת מתלה', 'הנזק מחייב תקנה 309',
        'כיול רדאר', 'העברת חיישנים', 'אחר'
      ];
      
      const workType = typeof work === 'object' ? (work.category || work.type) : work;
      const workNote = typeof work === 'object' ? (work.comments || work.note || '') : '';
      const workCost = typeof work === 'object' ? work.cost : 0;
      
      return `
        <div class="work-row" data-center="${centerIndex}" data-work="${workIndex}" style="display: grid; grid-template-columns: 2fr 2fr 1fr auto; gap: 8px; margin-bottom: 8px; padding: 8px; background: #f9f9f9; border-radius: 4px;">
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">סוג עבודה:</label>
            <select class="work-type" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" onchange="handleWorkTypeChange(this, ${centerIndex}, ${workIndex})">
              ${workTypes.map(type => `<option value="${type}" ${type === workType ? 'selected' : ''}>${type}</option>`).join('')}
            </select>
            <input type="text" class="work-type-other" placeholder="הכנס סוג עבודה אחר" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; margin-top: 4px; display: ${workType === 'אחר' ? 'block' : 'none'};" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">הערות:</label>
            <input type="text" value="${workNote}" placeholder="הערות נוספות" class="work-note" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">עלות (₪):</label>
            <input type="number" value="${workCost}" placeholder="0" class="work-cost" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" min="0" step="0.01" />
          </div>
          <button onclick="removeWorkRow(${centerIndex}, ${workIndex})" style="background: #dc3545; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; align-self: end;">מחק</button>
        </div>
      `;
    }

    // CREATE EDITABLE REPAIR ROW
    function createEditableRepairRow(repair, centerIndex, repairIndex) {
      const repairText = typeof repair === 'object' ? repair.description : repair;
      const repairCost = typeof repair === 'object' ? repair.cost : 0;
      const repairName = typeof repair === 'object' ? repair.name || '' : '';
      const repairHours = typeof repair === 'object' ? repair.hours || 0 : 0;
      
      return `
        <div class="repair-row" data-center="${centerIndex}" data-repair="${repairIndex}" style="display: grid; grid-template-columns: 1.5fr 2fr 0.8fr 1fr auto; gap: 8px; margin-bottom: 8px; padding: 8px; background: #f9f9f9; border-radius: 4px;">
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">שם התיקון:</label>
            <input type="text" value="${repairName}" placeholder="שם התיקון" class="repair-name" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">תיאור התיקון:</label>
            <textarea placeholder="תיאור התיקון" class="repair-text" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; font-family: inherit; min-height: 60px; resize: vertical;">${repairText}</textarea>
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">שעות:</label>
            <input type="number" value="${repairHours}" placeholder="0" class="repair-hours" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" min="0" step="0.1" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">עלות (₪):</label>
            <input type="number" value="${repairCost}" placeholder="0" class="repair-cost" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" min="0" step="0.01" />
          </div>
          <button onclick="removeRepairRow(${centerIndex}, ${repairIndex})" style="background: #dc3545; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; height: 32px; margin-top: 14px;">מחק</button>
        </div>
      `;
    }

    // LOAD LEVI ADJUSTMENTS
    // UNIFIED ADJUSTMENTS SYSTEM - Combines Levi adjustments and custom additions
    // Debounce mechanism to prevent duplicate loading
    let loadAdjustmentsTimeout;
    
    // CRITICAL FIX: Function to clean up duplicate data in helper
    function cleanupHelperDuplicates(helper) {
      try {
        // Clean up levi_report adjustments
        if (helper.levi_report?.adjustments) {
          const seenAdjustments = new Set();
          const cleanedAdjustments = [];
          
          helper.levi_report.adjustments.forEach(adj => {
            const key = `${adj.description}-${adj.value}-${adj.percent}`;
            if (!seenAdjustments.has(key)) {
              seenAdjustments.add(key);
              cleanedAdjustments.push(adj);
            }
          });
          
          const removedCount = helper.levi_report.adjustments.length - cleanedAdjustments.length;
          if (removedCount > 0) {
            console.log(`🧹 Removed ${removedCount} duplicate levi_report adjustments`);
          }
          
          helper.levi_report.adjustments = cleanedAdjustments;
        }
        
        // Clean up custom adjustments
        if (helper.levi?.custom_adjustments) {
          const seenCustom = new Set();
          const cleanedCustom = [];
          
          helper.levi.custom_adjustments.forEach(adj => {
            const key = `${adj.description}-${adj.value}-${adj.percentage}`;
            if (!seenCustom.has(key)) {
              seenCustom.add(key);
              cleanedCustom.push(adj);
            }
          });
          
          const removedCustomCount = helper.levi.custom_adjustments.length - cleanedCustom.length;
          if (removedCustomCount > 0) {
            console.log(`🧹 Removed ${removedCustomCount} duplicate custom adjustments`);
          }
          
          helper.levi.custom_adjustments = cleanedCustom;
        }
        
        return helper;
      } catch (error) {
        console.error('Error cleaning helper duplicates:', error);
        return helper;
      }
    }
    
    function loadAllAdjustments(helper) {
      try {
        // Get caller information for debugging
        const caller = new Error().stack.split('\n')[2].trim();
        console.log('🔄 loadAllAdjustments called (will be debounced) from:', caller);
        
        // Clear any existing timeout to prevent duplicate calls
        if (loadAdjustmentsTimeout) {
          clearTimeout(loadAdjustmentsTimeout);
          console.log('⚠️ Cleared previous loadAllAdjustments timeout');
        }
        
        // Debounce the loading to prevent rapid multiple calls
        // loadAdjustmentsTimeout = setTimeout(() => {
        //   loadAllAdjustmentsImmediate(helper);
        // }, 100);
        console.log('⚠️ loadAllAdjustmentsImmediate disabled - adjustments container was removed');
        
      } catch (error) {
        console.error('Error in loadAllAdjustments debounce:', error);
      }
    }
    
    function loadAllAdjustmentsImmediate(helper) {
      try {
        console.log('🔄 Loading all adjustments (immediate)');
        // Note: Final report adjustments section was removed - skipping that part
        
        // CRITICAL FIX: Clean up duplicate data in helper before loading
        helper = cleanupHelperDuplicates(helper);
        
        // Save the cleaned helper back to sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        console.log('🧹 Helper cleaned up and saved, proceeding with load...');
        
        // AGGRESSIVE FIX: Clear the container completely and verify it's empty
        adjustmentsContainer.innerHTML = '';
        
        // Force a DOM update to ensure the container is truly empty
        adjustmentsContainer.offsetHeight; // Force reflow
        
        console.log('🧹 Container cleared, current children count:', adjustmentsContainer.children.length);
        
        let adjustmentsHTML = '';
        
        // 1. Load Levi adjustments (read-only from Levi report)
        if (helper.levi_report?.adjustments && helper.levi_report.adjustments.length > 0) {
          console.log('📄 Loading Levi adjustments:', helper.levi_report.adjustments);
          console.log('📄 Levi adjustments count:', helper.levi_report.adjustments.length);
          helper.levi_report.adjustments.forEach((adjustment, index) => {
            console.log(`📄 Processing Levi adjustment ${index}:`, adjustment);
            adjustmentsHTML += createAdjustmentRow({
              description: adjustment.description || 'התאמה מלוי יצחק',
              percentage: adjustment.percentage || adjustment.percent || 0,
              value: adjustment.value || 0,
              source: 'levi',
              index: index,
              readonly: false
            });
          });
        } else {
          console.log('📄 No Levi adjustments found in helper.levi_report.adjustments');
        }
        
        // 2. Load custom adjustments (editable, stored in helper.levi.custom_adjustments)
        if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments.length > 0) {
          console.log('📄 Loading custom adjustments:', helper.levi.custom_adjustments);
          console.log('📄 Custom adjustments count:', helper.levi.custom_adjustments.length);
          helper.levi.custom_adjustments.forEach((adjustment, index) => {
            console.log(`📄 Processing custom adjustment ${index}:`, adjustment);
            adjustmentsHTML += createAdjustmentRow({
              description: adjustment.description || 'התאמה מותאמת אישית',
              percentage: adjustment.percentage || 0,
              value: adjustment.value || 0,
              source: 'custom',
              index: index,
              readonly: false,
              adjustmentType: adjustment.adjustmentType || 'addition'
            });
          });
        } else {
          console.log('📄 No custom adjustments found in helper.levi.custom_adjustments');
        }
        
        if (!adjustmentsHTML) {
          adjustmentsHTML = '<div style="color: #666; text-align: center; padding: 10px; font-size: 13px;">לא נמצאו התאמות - השתמש בכפתור "הוסף התאמה נוספת"</div>';
        }
        
        adjustmentsContainer.innerHTML = adjustmentsHTML;
        
        // Add event listeners for all adjustments
        setTimeout(() => {
          addAdjustmentEventListeners();
          
          // Trigger initial auto-calculation for existing custom adjustments
          if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments.length > 0) {
            console.log('🔄 Triggering initial calculation for existing adjustments');
            helper.levi.custom_adjustments.forEach((adjustment, index) => {
              if (adjustment.percentage && adjustment.percentage !== 0) {
                console.log(`🚀 Initial calculation for adjustment ${index}: ${adjustment.percentage}%`);
                calculateAdjustmentValue('custom', index, adjustment.percentage);
              }
            });
          }
        }, 300);
        
      } catch (error) {
        console.error('Error loading all adjustments:', error);
        // Note: allAdjustmentsRows-final-report container was removed
      }
      
      // Removed: Loading adjustments from helper.final_report.adjustments
      // Now using valuation.adjustments for all adjustment data flow
      if (false) { // Disabled - keeping code for reference
        console.log('📋 Loading saved adjustments from Helper:', helper.final_report.adjustments);
        
        // Clear existing rows to prevent duplication
        // REMOVED: Wrong loading from final_report.adjustments
        // The correct loading is done by loadGrossAdjustments(helper) which reads from estimate.adjustments
        
      }
      
      // Load saved legal text from final_report
      if (helper.final_report?.legal_text) {
        const legalTextElement = document.getElementById('legal-text-content');
        if (legalTextElement) {
          legalTextElement.value = helper.final_report.legal_text;
        }
      }
      
      // Attachments are now loaded by dedicated loadAttachmentsData() function
    }
    
    // Create unified adjustment row HTML
    function createAdjustmentRow(params) {
      const { description, percentage, value, source, index, readonly, adjustmentType } = params;
      const rowId = `adjustment-${source}-${index}`;
      
      // Determine type and colors
      let typeLabel, typeColor;
      if (source === 'levi') {
        typeLabel = 'לוי יצחק';
        typeColor = '#007bff';
      } else {
        // For custom adjustments, use the explicit type or infer from values
        const currentType = adjustmentType || (percentage < 0 || value < 0 ? 'subtraction' : 'addition');
        typeLabel = currentType === 'addition' ? 'תוספת' : 'הפחתה';
        typeColor = currentType === 'addition' ? '#28a745' : '#dc3545';
      }
      
      if (readonly) {
        // Read-only Levi adjustments (5-column layout)
        return `
          <div class="adjustment-row" id="${rowId}" style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr auto; gap: 8px; padding: 8px; border-bottom: 1px solid #e9ecef; background: #f8f9fa;">
            <div style="font-size: 13px;">
              <span style="background: ${typeColor}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 8px;">${typeLabel}</span>
              ${description}
            </div>
            <div style="font-size: 13px; text-align: center; color: ${typeColor}; font-weight: bold;">${typeLabel}</div>
            <div style="font-size: 13px; text-align: center;">${percentage}%</div>
            <div style="font-size: 13px; text-align: center;">₪${value.toLocaleString()}</div>
            <div style="font-size: 11px; color: #666;">קריאה בלבד</div>
          </div>
        `;
      } else {
        // Editable custom adjustments with type dropdown (5-column layout)
        const currentAdjustmentType = adjustmentType || 'addition';
        return `
          <div class="adjustment-row" id="${rowId}" style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr auto; gap: 8px; padding: 8px; border-bottom: 1px solid #e9ecef;" data-source="${source}" data-loaded-from-helper="true">
            <input type="text" value="${description}" data-field="description" data-source="${source}" data-index="${index}" 
                   style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px;" 
                   placeholder="תיאור ההתאמה" />
            <select data-field="adjustmentType" data-source="${source}" data-index="${index}"
                    style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px; background: white;">
              <option value="addition" ${currentAdjustmentType === 'addition' ? 'selected' : ''} style="color: #28a745;">תוספת</option>
              <option value="subtraction" ${currentAdjustmentType === 'subtraction' ? 'selected' : ''} style="color: #dc3545;">הפחתה</option>
            </select>
            <input type="number" value="${Math.abs(percentage)}" data-field="percentage" data-source="${source}" data-index="${index}"
                   style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px; text-align: center;" 
                   placeholder="0" step="0.1" min="0" />
            <input type="number" value="${Math.abs(value)}" data-field="value" data-source="${source}" data-index="${index}"
                   style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px; text-align: center; background: #f8f9fa;" 
                   placeholder="אוטומטי" step="100" min="0" readonly title="מחושב אוטומטית: אחוז × מחיר בסיס" />
            <button type="button" onclick="removeCustomAdjustment('${source}', ${index})" 
                    style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">מחק</button>
          </div>
        `;
      }
    }

    // ADD CUSTOM ADJUSTMENT FIELD - Unified system
    function addCustomAdjustmentField() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Initialize custom adjustments array if it doesn't exist
      if (!helper.levi) helper.levi = {};
      if (!helper.levi.custom_adjustments) helper.levi.custom_adjustments = [];
      
      // Add new empty adjustment with default type
      const newAdjustment = {
        description: '',
        percentage: 0,
        value: 0,
        adjustmentType: 'addition'
      };
      
      helper.levi.custom_adjustments.push(newAdjustment);
      
      // Save to sessionStorage
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Reload all adjustments to show the new one
      loadAllAdjustments(helper);
      
      console.log('Added new custom adjustment, total custom adjustments:', helper.levi.custom_adjustments.length);
      
      // Ensure event listeners are attached to the new row
      const newIndex = helper.levi.custom_adjustments.length - 1;
      setTimeout(() => {
        console.log('🆕 Setting up new adjustment row with event listeners');
        addAdjustmentEventListeners();
        
        // Focus on the new row's description field
        const newDescriptionInput = document.querySelector(`input[data-field="description"][data-source="custom"][data-index="${newIndex}"]`);
        if (newDescriptionInput) {
          newDescriptionInput.focus();
        }
        
        // Trigger initial calculation if it has a percentage
        const newAdjustment = helper.levi.custom_adjustments[newIndex];
        if (newAdjustment && newAdjustment.percentage !== 0) {
          calculateAdjustmentValue('custom', newIndex, newAdjustment.percentage);
        }
      }, 150);
    }
    
    // REMOVE CUSTOM ADJUSTMENT
    function removeCustomAdjustment(source, index) {
      if (source !== 'custom') return; // Only allow removing custom adjustments
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments[index]) {
        helper.levi.custom_adjustments.splice(index, 1);
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Reload all adjustments
        loadAllAdjustments(helper);
        
        // Re-attach event listeners after removal
        setTimeout(() => {
          addAdjustmentEventListeners();
        }, 100);
        
        console.log('Removed custom adjustment at index:', index);
      }
    }
    
    // ADD EVENT LISTENERS FOR ADJUSTMENT FIELDS
    function addAdjustmentEventListeners() {
      // Remove existing event listeners to prevent duplicates
      // Final report container removed - will return empty NodeList
      const existingInputs = document.querySelectorAll('#allAdjustmentsRows-final-report input[data-source], #allAdjustmentsRows-final-report select[data-source]');
      existingInputs.forEach(element => {
        // Clone element to remove all event listeners
        const newElement = element.cloneNode(true);
        element.parentNode.replaceChild(newElement, element);
      });
      
      // Add fresh event listeners to all adjustment inputs (both custom and levi)
      // Final report container removed - will return empty NodeList  
      const adjustmentInputs = document.querySelectorAll('#allAdjustmentsRows-final-report input[data-source], #allAdjustmentsRows-final-report select[data-source]');
      
      console.log(`🔗 Adding event listeners to ${adjustmentInputs.length} adjustment inputs`);
      
      adjustmentInputs.forEach(element => {
        // Input event for real-time updates
        element.addEventListener('input', function() {
          const source = this.dataset.source;
          const index = parseInt(this.dataset.index);
          const field = this.dataset.field;
          
          console.log(`📝 Input changed: ${field} for ${source}[${index}] = ${this.value}`);
          
          let value;
          if (field === 'description') {
            value = this.value;
          } else if (field === 'adjustmentType') {
            value = this.value;
          } else {
            value = parseFloat(this.value) || 0;
          }
          
          // Update helper based on source type
          if (source === 'custom') {
            updateCustomAdjustmentInHelper(source, index, field, value);
          } else if (source === 'levi') {
            updateLeviAdjustmentInHelper(source, index, field, value);
          }
          
          // Auto-calculate value when percentage changes
          if (field === 'percentage') {
            console.log(`🔢 Triggering auto-calculation for percentage: ${value}%`);
            calculateAdjustmentValue(source, index, value);
          }
          
          // Debug: Check if helper is updated
          const currentHelper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          console.log(`🔍 DEBUG: Helper after adjustment update:`, currentHelper.levi?.custom_adjustments);
          console.log(`🔍 DEBUG: Helper expertise.levi_report:`, currentHelper.expertise?.levi_report);
          
          // Trigger floating screen refresh when adjustments change
          triggerFloatingScreenRefresh();
        });
        
        // Change event for final updates
        element.addEventListener('change', function() {
          // Trigger calculation update on change
          calculateSummaryTotals();
          
          // Trigger floating screen refresh when adjustments change
          triggerFloatingScreenRefresh();
          
          // If adjustment type changed, reload to update display
          if (this.dataset.field === 'adjustmentType') {
            // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
            setTimeout(() => loadAllAdjustments(helper), 50);
          }
        });
        
        // For percentage fields, trigger auto-calculation on focus out
        if (element.dataset.field === 'percentage') {
          element.addEventListener('blur', function() {
            const value = parseFloat(this.value) || 0;
            if (value !== 0) {
              console.log(`🎯 Blur event: Recalculating for percentage ${value}%`);
              calculateAdjustmentValue(this.dataset.source, parseInt(this.dataset.index), value);
            }
          });
        }
      });
    }
    
    // AUTO-CALCULATE ADJUSTMENT VALUE FROM PERCENTAGE
    function calculateAdjustmentValue(source, index, percentage) {
      // Get base price from car details
      const basePrice = getBasePriceForCalculation();
      
      if (basePrice > 0 && percentage !== 0) {
        const calculatedValue = Math.round((basePrice * Math.abs(percentage)) / 100);
        
        console.log(`Auto-calculating adjustment value: ${percentage}% × ₪${basePrice.toLocaleString()} = ₪${calculatedValue.toLocaleString()}`);
        
        // Update the value field in DOM
        const valueInput = document.querySelector(`input[data-field="value"][data-source="${source}"][data-index="${index}"]`);
        if (valueInput) {
          valueInput.value = calculatedValue;
        }
        
        // Update helper with calculated value (works for both custom and levi)
        if (source === 'custom') {
          updateCustomAdjustmentInHelper(source, index, 'value', calculatedValue);
        } else if (source === 'levi') {
          updateLeviAdjustmentInHelper(source, index, 'value', calculatedValue);
        }
      }
    }
    
    // UPDATE LEVI ADJUSTMENT IN HELPER
    function updateLeviAdjustmentInHelper(source, index, field, value) {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Ensure Levi report structure exists
        if (!helper.levi_report) helper.levi_report = {};
        if (!helper.levi_report.adjustments) helper.levi_report.adjustments = [];
        
        // Update the specific adjustment
        if (helper.levi_report.adjustments[index]) {
          helper.levi_report.adjustments[index][field] = value;
          
          // Save back to helper
          sessionStorage.setItem('helper', JSON.stringify(helper));
          console.log(`✅ Updated Levi adjustment ${index}.${field} = ${value}`);
        }
      } catch (error) {
        console.error('Error updating Levi adjustment in helper:', error);
      }
    }
    
    // GET BASE PRICE FOR CALCULATION
    function getBasePriceForCalculation() {
      // Try multiple sources for base price
      let basePrice = 0;
      
      // Priority 1: Car base price field
      const carBasePriceField = document.getElementById('carBasePrice');
      if (carBasePriceField && carBasePriceField.value) {
        const carBasePriceStr = carBasePriceField.value.replace(/[₪,]/g, '') || '0';
        basePrice = parseFloat(carBasePriceStr) || 0;
      }
      
      // Priority 2: Helper data
      if (basePrice === 0) {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        basePrice = helper?.vehicle_value_base || 
                   helper?.car_details?.base_price || 
                   helper?.levi?.base_price || 
                   helper?.levi_report?.base_price || 0;
      }
      
      return basePrice;
    }
    
    // RECALCULATE ALL ADJUSTMENT VALUES (when base price changes)
    function recalculateAllAdjustmentValues() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments.length > 0) {
        console.log('🔄 Recalculating all adjustment values due to base price change');
        
        helper.levi.custom_adjustments.forEach((adjustment, index) => {
          if (adjustment.percentage && adjustment.percentage !== 0) {
            calculateAdjustmentValue('custom', index, adjustment.percentage);
          }
        });
      }
    }
    
    // UPDATE CUSTOM ADJUSTMENT IN HELPER
    function updateCustomAdjustmentInHelper(source, index, field, value) {
      if (source !== 'custom') return;
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments[index]) {
        const adjustment = helper.levi.custom_adjustments[index];
        
        // Update the field
        adjustment[field] = value;
        
        // Apply proper signs based on adjustment type when updating numeric fields
        if (field === 'percentage' || field === 'value') {
          const adjustmentType = adjustment.adjustmentType || 'addition';
          const absoluteValue = Math.abs(value);
          
          if (adjustmentType === 'subtraction') {
            adjustment[field] = -absoluteValue;
          } else {
            adjustment[field] = absoluteValue;
          }
        }
        
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log(`Updated custom adjustment ${index}.${field} to:`, adjustment[field]);
        console.log('Full adjustment object:', adjustment);
        
        // Update the structured Levi data for floating screen compatibility
        updateLeviDataStructure(helper);
        
        // Helper is already updated above with sessionStorage.setItem
        console.log('✅ Helper updated with adjustment data');
      }
    }
    
    // UPDATE LEVI DATA STRUCTURE FOR FLOATING SCREEN COMPATIBILITY
    function updateLeviDataStructure(helper) {
      try {
        // Ensure expertise.levi_report exists
        if (!helper.expertise) helper.expertise = {};
        if (!helper.expertise.levi_report) helper.expertise.levi_report = {};
        
        // Map basic vehicle info from other helper sections
        if (helper.car_details) {
          helper.expertise.levi_report.manufacturer = helper.car_details.manufacturer || helper.vehicle?.manufacturer;
          helper.expertise.levi_report.year = helper.car_details.year || helper.vehicle?.year;
          helper.expertise.levi_report.base_price = helper.car_details.base_price;
          helper.expertise.levi_report.final_price = helper.car_details.market_value;
          helper.expertise.levi_report.vehicle_type = helper.vehicle?.vehicle_type || '';
          helper.expertise.levi_report.model_code = helper.vehicle?.model_code || '';
          helper.expertise.levi_report.category = helper.vehicle?.category || '';
          helper.expertise.levi_report.full_model = helper.vehicle?.model || helper.car_details.model;
        }
        
        // Process custom adjustments into the structure expected by Levi floating screen
        if (helper.levi?.custom_adjustments) {
          // Initialize all adjustment fields to ensure they exist
          helper.expertise.levi_report.registration = '';
          helper.expertise.levi_report.registration_percent = '';
          helper.expertise.levi_report.registration_value = '';
          helper.expertise.levi_report.registration_total = '';
          helper.expertise.levi_report.ownership = '';
          helper.expertise.levi_report.ownership_percent = '';
          helper.expertise.levi_report.ownership_value = '';
          helper.expertise.levi_report.ownership_total = '';
          helper.expertise.levi_report.km = '';
          helper.expertise.levi_report.km_percent = '';
          helper.expertise.levi_report.km_value = '';
          helper.expertise.levi_report.km_total = '';
          helper.expertise.levi_report.owners = '';
          helper.expertise.levi_report.owners_percent = '';
          helper.expertise.levi_report.owners_value = '';
          helper.expertise.levi_report.owners_total = '';
          helper.expertise.levi_report.features = '';
          helper.expertise.levi_report.features_percent = '';
          helper.expertise.levi_report.features_value = '';
          helper.expertise.levi_report.features_total = '';
          
          helper.levi.custom_adjustments.forEach((adjustment, index) => {
            const desc = adjustment.description ? adjustment.description.toLowerCase() : '';
            
            console.log(`🔍 Mapping adjustment ${index}: "${adjustment.description}" (${adjustment.percentage}%, ₪${adjustment.value})`);
            
            // Map based on description keywords ONLY (check specific terms first to avoid conflicts)
            if (desc.includes('עליה לכביש') || desc.includes('registration') || desc.includes('רישוי')) {
              helper.expertise.levi_report.registration = adjustment.description || 'עליה לכביש';
              helper.expertise.levi_report.registration_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.registration_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.registration_total = Math.abs(adjustment.value || 0);
              console.log(`✅ Mapped to registration: ${adjustment.description}`);
            } else if (desc.includes('מספר בעלים') || desc.includes('owners')) {
              helper.expertise.levi_report.owners = adjustment.description || 'מספר בעלים';
              helper.expertise.levi_report.owners_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.owners_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.owners_total = Math.abs(adjustment.value || 0);
              console.log(`✅ Mapped to owners: ${adjustment.description}`);
            } else if (desc.includes('בעלות') || desc.includes('ownership')) {
              helper.expertise.levi_report.ownership = adjustment.description || 'בעלות';
              helper.expertise.levi_report.ownership_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.ownership_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.ownership_total = Math.abs(adjustment.value || 0);
              console.log(`✅ Mapped to ownership: ${adjustment.description}`);
            } else if (desc.includes('ק״מ') || desc.includes('km') || desc.includes('קילומטרים')) {
              helper.expertise.levi_report.km = adjustment.description || 'מס ק״מ';
              helper.expertise.levi_report.km_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.km_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.km_total = Math.abs(adjustment.value || 0);
              console.log(`✅ Mapped to km: ${adjustment.description}`);
            } else if (desc.includes('מאפיינים') || desc.includes('features')) {
              helper.expertise.levi_report.features = adjustment.description || 'מאפיינים';
              helper.expertise.levi_report.features_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.features_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.features_total = Math.abs(adjustment.value || 0);
              console.log(`✅ Mapped to features: ${adjustment.description}`);
            } else {
              console.log(`⚠️ No mapping found for: "${adjustment.description}" - will be stored in helper for validation/report`);
            }
          });
        }
        
        // Update helper in sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('📊 Updated Levi data structure for floating screen compatibility');
        
      } catch (error) {
        console.error('Error updating Levi data structure:', error);
      }
    }
    
    // CALCULATE SUMMARY TOTALS - Updates helper with calculated totals
    function calculateSummaryTotals() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Calculate Levi adjustment totals
        let leviTotal = 0;
        if (helper.levi?.adjustments) {
          leviTotal = helper.levi.adjustments.reduce((sum, adj) => sum + (parseFloat(adj.value) || 0), 0);
        }
        if (helper.levi?.custom_adjustments) {
          leviTotal += helper.levi.custom_adjustments.reduce((sum, adj) => sum + (parseFloat(adj.value) || 0), 0);
        }
        
        // Calculate damage center totals
        let damageTotal = 0;
        if (helper.expertise?.damage_blocks) {
          helper.expertise.damage_blocks.forEach(block => {
            damageTotal += (parseFloat(block.parts_cost) || 0) + (parseFloat(block.work_cost) || 0) + (parseFloat(block.repairs_cost) || 0);
          });
        }
        
        // Update helper with calculated totals
        helper.summary_totals = {
          levi_total: leviTotal,
          damage_total: damageTotal,
          total_before_vat: leviTotal + damageTotal,
          total_with_vat: Math.round((leviTotal + damageTotal) * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100)),
          calculated_at: new Date().toISOString()
        };
        
        sessionStorage.setItem('helper', JSON.stringify(helper));
        console.log('✅ Summary totals calculated and updated in helper:', helper.summary_totals);
        
        // Trigger floating screen updates when helper changes
        triggerFloatingScreenRefresh();
        
      } catch (error) {
        console.error('Error calculating summary totals:', error);
      }
    }

    // TRIGGER FLOATING SCREEN REFRESH - Updates all helper-dependent floating screens
    function triggerFloatingScreenRefresh() {
      try {
        console.log('🔄 Triggering floating screen refresh after helper update');
        
        // Update helper with current 3-bulk calculations
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Ensure calculations structure exists
        helper.calculations = helper.calculations || {};
        helper.expertise = helper.expertise || {};
        helper.expertise.calculations = helper.expertise.calculations || {};
        
        // Update with current bulk calculations - with safety checks
        let grossMarketValue = 0;
        let fullMarketValue = 0;
        let totalClaim = 0;
        let grossPercentage = 0;
        
        if (window.FinalReportCalculations && typeof window.FinalReportCalculations === 'object') {
          grossMarketValue = window.FinalReportCalculations.getGrossMarketValue();
          fullMarketValue = window.FinalReportCalculations.getFullMarketValue();
          totalClaim = window.FinalReportCalculations.getTotalClaim();
          grossPercentage = window.FinalReportCalculations.getGrossPercentage();
        } else {
          console.warn('FinalReportCalculations not yet initialized, using fallback values');
          // Try to get values from DOM or helper as fallback
          grossMarketValue = parseFloat(document.getElementById('grossMarketValueResult')?.value.replace(/[₪,]/g, '') || '0') || 0;
          fullMarketValue = parseFloat(document.getElementById('fullMarketValueResult')?.value.replace(/[₪,]/g, '') || '0') || 0;
          totalClaim = parseFloat(document.getElementById('totalClaim')?.value.replace(/[₪,]/g, '') || '0') || 0;
          grossPercentage = parseFloat(document.getElementById('grossPercent')?.value.replace(/[%]/g, '') || '0') || 0;
        }
        
        // ✅ FIX: Check for manual authorizedClaim value and use that instead of calculated totalClaim
        const authorizedClaimField = document.getElementById('authorizedClaim');
        if (authorizedClaimField && authorizedClaimField.value && authorizedClaimField.value !== '') {
          const manualTotalClaim = parseFloat(authorizedClaimField.value.replace(/[₪,]/g, '')) || 0;
          if (manualTotalClaim > 0) {
            totalClaim = manualTotalClaim;
            console.log(`🔧 Using manual authorizedClaim value: ${totalClaim} instead of calculated value`);
          }
        }
        
        // Get original base price from valuation (preserve webhook data)
        const rawBasePrice = helper.valuation?.base_price || 
                             helper.car_details?.base_price || 
                             helper.levi_report?.base_price || 0;
        const originalBasePrice = parseFloat(String(rawBasePrice).replace(/[₪,]/g, '')) || 0;
        
        helper.calculations.vehicle_value_gross = grossMarketValue;
        helper.calculations.market_value = fullMarketValue;
        helper.calculations.full_market_value = fullMarketValue;
        helper.calculations.total_damage = totalClaim;
        helper.calculations.damage_percent = grossPercentage;
        
        // Add new bridge fields between webhook and user modifications
        helper.calculations.base_price = originalBasePrice;
        helper.calculations.final_adjustments_value = Math.round(fullMarketValue - originalBasePrice);
        
        // Debug logging to verify correct calculation
        console.log(`🔍 Bridge Field Debug: fullMarketValue=${fullMarketValue}, originalBasePrice=${originalBasePrice}, final_adjustments_value=${Math.round(fullMarketValue - originalBasePrice)}`);
        
        // Update expertise calculations for compatibility
        helper.expertise.calculations.vehicle_value_gross = grossMarketValue;
        helper.expertise.calculations.market_value = fullMarketValue;
        helper.expertise.calculations.total_damage = totalClaim;
        helper.expertise.calculations.damage_percent = grossPercentage;
        
        // Update claims_data for UI consistency
        helper.claims_data = helper.claims_data || {};
        
        helper.claims_data.gross_percent = `${grossPercentage.toFixed(2)}%`;
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Debug: Check which refresh functions are available
        console.log('Debug: Available refresh functions:', {
          refreshLeviData: typeof window.refreshLeviData,
          refreshCarData: typeof window.refreshCarData, 
          refreshInvoiceData: typeof window.refreshInvoiceData,
          refreshPartsResults: typeof window.refreshPartsResults
        });
        
        // Refresh Levi floating screen if open
        if (window.refreshLeviData && typeof window.refreshLeviData === 'function') {
          console.log('🔄 Refreshing Levi floating screen');
          window.refreshLeviData();
        }
        
        // Refresh Car Details floating screen if open
        if (window.refreshCarData && typeof window.refreshCarData === 'function') {
          console.log('🔄 Refreshing Car Details floating screen');
          window.refreshCarData();
        }
        
        // Refresh Invoice floating screen if open
        if (window.refreshInvoiceData && typeof window.refreshInvoiceData === 'function') {
          console.log('🔄 Refreshing Invoice floating screen');
          window.refreshInvoiceData();
        }
        
        // Refresh Parts Search floating screen
        if (window.refreshPartsResults && typeof window.refreshPartsResults === 'function') {
          console.log('🔄 Refreshing Parts Search floating screen');
          window.refreshPartsResults();
        }
        
        // Alternative: Try to reload data directly from iframe/floating screens
        setTimeout(() => {
          // Try to refresh via postMessage to floating screens
          const floatingScreens = document.querySelectorAll('.floating-screen[style*="block"]');
          floatingScreens.forEach(screen => {
            console.log('🔄 Found open floating screen:', screen.id);
            const iframe = screen.querySelector('iframe');
            if (iframe && iframe.contentWindow) {
              try {
                iframe.contentWindow.postMessage({
                  type: 'refreshData',
                  source: 'final-report-builder',
                  calculations: helper.calculations,
                  timestamp: new Date().toISOString()
                }, '*');
              } catch (e) {
                console.log('Could not post message to iframe:', e);
              }
            }
          });
        }, 100);
        
        // Dispatch custom event for any other modules listening
        window.dispatchEvent(new CustomEvent('helperDataUpdated', {
          detail: { 
            timestamp: new Date().toISOString(),
            source: 'final-report-builder',
            calculations: helper.calculations
          }
        }));
        
        
        console.log('✅ Helper updated with 3-bulk calculations:', {
          grossMarketValue,
          fullMarketValue,
          totalClaim,
          grossPercentage
        });
        
      } catch (error) {
        console.error('Error triggering floating screen refresh:', error);
      }
    }

    // LEGACY FUNCTION - Keep for compatibility but redirect to unified system
    function addCustomSummaryField(summaryType) {
      // Redirect to new unified system
      addCustomAdjustmentField();
    }
    
    // DEBUG FUNCTION - Test the complete data flow chain
    window.testDataFlow = function() {
      console.log('🧪 TESTING DATA FLOW CHAIN');
      
      // 1. Check if helper exists
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('1️⃣ Helper exists:', !!helper);
      console.log('   Helper keys:', Object.keys(helper));
      
      // 2. Test manual helper update
      console.log('2️⃣ Testing manual helper update...');
      helper.test_field = 'test_value_' + Date.now();
      helper.car_details = helper.car_details || {};
      helper.car_details.manufacturer = 'TEST_MANUFACTURER';
      sessionStorage.setItem('helper', JSON.stringify(helper));
      console.log('   Helper updated with test data');
      
      // 3. Test floating screen refresh
      console.log('3️⃣ Testing floating screen refresh...');
      triggerFloatingScreenRefresh();
      
      // 4. Check if refresh functions are available
      console.log('4️⃣ Checking refresh function availability:');
      console.log('   refreshLeviData:', typeof window.refreshLeviData);
      console.log('   refreshCarData:', typeof window.refreshCarData);
      console.log('   refreshInvoiceData:', typeof window.refreshInvoiceData);
      console.log('   refreshPartsResults:', typeof window.refreshPartsResults);
      
      // 5. Test manual adjustment input
      console.log('5️⃣ Testing manual adjustment input...');
      // Final report container removed - will return empty NodeList
      const adjustmentInputs = document.querySelectorAll('#allAdjustmentsRows-final-report input[data-source="custom"]');
      console.log('   Found adjustment inputs:', adjustmentInputs.length);
      
      if (adjustmentInputs.length > 0) {
        const firstInput = adjustmentInputs[0];
        console.log('   First input element:', firstInput);
        console.log('   First input data attributes:', {
          source: firstInput.dataset.source,
          index: firstInput.dataset.index,
          field: firstInput.dataset.field
        });
        
        // Simulate input change
        firstInput.value = 'TEST_ADJUSTMENT_' + Date.now();
        firstInput.dispatchEvent(new Event('input', { bubbles: true }));
        console.log('   Simulated input change');
      }
      
      console.log('🧪 DATA FLOW TEST COMPLETE');
    };

    // REMOVED DUPLICATE FUNCTION - Using the enhanced version above

    // UPDATE HELPER FROM FIELD
    function updateHelperFromField(event) {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        const fieldId = event.target.id;
        const value = event.target.value;
        
        console.log(`📝 Field change detected: ${fieldId} = "${value}"`);
        
        // Update the appropriate helper section based on field
        if (['carPlate', 'carManufacturer', 'carModel', 'carYear', 'carModelCode', 'carBasePrice', 'carMarketValue', 'carReportDate', 'basicPrice', 'finalReportDate', 'finalReportDateSummary'].includes(fieldId)) {
          helper.car_details = helper.car_details || {};
          helper.vehicle = helper.vehicle || {};
          
          const mapping = {
            'carPlate': 'plate',
            'carManufacturer': 'manufacturer',
            'carModel': 'model',
            'carYear': 'year',
            'carModelCode': 'model_code',
            'carBasePrice': 'base_price',
            'carMarketValue': 'market_value',
            'carReportDate': 'report_date',
            'basicPrice': 'basic_price',
            'finalReportDate': 'final_report_date',
            'finalReportDateSummary': 'final_report_date'
          };
          
          // Update car_details (builder format)
          helper.car_details[mapping[fieldId]] = value;
          
          // Special handling for final report date - also save to final_report.report_date
          if (fieldId === 'finalReportDate' || fieldId === 'finalReportDateSummary') {
            helper.final_report = helper.final_report || {};
            helper.final_report.report_date = value;
            console.log('📅 Also saved to final_report.report_date:', value);
          }
          
          // Also update vehicle structure (floating screen format)
          if (fieldId === 'carManufacturer') {
            helper.vehicle.manufacturer = value;
            console.log('🚗 Updated vehicle manufacturer:', value);
          } else if (fieldId === 'carModel') {
            helper.vehicle.model = value;
            console.log('🚗 Updated vehicle model:', value);
          } else if (fieldId === 'carYear') {
            helper.vehicle.year = value;
            console.log('🚗 Updated vehicle year:', value);
          } else if (fieldId === 'carModelCode') {
            helper.vehicle.model_code = value;
            console.log('🚗 Updated vehicle model code:', value);
          } else if (fieldId === 'carPlate') {
            // CRITICAL FIX: Use centralized plate standardization function
            if (window.setPlateNumber) {
              window.setPlateNumber(value, 'final-report-builder');
            } else {
              // Fallback: standardize manually
              const standardizedPlate = value ? String(value).replace(/[-\s]/g, '') : '';
              helper.vehicle.plate_number = standardizedPlate;
              helper.meta = helper.meta || {};
              helper.meta.plate = standardizedPlate;
            }
            console.log('🚗 Updated vehicle plate:', value);
          } else if (fieldId === 'basicPrice') {
            // Update levi_report structure for basic price
            helper.levi_report = helper.levi_report || {};
            helper.levi_report.base_price = value.replace(/[₪,]/g, '');
            helper.expertise = helper.expertise || {};
            helper.expertise.levi_report = helper.expertise.levi_report || {};
            helper.expertise.levi_report.base_price = value.replace(/[₪,]/g, '');
            console.log('🚗 Updated basic price:', value);
          }
          
          // Plate update is now handled above with centralized function
        } else if (['ownerName', 'ownerAddress', 'ownerPhone', 'insuranceCompany', 'insuranceEmail', 'insuranceAgent', 'agentPhone', 'agentEmail'].includes(fieldId)) {
          helper.client = helper.client || {};
          helper.car_details = helper.car_details || {};
          
          const mapping = {
            'ownerName': 'name',
            'ownerAddress': 'address',
            'ownerPhone': 'phone',
            'insuranceCompany': 'insurance_company',
            'insuranceEmail': 'insurance_email',
            'insuranceAgent': 'insurance_agent',
            'agentPhone': 'insurance_agent_phone',
            'agentEmail': 'insurance_agent_email'
          };
          
          // Update client structure (main format)
          helper.client[mapping[fieldId]] = value;
          
          // Also update car_details structure (floating screen format)
          if (fieldId === 'ownerName') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.name = value;
            helper.car_details.owner = value;
          } else if (fieldId === 'ownerAddress') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.address = value;
            helper.car_details.ownerAddress = value;
          } else if (fieldId === 'ownerPhone') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.phone_number = value;
            helper.car_details.ownerPhone = value;
          } else if (fieldId === 'insuranceCompany') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_company = value;
            helper.car_details.insuranceCompany = value;
          } else if (fieldId === 'insuranceAgent') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_agent = value;
            helper.car_details.agentName = value;
          } else if (fieldId === 'agentPhone') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_agent_phone = value;
            helper.car_details.insurance_agent_phone = value;
          } else if (fieldId === 'agentEmail') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_agent_email = value;
            helper.car_details.insurance_agent_email = value;
          }
        } else if (fieldId === 'totalClaim') {
          // Claims data mapping
          helper.claims_data = helper.claims_data || {};
          helper.claims_data.total_claim = value;
          console.log(`💰 Updated claims_data.total_claim from ${fieldId}: ${value}`);
          
          // ✅ ENSURE: Update window.helper immediately
          window.helper = helper;
          
          // Also update expertise.calculations for compatibility
          helper.expertise = helper.expertise || {};
          helper.expertise.calculations = helper.expertise.calculations || {};
          if (fieldId === 'totalClaim') {
            // Remove currency formatting and parse number
            const numericValue = parseFloat(value.replace(/[₪,]/g, '')) || 0;
            helper.expertise.calculations.total_damage = numericValue;
          }
          
          console.log(`💰 Updated claims data: ${fieldId} = "${value}"`);
        } else if (['sumMarketValue', 'sumClaim', 'sumVAT', 'sumTotalClaim', 'depCompensation', 'salvageValue', 'garageDays', 
                   'sumMarketValueGlobal', 'sumMarketValueDamage', 'sumMarketValueTotal', 'sumMarketValueLegal',
                   'saleValueDamage', 'afterSaleDamage', 'salvageValueTotal', 'storageValueTotal', 'afterSaleTotal',
                   'salvageValueLegal', 'afterSaleLegal'].includes(fieldId)) {
          
          // COMPREHENSIVE SUMMARY FIELD MAPPING FOR ALL 5 REPORT VARIANTS
          
          // Handle garage days separately
          if (fieldId === 'garageDays') {
            helper.final_report.work_days = value;
          } else {
            helper.final_report.summary = helper.final_report.summary || {};
            
            // COMPREHENSIVE FIELD MAPPING DICTIONARY FOR ALL VARIANTS
            const comprehensiveMapping = {
              // COMMON FIELDS (used across multiple variants)
              'sumMarketValue': 'market_value',           // Private report market value
              'sumMarketValueGlobal': 'market_value_global',     // Global report market value  
              'sumMarketValueDamage': 'market_value_damage',     // Damage sale report market value
              'sumMarketValueTotal': 'market_value_total',       // Total loss report market value
              'sumMarketValueLegal': 'market_value_legal',       // Legal loss report market value
              
              // PRIVATE REPORT SPECIFIC FIELDS  
              'sumClaim': 'total_claim',
              'sumVAT': 'vat',
              'sumTotalClaim': 'total_with_vat',
              'depCompensation': 'dep_compensation',
              
              // DAMAGED SALE VARIANT SPECIFIC FIELDS
              'saleValueDamage': 'sale_value_damaged',           // Manual input: sale value in damaged state
              'paymentMethod': 'paymentMethod',                  // Manual input: payment method for damaged sale
              'afterSaleDamage': 'total_after_sale_damage',      // Calculated: market value - sale value
              
              // TOTAL LOSS VARIANT SPECIFIC FIELDS  
              'salvageValueTotal': 'salvage_value_total',        // Manual input: salvage value for total loss
              'storageValueTotal': 'storage_towing_value_total', // Manual input: storage/towing costs
              'afterSaleTotal': 'total_after_salvage_total',     // Calculated: market value - salvage + storage
              
              // LEGAL LOSS VARIANT SPECIFIC FIELDS
              'salvageValueLegal': 'salvage_value_legal',        // Manual input: salvage value for legal loss
              'afterSaleLegal': 'total_after_salvage_legal',     // Calculated: market value - salvage
              
              // LEGACY FIELDS (maintain compatibility)
              'salvageValue': 'salvage_value'                    // General salvage value field
            };
            
            // Map field to helper structure
            const mappedKey = comprehensiveMapping[fieldId];
            if (mappedKey) {
              helper.final_report.summary[mappedKey] = value;
              console.log(`📊 Updated summary field: ${fieldId} -> ${mappedKey} = "${value}"`);
            } else {
              console.warn(`⚠️ No mapping found for field: ${fieldId}`);
            }
          }
        }
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Trigger floating screen updates when helper changes
        triggerFloatingScreenRefresh();
        
        // Update page title if plate changed
        if (fieldId === 'carPlate') {
          // Standardize plate format
          const standardizedValue = value && value !== '...' ? String(value).replace(/[-\s]/g, '') : (value || '...');
          document.getElementById('pageTitle').textContent = `רכב מס. ${standardizedValue}`;
        }
        
        // Update legal text with new data
        loadLegalText().catch(console.error);
        
        // Special handling for salvage value changes
        if (fieldId === 'salvageValue') {
          console.log('Salvage value updated:', value);
        }
        
        // Trigger calculations if field affects calculations
        const calculationFields = ['basicPrice', 'carBasePrice', 'carMarketValue', 'totalClaim'];
        if (calculationFields.includes(fieldId)) {
          setTimeout(() => {
            if (window.FinalReportCalculations && typeof window.FinalReportCalculations.refresh3BulkCalculations === 'function') {
              window.FinalReportCalculations.refresh3BulkCalculations();
            }
          }, 100);
        }
        
      } catch (error) {
        console.error('Error updating helper from field:', error);
      }
    }

    // ✅ STANDARDIZED CLAIMS DATA MAPPING FUNCTION
    function updateClaimsDataFromField(element, claimsKey) {
      try {
        const helper = window.helper || {};
        if (!helper.claims_data) helper.claims_data = {};
        
        let value = element.value;
        const fieldId = element.id;
        
        console.log(`💰 Claims data field change: ${fieldId} -> claims_data.${claimsKey} = "${value}"`);
        
        // Format currency fields
        if (claimsKey === 'authorized_claim' && value) {
          // Remove existing currency symbols and format properly
          value = value.replace(/[₪,]/g, '').trim();
          if (value && !isNaN(value)) {
            const numericValue = parseInt(value);
            value = `₪${numericValue.toLocaleString()}`;
          }
        }
        
        // Update claims_data
        helper.claims_data[claimsKey] = value;
        
        // Also update calculations.authorized_claim when authorized_claim is updated
        if (claimsKey === 'authorized_claim') {
          if (!helper.calculations) helper.calculations = {};
          helper.calculations.authorized_claim = value;
        }
        
        // Save to helper
        window.helper = helper;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log(`✅ Updated claims_data.${claimsKey} = "${value}"`);
        
        // Trigger floating screen refresh
        if (typeof triggerFloatingScreenRefresh === 'function') {
          triggerFloatingScreenRefresh();
        }
        
      } catch (error) {
        console.error('Error updating claims data:', error);
      }
    }

    // Update helper from contact field - delegates to updateHelperFromField
    function updateHelperFromContactField(element) {
      const event = { target: element };
      updateHelperFromField(event);
    }

    // Copied from estimator-builder.html - dynamic sign handling
    function getDropdownTypeFromValues(percentValue, amountValue, currentType) {
      // Priority: Check percent first, then amount
      let numericValue = null;
      
      if (percentValue !== null && percentValue !== undefined && percentValue !== '' && !isNaN(percentValue)) {
        numericValue = parseFloat(percentValue);
      } else if (amountValue !== null && amountValue !== undefined && amountValue !== '' && !isNaN(amountValue)) {
        numericValue = parseFloat(amountValue);
      }
      
      // If we have a numeric value, determine type based on sign
      if (numericValue !== null && numericValue !== 0) {
        return numericValue < 0 ? 'minus' : 'plus';
      }
      
      // Fall back to current type or default to 'plus'
      return currentType || 'plus';
    }

    // ✅ STANDARDIZED CLAIMS DATA MAPPING - Load from helper to UI
    function loadClaimsDataToUI() {
      try {
        const helper = window.helper || {};
        const claimsData = helper.claims_data || {};
        
        // Insurance authorization field
        const insuranceField = document.getElementById('insuranceAuthorization');
        if (insuranceField && claimsData.authorized_claim) {
          insuranceField.value = claimsData.authorized_claim;
        }
        
        console.log('✅ Claims data loaded to UI fields');
        
      } catch (error) {
        console.error('Error loading claims data to UI:', error);
      }
    }

    // UPDATE REPORT TYPE
    function updateReportType() {
      const reportTypeSelect = document.getElementById('reportType');
      const selectedType = reportTypeSelect?.value || 'חוות דעת פרטית';
      
      console.log('🔄 Updating report type to:', selectedType);
      
      // Hide all summary sections first
      const summaryBlocks = document.querySelectorAll('.summary-block');
      summaryBlocks.forEach(block => block.style.display = 'none');
      
      // Show the correct summary section based on selected type
      let summaryId = '';
      switch(selectedType) {
        case 'חוות דעת פרטית':
          summaryId = 'summaryPrivate';
          break;
        case 'חוות דעת גלובלית':
          summaryId = 'summaryGlobal';
          break;
        case 'חוות דעת מכירה מצבו הניזוק':
          summaryId = 'summaryDamage';
          break;
        case 'חוות דעת טוטלוסט':
          summaryId = 'summaryTotalLoss';
          break;
        case 'חוות דעת אובדן להלכה':
          summaryId = 'summaryLegalLoss';
          break;
        default:
          summaryId = 'summaryPrivate';
      }
      
      // Show the selected summary section
      const selectedSummary = document.getElementById(summaryId);
      if (selectedSummary) {
        selectedSummary.style.display = 'block';
        console.log('✅ Showing summary section:', summaryId);
        
        // 🔧 FIX: Refresh summary content after changing report type
        refreshSummary();
        console.log('🔄 Summary content refreshed for report type:', selectedType);
      } else {
        console.warn('⚠️ Summary section not found:', summaryId);
      }
    }


    // LOAD LEGAL TEXT USING CENTRALIZED ENGINE
    async function loadLegalText() {
      const reportTypeSelect = document.getElementById('reportType');
      const reportType = reportTypeSelect?.value || 'חוות דעת פרטית';
      
      console.log('🔄 Loading legal text for report type:', reportType);
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Collect values for placeholder replacement
      const placeholderValues = {
        plate: document.getElementById('carPlate')?.value || helper.meta?.plate,
        manufacturer: document.getElementById('carManufacturer')?.value || helper.car_details?.manufacturer,
        model: document.getElementById('carModel')?.value || helper.car_details?.model,
        year: document.getElementById('carYear')?.value || helper.car_details?.year,
        ownerName: document.getElementById('ownerName')?.value || helper.client?.name,
        modelCode: document.getElementById('carModelCode')?.value || helper.car_details?.model_code || helper.levi_report?.model_code,
        damagePercent: document.getElementById('grossPercent')?.value || helper.claims_data?.gross_percent || calculateDamagePercentage() || helper.expertise?.calculations?.damage_percent,
        depreciation: document.getElementById('globalDep1')?.value || helper.final_report?.depreciation?.global_percent,
        damageCenters: (() => {
          // Primary source: damage_assessment.total_centers
          if (helper.damage_assessment?.total_centers) {
            return helper.damage_assessment.total_centers.toString();
          }
          
          // Fallback: Try multiple sources for damage centers count
          if (helper.damage_centers_summary && typeof helper.damage_centers_summary === 'object') {
            return Object.keys(helper.damage_centers_summary).filter(key => key.startsWith('Damage center')).length || 
                   Object.keys(helper.damage_centers_summary).length;
          }
          if (helper.damage_assessment?.comprehensive?.centers && typeof helper.damage_assessment.comprehensive.centers === 'object') {
            return Object.keys(helper.damage_assessment.comprehensive.centers).length;
          }
          if (helper.expertise?.damage_blocks?.length) {
            return helper.expertise.damage_blocks.length;
          }
          return '1'; // Default fallback
        })(),
        garageDays: document.getElementById('garageDays')?.value || helper.final_report?.work_days || helper.expertise?.depreciation?.work_days,
        carValue: document.getElementById('carMarketValue')?.value || document.getElementById('sumMarketValue')?.value || (helper.calculations?.full_market_value ? `₪${helper.calculations.full_market_value.toLocaleString()}` : undefined),
        salvageValue: (() => {
          // Check report type to determine correct salvage field
          const reportType = reportTypeSelect?.value || 'חוות דעת פרטית';
          let salvageInput;
          
          if (reportType === 'חוות דעת טוטלוסט') {
            // Total Loss variant uses salvageValueTotal
            salvageInput = document.getElementById('salvageValueTotal')?.value;
          } else if (reportType === 'חוות דעת אובדן להלכה') {
            // Legal Loss variant uses salvageValueLegal  
            salvageInput = document.getElementById('salvageValueLegal')?.value;
          } else {
            // Other variants use general salvageValue
            salvageInput = document.getElementById('salvageValue')?.value;
          }
          
          // Enhanced helper data fallback for variant-specific salvage values
          let helperSalvage = '';
          if (reportType === 'חוות דעת טוטלוסט') {
            helperSalvage = helper.final_report?.summary?.salvage_value_total ||
                           helper.final_report?.summary?.salvageValueTotal ||
                           helper.salvage_value_total_loss ||
                           helper.salvageValueTotal;
          } else if (reportType === 'חוות דעת אובדן להלכה') {
            helperSalvage = helper.final_report?.summary?.salvage_value_legal ||
                           helper.final_report?.summary?.salvageValueLegal ||
                           helper.salvage_value_legal_loss ||
                           helper.salvageValueLegal;
          } else {
            helperSalvage = helper.final_report?.summary?.salvage_value || 
                           helper.final_report?.salvage_value ||
                           helper.salvage_value;
          }
          
          let rawValue = '';
          if (salvageInput && salvageInput.trim() !== '' && salvageInput !== '₪0') {
            rawValue = salvageInput;
          } else if (helperSalvage && helperSalvage !== '₪0') {
            rawValue = helperSalvage;
          }
          
          // Remove existing currency symbols to prevent doubling
          if (rawValue) {
            rawValue = rawValue.replace(/₪|ש\"ח|ש״ח/g, '').trim();
            // Add clean currency formatting
            const numericValue = rawValue.replace(/[^\d.-]/g, '');
            if (numericValue) {
              return `₪${Number(numericValue).toLocaleString()}`;
            }
          }
          return undefined;
        })(),
        compensation: (() => {
          // For Global variant - prioritize final_report.summary.global_before_differentials
          const globalSummary = helper.final_report?.summary?.global_before_differentials;
          const depCompField = document.getElementById('depCompensation')?.value;
          const helperComp = helper.final_report?.summary?.dep_compensation;
          const globalDepValue = helper.depreciation?.globalDepValue;
          
          let rawValue = '';
          if (globalSummary && globalSummary !== '₪0') {
            rawValue = globalSummary;
          } else if (depCompField && depCompField.trim() !== '' && depCompField !== '₪0') {
            rawValue = depCompField;
          } else if (helperComp && helperComp !== '₪0') {
            rawValue = helperComp;
          } else if (globalDepValue) {
            rawValue = `₪${globalDepValue.toLocaleString()}`;
          }
          
          // Remove existing currency symbols to prevent doubling
          if (rawValue) {
            rawValue = rawValue.replace(/₪|ש\"ח|ש״ח/g, '').trim();
            // Add clean currency formatting
            const numericValue = rawValue.replace(/[^\d.-]/g, '');
            if (numericValue) {
              return `₪${Number(numericValue).toLocaleString()}`;
            }
          }
          return undefined;
        })(),
        salePrice: (() => {
          // For Damaged Sale variant - use saleValueDamage field
          const saleField = document.getElementById('saleValueDamage')?.value;
          const helperSale = helper.final_report?.summary?.sale_value_damaged;
          
          let rawValue = '';
          if (saleField && saleField.trim() !== '' && saleField !== '₪0') {
            rawValue = saleField;
          } else if (helperSale && helperSale !== '₪0') {
            rawValue = helperSale;
          }
          
          // Remove existing currency symbols to prevent doubling
          if (rawValue) {
            rawValue = rawValue.replace(/₪|ש\"ח|ש״ח/g, '').trim();
            // Add clean currency formatting
            const numericValue = rawValue.replace(/[^\d.-]/g, '');
            if (numericValue) {
              return `₪${Number(numericValue).toLocaleString()}`;
            }
          }
          return undefined;
        })(),
        paymentMethod: (() => {
          // For Damaged Sale variant - payment method from UI field
          const paymentField = document.getElementById('paymentMethod')?.value;
          const helperPayment = helper.final_report?.summary?.paymentMethod;
          
          if (paymentField && paymentField.trim() !== '') {
            return paymentField.trim();
          } else if (helperPayment && helperPayment.trim() !== '') {
            return helperPayment;
          }
          return undefined;
        })()
      };
      
      try {
        // Use the centralized legal text engine
        const legalText = await window.LegalTextEngine.getProcessedText(
          reportType, 
          placeholderValues, 
          'final_report'
        );
        
        const legalTextElement = document.getElementById('legal-text-content');
        if (legalTextElement) {
          legalTextElement.value = legalText;
          console.log('✅ Legal text loaded successfully from vault for:', reportType);
        } else {
          console.error('❌ Legal text element not found: legal-text-content');
        }
        
      } catch (error) {
        console.error('❌ Error loading legal text:', error);
        const legalTextElement = document.getElementById('legal-text-content');
        if (legalTextElement) {
          legalTextElement.value = 'שגיאה בטעינת טקסט משפטי מהכספת - אנא בדוק את החיבור';
        }
      }
    }

    // LOAD LEGAL TEXT FROM VAULT - SEPARATE FUNCTION FOR BUTTON
    function loadLegalTextFromVault() {
      try {
        loadLegalText().then(() => {
          // Save the legal text to helper after it's been loaded
          setTimeout(() => {
            try {
              const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
              
              // Initialize final_report object if it doesn't exist
              if (!helper.final_report) {
                helper.final_report = {};
              }
              
              const legalTextElement = document.getElementById('legal-text-content');
              if (legalTextElement && legalTextElement.value) {
                helper.final_report.legal_text = legalTextElement.value;
                sessionStorage.setItem('helper', JSON.stringify(helper));
                console.log('✅ Legal text loaded from vault and saved to final report');
              } else {
                console.error('❌ Legal text element not found or empty');
              }
            } catch (error) {
              console.error('❌ Error saving legal text to helper:', error);
            }
          }, 100);
        }).catch(error => {
          console.error('❌ Error loading legal text from vault:', error);
        });
      } catch (error) {
        console.error('❌ Error in loadLegalTextFromVault:', error);
      }
    }

    // Save legal text after report type or other changes
    function saveLegalTextAfterChange() {
      // Wait for legal text to be loaded, then save to helper
      setTimeout(() => {
        const legalTextArea = document.getElementById('legal-text-content');
        if (legalTextArea && legalTextArea.value && legalTextArea.value.trim() !== '') {
          const helper = window.helper || {};
          
          // Initialize final_report object if it doesn't exist
          if (!helper.final_report) {
            helper.final_report = {};
          }
          helper.final_report.legal_text = legalTextArea.value;
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
          updateBuilderCurrentState('final_report.legal_text', legalTextArea.value);
          
          console.log('✅ Legal text updated and saved to helper after report type change');
        }
      }, 1500); // Wait longer for legal text engine to load new content
    }

    // RESET LEGAL TEXT
    function resetLegalText() {
      const reportTypeSelect = document.getElementById('reportType');
      const reportType = reportTypeSelect?.value || 'חוות דעת פרטית';
      // Map report type to display text
      let typeText = 'פרטית';
      switch(reportType) {
        case 'חוות דעת פרטית':
          typeText = 'פרטית';
          break;
        case 'חוות דעת גלובלית':
          typeText = 'גלובלית';
          break;
        case 'חוות דעת מכירה מצבו הניזוק':
          typeText = 'מכירה מצבו הניזוק';
          break;
        case 'חוות דעת טוטלוסט':
          typeText = 'טוטלוסת';
          break;
        case 'חוות דעת אובדן להלכה':
          typeText = 'אובדן להלכה';
          break;
      }
      
      document.getElementById('legal-text-content').value = `טקסט משפטי לחוות דעת סופית ${typeText} - מוכן לעריכה`;
      
      // Clear saved legal text from helper
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (helper.final_report) {
        delete helper.final_report.legal_text;
      }
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      console.log('Legal text reset');
    }

    // LOAD ATTACHMENTS FROM VAULT
    async function loadAttachmentsFromVault() {
      console.log('🔵 loadAttachmentsFromVault function called');
      
      try {
        // Get selected type from dropdown
        const reportTypeSelect = document.getElementById('reportType');
        console.log('🔵 reportTypeSelect element:', reportTypeSelect);
        
        const reportType = reportTypeSelect?.value || 'חוות דעת פרטית';
        console.log('📎 Loading attachments from vault for type:', reportType);
        
        // Use the legal text engine to get attachments from the actual vault
        if (window.LegalTextEngine) {
          console.log('🔵 LegalTextEngine is available');
          const attachmentsText = await window.LegalTextEngine.getAttachments(reportType);
          
          const attachmentsElement = document.getElementById('attachments-content');
          console.log('🔵 attachments-content element:', attachmentsElement);
          
          if (attachmentsElement) {
            attachmentsElement.value = attachmentsText;
            console.log('🔵 Attachments text set to textarea');
          } else {
            console.error('❌ attachments-content element not found');
          }
          
          // Save to helper and LOCK the selection
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          if (!helper.final_report) helper.final_report = {};
          helper.final_report.attachments = attachmentsText;
          helper.final_report.attachments_locked = true; // Lock the selection
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          console.log('✅ Attachments loaded from vault using LegalTextEngine and LOCKED');
        } else {
          console.error('❌ LegalTextEngine not available');
          // Fallback to hardcoded with חשכ"ט
          const fallbackText = '**לוטה**\nתצלומי הרכב הניזוק\nחשבוניות תיקון\nערך רכב ממוחשב\nצילום רישיון הרכב\nחשכ"ט';
          document.getElementById('attachments-content').value = fallbackText;
        }
      } catch (error) {
        console.error('❌ Error loading attachments from vault:', error);
        // Fallback to default with חשכ"ט
        const fallbackText = '**לוטה**\nתצלומי הרכב הניזוק\nחשבוניות תיקון\nערך רכב ממוחשב\nצילום רישיון הרכב\nחשכ"ט';
        document.getElementById('attachments-content').value = fallbackText;
      }
    }

    // RESET ATTACHMENTS
    function resetAttachments() {
      try {
        // Reset to default attachments
        const defaultAttachments = '**לוטה**\nתצלומי הרכב הניזוק\nחשבוניות תיקון\nערך רכב ממוחשב\nצילום רישיון הרכב\nחשכ"ט';
        document.getElementById('attachments-content').value = defaultAttachments;
        
        // Clear from helper safely
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (!helper.final_report) helper.final_report = {};
        delete helper.final_report.attachments;
        delete helper.final_report.attachments_locked;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('✅ Attachments reset to default list');
      } catch (error) {
        console.error('❌ Error resetting attachments:', error);
      }
    }

    // LOAD ATTACHMENTS DATA FROM HELPER
    function loadAttachmentsData() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Load saved attachments if they exist and are locked
      if (helper.final_report?.attachments && helper.final_report?.attachments_locked) {
        const attachmentsElement = document.getElementById('attachments-content');
        if (attachmentsElement) {
          attachmentsElement.value = helper.final_report.attachments;
          console.log('📎 Loaded LOCKED attachments from helper - will not revert to default');
        }
      } else if (helper.final_report?.attachments) {
        const attachmentsElement = document.getElementById('attachments-content');
        if (attachmentsElement) {
          attachmentsElement.value = helper.final_report.attachments;
          console.log('📎 Loaded saved attachments from helper (not locked)');
        }
      } else {
        console.log('📎 No saved attachments found, keeping default');
      }
    }

    // ADD GLOBAL DEPRECIATION CALCULATION
    function updateGlobalDepreciationCalculation() {
      const globalDepInput = document.getElementById('globalDep1');
      const globalDepValueInput = document.getElementById('globalDepValue');
      
      if (globalDepInput && globalDepValueInput) {
        globalDepInput.addEventListener('input', function() {
          // Clean the value to extract the numeric part
          const cleanValue = this.value.replace('%', '').replace(/[^0-9.-]/g, '');
          let percent = parseFloat(cleanValue) || 0;
          
          // Keep value as clean decimal number without % sign
          this.value = cleanValue;
          
          // Calculate value from market price automatically - try multiple sources
          let marketValue = 0;
          
          // First try summary market value (priority)
          const sumMarketValueField = document.getElementById('sumMarketValue');
          if (sumMarketValueField && sumMarketValueField.value) {
            const sumMarketStr = sumMarketValueField.value.replace(/[₪,]/g, '') || '0';
            marketValue = parseFloat(sumMarketStr) || 0;
          }
          
          // If no summary value, try car details market value
          if (marketValue === 0) {
            const carMarketValueField = document.getElementById('carMarketValue');
            if (carMarketValueField && carMarketValueField.value) {
              const carMarketStr = carMarketValueField.value.replace(/[₪,]/g, '') || '0';
              marketValue = parseFloat(carMarketStr) || 0;
            }
          }
          
          console.log('Global depreciation calculation:', {
            percent,
            marketValue,
            calculation: (marketValue * percent) / 100
          });
          
          const calculatedValue = (marketValue * percent) / 100;
          globalDepValueInput.value = calculatedValue ? `₪${Math.round(calculatedValue).toLocaleString()}` : '';
          
          // TRIGGER SUMMARY UPDATE when global depreciation value changes
          if (window.addSummaryCalculationListeners) {
            const sumCalculate = document.querySelector('[data-summary-calculate]');
            if (sumCalculate) {
              sumCalculate.click();
            }
          }
          
          // Direct trigger for summary calculations
          setTimeout(() => {
            const event = new Event('input', { bubbles: true });
            globalDepValueInput.dispatchEvent(event);
          }, 100);
        });
      }
    }
    
    // CALCULATE DAMAGE PERCENTAGE
    function calculateDamagePercentage() {
      try {
        const totalClaim = parseFloat(document.getElementById('sumClaim')?.value.replace(/[₪,]/g, '') || '0') || 0;
        
        // Try to get vehicle_value_gross from helper first (gross market value for damage calculation)
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        const vehicleValueGross = helper.calculations?.vehicle_value_gross || 0;
        
        // Fallback to market value if vehicle_value_gross not available
        const marketValue = parseFloat(document.getElementById('sumMarketValue')?.value.replace(/[₪,]/g, '') || '0') || 0;
        const calculationBase = vehicleValueGross > 0 ? vehicleValueGross : marketValue;
        
        if (calculationBase > 0 && totalClaim > 0) {
          const percentage = (totalClaim / calculationBase) * 100;
          console.log(`📊 Damage percentage calculation: ${totalClaim.toLocaleString()} ÷ ${calculationBase.toLocaleString()} = ${Math.round(percentage)}%`);
          return Math.round(percentage) + '%';
        }
        return '[אחוז נזק]';
      } catch (error) {
        return '[אחוז נזק]';
      }
    }

    // UPDATE GROSS MARKET VALUE FIELD
    function updateGrossMarketValueField() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        let vehicleValueGross = helper.calculations?.vehicle_value_gross;
        
        console.log('🔍 Checking vehicle_value_gross:', {
          helper_calculations: helper.calculations,
          vehicle_value_gross: vehicleValueGross,
          levi_report_final_price: helper.levi_report?.final_price,
          expertise_calculations: helper.expertise?.calculations
        });
        
        // If vehicle_value_gross is missing, try to calculate it from Levi data
        if (!vehicleValueGross && helper.levi_report) {
          const leviReport = helper.levi_report;
          const basePrice = parseFloat(leviReport.base_price || 0);
          const featuresValue = parseFloat(leviReport.features_value || 0);
          const registrationValue = parseFloat(leviReport.registration_value || 0);
          
          if (basePrice > 0) {
            vehicleValueGross = basePrice + featuresValue + registrationValue;
            console.log(`🔧 Calculated vehicle_value_gross from Levi data: ${basePrice} + ${featuresValue} + ${registrationValue} = ${vehicleValueGross}`);
            
            // Update helper with calculated value
            helper.calculations = helper.calculations || {};
            helper.calculations.vehicle_value_gross = vehicleValueGross;
            sessionStorage.setItem('helper', JSON.stringify(helper));
          }
        }
        
        // If still no value, try other fallbacks
        if (!vehicleValueGross) {
          const fallbackSources = [
            helper.levi_report?.final_price,
            helper.expertise?.calculations?.market_value,
            helper.expertise?.calculations?.vehicle_value_gross,
            helper.levisummary?.final_price
          ];
          
          for (const fallback of fallbackSources) {
            if (fallback && fallback > 0) {
              vehicleValueGross = fallback;
              console.log(`🔧 Using fallback for vehicle_value_gross: ${vehicleValueGross}`);
              break;
            }
          }
        }
        
        // Update the field if we have a value
        if (vehicleValueGross && vehicleValueGross > 0) {
          const leviPriceListField = document.getElementById('leviPriceList');
          if (leviPriceListField) {
            leviPriceListField.value = `₪${vehicleValueGross.toLocaleString()}`;
            
            // Update helper claims data to maintain consistency
            helper.claims_data = helper.claims_data || {};
            helper.claims_data.gross_value = `₪${vehicleValueGross.toLocaleString()}`;
            sessionStorage.setItem('helper', JSON.stringify(helper));
            
            console.log(`💰 Updated gross market value field: ₪${vehicleValueGross.toLocaleString()}`);
          }
        } else {
          console.log('ℹ️ vehicle_value_gross not found - will be calculated when needed');
        }
        
        // Do NOT call updateGrossPercentageField here to avoid infinite loop
      } catch (error) {
        console.error('Error updating gross market value field:', error);
      }
    }

    // LOAD GROSS ADJUSTMENTS FROM helper.estimate.adjustments
    function loadGrossAdjustments(helper, forceReload = false) {
      try {

        const featuresContainer = document.getElementById('featuresAdjustmentsList');
        const registrationContainer = document.getElementById('registrationAdjustmentsList');

        if (featuresContainer) featuresContainer.innerHTML = '';
        if (registrationContainer) registrationContainer.innerHTML = '';

        // Use SINGLE CLEAN SOURCE like reloadGrossAdjustments: estimate.adjustments || valuation.adjustments
        const adjustments = helper.estimate?.adjustments || helper.valuation?.adjustments || {};
        
        console.log('📍 Loading from: estimate.adjustments → valuation.adjustments (clean single source)');
        console.log('🔍 Available adjustments data:', adjustments);
        
        // Load features and registration only (matching reloadGrossAdjustments)
        const categories = [
          { key: 'features', addFunction: addFeatureAdjustment, container: featuresContainer },
          { key: 'registration', addFunction: addRegistrationAdjustment, container: registrationContainer }
        ];
        
        categories.forEach(({ key, addFunction, container }) => {
          const finalReportData = helper.final_report?.adjustments?.[key] || [];
          const estimateData = adjustments[key];
          const deletedItems = helper.grossSectionDeletedItems?.[key] || [];
          
          let categoryData;
          // Always use final_report if it has data (preserves user changes)
          if (Array.isArray(finalReportData) && finalReportData.length > 0) {
            console.log(`📝 Loading ${key} from final_report (has ${finalReportData.length} items)`);
            categoryData = finalReportData;
          } else if (estimateData && !forceReload) {
            // Filter out deleted items from estimate data
            const filteredData = Array.isArray(estimateData) ? estimateData : [estimateData];
            categoryData = filteredData.filter(item => {
              const isDeleted = deletedItems.some(deleted => 
                deleted.value === item.value || deleted.description === item.description
              );
              return !isDeleted;
            });
            console.log(`📝 Loading ${key} from estimate (${categoryData.length} items after filtering deleted)`);
          } else {
            console.log(`📝 Loading ${key} from estimate.adjustments (full reload)`);
            categoryData = estimateData;
          }
          
          if (categoryData && container) {
            console.log(`📝 Loading ${key} adjustments:`, categoryData);
            
            // Handle both array and single object data
            const items = Array.isArray(categoryData) ? categoryData : (categoryData && (categoryData.percent || categoryData.percentage || categoryData.amount) ? [categoryData] : []);
            
            items.forEach((item, index) => {
              if (item && (item.percent || item.percentage || item.amount || item.value)) {
                // Add new row
                addFunction();
                
                // Fill the data
                const rows = container.querySelectorAll('div[id*="Adj_"]');
                const lastRow = rows[rows.length - 1];
                
                if (lastRow) {
                  const inputs = lastRow.querySelectorAll('input, select');
                  if (inputs.length >= 4) {
                    // Field mapping: value → תיאור (description) - PRESERVE FULL TEXT
                    inputs[0].value = item.value || '';
                    
                    // Type dropdown - use stored type directly
                    const itemPercent = item.percentage || item.percent;
                    const itemAmount = item.amount;
                    const storedType = item.type || 'plus';
                    if (storedType === 'minus' || storedType === 'הפחתה' || storedType === 'הפחתה (-)') {
                      inputs[1].value = 'minus';
                    } else if (storedType === 'plus' || storedType === 'תוספת' || storedType === 'תוספת (+)') {
                      inputs[1].value = 'plus';
                    } else {
                      inputs[1].value = storedType; // For % or ₪ types
                    }
                    
                    // Percent and amount - preserve sign based on type
                    inputs[2].value = itemPercent ? Math.abs(itemPercent) : '';
                    
                    // FIXED: Preserve amount display properly
                    if (item.amount_display) {
                      inputs[3].value = item.amount_display;
                    } else if (item.amount !== undefined && item.amount !== 0) {
                      const absAmount = Math.abs(item.amount);
                      inputs[3].value = `₪${absAmount.toLocaleString()}`;
                    } else {
                      inputs[3].value = '';
                    }
                    
                    // Trigger change events
                    inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
                    if (inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
                    if (inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
                    
                    // Call formatAdjustmentDisplay to ensure proper sign display
                    formatAdjustmentDisplay(lastRow, inputs[1].value, itemPercent, itemAmount);
                    
                    // Mark source as original for page refresh loads
                    lastRow.setAttribute('data-source', 'original');
                    
                    console.log(`✅ Loaded ${key} item ${index}:`, {
                      description: inputs[0].value,
                      type: inputs[1].value,
                      percent: itemPercent,
                      amount: itemAmount
                    });
                  }
                }
              }
            });
          }
        });
        
        // Trigger calculations after loading
        setTimeout(() => {
          updateGrossMarketValueCalculation();
          console.log('✅ Gross adjustments loaded from clean single source');
        }, 100);
        
      } catch (error) {
        console.error('❌ Error loading gross adjustments:', error);
      }
    }
    
    // LOAD TOTAL VALUE SECTION ADJUSTMENTS FROM final_report.adjustments
    function loadTotalValueSectionAdjustments(helper) {
      try {
        console.log('🔄 Auto-loading Total Value Section with mixed data sources');
        
        // Mixed data sources (EXACT same as reload button):
        // - Features & Registration: from final_report.adjustments (sync with Gross section)  
        // - Others (KM, Ownership, Owners, Additional): from estimate.adjustments with valuation fallback
        const estimateAdjustments = helper.estimate?.adjustments || helper.valuation?.adjustments || {};
        const finalReportAdjustments = helper.final_report?.adjustments || {};
        
        console.log('📦 estimate.adjustments:', estimateAdjustments);
        console.log('📦 final_report.adjustments:', finalReportAdjustments);
        console.log('📦 helper.valuation.adjustments:', helper.valuation?.adjustments);
        console.log('📦 helper.valuation.adjustments keys:', Object.keys(helper.valuation?.adjustments || {}));
        
        // Helper function to create adjustment row
        function createTotalValueRow(adj, category, source) {
          const rowId = category === 'additional' ? `fullAdj_${Date.now()}` : `totalValue_${category}_${Date.now()}_${Math.random()}`;
          
          // DEBUG: Log the actual adjustment data being processed
          console.log(`🔍 DEBUG createTotalValueRow for ${category} from ${source}:`, {
            fullAdjustment: adj,
            type: adj.type,
            percent: adj.percent,
            percentage: adj.percentage,
            amount: adj.amount,
            value: adj.value
          });
          
          // Determine the type based on adjustment data
          let selectedType = '%'; // default
          
          // Get values for analysis
          const percentValue = adj.percent || adj.percentage || 0;
          const amountValue = adj.amount || 0;
          
          // First, determine if it's plus or minus based on values
          const isNegative = percentValue < 0 || amountValue < 0;
          
          // FIX: Use stored type directly, don't detect from values
          const itemPercent = adj.percentage || adj.percent;
          const itemAmount = adj.amount;
          const storedType = adj.type || 'plus';
          
          // DEBUG: Log type loading for ownership_history
          if (category === 'ownership_history') {
            console.log(`🔍 OWNERSHIP_HISTORY TYPE LOADING:`, {
              category,
              source,
              storedType,
              fullAdjustment: adj
            });
          }
          
          // Map stored type to dropdown value
          if (storedType === 'minus' || storedType === 'הפחתה' || storedType === 'הפחתה (-)') {
            selectedType = 'minus';
          } else if (storedType === 'plus' || storedType === 'תוספת' || storedType === 'תוספת (+)') {
            selectedType = 'plus';
          } else {
            // Default to plus if type is unclear
            selectedType = 'plus';
          }
          
          // DEBUG: Log final type selection for ownership_history
          if (category === 'ownership_history') {
            console.log(`🎯 OWNERSHIP_HISTORY FINAL TYPE: ${storedType} → ${selectedType}`);
          }
          
          
          const description = adj.value || adj.description || '';
          // Escape HTML entities to preserve special characters
          const escapedDescription = description
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
          // Populate percentage and amount from adjustment data (handle negative values properly)
          let percentage = '';
          let amount = '';
          
          // CRITICAL FIX: Percentage should always show positive in UI, type dropdown controls sign
          if (itemPercent !== undefined && itemPercent !== null && itemPercent !== '') {
            let cleanPercent = itemPercent;
            if (typeof itemPercent === 'string') {
              cleanPercent = itemPercent.replace('%', '');
            }
            const parsedPercent = parseFloat(cleanPercent);
            // ALWAYS show positive percentage - type dropdown controls the actual sign
            percentage = !isNaN(parsedPercent) ? Math.abs(parsedPercent) : '';
            console.log(`🔧 PERCENTAGE FIX: original=${parsedPercent}, displayed=${percentage}, type=${selectedType}`);
          } else {
            percentage = '';
          }
          
          // PRESERVE SIGN - don't use Math.abs() 
          if (adj.amount_display) {
            amount = adj.amount_display;
          } else if (adj.amount) {
            const amountValue = parseFloat(adj.amount);
            if (amountValue < 0) {
              amount = `-₪${Math.abs(amountValue).toLocaleString()}`;
            } else {
              amount = `₪${amountValue.toLocaleString()}`;
            }
          } else {
            amount = '';
          }
          
          // Make features and registration read-only in Total Market Value section
          const isReadOnlyCategory = (category === 'features' || category === 'registration');
          const readOnlyAttr = isReadOnlyCategory ? 'readonly' : '';
          const readOnlyStyle = isReadOnlyCategory ? ' background: #f8f9fa; color: #6c757d;' : '';
          const disabledAttr = isReadOnlyCategory ? 'disabled' : '';
          
          console.log(`🔒 Making ${category} read-only in Total Market Value: ${isReadOnlyCategory}`);
          
          const html = `
            <div id="${rowId}" class="adjustment-row" data-source="${source}">
              <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
                <div><input type="text" placeholder="תיאור התאמה" value="${escapedDescription}" ${readOnlyAttr} style="${readOnlyStyle}" ${isReadOnlyCategory ? '' : `onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, '${category}');"`} /></div>
                <div>
                  ${category === 'additional' ? 
                    `<select ${disabledAttr} style="${readOnlyStyle}" ${isReadOnlyCategory ? '' : `onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, '${category}');"`}>
                      <option value="plus" ${adj.type === 'plus' || selectedType === 'תוספת (+)' ? 'selected' : ''}>תוספת (+)</option>
                      <option value="minus" ${adj.type === 'minus' || selectedType === 'הפחתה (-)' ? 'selected' : ''}>הפחתה (-)</option>
                    </select>` :
                    `<select ${disabledAttr} style="${readOnlyStyle}" ${isReadOnlyCategory ? '' : `onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, '${category}');"`}>
                      <option value="plus" ${selectedType === 'plus' ? 'selected' : ''}>תוספת (+)</option>
                      <option value="minus" ${selectedType === 'minus' ? 'selected' : ''}>הפחתה (-)</option>
                    </select>`
                  }
                </div>
                <div><input type="text" placeholder="אחוז" value="${percentage}" ${readOnlyAttr} style="direction: ltr; text-align: right;${readOnlyStyle}" ${isReadOnlyCategory ? '' : `onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, '${category}');"`} /></div>
                <div><input type="text" placeholder="ערך" value="${amount}" ${readOnlyAttr} style="direction: ltr; text-align: right;${readOnlyStyle}" ${isReadOnlyCategory ? '' : `onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, '${category}');"`} /></div>
                <div>
                  ${isReadOnlyCategory ? 
                    '<span style="color: #6c757d; font-size: 12px;">קריאה בלבד</span>' : 
                    `<button class="btn remove" type="button" onclick="removeAdjustmentRow('${rowId}')">הסר</button>`
                  }
                </div>
              </div>
              <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
                ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">${adj.cumulative ? `₪${adj.cumulative.toLocaleString()}` : '₪0'}</span>
              </div>
            </div>
          `;
          
          // Apply formatting after row is created AND trigger change events for consistency
          setTimeout(() => {
            const row = document.getElementById(rowId);
            if (row) {
              const inputs = row.querySelectorAll('input, select');
              if (inputs.length >= 4) {
                // Trigger change events (CRITICAL FOR MINUS SIGN DETECTION)
                inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
                if (inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
                if (inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
                
                // Also call formatAdjustmentDisplay directly as backup
                const itemPercent = adj.percentage || adj.percent;
                const itemAmount = adj.amount;
                formatAdjustmentDisplay(row, selectedType, itemPercent, itemAmount);
              }
            }
          }, 150);
          
          return html;
        }
        
        // 1. Load features from final_report.adjustments into fullFeaturesAdjustmentsList
        const featuresContainer = document.getElementById('fullFeaturesAdjustmentsList');
        if (featuresContainer) {
          featuresContainer.innerHTML = '';
          const features = finalReportAdjustments.features || [];
          console.log('📦 Loading features from final_report.adjustments:', features);
          if (Array.isArray(features)) {
            features.forEach((adj, index) => {
              console.log(`🔍 Processing features[${index}]:`, adj);
              // Load all non-empty items (check for any content)
              if (adj && (adj.value || adj.description || adj.percentage || adj.percent || adj.amount)) {
                const rowHtml = createTotalValueRow(adj, 'features', 'final_report');
                featuresContainer.insertAdjacentHTML('beforeend', rowHtml);
                
                // Update row cumulative if available from helper
                if (adj.cumulative !== undefined) {
                  setTimeout(() => {
                    const rows = featuresContainer.querySelectorAll('.adjustment-row');
                    const lastRow = rows[rows.length - 1];
                    const cumulativeSpan = lastRow?.querySelector('.row-cumulative');
                    if (cumulativeSpan) {
                      cumulativeSpan.textContent = `₪${Math.round(adj.cumulative).toLocaleString()}`;
                    }
                  }, 10);
                }
                console.log(`✅ Added features[${index}] to Total Value Section`);
              } else {
                console.log(`⚠️ Skipped features[${index}] - no content`);
              }
            });
          }
          console.log(`✅ Loaded ${features.length} total features, filtered and added to Total Value Section`);
        }
        
        // 2. Load registration from final_report.adjustments into fullRegistrationAdjustmentsList
        const registrationContainer = document.getElementById('fullRegistrationAdjustmentsList');
        if (registrationContainer) {
          registrationContainer.innerHTML = '';
          const registration = finalReportAdjustments.registration || [];
          console.log('📦 Loading registration from final_report.adjustments:', registration);
          if (Array.isArray(registration)) {
            registration.forEach((adj, index) => {
              console.log(`🔍 Processing registration[${index}]:`, adj);
              // Load all non-empty items (check for any content)
              if (adj && (adj.value || adj.description || adj.percentage || adj.percent || adj.amount)) {
                const rowHtml = createTotalValueRow(adj, 'registration', 'final_report');
                registrationContainer.insertAdjacentHTML('beforeend', rowHtml);
                
                // Update row cumulative if available from helper
                if (adj.cumulative !== undefined) {
                  setTimeout(() => {
                    const rows = registrationContainer.querySelectorAll('.adjustment-row');
                    const lastRow = rows[rows.length - 1];
                    const cumulativeSpan = lastRow?.querySelector('.row-cumulative');
                    if (cumulativeSpan) {
                      cumulativeSpan.textContent = `₪${Math.round(adj.cumulative).toLocaleString()}`;
                    }
                  }, 10);
                }
                console.log(`✅ Added registration[${index}] to Total Value Section`);
              } else {
                console.log(`⚠️ Skipped registration[${index}] - no content`);
              }
            });
          }
          console.log(`✅ Loaded ${registration.length} total registration, filtered and added to Total Value Section`);
        }
        
        // 3. Load KM from final_report.adjustments (priority) with fallback to estimate/valuation
        const mileageContainer = document.getElementById('mileageAdjustmentsList');
        if (mileageContainer) {
          mileageContainer.innerHTML = '';
          
          // FIXED: Load from final_report.adjustments FIRST (preserves manual additions)
          let mileage = finalReportAdjustments.mileage || [];
          let source = 'final_report';
          
          // Only fall back to estimate/valuation if final_report is empty
          if (!Array.isArray(mileage) || mileage.length === 0) {
            // Fallback to estimate.adjustments.mileage
            mileage = estimateAdjustments.mileage || [];
            source = 'estimate';
            
            if (!Array.isArray(mileage) || mileage.length === 0) {
              // Final fallback to valuation.adjustments.mileage
              console.log(`🔍 DEBUG: Checking valuation fallback for mileage`, helper.valuation?.adjustments);
              const valuationMileage = helper.valuation?.adjustments?.mileage;
              if (valuationMileage) {
                mileage = Array.isArray(valuationMileage) ? valuationMileage : [valuationMileage];
                source = 'original';
                console.log(`📦 Fallback: Loading mileage from valuation.adjustments:`, {
                  originalData: valuationMileage,
                  processedArray: mileage
                });
              } else {
                console.log(`📦 No mileage data in any source`);
              }
            } else {
              console.log(`📦 Loading mileage from estimate.adjustments:`, mileage);
            }
          } else {
            console.log(`📦 Loading mileage from final_report.adjustments (preserving manual additions):`, mileage);
          }
          
          if (Array.isArray(mileage)) {
            mileage.forEach((adj, index) => {
              if (adj && (adj.value || adj.percentage || adj.percent || adj.amount)) {
                const rowHtml = createTotalValueRow(adj, 'mileage', source);
                mileageContainer.insertAdjacentHTML('beforeend', rowHtml);
                
                // Update row cumulative if available from helper
                if (adj.cumulative !== undefined) {
                  setTimeout(() => {
                    const rows = mileageContainer.querySelectorAll('.adjustment-row');
                    const lastRow = rows[rows.length - 1];
                    const cumulativeSpan = lastRow?.querySelector('.row-cumulative');
                    if (cumulativeSpan) {
                      cumulativeSpan.textContent = `₪${Math.round(adj.cumulative).toLocaleString()}`;
                    }
                  }, 10);
                }
                console.log(`✅ Added mileage adjustment from ${source}:`, adj.value || 'no description');
              }
            });
          }
          console.log(`✅ Loaded ${mileage.length} mileage adjustments to Total Value Section from ${source}`);
        }
        
        // 4. Load ownership_type from final_report.adjustments (priority) with fallback to estimate/valuation
        const ownershipContainer = document.getElementById('ownershipAdjustmentsList');
        if (ownershipContainer) {
          ownershipContainer.innerHTML = '';
          
          // FIXED: Load from final_report.adjustments FIRST (preserves manual additions)
          let ownership = finalReportAdjustments.ownership_type || [];
          let source = 'final_report';
          
          // Only fall back to estimate/valuation if final_report is empty
          if (!Array.isArray(ownership) || ownership.length === 0) {
            // Fallback to estimate.adjustments.ownership_type
            ownership = estimateAdjustments.ownership_type || estimateAdjustments.ownership || [];
            source = 'estimate';
            
            if (!Array.isArray(ownership) || ownership.length === 0) {
              // Final fallback to valuation.adjustments.ownership_type
              console.log(`🔍 DEBUG: Checking valuation fallback for ownership_type`, helper.valuation?.adjustments);
              const valuationOwnership = helper.valuation?.adjustments?.ownership_type;
              if (valuationOwnership) {
                ownership = Array.isArray(valuationOwnership) ? valuationOwnership : [valuationOwnership];
                source = 'original';
                console.log(`📦 Fallback: Loading ownership from valuation.adjustments:`, {
                  originalData: valuationOwnership,
                  processedArray: ownership
                });
              } else {
                console.log(`📦 No ownership data in any source`);
              }
            } else {
              console.log(`📦 Loading ownership from estimate.adjustments:`, ownership);
            }
          } else {
            console.log(`📦 Loading ownership from final_report.adjustments (preserving manual additions):`, ownership);
          }
          
          if (Array.isArray(ownership)) {
            ownership.forEach((adj, index) => {
              if (adj && (adj.value || adj.percentage || adj.percent || adj.amount)) {
                const rowHtml = createTotalValueRow(adj, 'ownership_type', source);
                ownershipContainer.insertAdjacentHTML('beforeend', rowHtml);
                
                // Update row cumulative if available from helper
                if (adj.cumulative !== undefined) {
                  setTimeout(() => {
                    const rows = ownershipContainer.querySelectorAll('.adjustment-row');
                    const lastRow = rows[rows.length - 1];
                    const cumulativeSpan = lastRow?.querySelector('.row-cumulative');
                    if (cumulativeSpan) {
                      cumulativeSpan.textContent = `₪${Math.round(adj.cumulative).toLocaleString()}`;
                    }
                  }, 10);
                }
                console.log(`✅ Added ownership adjustment from ${source}:`, adj.value || 'no description');
              }
            });
          }
          console.log(`✅ Loaded ${ownership.length} ownership adjustments to Total Value Section from ${source}`);
        }
        
        // 5. Load ownership_history from final_report.adjustments (priority) with fallback to estimate/valuation
        const ownersContainer = document.getElementById('ownersAdjustmentsList');
        if (ownersContainer) {
          ownersContainer.innerHTML = '';
          
          // FIXED: Load from final_report.adjustments FIRST (preserves manual additions)
          let owners = finalReportAdjustments.ownership_history || [];
          let source = 'final_report';
          
          // DEBUG: Log ownership_history data source decision
          console.log(`🔍 OWNERSHIP_HISTORY DATA SOURCE CHECK:`, {
            finalReportOwners: finalReportAdjustments.ownership_history,
            ownersFallback: owners,
            estimateOwners: estimateAdjustments.owners,
            estimateOwnershipHistory: estimateAdjustments.ownership_history,
            willFallback: !Array.isArray(owners) || owners.length === 0
          });
          
          // CRITICAL FIX: Only fall back if final_report is truly empty AND not during save operations
          // This prevents overriding user edits during save process
          const shouldFallback = (!Array.isArray(owners) || owners.length === 0);
          
          if (shouldFallback) {
            console.log(`⚠️ OWNERSHIP_HISTORY: final_report is empty, falling back to estimate/valuation data`);
          } else {
            console.log(`✅ OWNERSHIP_HISTORY: Using final_report data (preserving user edits)`);
          }
          
          if (shouldFallback) {
            // Fallback to estimate.adjustments.ownership_history
            owners = estimateAdjustments.ownership_history || estimateAdjustments.owners || [];
            source = 'estimate';
            
            if (!Array.isArray(owners) || owners.length === 0) {
              // Final fallback to valuation.adjustments.ownership_history
              console.log(`🔍 DEBUG: Checking valuation fallback for ownership_history`, helper.valuation?.adjustments);
              const valuationOwners = helper.valuation?.adjustments?.ownership_history;
              if (valuationOwners) {
                owners = Array.isArray(valuationOwners) ? valuationOwners : [valuationOwners];
                source = 'original';
                console.log(`📦 Fallback: Loading owners from valuation.adjustments:`, {
                  originalData: valuationOwners,
                  processedArray: owners
                });
              } else {
                console.log(`📦 No owners data in any source`);
              }
            } else {
              console.log(`📦 Loading owners from estimate.adjustments:`, owners);
            }
          } else {
            console.log(`📦 Loading owners from final_report.adjustments (preserving manual additions):`, owners);
          }
          
          if (Array.isArray(owners)) {
            owners.forEach((adj, index) => {
              if (adj && (adj.value || adj.percentage || adj.percent || adj.amount)) {
                const rowHtml = createTotalValueRow(adj, 'ownership_history', source);
                ownersContainer.insertAdjacentHTML('beforeend', rowHtml);
                
                // Update row cumulative if available from helper
                if (adj.cumulative !== undefined) {
                  setTimeout(() => {
                    const rows = ownersContainer.querySelectorAll('.adjustment-row');
                    const lastRow = rows[rows.length - 1];
                    const cumulativeSpan = lastRow?.querySelector('.row-cumulative');
                    if (cumulativeSpan) {
                      cumulativeSpan.textContent = `₪${Math.round(adj.cumulative).toLocaleString()}`;
                    }
                  }, 10);
                }
                console.log(`✅ Added owners adjustment from ${source}:`, adj.value || 'no description');
              }
            });
          }
          console.log(`✅ Loaded ${owners.length} owners adjustments to Total Value Section from ${source}`);
        }
        
        // 6. Load additional from final_report.adjustments (priority) with fallback to estimate/valuation
        const additionalContainer = document.getElementById('allAdjustmentsList');
        if (additionalContainer) {
          additionalContainer.innerHTML = '';
          
          // FIXED: Load from final_report.adjustments FIRST (preserves manual additions)
          let additional = finalReportAdjustments.additional || [];
          let source = 'final_report';
          
          // Only fall back to estimate/valuation if final_report is empty
          if (!Array.isArray(additional) || additional.length === 0) {
            // Fallback to estimate.adjustments.additional
            additional = estimateAdjustments.additional || [];
            source = 'estimate';
            
            if (!Array.isArray(additional) || additional.length === 0) {
              // Final fallback to valuation.adjustments.additional
              const valuationAdditional = helper.valuation?.adjustments?.additional;
              if (valuationAdditional) {
                additional = Array.isArray(valuationAdditional) ? valuationAdditional : [valuationAdditional];
                source = 'original';
                console.log(`📦 Fallback: Loading additional from valuation.adjustments:`, additional);
              } else {
                console.log(`📦 No additional data in any source`);
              }
            } else {
              console.log(`📦 Loading additional from estimate.adjustments:`, additional);
            }
          } else {
            console.log(`📦 Loading additional from final_report.adjustments (preserving manual additions):`, additional);
          }
          
          if (Array.isArray(additional)) {
            additional.forEach((adj, index) => {
              if (adj && (adj.value || adj.percentage || adj.percent || adj.amount)) {
                // Create row with proper handlers for additional adjustments
                const rowId = 'fullAdj_' + Date.now() + '_' + Math.random();
                const newRow = `
                  <div id="${rowId}" class="adjustment-row" data-source="${source}">
                    <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
                      <div><input type="text" placeholder="תיאור התאמה נוספת" value="${adj.value || ''}" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional');" /></div>
                      <div><select onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));">
                        <option value="plus" ${adj.type === 'plus' ? 'selected' : ''}>תוספת (+)</option>
                        <option value="minus" ${adj.type === 'minus' ? 'selected' : ''}>הפחתה (-)</option>
                      </select></div>
                      <div><input type="text" placeholder="אחוז" value="${adj.percentage || adj.percent || ''}" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(this.value) || 0), safeParseAmount(inputs[3].value));" /></div>
                      <div><input type="text" placeholder="₪" value="${adj.amount_display || (adj.amount ? (adj.amount < 0 ? '-₪' + Math.abs(adj.amount).toLocaleString() : '₪' + Math.abs(adj.amount).toLocaleString()) : '')}" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(this.value));" /></div>
                      <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
                    </div>
                    <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
                      ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
                    </div>
                  </div>
                `;
                additionalContainer.insertAdjacentHTML('beforeend', newRow);
                
                // Trigger formatAdjustmentDisplay for proper minus sign display and update cumulative
                setTimeout(() => {
                  const row = document.getElementById(rowId);
                  if (row) {
                    formatAdjustmentDisplay(row, adj.type, adj.percentage || adj.percent, adj.amount);
                    
                    // Update row cumulative if available from helper
                    if (adj.cumulative !== undefined) {
                      const cumulativeSpan = row.querySelector('.row-cumulative');
                      if (cumulativeSpan) {
                        cumulativeSpan.textContent = `₪${Math.round(adj.cumulative).toLocaleString()}`;
                      }
                    }
                  }
                }, 10);
                
                console.log(`✅ Added additional adjustment from ${source}:`, adj.value || 'no description');
              }
            });
          }
          
          console.log(`✅ Loaded ${additional.length} additional adjustments to Total Value Section from ${source}`);
        }
        
        console.log('✅ Completed loading Total Value Section adjustments');
        
      } catch (error) {
        console.error('Error loading Total Value Section adjustments:', error);
      }
    }
    
    // RELOAD GROSS ADJUSTMENTS - triggered by reload button
    function reloadGrossAdjustments() {
      try {
        console.log('🔄 Reloading gross adjustments from estimate.adjustments with fallback to valuation.adjustments');
        
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Clear deleted items list to allow full reload
        if (helper.grossSectionDeletedItems) {
          delete helper.grossSectionDeletedItems;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          window.helper = helper;
        }
        
        // FIXED: Only clear Gross section data (features and registration), preserve Total section data
        if (helper.final_report && helper.final_report.adjustments) {
          // Preserve Total section data before clearing
          const preservedData = {
            mileage: helper.final_report.adjustments.mileage || [],
            ownership_type: helper.final_report.adjustments.ownership_type || [],
            ownership_history: helper.final_report.adjustments.ownership_history || [],
            usage: helper.final_report.adjustments.usage || [],
            additional: helper.final_report.adjustments.additional || []
          };
          
          // Clear only features and registration (Gross section data)
          helper.final_report.adjustments.features = [];
          helper.final_report.adjustments.registration = [];
          
          // Restore preserved Total section data
          Object.assign(helper.final_report.adjustments, preservedData);
          
          console.log('🧹 Cleared only Gross section data (features & registration), preserved Total section data');
          console.log('📦 Preserved Total section data:', preservedData);
        }
        
        // Clear existing rows
        const featuresContainer = document.getElementById('featuresAdjustmentsList');
        const registrationContainer = document.getElementById('registrationAdjustmentsList');
        
        if (featuresContainer) featuresContainer.innerHTML = '';
        if (registrationContainer) registrationContainer.innerHTML = '';
        
        // FORCE reload from estimate.adjustments (button overrides user changes)
        const adjustments = helper.estimate?.adjustments || helper.valuation?.adjustments || {};
        
        console.log('📍 Force loading from: estimate.adjustments → valuation.adjustments (button override)');
        console.log('🔍 Available adjustments data:', adjustments);
        
        // Load features and registration only (for gross section)
        const categories = [
          { key: 'features', addFunction: addFeatureAdjustment, container: featuresContainer },
          { key: 'registration', addFunction: addRegistrationAdjustment, container: registrationContainer }
        ];
        
        categories.forEach(({ key, addFunction, container }) => {
          const categoryData = adjustments[key];
          if (categoryData && container) {
            console.log(`📝 Loading ${key} adjustments:`, categoryData);
            
            // Handle both array and single object data
            const items = Array.isArray(categoryData) ? categoryData : (categoryData && (categoryData.percent || categoryData.percentage || categoryData.amount) ? [categoryData] : []);
            
            items.forEach((item, index) => {
              if (item && (item.percent || item.percentage || item.amount)) {
                // Add new row
                addFunction();
                
                // Fill the data
                const rows = container.querySelectorAll('div[id*="Adj_"]');
                const lastRow = rows[rows.length - 1];
                
                if (lastRow) {
                  const inputs = lastRow.querySelectorAll('input, select');
                  if (inputs.length >= 4) {
                    // Field mapping: value → תיאור (description)
                    inputs[0].value = item.value || '';
                    
                    // Type dropdown - use stored type directly
                    const itemPercent = item.percentage || item.percent;
                    const itemAmount = item.amount;
                    // FIX: Trust the stored type instead of detecting from values
                    const storedType = item.type || 'plus';
                    // Handle Hebrew type values
                    if (storedType === 'הפחתה' || storedType === 'הפחתה (-)' || storedType === 'הורדה' || storedType === 'minus') {
                      inputs[1].value = 'minus';
                    } else if (storedType === 'תוספת' || storedType === 'תוספת (+)' || storedType === 'plus') {
                      inputs[1].value = 'plus';
                    } else if (storedType === '%' || storedType === '₪') {
                      inputs[1].value = storedType;
                    } else {
                      // Default to plus if type is unclear
                      inputs[1].value = 'plus';
                    }
                    
                    // Percent and amount - preserve sign based on type
                    inputs[2].value = itemPercent ? Math.abs(itemPercent) : '';
                    
                    // FIXED: Preserve amount display properly
                    if (item.amount_display) {
                      inputs[3].value = item.amount_display;
                    } else if (item.amount !== undefined && item.amount !== 0) {
                      const absAmount = Math.abs(item.amount);
                      inputs[3].value = `₪${absAmount.toLocaleString()}`;
                    } else {
                      inputs[3].value = '';
                    }
                    
                    // Trigger change events
                    inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
                    if (inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
                    if (inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
                    
                    // Mark source based on data origin
                    const dataSource = item.source || 'estimate'; // Use original source if available
                    lastRow.setAttribute('data-source', dataSource);
                    
                    if (dataSource === 'manual') {
                      lastRow.style.background = '#fff8e1';
                      lastRow.style.border = '1px solid #ff9800';
                    } else {
                      lastRow.style.background = '#e8f5e8';
                      lastRow.style.border = '1px solid #28a745';
                    }
                    
                    console.log(`✅ Reloaded ${key} item ${index}:`, {
                      description: inputs[0].value,
                      type: inputs[1].value,
                      percent: inputs[2].value,
                      amount: inputs[3].value
                    });
                  }
                }
              }
            });
          }
        });
        
        // No need to load manual entries separately - final_report.adjustments already contains all data
        
        // Trigger calculation after reloading
        updateGrossMarketValueCalculation();
        
        // DELAY before updating helper to ensure UI is fully loaded
        setTimeout(() => {
          // REMOVED: updateHelperFromAdjustments() to prevent overwriting calculated amounts on page load
          
          // CRITICAL: Save current state to sessionStorage so refresh loads correct data
          const updatedHelper = window.helper || {};
          sessionStorage.setItem('helper', JSON.stringify(updatedHelper));
          console.log('💾 Saved updated helper to sessionStorage after reload with delay');
        }, 300);
        
        console.log('✅ Gross adjustments reload completed');
        
      } catch (error) {
        console.error('❌ Error reloading gross adjustments:', error);
      }
    }
    
    // GROSS DAMAGE PERCENTAGE CALCULATION FUNCTIONS
    
    // Add feature adjustment row
    function addFeatureAdjustment() {
      const container = document.getElementById('featuresAdjustmentsList');
      const rowId = 'featureAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור המאפיין" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'features');" /></div>
            <div><select onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));">
              <option value="plus">תוספת (+)</option>
              <option value="minus">הפחתה (-)</option>
            </select></div>
            <div><input type="text" placeholder="אחוז" oninput="calculateAdjustmentValueSimple(this);" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(this.value) || 0), safeParseAmount(inputs[3].value));" /></div>
            <div><input type="text" placeholder="₪" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(this.value));" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      updateGrossMarketValueCalculation();
    }
    
    // Add registration adjustment row
    function addRegistrationAdjustment() {
      const container = document.getElementById('registrationAdjustmentsList');
      const rowId = 'regAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור עליה לכביש" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');" /></div>
            <div><select onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));">
              <option value="plus">תוספת (+)</option>
              <option value="minus">הפחתה (-)</option>
            </select></div>
            <div><input type="text" placeholder="אחוז" oninput="calculateAdjustmentValueSimple(this);" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(this.value) || 0), safeParseAmount(inputs[3].value));" /></div>
            <div><input type="text" placeholder="₪" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(this.value));" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      updateGrossMarketValueCalculation();
    }
    
    // ============================================================================
    // AUTO-POPULATION FROM LEVI SUMMARY
    // ============================================================================
    
    // Flag to prevent multiple executions
    let autoPopulationInProgress = false;
    let autoPopulationCompleted = sessionStorage.getItem('autoPopulationCompleted') === 'true';
    
    /**
     * Auto-populate features and registration adjustments from Levi summary data
     */
    function autoPopulateFromLeviSummary() {
      if (autoPopulationInProgress) {
        console.log('⚠️ Auto-population already in progress, skipping...');
        return;
      }
      
      if (autoPopulationCompleted) {
        console.log('⚠️ Auto-population already completed, skipping...');
        return;
      }
      
      // NEW: Don't auto-populate if final_report.adjustments already has user data
      const helper = window.helper || {};
      if (helper.final_report?.adjustments?.features?.length > 0 || helper.final_report?.adjustments?.registration?.length > 0) {
        console.log('⚠️ User data exists in final_report.adjustments, skipping auto-population');
        autoPopulationCompleted = true;
        sessionStorage.setItem('autoPopulationCompleted', 'true');
        return;
      }
      
      autoPopulationInProgress = true;
      console.log('🚀 Starting auto-population from Levi summary...');
      
      // ENHANCED: Ensure FinalReportCalculations is ready before proceeding
      if (!window.FinalReportCalculations) {
        console.log('⏳ FinalReportCalculations not ready, waiting...');
        setTimeout(() => {
          autoPopulationInProgress = false;
          autoPopulateFromLeviSummary();
        }, 200);
        return;
      }
      
      // Use the helper already declared above
      // const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Check for valuation adjustments (primary source) and fallback sources
      if (!helper.valuation?.adjustments && !helper.levisummary && !helper.levi_report && !helper.expertise?.levi_report) {
        autoPopulationInProgress = false;
        return;
      }
      
      clearLeviAdjustments();
      
      // Get Levi data from valuation adjustments (primary) or fallback sources
      const leviData = helper.valuation?.adjustments || helper.levisummary || helper.levi_report || helper.expertise?.levi_report || {};
      const featuresData = leviData.features || {};
      const registrationData = leviData.registration || {};
      
      // Auto-populate features adjustments (מאפיינים) - GROSS section only
      // ENHANCED: Try multiple possible field locations for better data capture
      const featuresPercent = featuresData.percent || featuresData.percentage || 
                             leviData['מחיר מאפיינים %'] || leviData['מאפיינים %'] || 
                             helper['מחיר מאפיינים %'] || helper['מאפיינים %'] ||
                             helper.levi?.['מחיר מאפיינים %'] ||
                             helper.expertise?.levi_report?.['מחיר מאפיינים %'] || '';
      const featuresAmount = featuresData.amount || featuresData.value || 
                            leviData['ערך ש"ח מאפיינים'] || leviData['ערך מאפיינים'] || 
                            helper['ערך ש"ח מאפיינים'] || helper['ערך מאפיינים'] ||
                            helper.levi?.['ערך ש"ח מאפיינים'] ||
                            helper.expertise?.levi_report?.['ערך ש"ח מאפיינים'] || '';
      const featuresDescription = featuresData.description || featuresData.reason || 'תוספות מאפיינים';
      
      if (featuresPercent || featuresAmount) {
        if (typeof addFeatureAdjustment === 'function') {
          addFeatureAdjustment();
        }
        
        const rows = document.querySelectorAll('#featuresAdjustmentsList > div');
        const lastRow = rows[rows.length - 1];
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            inputs[0].value = featuresDescription || 'תוספות מאפיינים (מלוי יצחק)';
            inputs[1].value = String(featuresPercent).includes('-') ? 'minus' : 'plus';
            // CRITICAL FIX: Display minus sign for negative values
            const featuresPercentValue = parseFloat(String(featuresPercent).replace(/[%\s+]/g, '')) || 0;
            const displayFeaturesPercent = String(featuresPercent).includes('-') ? `-${Math.abs(featuresPercentValue)}` : Math.abs(featuresPercentValue);
            inputs[2].value = displayFeaturesPercent || '';
            // CRITICAL FIX: Display minus sign for amount values too
            const featuresAmountValue = parseFloat(String(featuresAmount).replace(/[₪,\s]/g, '')) || 0;
            const displayFeaturesAmount = String(featuresPercent).includes('-') ? `-${Math.abs(featuresAmountValue)}` : Math.abs(featuresAmountValue);
            inputs[3].value = featuresAmount ? `₪${displayFeaturesAmount.toLocaleString()}` : '';
            
            lastRow.setAttribute('data-source', 'levi');
            lastRow.style.background = '#f0f8ff';
          }
        }
      }
      
      // Auto-populate registration adjustments (עליה לכביש) - GROSS section only  
      // ENHANCED: Try multiple possible field locations for better data capture
      const registrationPercent = registrationData.percent || registrationData.percentage || 
                                 leviData['עליה לכביש %'] || 
                                 helper['עליה לכביש %'] ||
                                 helper.levi?.['עליה לכביש %'] ||
                                 helper.expertise?.levi_report?.['עליה לכביש %'] || '';
      const registrationAmount = registrationData.amount || registrationData.value ||
                                leviData['ערך ש"ח עליה לכביש'] || leviData['ערך עליה לכביש'] ||
                                helper['ערך ש"ח עליה לכביש'] || helper['ערך עליה לכביש'] ||
                                helper.levi?.['ערך ש"ח עליה לכביש'] ||
                                helper.expertise?.levi_report?.['ערך ש"ח עליה לכביש'] || '';
      const registrationDescription = registrationData.description || registrationData.reason || 'עליה לכביש';
      
      if (registrationPercent || registrationAmount) {
        if (typeof addRegistrationAdjustment === 'function') {
          addRegistrationAdjustment();
        }
        
        const rows = document.querySelectorAll('#registrationAdjustmentsList > div');
        const lastRow = rows[rows.length - 1];
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            inputs[0].value = registrationDescription || 'עליה לכביש (מלוי יצחק)';
            inputs[1].value = String(registrationPercent).includes('-') ? 'minus' : 'plus';
            // CRITICAL FIX: Display minus sign for negative values
            const registrationPercentValue = parseFloat(String(registrationPercent).replace(/[%\s+]/g, '')) || 0;
            const displayRegistrationPercent = String(registrationPercent).includes('-') ? `-${Math.abs(registrationPercentValue)}` : Math.abs(registrationPercentValue);
            inputs[2].value = displayRegistrationPercent || '';
            
            // CRITICAL FIX: Display minus sign for amount values too
            const registrationAmountValue = parseFloat(String(registrationAmount).replace(/[₪,\s]/g, '')) || 0;
            const displayRegistrationAmount = String(registrationPercent).includes('-') ? `-${Math.abs(registrationAmountValue)}` : Math.abs(registrationAmountValue);
            inputs[3].value = registrationAmount ? `₪${displayRegistrationAmount.toLocaleString()}` : '';
            
            lastRow.setAttribute('data-source', 'levi');
            lastRow.style.background = '#f0f8ff';
          }
        }
      }
      
      // ===== END OF GROSS ADJUSTMENTS =====
      // Note: Market adjustments (mileage, ownership, owners) belong in "Full Market Value" section,
      // not in the gross value section which is only for car properties (features + registration)
      
      // Trigger calculations after auto-population
      setTimeout(() => {
        if (typeof updateGrossMarketValueCalculation === 'function') {
          updateGrossMarketValueCalculation();
        }
        // REMOVED: updateHelperFromAdjustments() to prevent overwriting calculated amounts on page load
        if (window.FinalReportCalculations && typeof window.FinalReportCalculations.refresh3BulkCalculations === 'function') {
          window.FinalReportCalculations.refresh3BulkCalculations();
        }
      }, 100);
      
      autoPopulationInProgress = false;
      autoPopulationCompleted = true;
      sessionStorage.setItem('autoPopulationCompleted', 'true');
    }
    
    /**
     * Auto-populate market adjustments (mileage, ownership) for Full Market Value section
     */
    function autoPopulateMarketAdjustments() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const adjustments = helper.estimate?.adjustments || {};
      
      console.log('🏪 Auto-populating market adjustments from helper.estimate.adjustments');
      console.log('🔍 Available adjustments:', adjustments);
      
      // Get base price for calculations
      let basePrice = 0;
      const basicPriceField = document.getElementById('basicPrice');
      if (basicPriceField && basicPriceField.value) {
        basePrice = parseFloat(basicPriceField.value.replace(/[₪,]/g, '')) || 0;
      }
      console.log('📊 Base price for calculations:', basePrice);
      
      // Clear existing auto-populated adjustments from ALL containers
      const containers = [
        'fullFeaturesAdjustmentsList',
        'fullRegistrationAdjustmentsList', 
        'mileageAdjustmentsList',
        'ownershipAdjustmentsList',
        'ownersAdjustmentsList'
      ];
      
      containers.forEach(containerId => {
        const container = document.getElementById(containerId);
        if (container) {
          const leviRows = container.querySelectorAll('div[data-source="levi"]');
          leviRows.forEach(row => row.remove());
          console.log(`🧹 Cleared ${leviRows.length} Levi rows from ${containerId}`);
        }
      });
      
      // Auto-populate adjustments in CORRECT ORDER as per user requirements:
      // 1. Features → 2. Registration → 3. Mileage → 4. Ownership → 5. Owners
      // FIXED: Use correct keys from helper data structure
      const adjustmentMapping = [
        { key: 'features', label: 'תוספות מאפיינים', containerId: 'fullFeaturesAdjustmentsList', addFunction: addFullFeaturesAdjustment },
        { key: 'registration', label: 'עליה לכביש', containerId: 'fullRegistrationAdjustmentsList', addFunction: addFullRegistrationAdjustment },
        { key: 'mileage', label: 'מס ק"מ', containerId: 'mileageAdjustmentsList', addFunction: addMileageAdjustment },
        { key: 'ownership_type', label: 'סוג בעלות', containerId: 'ownershipAdjustmentsList', addFunction: addOwnershipAdjustment },
        { key: 'ownership_history', label: 'מספר בעלים', containerId: 'ownersAdjustmentsList', addFunction: addOwnersAdjustment }
      ];
      
      adjustmentMapping.forEach(({ key, label, containerId, addFunction }) => {
        const adjData = adjustments[key] || [];
        console.log(`🔍 Processing ${key}:`, adjData);
        
        // Handle both array and single object data from estimate.adjustments
        const items = Array.isArray(adjData) ? adjData : (adjData && (adjData.percent || adjData.percentage || adjData.amount) ? [adjData] : []);
        
        items.forEach((item, index) => {
          if (item && (item.percent || item.percentage || item.amount)) {
            // Extract percentage - handle negative values  
            let percent = parseFloat(item.percent || item.percentage) || 0;
            
            // Extract amount
            let amount = parseFloat(item.amount) || 0;
            
            // Field mapping: value → תיאור
            const description = item.value || item.description || label;
          
            
            console.log(`📝 Importing ${key} item ${index}:`, {
              description,
              percent,
              amount,
              type: item.type
            });
            
            // Add the adjustment row
            addFunction();
            
            const container = document.getElementById(containerId);
            const rows = container.querySelectorAll('div.adjustment-row');
            const lastRow = rows[rows.length - 1];
            
            if (lastRow) {
              const inputs = lastRow.querySelectorAll('input, select');
              if (inputs.length >= 4) {
                // Use exact estimator builder logic for field assignment
                inputs[0].value = item.value || '';
                const itemPercent = item.percentage || item.percent;
                const itemAmount = item.amount;
                // FIX: Use stored type directly instead of detection
                const storedType = item.type || 'plus';
                if (storedType === 'הפחתה' || storedType === 'הפחתה (-)' || storedType === 'הורדה' || storedType === 'minus') {
                  inputs[1].value = 'minus';
                } else if (storedType === 'תוספת' || storedType === 'תוספת (+)' || storedType === 'plus') {
                  inputs[1].value = 'plus';
                } else {
                  inputs[1].value = storedType; // Use as-is for %, ₪ etc
                }
                // CRITICAL FIX: Display minus sign for negative values
                const displayPercent = isReductionType(item.type) && itemPercent > 0 ? `-${Math.abs(itemPercent)}` : Math.abs(itemPercent || 0);
                const displayAmount = isReductionType(item.type) && item.amount > 0 ? `-${Math.abs(item.amount)}` : Math.abs(item.amount || 0);
                
                inputs[2].value = itemPercent ? displayPercent : '';
                inputs[3].value = item.amount_display || (item.amount ? `₪${displayAmount.toLocaleString()}` : '');
              
              // Trigger onchange events to ensure handlers are active
              inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
              if (inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
              if (inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
              
              // Mark as Levi data
              lastRow.setAttribute('data-source', 'levi');
              lastRow.style.background = '#f0f8ff';
              lastRow.style.border = '1px solid #4a90e2';
              
              console.log(`✅ Populated ${key}:`, {
                description: inputs[0].value,
                type: inputs[1].value,
                percent: inputs[2].value,
                amount: inputs[3].value
              });
            }
          }
          }
        });
        
        if (items.length === 0) {
          console.log(`⚠️ No valid data for ${key}:`, adjData);
        }
      });
      
      // Trigger calculation after populating all adjustments
      if (typeof updateFullMarketValueCalculation === 'function') {
        setTimeout(() => {
          updateFullMarketValueCalculation();
          console.log('✅ Full market value calculation triggered after auto-population');
        }, 100);
      }
      
      console.log('✅ Market adjustments auto-population completed from helper.valuation.adjustments');
    }
    
    // RELOAD FULL MARKET ADJUSTMENTS - triggered by reload button
    function reloadFullMarketAdjustments() {
      try {
        console.log('🔄 Reloading Total Value adjustments with mixed sources: Features/Registration from final_report, Others from estimate');
        
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Mixed data sources for Total Value section reload:
        // - Features & Registration: from final_report.adjustments (sync with Gross section)
        // - Others (KM, Ownership, Owners, Additional): from estimate.adjustments (original Levi data)
        const estimateAdjustments = helper.estimate?.adjustments || helper.valuation?.adjustments || {};
        const finalReportAdjustments = helper.final_report?.adjustments || {};
        
        console.log('🔍 estimate.adjustments:', estimateAdjustments);
        console.log('🔍 final_report.adjustments:', finalReportAdjustments);
        
        // Clear existing rows from NON-SYNCED containers only (preserve features/registration)
        const containersToReload = [
          'mileageAdjustmentsList',
          'ownershipAdjustmentsList', 
          'ownersAdjustmentsList',
          'allAdjustmentsList'
        ];
        
        containersToReload.forEach(containerId => {
          const container = document.getElementById(containerId);
          if (container) {
            container.innerHTML = '';
            console.log(`🧹 Cleared container: ${containerId}`);
          }
        });
        
        console.log('⚠️ SKIPPING features/registration reload to preserve Total Value manual additions');
        
        // Load ONLY non-synced categories (skip features/registration to preserve manual additions)
        const adjustmentMapping = [
          // SKIPPED: features and registration to preserve Total Value manual additions
          { key: 'mileage', label: 'מס ק"מ', containerId: 'mileageAdjustmentsList', addFunction: addMileageAdjustment },
          { key: 'ownership_type', label: 'סוג בעלות', containerId: 'ownershipAdjustmentsList', addFunction: addOwnershipAdjustment },
          { key: 'ownership_history', label: 'מספר בעלים', containerId: 'ownersAdjustmentsList', addFunction: addOwnersAdjustment }
          // REMOVED: additional - it's handled separately in loadFullMarketValueData to avoid duplicates
        ];
        
        adjustmentMapping.forEach(({ key, label, containerId, addFunction }) => {
          // All categories now load from estimate.adjustments (no features/registration)
          const categoryData = estimateAdjustments[key];
          console.log(`📦 Loading ${key} from estimate.adjustments:`, categoryData);
          if (categoryData) {
            console.log(`📝 Loading ${key} adjustments:`, categoryData);
            
            const container = document.getElementById(containerId);
            if (container) {
              // Handle both array and single object data
              const items = Array.isArray(categoryData) ? categoryData : (categoryData && (categoryData.percent || categoryData.percentage || categoryData.amount) ? [categoryData] : []);
              
              items.forEach((item, index) => {
                if (item && (item.percent || item.percentage || item.amount)) {
                  // Add new row
                  addFunction();
                  
                  // Fill the data
                  const rows = container.querySelectorAll('div[id*="Adj_"]');
                  const lastRow = rows[rows.length - 1];
                  
                  if (lastRow) {
                    const inputs = lastRow.querySelectorAll('input, select');
                    if (inputs.length >= 4) {
                      // Field mapping: value → תיאור (description)
                      inputs[0].value = item.value || '';
                      
                      // Type dropdown - use stored type directly  
                      const itemPercent = item.percentage || item.percent;
                      const itemAmount = item.amount;
                      const storedType = item.type || 'plus';
                      if (storedType === 'minus' || storedType === 'הפחתה' || storedType === 'הפחתה (-)') {
                        inputs[1].value = 'minus';
                      } else if (storedType === 'plus' || storedType === 'תוספת' || storedType === 'תוספת (+)') {
                        inputs[1].value = 'plus';
                      } else {
                        inputs[1].value = storedType; // For % or ₪ types
                      }
                      
                      // Percent and amount - preserve sign based on type
                      inputs[2].value = itemPercent ? Math.abs(itemPercent) : '';
                      // Check if it's a reduction type to preserve minus sign
                      const isReduction = isReductionType(item.type);
                      let displayAmount = Math.abs(item.amount || 0);
                      if (isReduction && displayAmount > 0) {
                        displayAmount = -displayAmount;
                      }
                      inputs[3].value = item.amount_display || (item.amount ? `₪${displayAmount.toLocaleString()}` : '');
                      
                      // Trigger change events
                      inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
                      if (inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
                      if (inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
                      
                      // Mark as loaded data
                      lastRow.setAttribute('data-source', 'estimate');
                      lastRow.style.background = '#e8f5e8';
                      lastRow.style.border = '1px solid #28a745';
                      
                      console.log(`✅ Reloaded ${key} item ${index}:`, {
                        description: inputs[0].value,
                        type: inputs[1].value,
                        percent: inputs[2].value,
                        amount: inputs[3].value
                      });
                      
                      // Apply unified formatting to ensure proper minus signs
                      setTimeout(() => {
                        formatAdjustmentDisplay(lastRow, inputs[1].value, itemPercent, itemAmount);
                      }, 10);
                    }
                  }
                }
              });
            }
          }
        });
        
        // Trigger calculation after reloading
        if (typeof updateFullMarketValueCalculation === 'function') {
          setTimeout(() => {
            updateFullMarketValueCalculation();
            console.log('✅ Full market value calculation triggered after reload');
          }, 100);
        }
        
        // REMOVED: updateHelperFromAdjustments() to prevent overwriting calculated amounts on page load
        
        // CRITICAL: Save Total Value sections to helper after reload
        updateFullMarketValueToFinalReportAndValuation(helper);
        
        // Save updated helper to storage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        console.log('💾 Saved updated helper to storage after reload');
        
        console.log('✅ Full market adjustments reload completed');
        
      } catch (error) {
        console.error('❌ Error reloading full market adjustments:', error);
      }
    }
    
    /**
     * Clear existing auto-populated Levi adjustments before re-populating
     */
    function clearLeviAdjustments() {
      // Clear features adjustments marked as Levi data
      const featureRows = document.querySelectorAll('#featuresAdjustmentsList div[data-source="levi"]');
      console.log(`🧹 Clearing ${featureRows.length} Levi feature rows`);
      featureRows.forEach(row => row.remove());
      
      // Clear registration adjustments marked as Levi data
      const registrationRows = document.querySelectorAll('#registrationAdjustmentsList div[data-source="levi"]');
      console.log(`🧹 Clearing ${registrationRows.length} Levi registration rows`);
      registrationRows.forEach(row => row.remove());
      
      // Clear market adjustments marked as Levi data 
      const marketRows = document.querySelectorAll('#allAdjustmentsList div[data-source="levi"]');
      console.log(`🧹 Clearing ${marketRows.length} Levi market rows`);
      marketRows.forEach(row => row.remove());
      
      console.log('✅ Cleared all existing Levi adjustments');
    }
    
    /**
     * Enhanced two-way data binding: sync individual adjustment changes to helper
     */
    // UNIFIED DISPLAY FORMATTING FOR FEATURES AND REGISTRATION
    function formatAdjustmentDisplay(row, type, percent, amount) {
      try {
        const inputs = row.querySelectorAll('input, select');
        if (inputs.length < 4) return;
        
        const percentInput = inputs[2];
        const amountInput = inputs[3];
        
        
        // Determine if it's a reduction/subtraction
        const isReduction = isReductionType(type);
        
        
        // Determine field type based on category and data source
        // Features, KM, Ownership are typically percentage-based
        // Registration is typically amount-based
        const containerId = percentInput.closest('[id$="AdjustmentsList"]')?.id || '';
        
        // Simple logic: if we have percent data, show percentage mode; if we have amount data, show amount mode
        const hasPercent = (percent !== null && percent !== undefined && percent !== 0);
        const hasAmount = (amount !== null && amount !== undefined && amount !== 0);
        
        if (hasPercent && !hasAmount) {
          // Percentage mode: show percent value, make both editable
          percentInput.value = isReduction ? `-${Math.abs(percent)}` : Math.abs(percent);
          percentInput.readOnly = false;
          percentInput.style.background = '';
          amountInput.value = '';
          amountInput.readOnly = false;
          amountInput.style.background = '';
        } else if (hasAmount && !hasPercent) {
          // Amount mode: show amount value, make both editable
          const validAmount = safeParseAmount(amount);
          amountInput.value = validAmount === 0 ? '' : (isReduction ? `-₪${Math.abs(validAmount).toLocaleString()}` : `₪${Math.abs(validAmount).toLocaleString()}`);
          amountInput.readOnly = false;
          amountInput.style.background = '';
          percentInput.value = '';
          percentInput.readOnly = false;
          percentInput.style.background = '';
        } else {
          // Default: make both fields editable
          const validAmount = safeParseAmount(amount);
          percentInput.value = isReduction && percent ? `-${Math.abs(percent)}` : Math.abs(percent || 0);
          amountInput.value = validAmount === 0 ? '' : (isReduction ? `-₪${Math.abs(validAmount).toLocaleString()}` : `₪${Math.abs(validAmount).toLocaleString()}`);
          percentInput.readOnly = false;
          amountInput.readOnly = false;
          percentInput.style.background = '';
          amountInput.style.background = '';
        }
        
        
      } catch (error) {
        console.error('Error in formatAdjustmentDisplay:', error);
      }
    }

    // Save adjustment amount immediately without waiting for field change
    function saveAdjustmentAmount(category, amount, cumulativeValue) {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Ensure structures exist
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // Round amount to whole number
        const roundedAmount = Math.round(amount);
        const roundedCumulative = cumulativeValue !== undefined ? Math.round(cumulativeValue) : undefined;
        
        // Format amount display with rounded value
        const amountDisplay = roundedAmount !== 0 ? `₪${Math.abs(roundedAmount).toLocaleString()}` : '';
        
        // Update valuation.adjustments
        if (!helper.valuation.adjustments[category]) {
          helper.valuation.adjustments[category] = {};
        }
        helper.valuation.adjustments[category].amount = roundedAmount;
        helper.valuation.adjustments[category].amount_display = amountDisplay;
        if (roundedCumulative !== undefined) {
          helper.valuation.adjustments[category].cumulative = roundedCumulative;
        }
        
        // Update final_report.adjustments (ensure array exists and update first item)
        if (!helper.final_report.adjustments[category]) {
          helper.final_report.adjustments[category] = [];
        }
        if (helper.final_report.adjustments[category].length === 0) {
          helper.final_report.adjustments[category].push({});
        }
        helper.final_report.adjustments[category][0].amount = roundedAmount;
        helper.final_report.adjustments[category][0].amount_display = amountDisplay;
        if (roundedCumulative !== undefined) {
          helper.final_report.adjustments[category][0].cumulative = roundedCumulative;
        }
        
        // Save to storage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        console.log(`💾 Saved amount for ${category}: ${roundedAmount} (cumulative: ${roundedCumulative})`);
      } catch (error) {
        console.error('Error saving adjustment amount:', error);
      }
    }

    // Restore adjustment amounts from helper data on page load
    function restoreAdjustmentAmounts() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        console.log('🔄 Restoring adjustment amounts from helper...');
        console.log('🔍 DEBUG: helper.valuation.adjustments:', helper.valuation?.adjustments);
        
        // Restore amounts for our three categories plus additional
        const categories = ['mileage', 'ownership_type', 'ownership_history', 'additional'];
        
        categories.forEach(category => {
          // Check both locations for amount data
          const valuationAmount = helper.valuation?.adjustments?.[category]?.amount;
          const finalReportAmount = helper.final_report?.adjustments?.[category]?.[0]?.amount;
          
          console.log(`🔍 DEBUG ${category}: valuationAmount=${valuationAmount}, finalReportAmount=${finalReportAmount}`);
          
          // Use valuation amount if available, otherwise final_report
          const amount = valuationAmount !== undefined ? valuationAmount : finalReportAmount;
          
          if (amount !== undefined && amount !== 0) {
            // Round the amount to ensure no fractions
            const roundedAmount = Math.round(amount);
            console.log(`📖 Found saved amount for ${category}: ${roundedAmount}`);
            
            // Find the corresponding container
            let containerId = '';
            if (category === 'mileage') containerId = 'mileageAdjustmentsList';
            else if (category === 'ownership_type') containerId = 'ownershipAdjustmentsList';
            else if (category === 'ownership_history') containerId = 'ownersAdjustmentsList';
            else if (category === 'additional') containerId = 'allAdjustmentsList';
            
            const container = document.getElementById(containerId);
            if (container) {
              const rows = container.querySelectorAll('div[id*="Adj_"]');
              if (rows.length > 0) {
                // Update the first row's amount field (original working logic)
                const firstRow = rows[0];
                const inputs = firstRow.querySelectorAll('input[type="text"]');
                if (inputs.length >= 3) {
                  const valueInput = inputs[2]; // Amount field
                  if (valueInput) {
                    valueInput.value = roundedAmount < 0 ? `-₪${Math.abs(roundedAmount).toLocaleString()}` : `₪${Math.abs(roundedAmount).toLocaleString()}`;
                    console.log(`✅ Restored amount for ${category} first row in UI`);
                  }
                }
              }
              
              // EXTEND: Also restore added rows (index > 0) from final_report.adjustments
              const finalReportAdjustments = helper.final_report?.adjustments?.[category];
              if (finalReportAdjustments && finalReportAdjustments.length > 1) {
                for (let i = 1; i < finalReportAdjustments.length; i++) {
                  const savedAdjustment = finalReportAdjustments[i];
                  if (savedAdjustment && savedAdjustment.amount !== undefined && rows[i]) {
                    const addedRow = rows[i];
                    const addedInputs = addedRow.querySelectorAll('input[type="text"]');
                    if (addedInputs.length >= 3) {
                      const addedValueInput = addedInputs[2]; // Amount field
                      if (addedValueInput) {
                        const savedAmount = Math.round(savedAdjustment.amount);
                        addedValueInput.value = savedAmount < 0 ? `-₪${Math.abs(savedAmount).toLocaleString()}` : `₪${Math.abs(savedAmount).toLocaleString()}`;
                        console.log(`✅ Restored amount for ${category} added row ${i}: ${savedAmount}`);
                        console.log(`🔍 Input value after restore: "${addedValueInput.value}"`);
                      }
                    }
                  }
                }
              }
            }
          }
        });
        
        // Trigger calculation update to refresh cumulative displays
        setTimeout(() => {
          updateFullMarketValueCalculation();
          
          // IMPORTANT: Restore added rows amounts AFTER calculation to prevent clearing
          setTimeout(() => {
            restoreAddedRowsAmounts();
          }, 200);
        }, 100);
        
      } catch (error) {
        console.error('Error restoring adjustment amounts:', error);
      }
    }

    // Separate function to restore added rows amounts after calculations
    function restoreAddedRowsAmounts() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        console.log('🔄 Restoring added rows amounts after calculations...');
        
        const categories = ['mileage', 'ownership_type', 'ownership_history', 'additional', 'features', 'registration'];
        
        categories.forEach(category => {
          let containerId = '';
          if (category === 'mileage') containerId = 'mileageAdjustmentsList';
          else if (category === 'ownership_type') containerId = 'ownershipAdjustmentsList';
          else if (category === 'ownership_history') containerId = 'ownersAdjustmentsList';
          else if (category === 'additional') containerId = 'allAdjustmentsList';
          else if (category === 'features') {
            // Check both gross and full market sections
            const grossContainer = document.getElementById('featuresAdjustmentsList');
            const fullContainer = document.getElementById('fullFeaturesAdjustmentsList');
            if (grossContainer && grossContainer.children.length > 0) containerId = 'featuresAdjustmentsList';
            else if (fullContainer && fullContainer.children.length > 0) containerId = 'fullFeaturesAdjustmentsList';
          }
          else if (category === 'registration') {
            // Check both gross and full market sections  
            const grossContainer = document.getElementById('registrationAdjustmentsList');
            const fullContainer = document.getElementById('fullRegistrationAdjustmentsList');
            if (grossContainer && grossContainer.children.length > 0) containerId = 'registrationAdjustmentsList';
            else if (fullContainer && fullContainer.children.length > 0) containerId = 'fullRegistrationAdjustmentsList';
          }
          
          if (!containerId) return;
          
          const container = document.getElementById(containerId);
          if (!container) return;
          
          const rows = container.querySelectorAll('div[id*="Adj_"]');
          const finalReportAdjustments = helper.final_report?.adjustments?.[category];
          
          if (finalReportAdjustments && finalReportAdjustments.length > 1) {
            for (let i = 1; i < finalReportAdjustments.length; i++) {
              const savedAdjustment = finalReportAdjustments[i];
              if (savedAdjustment && savedAdjustment.amount !== undefined && rows[i]) {
                const addedRow = rows[i];
                const addedInputs = addedRow.querySelectorAll('input[type="text"]');
                if (addedInputs.length >= 3) {
                  const addedValueInput = addedInputs[2]; // Amount field
                  if (addedValueInput) {
                    const savedAmount = Math.round(savedAdjustment.amount);
                    addedValueInput.value = savedAmount < 0 ? `-₪${Math.abs(savedAmount).toLocaleString()}` : `₪${Math.abs(savedAmount).toLocaleString()}`;
                    console.log(`✅ FINAL restore: ${category} added row ${i}: ${savedAmount}`);
                  }
                }
              }
            }
          }
        });
        
      } catch (error) {
        console.error('Error in restoreAddedRowsAmounts:', error);
      }
    }

    // Load additional adjustments from helper to UI
    function loadAdditionalAdjustments() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        console.log('🔄 Loading additional adjustments from helper...');
        
        // Check for additional adjustments in final_report
        const additionalAdjustments = helper.final_report?.adjustments?.additional || [];
        
        if (additionalAdjustments.length > 0) {
          const container = document.getElementById('allAdjustmentsList');
          if (!container) return;
          
          // Clear existing rows first
          container.innerHTML = '';
          
          // Create rows for each saved adjustment
          additionalAdjustments.forEach((adjustment, index) => {
            const rowId = 'fullAdj_' + Date.now() + '_' + index;
            const type = adjustment.type || 'plus';
            const description = adjustment.value || '';
            const percentage = adjustment.percentage || adjustment.percent || 0;
            const amount = adjustment.amount || 0;
            const amountDisplay = adjustment.amount_display || (amount !== 0 ? `₪${Math.abs(amount).toLocaleString()}` : '');
            
            const newRow = `
              <div id="${rowId}" class="adjustment-row" data-source="restored" style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
                <div><input type="text" placeholder="תיאור התאמה נוספת" value="${description}" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(inputs[2].value) || 0, safeParseAmount(inputs[3].value));" /></div>
                <div><select onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, parseFloat(inputs[2].value) || 0, safeParseAmount(inputs[3].value));">
                  <option value="plus" ${type === 'plus' ? 'selected' : ''}>תוספת (+)</option>
                  <option value="minus" ${type === 'minus' ? 'selected' : ''}>הפחתה (-)</option>
                </select></div>
                <div><input type="text" placeholder="אחוז" value="${Math.abs(percentage)}" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(this.value) || 0, safeParseAmount(inputs[3].value));" /></div>
                <div><input type="text" placeholder="₪" value="${amountDisplay}" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(inputs[2].value) || 0, safeParseAmount(this.value));" /></div>
                <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
              </div>
            `;
            
            container.insertAdjacentHTML('beforeend', newRow);
          });
          
          console.log(`✅ Loaded ${additionalAdjustments.length} additional adjustments to UI`);
        }
        
      } catch (error) {
        console.error('Error loading additional adjustments:', error);
      }
    }

    // Save only cumulative value for an adjustment category (without other fields)
    function saveAdjustmentCumulativeOnly(category, cumulativeValue) {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Ensure structures exist
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // Round cumulative value
        const roundedCumulative = Math.round(cumulativeValue);
        
        // Update valuation.adjustments cumulative
        if (!helper.valuation.adjustments[category]) {
          helper.valuation.adjustments[category] = {};
        }
        helper.valuation.adjustments[category].cumulative = roundedCumulative;
        
        // Update final_report.adjustments cumulative for all items in array
        if (helper.final_report.adjustments[category] && Array.isArray(helper.final_report.adjustments[category])) {
          helper.final_report.adjustments[category].forEach(item => {
            item.cumulative = roundedCumulative;
          });
        }
        
        // Save to storage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        console.log(`💾 Saved cumulative for ${category}: ${roundedCumulative}`);
      } catch (error) {
        console.error('Error saving adjustment cumulative:', error);
      }
    }

    // Sync cumulative values for gross section categories after calculations
    function syncGrossCumulativeValues() {
      try {
        console.log('🔄 Syncing gross section cumulative values...');
        
        // For features
        const featuresContainer = document.getElementById('featuresAdjustmentsList');
        if (featuresContainer && featuresContainer.children.length > 0) {
          const firstInput = featuresContainer.children[0].querySelector('input');
          if (firstInput) {
            syncAdjustmentToHelper(firstInput, 'features');
          }
        }
        
        // For registration
        const registrationContainer = document.getElementById('registrationAdjustmentsList');
        if (registrationContainer && registrationContainer.children.length > 0) {
          const firstInput = registrationContainer.children[0].querySelector('input');
          if (firstInput) {
            syncAdjustmentToHelper(firstInput, 'registration');
          }
        }
        
        console.log('✅ Gross cumulative values synced');
      } catch (error) {
        console.error('Error syncing gross cumulative values:', error);
      }
    }

    function syncAdjustmentToHelper(element, category) {
      try {
        console.log(`🔥 syncAdjustmentToHelper called for category: ${category}, element:`, element);
        
        // Skip sync during page load to prevent clearing saved data
        if (window.pageLoadInProgress) {
          console.log('⏸️ Skipping sync during page load to preserve data');
          return;
        }
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Ensure structures exist
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.estimate) helper.estimate = {};
        if (!helper.estimate.adjustments) helper.estimate.adjustments = {};
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // Map category to container ID - Check both full market and gross containers
        let containerId = '';
        if (category === 'features') {
          // Check if element is from gross section or full market section
          const row = element.closest('div');
          const grossContainer = document.getElementById('featuresAdjustmentsList');
          const fullContainer = document.getElementById('fullFeaturesAdjustmentsList');
          
          if (grossContainer && grossContainer.contains(row)) {
            containerId = 'featuresAdjustmentsList'; // Gross section
            console.log(`🎯 Detected GROSS features section for ${category}`);
          } else {
            containerId = 'fullFeaturesAdjustmentsList'; // Full market section
            console.log(`🎯 Detected FULL MARKET features section for ${category}`);
          }
        }
        else if (category === 'registration') {
          // Check if element is from gross section or full market section  
          const row = element.closest('div');
          const grossContainer = document.getElementById('registrationAdjustmentsList');
          const fullContainer = document.getElementById('fullRegistrationAdjustmentsList');
          
          if (grossContainer && grossContainer.contains(row)) {
            containerId = 'registrationAdjustmentsList'; // Gross section
            console.log(`🎯 Detected GROSS registration section for ${category}`);
          } else {
            containerId = 'fullRegistrationAdjustmentsList'; // Full market section
            console.log(`🎯 Detected FULL MARKET registration section for ${category}`);
          }
        }
        else if (category === 'mileage') containerId = 'mileageAdjustmentsList';
        else if (category === 'ownership_type') containerId = 'ownershipAdjustmentsList';
        else if (category === 'ownership_history') containerId = 'ownersAdjustmentsList';
        else if (category === 'additional') containerId = 'allAdjustmentsList';
        
        if (!containerId) {
          console.error('❌ Unknown category:', category);
          return;
        }
        
        const container = document.getElementById(containerId);
        if (!container) {
          console.error('❌ Container not found:', containerId);
          return;
        }
        
        console.log(`🔄 Rebuilding ${category} from all UI rows in ${containerId}`);
        
        // FINAL REPORT PATTERN: Rebuild entire category array from ALL visible UI rows
        // DO NOT WRITE TO estimate.adjustments - it should be READ-ONLY!
        const allRows = Array.from(container.children);
        
        // PRESERVE EXISTING DATA: Don't clear the entire array, preserve entries beyond UI rows
        const existingAdjustments = helper.final_report.adjustments[category] || [];
        helper.final_report.adjustments[category] = [];
        
        allRows.forEach((row, index) => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            // Start with existing data if available
            const existingData = existingAdjustments[index] || {};
            
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percentage: parseFloat(inputs[2].value) || 0,
              percent: parseFloat(inputs[2].value) || 0, // Backward compatibility
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value) || existingData.amount || 0, // PRESERVE existing amount if UI is empty
              source: 'manual',
              timestamp: new Date().toISOString()
            };
            
            // DEBUG: Log type saving for ownership_history
            if (category === 'ownership_history') {
              console.log(`💾 OWNERSHIP_HISTORY TYPE SAVING [${index}]:`, {
                category,
                inputType: inputs[1].value,
                finalType: adjustmentData.type,
                allInputs: Array.from(inputs).map(i => i.value)
              });
            }
            
            
            // Calculate amount from percentage if needed (BEFORE applying signs)
            // FIXED: Only calculate if BOTH conditions are met:
            // 1. Percentage exists and is non-zero
            // 2. Amount is truly empty (not manually entered)
            const amountFromUI = safeParseAmount(inputs[3].value);
            const hasManualAmount = amountFromUI !== 0 || inputs[3].value.trim() !== '';
            
            if (adjustmentData.percentage && !hasManualAmount) {
              const baseValue = parseFloat(helper.estimate?.market_value_base) || 0;
              if (baseValue > 0) {
                const amount = Math.round((baseValue * Math.abs(adjustmentData.percentage)) / 100);
                adjustmentData.amount = amount; // Set as positive first
                adjustmentData.isCalculatedAmount = true; // Flag for calculated amounts
              }
            } else if (hasManualAmount) {
              adjustmentData.amount = amountFromUI;
              adjustmentData.isManualAmount = true; // Flag for manual amounts
            }
            
            // Round the amount to ensure no fractions
            adjustmentData.amount = Math.round(adjustmentData.amount);
            
            // Apply sign based on type (CRITICAL FOR MINUS SIGNS) - AFTER amount calculation
            if (adjustmentData.type === 'minus') {
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
            }
            
            // Add cumulative tracking for all adjustment categories
            if (category === 'mileage' || category === 'ownership_type' || category === 'ownership_history' || 
                category === 'features' || category === 'registration' || category === 'additional') {
              // FIXED: Get cumulative from the row itself, not the category total
              const rowCumulativeSpan = row.querySelector('.row-cumulative');
              if (rowCumulativeSpan) {
                const cumulativeText = rowCumulativeSpan.textContent.replace(/[₪,]/g, '');
                const cumulativeValue = parseFloat(cumulativeText) || 0;
                // Round cumulative value to ensure no fractions
                adjustmentData.cumulative = Math.round(cumulativeValue);
                console.log(`📊 Captured row cumulative for ${category}[${index}]: ${adjustmentData.cumulative}`);
              } else {
                // Fallback to category cumulative for backward compatibility
                let cumulativeId = '';
                
                // For features and registration, determine if it's gross or full market section
                if (category === 'features') {
                  // Check if it's gross section or full market section based on container
                  if (containerId === 'featuresAdjustmentsList') {
                    cumulativeId = 'grossFeaturesCumulative'; // Gross section
                  } else {
                    cumulativeId = 'featuresCumulative'; // Full market section
                  }
                }
                else if (category === 'registration') {
                  // Check if it's gross section or full market section based on container
                  if (containerId === 'registrationAdjustmentsList') {
                    cumulativeId = 'grossRegistrationCumulative'; // Gross section
                  } else {
                    cumulativeId = 'registrationCumulative'; // Full market section
                  }
                }
                else if (category === 'mileage') cumulativeId = 'mileageCumulative';
                else if (category === 'ownership_type') cumulativeId = 'ownershipCumulative';
                else if (category === 'ownership_history') cumulativeId = 'ownersCumulative';
                
                const cumulativeElement = document.getElementById(cumulativeId);
                if (cumulativeElement) {
                  const cumulativeSpan = cumulativeElement.querySelector('span');
                  if (cumulativeSpan) {
                    const cumulativeText = cumulativeSpan.textContent.replace(/[₪,]/g, '');
                    const cumulativeValue = parseFloat(cumulativeText) || 0;
                    // Round cumulative value to ensure no fractions
                    adjustmentData.cumulative = Math.round(cumulativeValue);
                    console.log(`📊 Captured category cumulative for ${category}: ${adjustmentData.cumulative}`);
                  }
                }
              }
            }
            
            // ONLY write to final_report - estimate should remain READ-ONLY
            helper.final_report.adjustments[category].push(adjustmentData);
            console.log(`📝 Added row ${index} to final_report.${category}:`, adjustmentData.value);
          }
        });
        
        console.log(`✅ Rebuilt ${category}: ${helper.final_report.adjustments[category].length} items total`);
        console.log(`📊 Final final_report.adjustments.${category}:`, helper.final_report.adjustments[category]);
        
        // FINAL REPORT PATTERN: Update valuation.adjustments with first item (for backward compatibility)
        if (helper.final_report.adjustments[category].length > 0) {
          helper.valuation.adjustments[category] = helper.final_report.adjustments[category][0];
          
          // Ensure cumulative is also copied to valuation for all categories with cumulative tracking
          if ((category === 'mileage' || category === 'ownership_type' || category === 'ownership_history' || 
               category === 'features' || category === 'registration') && 
              helper.final_report.adjustments[category][0].cumulative !== undefined) {
            helper.valuation.adjustments[category].cumulative = helper.final_report.adjustments[category][0].cumulative;
          }
        } else {
          // Clear valuation if no items remain
          if (helper.valuation.adjustments[category]) {
            delete helper.valuation.adjustments[category];
          }
        }
        
        // Save to storage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper; // Update window.helper
        
      } catch (error) {
        console.error('Error in syncAdjustmentToHelper:', error);
      }
    }
    
    // Sync UI section with data array (for bidirectional sync)
    function syncUISection(containerId, dataArray) {
      try {
        const container = document.getElementById(containerId);
        if (!container) {
          console.log(`Container ${containerId} not found`);
          return;
        }
        
        console.log(`🔄 Syncing ${dataArray.length} items to ${containerId}`);
        
        // Get existing rows
        const existingRows = container.querySelectorAll('div[id^="featureAdj_"], div[id^="regAdj_"], div[id^="fullFeatureAdj_"], div[id^="fullRegAdj_"]');
        
        // Try to preserve existing rows where possible
        dataArray.forEach((item, index) => {
          if (index < existingRows.length) {
            // Update existing row
            const row = existingRows[index];
            const inputs = row.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              inputs[0].value = item.value || '';
              inputs[1].value = item.type || '%';
              inputs[2].value = item.percentage || '';
              inputs[3].value = item.amount || '';
              
              // Update readonly states based on type - ONLY for Full Market sections with %/₪ dropdowns
              if (containerId.includes('full') || containerId.includes('all')) {
                // Full Market sections use %/₪ type dropdowns
                if (inputs[1].value === '%') {
                  inputs[2].removeAttribute('readonly');
                  inputs[2].style.background = '';
                  inputs[3].setAttribute('readonly', 'readonly');
                  inputs[3].style.background = '#f0f0f0';
                } else {
                  inputs[2].setAttribute('readonly', 'readonly');
                  inputs[2].style.background = '#f0f0f0';
                  inputs[3].removeAttribute('readonly');
                  inputs[3].style.background = '';
                }
              } else {
                // Gross sections use plus/minus dropdowns - both percent and amount should be editable
                inputs[2].removeAttribute('readonly');
                inputs[2].style.background = '';
                inputs[3].removeAttribute('readonly');
                inputs[3].style.background = '';
              }
            }
          } else {
            // Add new row
            if (containerId === 'featuresAdjustmentsList') {
              addFeatureAdjustment();
            } else if (containerId === 'registrationAdjustmentsList') {
              addRegistrationAdjustment();
            } else if (containerId === 'fullFeaturesAdjustmentsList') {
              addFullFeaturesAdjustment();
            } else if (containerId === 'fullRegistrationAdjustmentsList') {
              addFullRegistrationAdjustment();
            }
            
            // Get the newly added row and populate it
            const newRows = container.querySelectorAll('div[id^="featureAdj_"], div[id^="regAdj_"], div[id^="fullFeatureAdj_"], div[id^="fullRegAdj_"]');
            const newRow = newRows[newRows.length - 1];
            if (newRow) {
              const inputs = newRow.querySelectorAll('input, select');
              if (inputs.length >= 4) {
                inputs[0].value = item.value || '';
                inputs[1].value = item.type || '%';
                inputs[2].value = item.percentage || '';
                inputs[3].value = item.amount || '';
                
                // Update readonly states - ONLY for Full Market sections with %/₪ dropdowns
                if (containerId.includes('full') || containerId.includes('all')) {
                  // Full Market sections use %/₪ type dropdowns
                  if (inputs[1].value === '%') {
                    inputs[2].removeAttribute('readonly');
                    inputs[2].style.background = '';
                    inputs[3].setAttribute('readonly', 'readonly');
                    inputs[3].style.background = '#f0f0f0';
                  } else {
                    inputs[2].setAttribute('readonly', 'readonly');
                    inputs[2].style.background = '#f0f0f0';
                    inputs[3].removeAttribute('readonly');
                    inputs[3].style.background = '';
                  }
                } else {
                  // Gross sections use plus/minus dropdowns - both percent and amount should be editable
                  inputs[2].removeAttribute('readonly');
                  inputs[2].style.background = '';
                  inputs[3].removeAttribute('readonly');
                  inputs[3].style.background = '';
                }
              }
            }
          }
        });
        
        // Remove extra rows
        for (let i = dataArray.length; i < existingRows.length; i++) {
          existingRows[i].remove();
        }
        
        console.log(`✅ Synced ${containerId}`);
        
      } catch (error) {
        console.error(`Error syncing UI section ${containerId}:`, error);
      }
    }
    
    // Remove adjustment row
    function removeAdjustmentRow(rowId) {
      const row = document.getElementById(rowId);
      if (row) {
        // Determine which section this row belongs to
        const isGrossFeatures = row.closest('#featuresAdjustmentsList');
        const isGrossRegistration = row.closest('#registrationAdjustmentsList');
        const isFullSection = row.closest('#fullFeaturesAdjustmentsList, #fullRegistrationAdjustmentsList, #mileageAdjustmentsList, #ownershipAdjustmentsList, #ownersAdjustmentsList, #allAdjustmentsList');
        
        // Track deleted items for gross section rows
        if (isGrossFeatures || isGrossRegistration) {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const deletedItem = {
              value: inputs[0]?.value || '',
              description: inputs[0]?.value || '',
              type: inputs[1]?.value || '',
              percent: inputs[2]?.value || '',
              amount: inputs[3]?.value || ''
            };
            
            const category = isGrossFeatures ? 'features' : 'registration';
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            
            if (!helper.grossSectionDeletedItems) helper.grossSectionDeletedItems = {};
            if (!helper.grossSectionDeletedItems[category]) helper.grossSectionDeletedItems[category] = [];
            
            helper.grossSectionDeletedItems[category].push(deletedItem);
            sessionStorage.setItem('helper', JSON.stringify(helper));
            window.helper = helper;
            
            console.log(`🗑️ Tracked deleted ${category} item:`, deletedItem);
          }
        }
        
        // Check if this is an additional adjustment row
        const isAdditionalAdjustment = row.closest('#allAdjustmentsList');
        
        // CRITICAL FIX: Get the description BEFORE removing the row
        let description = '';
        let category = '';
        if (isAdditionalAdjustment) {
          const inputs = row.querySelectorAll('input');
          description = inputs[0]?.value || '';
          category = 'additional';
          console.log(`🗑️ Preparing to remove additional adjustment: "${description}"`);
        } else {
          // Determine category for other sections
          if (row.closest('#featuresAdjustmentsList') || row.closest('#fullFeaturesAdjustmentsList')) category = 'features';
          else if (row.closest('#registrationAdjustmentsList') || row.closest('#fullRegistrationAdjustmentsList')) category = 'registration';
          else if (row.closest('#mileageAdjustmentsList')) category = 'mileage';
          else if (row.closest('#ownershipAdjustmentsList')) category = 'ownership_type';
          else if (row.closest('#ownersAdjustmentsList')) category = 'ownership_history';
        }
        
        // Remove the row from UI
        row.remove();
        
        // For any category, trigger the sync function to rebuild arrays properly
        if (category) {
          console.log(`🔄 Triggering sync for category: ${category} after row deletion`);
          
          // Find the container and trigger sync with remaining rows
          let containerId = '';
          if (category === 'features') {
            containerId = isGrossFeatures ? 'featuresAdjustmentsList' : 'fullFeaturesAdjustmentsList';
          } else if (category === 'registration') {
            containerId = isGrossRegistration ? 'registrationAdjustmentsList' : 'fullRegistrationAdjustmentsList';
          } else if (category === 'mileage') containerId = 'mileageAdjustmentsList';
          else if (category === 'ownership_type') containerId = 'ownershipAdjustmentsList';
          else if (category === 'ownership_history') containerId = 'ownersAdjustmentsList';
          else if (category === 'additional') containerId = 'allAdjustmentsList';
          
          const container = document.getElementById(containerId);
          if (container && container.children.length > 0) {
            // Use first remaining input to trigger sync
            const firstInput = container.children[0].querySelector('input');
            if (firstInput) {
              syncAdjustmentToHelper(firstInput, category);
            }
          } else {
            // No rows left, manually clear the category
            const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
            
            // Clear from all locations
            if (helper.estimate?.adjustments?.[category]) {
              helper.estimate.adjustments[category] = [];
            }
            if (helper.final_report?.adjustments?.[category]) {
              helper.final_report.adjustments[category] = [];
            }
            if (helper.valuation?.adjustments?.[category]) {
              delete helper.valuation.adjustments[category];
            }
            
            sessionStorage.setItem('helper', JSON.stringify(helper));
            window.helper = helper;
            
            console.log(`🧹 Cleared all data for category: ${category}`);
          }
        }
        
        // Call appropriate calculation function based on section
        if (isGrossFeatures || isGrossRegistration) {
          console.log('🔄 Updating GROSS calculation after row removal');
          updateGrossMarketValueCalculation();
        }
        if (isFullSection) {
          console.log('🔄 Updating FULL calculation after row removal');
          updateFullMarketValueCalculation();
        }
        
        // OLD BROKEN CODE - KEEPING FOR REFERENCE BUT IT'S NOT NEEDED WITH SYNC PATTERN
        /*
        // For additional adjustments, we need to remove from helper arrays before updating
        if (isAdditionalAdjustment) {
          console.log('🗑️ Removing additional adjustment from helper arrays');
          
          // Get the description/value from the row to identify which item to remove
          const inputs = row.querySelectorAll('input');
          const description = inputs[0]?.value || '';
        */
        
        console.log(`✅ Successfully removed row and synced data using new estimator pattern`);
      }
    }
    
    // Get cumulative value from previous category for correct percentage base calculation
    function getPreviousCategoryCumulative(categoryContainer) {
      let cumulativeValue = 0;
      
      if (categoryContainer === 'mileageAdjustmentsList') {
        // Mileage should use cumulative after Features + Registration
        const registrationCumulative = document.getElementById('registrationCumulative');
        if (registrationCumulative) {
          const span = registrationCumulative.querySelector('span');
          if (span) {
            const text = span.textContent.replace(/[₪,]/g, '');
            cumulativeValue = parseFloat(text) || 0;
          }
        }
      } else if (categoryContainer === 'ownershipAdjustmentsList') {
        // Ownership Type should use cumulative after Mileage
        const mileageCumulative = document.getElementById('mileageCumulative');
        if (mileageCumulative) {
          const span = mileageCumulative.querySelector('span');
          if (span) {
            const text = span.textContent.replace(/[₪,]/g, '');
            cumulativeValue = parseFloat(text) || 0;
          }
        }
      } else if (categoryContainer === 'ownersAdjustmentsList') {
        // Ownership History should use cumulative after Ownership Type
        const ownershipCumulative = document.getElementById('ownershipCumulative');
        if (ownershipCumulative) {
          const span = ownershipCumulative.querySelector('span');
          if (span) {
            const text = span.textContent.replace(/[₪,]/g, '');
            cumulativeValue = parseFloat(text) || 0;
          }
        }
      } else if (categoryContainer === 'allAdjustmentsList') {
        // Additional should use cumulative after Ownership History
        const ownersCumulative = document.getElementById('ownersCumulative');
        if (ownersCumulative) {
          const span = ownersCumulative.querySelector('span');
          if (span) {
            const text = span.textContent.replace(/[₪,]/g, '');
            cumulativeValue = parseFloat(text) || 0;
          }
        }
      }
      
      return cumulativeValue;
    }
    
    // Get basic price fallback for Gross section or when cumulative is not available
    function getBasicPriceFallback() {
      let basicPrice = 0;
      const basicPriceField = document.getElementById('basicPrice');
      if (basicPriceField?.value) {
        basicPrice = parseFloat(basicPriceField.value.replace(/[₪,]/g, '')) || 0;
      }
      
      // Fallback to helper data if needed
      if (basicPrice === 0) {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        basicPrice = helper.estimate?.market_value_base || helper.levisummary?.base_price || 118000;
      }
      
      return basicPrice;
    }

    // Calculate adjustment value for simple percentage input
    function calculateAdjustmentValueSimple(percentInput) {
      const row = percentInput.closest('div[id*="Adj_"]');
      if (!row) return;
      
      const inputs = row.querySelectorAll('input, select');
      if (inputs.length < 4) return;
      
      const percent = parseFloat(percentInput.value) || 0;
      if (percent === 0) return;
      
      // CRITICAL: First ensure cumulative displays are updated by running calculation
      setTimeout(() => {
        if (typeof updateFullMarketValueCalculation === 'function') {
          updateFullMarketValueCalculation();
        }
        
        // Then proceed with the calculation using updated cumulatives
        setTimeout(() => {
          performManualRowCalculation(percentInput, row, inputs, percent);
        }, 50);
      }, 10);
    }
    
    // Separated calculation logic to run after cumulative updates
    function performManualRowCalculation(percentInput, row, inputs, percent) {
      // CRITICAL FIX: Determine which category this row belongs to and get correct base value
      let baseValue = 0;
      const isMileage = row.closest('#mileageAdjustmentsList');
      const isOwnership = row.closest('#ownershipAdjustmentsList'); 
      const isOwners = row.closest('#ownersAdjustmentsList');
      const isAdditional = row.closest('#allAdjustmentsList');
      const isGrossFeatures = row.closest('#featuresAdjustmentsList');
      const isGrossRegistration = row.closest('#registrationAdjustmentsList');
      const isFullFeatures = row.closest('#fullFeaturesAdjustmentsList');
      const isFullRegistration = row.closest('#fullRegistrationAdjustmentsList');
      
      if (isMileage) {
        // Mileage manual rows should use cumulative from Features+Registration
        baseValue = getPreviousCategoryCumulative('mileageAdjustmentsList');
        console.log(`🔧 MILEAGE manual row: Using Features+Registration cumulative base: ₪${baseValue.toLocaleString()}`);
      } else if (isOwnership) {
        // Ownership Type manual rows should use cumulative from Mileage
        baseValue = getPreviousCategoryCumulative('ownershipAdjustmentsList');
        console.log(`🔧 OWNERSHIP TYPE manual row: Using Mileage cumulative base: ₪${baseValue.toLocaleString()}`);
      } else if (isOwners) {
        // Ownership History manual rows should use cumulative from Ownership Type
        baseValue = getPreviousCategoryCumulative('ownersAdjustmentsList');
        console.log(`🔧 OWNERSHIP HISTORY manual row: Using Ownership Type cumulative base: ₪${baseValue.toLocaleString()}`);
      } else if (isAdditional) {
        // Additional manual rows should use cumulative from Ownership History
        baseValue = getPreviousCategoryCumulative('allAdjustmentsList');
        console.log(`🔧 ADDITIONAL manual row: Using Ownership History cumulative base: ₪${baseValue.toLocaleString()}`);
      } else if (isGrossFeatures || isGrossRegistration || isFullFeatures || isFullRegistration) {
        // Gross section OR Full Market Features/Registration continue using basicPrice
        baseValue = getBasicPriceFallback();
        const sectionType = (isGrossFeatures || isGrossRegistration) ? 'GROSS' : 'FULL MARKET';
        console.log(`🔧 ${sectionType} Features/Registration manual row: Using basic price base: ₪${baseValue.toLocaleString()}`);
      } else {
        // Default fallback to basicPrice for unknown categories
        baseValue = getBasicPriceFallback();
        console.log(`🔧 UNKNOWN category manual row: Using basic price fallback: ₪${baseValue.toLocaleString()}`);
      }
      
      // If no cumulative found, fallback to basic price
      if (baseValue === 0) {
        baseValue = getBasicPriceFallback();
        console.log(`🔧 No cumulative found, using basic price fallback: ₪${baseValue.toLocaleString()}`);
      }
      
      const calculatedValue = (baseValue * percent) / 100;
      const type = inputs[1].value;
      
      console.log(`💰 Manual row calculation: ${percent}% × ₪${baseValue.toLocaleString()} = ₪${Math.round(calculatedValue).toLocaleString()}`);
      
      // Apply sign based on type
      if (type === 'minus' || type === 'הפחתה' || type === 'הפחתה (-)') {
        inputs[3].value = `-₪${Math.round(calculatedValue).toLocaleString()}`;
      } else {
        inputs[3].value = `₪${Math.round(calculatedValue).toLocaleString()}`;
      }
    }
    
    // ============================================================================
    // END OF AUTO-POPULATION FUNCTIONS
    // ============================================================================
    
    // Update helper from adjustments - IMPROVED VERSION with proper save pattern
    function updateHelperFromAdjustments() {
      try {
        console.log('🔄 updateHelperFromAdjustments called');
        
        const helper = window.helper || {};
        
        // Call the new dedicated save functions for each section
        updateGrossValueToFinalReportAndValuation(helper);
        updateFullMarketValueToFinalReportAndValuation(helper);
        
        // Save to sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper; // Update window.helper too
        
        console.log('✅ updateHelperFromAdjustments completed - used dedicated save functions');
        
      } catch (error) {
        console.error('❌ Error in updateHelperFromAdjustments:', error);
      }
    }

    /**
     * Trigger change events on all adjustment fields to ensure formatAdjustmentDisplay runs
     * Critical for minus sign detection on page refresh
     */
    function triggerAllAdjustmentChangeEvents() {
      try {
        console.log('🔄 Triggering all adjustment change events for proper formatting');
        
        // Find all adjustment containers
        const containers = [
          'grossFeaturesAdjustmentsList',
          'grossRegistrationAdjustmentsList', 
          'fullFeaturesAdjustmentsList',
          'fullRegistrationAdjustmentsList',
          'mileageAdjustmentsList',
          'ownershipAdjustmentsList',
          'ownersAdjustmentsList',
          'allAdjustmentsList'
        ];
        
        containers.forEach(containerId => {
          const container = document.getElementById(containerId);
          if (container) {
            const rows = container.querySelectorAll('div[id*="Adj_"]');
            rows.forEach(row => {
              const inputs = row.querySelectorAll('input, select');
              if (inputs.length >= 4) {
                // Get current values for formatAdjustmentDisplay
                const type = inputs[1].value;
                const percent = parseFloat(inputs[2].value) || 0;
                const amountText = inputs[3].value || '';
                const amount = parseFloat(amountText.replace(/[₪,-]/g, '')) || 0;
                
                // Call formatAdjustmentDisplay directly to ensure proper formatting
                formatAdjustmentDisplay(row, type, percent, amount);
                
                // Also trigger change events
                if (inputs[1]) inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
                if (inputs[2] && inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
                if (inputs[3] && inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
              }
            });
            console.log(`✅ Triggered change events for ${rows.length} rows in ${containerId}`);
          }
        });
        
        console.log('✅ Completed triggering all adjustment change events');
        
      } catch (error) {
        console.error('❌ Error triggering adjustment change events:', error);
      }
    }

    /**
     * Update gross value adjustments to BOTH final_report.adjustments AND valuation.adjustments
     * Based on working pattern from estimator-builder.html
     */
    function updateGrossValueToFinalReportAndValuation(helper) {
      try {
        // Initialize structures
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // 1. FEATURES - Copy EXACT estimator pattern
        const featuresRows = document.querySelectorAll('#featuresAdjustmentsList > div');
        helper.final_report.adjustments.features = [];
        
        featuresRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value),
              source: row.getAttribute('data-source') || 'manual'
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.final_report.adjustments.features.push(adjustmentData);
          }
        });
        
        // Update valuation.adjustments ONLY with ORIGINAL rows (not additional manual rows)
        if (helper.estimate?.adjustments?.features && Array.isArray(helper.estimate.adjustments.features) && helper.estimate.adjustments.features.length > 0) {
          helper.valuation.adjustments.features = helper.estimate.adjustments.features[0];
          console.log('💾 Updated valuation.adjustments.features from estimate (Levi data)');
        } else {
          // Look for ORIGINAL rows only (not manual additions)
          const originalRow = [...featuresRows].find(row => {
            const dataSource = row.getAttribute('data-source');
            return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
          });
          
          if (originalRow) {
            const inputs = originalRow.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              const adjustmentData = {
                value: inputs[0].value || '',
                type: inputs[1].value || 'plus',
                percent: parseFloat(inputs[2].value) || 0,
                percentage: parseFloat(inputs[2].value) || 0,
                amount_display: inputs[3].value || '',
                amount: safeParseAmount(inputs[3].value),
                source: originalRow.getAttribute('data-source') || 'original'
              };
              
              // Apply sign based on type
              if (inputs[1].value === 'minus') {
                adjustmentData.amount = -Math.abs(adjustmentData.amount);
                adjustmentData.percent = -Math.abs(adjustmentData.percent);
                adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
              }
              
              helper.valuation.adjustments.features = adjustmentData;
              console.log('💾 Updated valuation.adjustments.features from ORIGINAL row');
            }
          } else {
            // Only delete if we're certain there's no original data
            if (!helper.valuation?.adjustments?.features?.value && !helper.valuation?.adjustments?.features?.percent) {
              delete helper.valuation.adjustments.features;
              console.log('🗑️ Cleared valuation.adjustments.features (no original data)');
            }
          }
        }
        
        // 2. REGISTRATION - Copy EXACT estimator pattern
        const registrationRows = document.querySelectorAll('#registrationAdjustmentsList > div');
        helper.final_report.adjustments.registration = [];
        
        registrationRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value),
              source: row.getAttribute('data-source') || 'manual'
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.final_report.adjustments.registration.push(adjustmentData);
          }
        });
        
        // Update valuation.adjustments ONLY with ORIGINAL rows (not additional manual rows)
        if (helper.estimate?.adjustments?.registration && Array.isArray(helper.estimate.adjustments.registration) && helper.estimate.adjustments.registration.length > 0) {
          helper.valuation.adjustments.registration = helper.estimate.adjustments.registration[0];
          console.log('💾 Updated valuation.adjustments.registration from estimate (Levi data)');
        } else {
          // Look for ORIGINAL rows only (not manual additions)
          const originalRow = [...registrationRows].find(row => {
            const dataSource = row.getAttribute('data-source');
            return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
          });
          
          if (originalRow) {
            const inputs = originalRow.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              const adjustmentData = {
                value: inputs[0].value || '',
                type: inputs[1].value || 'plus',
                percent: parseFloat(inputs[2].value) || 0,
                percentage: parseFloat(inputs[2].value) || 0,
                amount_display: inputs[3].value || '',
                amount: safeParseAmount(inputs[3].value),
                source: originalRow.getAttribute('data-source') || 'original'
              };
              
              // Apply sign based on type
              if (inputs[1].value === 'minus') {
                adjustmentData.amount = -Math.abs(adjustmentData.amount);
                adjustmentData.percent = -Math.abs(adjustmentData.percent);
                adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
              }
              
              helper.valuation.adjustments.registration = adjustmentData;
              console.log('💾 Updated valuation.adjustments.registration from ORIGINAL row');
            }
          } else {
            // Only delete if we're certain there's no original data
            if (!helper.valuation?.adjustments?.registration?.value && !helper.valuation?.adjustments?.registration?.percent) {
              delete helper.valuation.adjustments.registration;
              console.log('🗑️ Cleared valuation.adjustments.registration (no original data)');
            }
          }
        }
        
        console.log('✅ Updated gross value adjustments to BOTH final_report.adjustments AND valuation.adjustments');
        
        // DISABLED: Auto-populate that clears Total Value manual additions
        // if (helper.final_report.adjustments.features) {
        //   syncFullMarketFeaturesWithGross(helper.final_report.adjustments.features);
        // }
        // if (helper.final_report.adjustments.registration) {
        //   syncFullMarketRegistrationWithGross(helper.final_report.adjustments.registration);
        // }
        
      } catch (error) {
        console.error('❌ Error updating gross value to final_report and valuation adjustments:', error);
      }
    }

    /**
     * Update FULL MARKET VALUE categories to BOTH final_report.adjustments AND valuation.adjustments
     * Based on working pattern from estimator-builder.html
     */
    function updateFullMarketValueToFinalReportAndValuation(helper) {
      try {
        // CRITICAL FIX: Skip during page load to prevent overriding saved dropdown states
        if (window.pageLoadInProgress) {
          console.log('⏸️ Skipping updateFullMarketValueToFinalReportAndValuation during page load to preserve saved types');
          return;
        }
        
        // Initialize structures
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // 1. FEATURES - Only sync ORIGINAL rows to valuation (not additional manual rows)
        const fullFeaturesRows = document.querySelectorAll('#fullFeaturesAdjustmentsList > div');
        const originalFeatureRow = [...fullFeaturesRows].find(row => {
          const dataSource = row.getAttribute('data-source');
          return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
        });
        
        if (originalFeatureRow) {
          const inputs = originalFeatureRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            helper.valuation.adjustments.features = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value)
            };
            console.log('💾 Updated valuation.adjustments.features from ORIGINAL Total Market Value row');
          }
        }
        
        // 2. REGISTRATION - Only sync ORIGINAL rows to valuation (not additional manual rows)
        const fullRegistrationRows = document.querySelectorAll('#fullRegistrationAdjustmentsList > div');
        const originalRegistrationRow = [...fullRegistrationRows].find(row => {
          const dataSource = row.getAttribute('data-source');
          return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
        });
        
        if (originalRegistrationRow) {
          const inputs = originalRegistrationRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            helper.valuation.adjustments.registration = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value)
            };
            console.log('💾 Updated valuation.adjustments.registration from ORIGINAL Total Market Value row');
          }
        }
        
        // 3. MILEAGE (KM) - Save ALL rows to final_report, ONLY ORIGINAL rows to valuation
        const mileageRows = document.querySelectorAll('#mileageAdjustmentsList > div');
        helper.final_report.adjustments.mileage = [];
        
        // Save ALL mileage rows to final_report.adjustments
        mileageRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value),
              source: row.getAttribute('data-source') || 'manual'
            };
            
            // Apply sign based on type - CRITICAL FOR MINUS VALUES
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.final_report.adjustments.mileage.push(adjustmentData);
          }
        });
        
        // Save ONLY ORIGINAL row to valuation.adjustments
        const originalMileageRow = [...mileageRows].find(row => {
          const dataSource = row.getAttribute('data-source');
          return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
        });
        
        if (originalMileageRow) {
          const inputs = originalMileageRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value)
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.valuation.adjustments.mileage = adjustmentData;
            console.log('💾 Updated valuation.adjustments.mileage from ORIGINAL row');
          }
        }
        
        // 4. OWNERSHIP TYPE - Save ALL rows to final_report, ONLY ORIGINAL rows to valuation
        const ownershipRows = document.querySelectorAll('#ownershipAdjustmentsList > div');
        helper.final_report.adjustments.ownership_type = [];
        
        // Save ALL ownership rows to final_report.adjustments
        ownershipRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value),
              source: row.getAttribute('data-source') || 'manual'
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.final_report.adjustments.ownership_type.push(adjustmentData);
          }
        });
        
        // Save ONLY ORIGINAL row to valuation.adjustments
        const originalOwnershipRow = [...ownershipRows].find(row => {
          const dataSource = row.getAttribute('data-source');
          return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
        });
        
        if (originalOwnershipRow) {
          const inputs = originalOwnershipRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value)
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.valuation.adjustments.ownership_type = adjustmentData;
            console.log('💾 Updated valuation.adjustments.ownership_type from ORIGINAL row');
          }
        }
        
        // 5. OWNERSHIP HISTORY - Save ALL rows to final_report, ONLY ORIGINAL rows to valuation
        const ownersRows = document.querySelectorAll('#ownersAdjustmentsList > div');
        helper.final_report.adjustments.ownership_history = [];
        
        // DEBUG: Log when this function clears and rebuilds ownership_history
        console.log(`🚨 updateFullMarketValueToFinalReportAndValuation CLEARING ownership_history and rebuilding from UI`, {
          pageLoadInProgress: window.pageLoadInProgress,
          ownersRowsCount: ownersRows.length
        });
        
        // Save ALL ownership history rows to final_report.adjustments
        ownersRows.forEach((row, index) => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            // DEBUG: Log what type is being read from dropdown
            console.log(`🔍 REBUILDING owners[${index}] type from dropdown: ${inputs[1].value}`, {
              dropdown: inputs[1],
              selectedValue: inputs[1].value,
              selectedIndex: inputs[1].selectedIndex,
              options: Array.from(inputs[1].options).map(o => ({value: o.value, selected: o.selected}))
            });
            
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value),
              source: row.getAttribute('data-source') || 'manual'
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.final_report.adjustments.ownership_history.push(adjustmentData);
          }
        });
        
        // Save ONLY ORIGINAL row to valuation.adjustments
        const originalOwnersRow = [...ownersRows].find(row => {
          const dataSource = row.getAttribute('data-source');
          return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
        });
        
        if (originalOwnersRow) {
          const inputs = originalOwnersRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value)
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.valuation.adjustments.ownership_history = adjustmentData;
            console.log('💾 Updated valuation.adjustments.ownership_history from ORIGINAL row');
          }
        }
        
        // 6. ADDITIONAL - Only in Full Market Value
        const additionalRows = document.querySelectorAll('#allAdjustmentsList > div');
        if (additionalRows.length > 0) {
          helper.final_report.adjustments.additional = [];
          additionalRows.forEach(row => {
            const inputs = row.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              const adjustmentData = {
                value: inputs[0].value || '',
                type: inputs[1].value || 'plus',
                percent: parseFloat(inputs[2].value) || 0,
                percentage: parseFloat(inputs[2].value) || 0,
                amount_display: inputs[3].value || '',
                amount: safeParseAmount(inputs[3].value),
                source: row.getAttribute('data-source') || 'manual'
              };
              
              // Apply sign based on type - CRITICAL FOR MINUS VALUES
              if (inputs[1].value === 'minus') {
                adjustmentData.amount = -Math.abs(adjustmentData.amount);
                adjustmentData.percent = -Math.abs(adjustmentData.percent);
                adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
              }
              
              helper.final_report.adjustments.additional.push(adjustmentData);
            }
          });
          
          // CRITICAL: DO NOT write additional categories to valuation.adjustments
          // Additional adjustments should ONLY exist in final_report.adjustments
        } else {
          helper.final_report.adjustments.additional = [];
          // Don't touch valuation.adjustments for additional categories
        }
        
        console.log('✅ Updated full market value adjustments to BOTH final_report.adjustments AND valuation.adjustments');
        
      } catch (error) {
        console.error('❌ Error updating full market value to final_report and valuation adjustments:', error);
      }
    }
    
    /**
     * Sync Full Market Value Registration with Gross Value Section
     * CRITICAL for Issue 5: Data Sync Between Sections
     */
    function syncFullMarketRegistrationWithGross(grossRegistrations) {
      try {
        const container = document.getElementById('fullRegistrationAdjustmentsList');
        if (!container || !grossRegistrations || grossRegistrations.length === 0) return;
        
        // Clear existing Full Market registration
        container.innerHTML = '';
        
        // Add each gross registration to Full Market section
        grossRegistrations.forEach(registration => {
          addFullMarketRegistrationAdjustment();
          const lastRow = container.querySelector('div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              inputs[0].value = registration.value || '';
              inputs[1].value = registration.type || 'plus';
              
              // CRITICAL FIX: Display minus sign for negative values
              const displayPercent = isReductionType(registration.type) && registration.percent > 0 ? 
                `-${Math.abs(registration.percent)}` : Math.abs(registration.percent || 0);
              const displayAmount = isReductionType(registration.type) && registration.amount > 0 ? 
                `-${Math.abs(registration.amount)}` : Math.abs(registration.amount || 0);
              
              inputs[2].value = displayPercent || '';
              inputs[3].value = registration.amount_display || (registration.amount ? `₪${displayAmount.toLocaleString()}` : '');
              lastRow.setAttribute('data-source', registration.source || 'gross_sync');
            }
          }
        });
        
        console.log('✅ Synced Full Market Registration with Gross Value section');
        
      } catch (error) {
        console.error('❌ Error syncing Full Market Registration with Gross Value:', error);
      }
    }

    /**
     * Sync Full Market Value Features with Gross Value Section
     * CRITICAL for Issue 5: Data Sync Between Sections
     */
    function syncFullMarketFeaturesWithGross(grossFeatures) {
      try {
        const container = document.getElementById('fullFeaturesAdjustmentsList');
        if (!container || !grossFeatures || grossFeatures.length === 0) return;
        
        // Clear existing Full Market features
        container.innerHTML = '';
        
        // Add each gross feature to Full Market section
        grossFeatures.forEach(feature => {
          addFullMarketFeatureAdjustment();
          const lastRow = container.querySelector('div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              inputs[0].value = feature.value || '';
              inputs[1].value = feature.type || 'plus';
              
              // CRITICAL FIX: Display minus sign for negative values
              const displayPercent = isReductionType(feature.type) && feature.percent > 0 ? 
                `-${Math.abs(feature.percent)}` : Math.abs(feature.percent || 0);
              const displayAmount = isReductionType(feature.type) && feature.amount > 0 ? 
                `-${Math.abs(feature.amount)}` : Math.abs(feature.amount || 0);
              
              inputs[2].value = displayPercent || '';
              inputs[3].value = feature.amount_display || (feature.amount ? `₪${displayAmount.toLocaleString()}` : '');
              lastRow.setAttribute('data-source', feature.source || 'gross_sync');
            }
          }
        });
        
        console.log('✅ Synced Full Market features with Gross Value section');
        
      } catch (error) {
        console.error('❌ Error syncing Full Market features:', error);
      }
    }

    /**
     * Sync Full Market Value Registration with Gross Value Section
     * CRITICAL for Issue 5: Data Sync Between Sections
     */
    function syncFullMarketRegistrationWithGross(grossRegistration) {
      try {
        const container = document.getElementById('fullRegistrationAdjustmentsList');
        if (!container || !grossRegistration || grossRegistration.length === 0) return;
        
        // Clear existing Full Market registration
        container.innerHTML = '';
        
        // Add each gross registration to Full Market section
        grossRegistration.forEach(registration => {
          addFullMarketRegistrationAdjustment();
          const lastRow = container.querySelector('div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              inputs[0].value = registration.value || '';
              inputs[1].value = registration.type || 'plus';
              
              // CRITICAL FIX: Display minus sign for negative values
              const displayPercent = isReductionType(registration.type) && registration.percent > 0 ? 
                `-${Math.abs(registration.percent)}` : Math.abs(registration.percent || 0);
              const displayAmount = isReductionType(registration.type) && registration.amount > 0 ? 
                `-${Math.abs(registration.amount)}` : Math.abs(registration.amount || 0);
              
              inputs[2].value = displayPercent || '';
              inputs[3].value = registration.amount_display || (registration.amount ? `₪${displayAmount.toLocaleString()}` : '');
              lastRow.setAttribute('data-source', registration.source || 'gross_sync');
            }
          }
        });
        
        console.log('✅ Synced Full Market registration with Gross Value section');
        
      } catch (error) {
        console.error('❌ Error syncing Full Market registration:', error);
      }
    }

    /**
     * Add Full Market Feature Adjustment (for sync with Gross Value)
     */
    function addFullMarketFeatureAdjustment() {
      const container = document.getElementById('fullFeaturesAdjustmentsList');
      const rowId = 'fullFeatureAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
          <div><input type="text" placeholder="תיאור המאפיין" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features');" /></div>
          <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features');">
            <option value="plus">תוספת (+)</option>
            <option value="minus">הפחתה (-)</option>
          </select></div>
          <div><input type="text" placeholder="אחוז" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features');" /></div>
          <div><input type="text" placeholder="₪" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features');" /></div>
          <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
    }

    /**
     * Add Full Market Registration Adjustment (for sync with Gross Value)
     */
    function addFullMarketRegistrationAdjustment() {
      const container = document.getElementById('fullRegistrationAdjustmentsList');
      const rowId = 'fullRegAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
          <div><input type="text" placeholder="תיאור עליה לכביש" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');" /></div>
          <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');">
            <option value="plus">תוספת (+)</option>
            <option value="minus">הפחתה (-)</option>
          </select></div>
          <div><input type="text" placeholder="אחוז" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');" /></div>
          <div><input type="text" placeholder="₪" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');" /></div>
          <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
    }

    // NOTE: Duplicate function removed - using the updated version with dedicated save functions
    
    /**
     * Listen for helper updates to trigger re-population when Levi data changes
     */
    let lastLeviDataHash = null;
    function setupLeviDataListener() {
      // Calculate initial Levi data hash to detect real changes
      function getLeviDataHash(helperData) {
        if (!helperData) return null;
        const leviData = {
          summary: helperData.levisummary,
          report: helperData.levi_report
        };
        return JSON.stringify(leviData);
      }
      
      // Set initial hash
      lastLeviDataHash = getLeviDataHash(helper);
      
      // Listen for storage events (when helper data changes)
      window.addEventListener('storage', (event) => {
        if (event.key === 'helper' && event.newValue) {
          try {
            const newHelper = JSON.parse(event.newValue);
            const newLeviDataHash = getLeviDataHash(newHelper);
            
            // Only clear and re-populate if Levi data actually changed
            if (newLeviDataHash !== lastLeviDataHash && (newHelper.levisummary || newHelper.levi_report)) {
              console.log('📡 Detected Levi data update, re-populating adjustments...');
              lastLeviDataHash = newLeviDataHash;
              clearLeviAdjustments();
              helper = newHelper; // Update global helper
              autoPopulateFromLeviSummary();
            } else {
              // Just update the helper reference without clearing user input
              helper = newHelper;
            }
          } catch (error) {
            console.error('❌ Error processing helper update:', error);
          }
        }
      });
      
      // Also listen for custom events
      document.addEventListener('helperUpdate', (event) => {
        if (event.detail && (event.detail.section === 'levisummary' || event.detail.section === 'levi_report')) {
          console.log('📡 Detected Levi data event, re-populating adjustments...');
          clearLeviAdjustments();
          autoPopulateFromLeviSummary();
        }
      });
      
      console.log('📡 Levi data listener setup completed');
    }
    
    // Calculate adjustment value from percentage - ENHANCED
    function calculateAdjustmentValue(percentInput) {
      const row = percentInput.closest('div[id^="featureAdj_"], div[id^="regAdj_"]');
      if (!row) {
        console.warn('⚠️ Cannot find adjustment row for calculation');
        return;
      }
      
      const percent = parseFloat(percentInput.value.replace('%', '')) || 0;
      let basicPrice = parseFloat(document.getElementById('basicPrice')?.value.replace(/[₪,]/g, '')) || 0;
      
      // Try alternative price sources if basicPrice is empty
      if (basicPrice === 0) {
        // Try grossMarketValue first (from calculations)
        const grossMarketValue = parseFloat(document.getElementById('grossMarketValue')?.value.replace(/[₪,]/g, '')) || 0;
        if (grossMarketValue > 0) {
          basicPrice = grossMarketValue;
          console.log('📊 Using grossMarketValue for calculation:', basicPrice);
        }
      }
      
      // If still no price, try to get BASE PRICE from helper
      if (basicPrice === 0) {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        if (helper.levi_report?.base_price) {
          basicPrice = parseFloat(helper.levi_report.base_price);
        } else if (helper.expertise?.levi_report?.base_price) {
          basicPrice = parseFloat(helper.expertise.levi_report.base_price);
        } else if (helper.levisummary?.base_price) {
          basicPrice = parseFloat(helper.levisummary.base_price);
        } else if (helper.car_details?.base_price) {
          basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[₪,]/g, ''));
        } else {
          // REMOVED market_value fallback - we need BASE price only for calculations
          console.warn('⚠️ No Levi BASE PRICE found for adjustment calculation');
        }
        
        // If we found a basic price, update the field
        if (basicPrice > 0) {
          const basicPriceField = document.getElementById('basicPrice');
          if (basicPriceField) {
            basicPriceField.value = `₪${basicPrice.toLocaleString()}`;
          }
        }
      }
      
      const valueInput = row.querySelector('input[placeholder="₪"]');
      
      if (!valueInput) {
        console.error('⚠️ Cannot find value input field in adjustment row');
        return;
      }
      
      if (basicPrice > 0 && percent !== 0) {
        const calculatedValue = (basicPrice * percent) / 100;
        valueInput.value = `₪${Math.round(calculatedValue).toLocaleString()}`;
        console.log(`💰 Calculated adjustment value: ${percent}% × ₪${basicPrice.toLocaleString()} = ₪${Math.round(calculatedValue).toLocaleString()}`);
        
        // Trigger change event to update other calculations
        valueInput.dispatchEvent(new Event('change', { bubbles: true }));
      } else {
        console.warn(`⚠️ Cannot calculate adjustment value - basicPrice: ${basicPrice}, percent: ${percent}`);
        if (basicPrice === 0) {
          console.warn('⚠️ No car price found. Please set the basic price first.');
        }
      }
    }
    
    // SIMPLE ADJUSTMENT CALCULATION - COPIED FROM WORKING DEPRECIATION
    // Duplicate function - removing to avoid conflicts
    // (Already defined above with proper implementation)

    // SIMPLE FINAL REPORTADJUSTMENT CALCULATION - COPIED FROM WORKING DEPRECIATION
    function calculateFinalReportAdjustmentValueSimple(percentInput) {
      const percent = parseFloat(percentInput.value) || 0;
      const row = percentInput.closest('div');
      
      if (!row) return;
      
      // Get helper data like the working depreciation does
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const marketValue = parseFloat(helper.expertise?.levi_report?.final_price) || 0;
      
      // Calculate value exactly like working depreciation
      const calculatedValue = Math.round((marketValue * percent) / 100);
      
      // Find value input (third input in row)
      const inputs = row.querySelectorAll('input');
      if (inputs.length > 2) {
        const valueInput = inputs[2];
        valueInput.value = calculatedValue || '';
      }
    }

    // Test function to manually add adjustment data for debugging
    function addTestAdjustments() {
      console.log('🧪 Adding test adjustments for debugging');
      
      // Add test features adjustment
      addFeatureAdjustment();
      const featuresContainer = document.getElementById('featuresAdjustmentsList');
      const lastFeaturesRow = featuresContainer.querySelector('div:last-child');
      if (lastFeaturesRow) {
        const inputs = lastFeaturesRow.querySelectorAll('input[type="text"]');
        inputs[0].value = 'מאפיין בדיקה';
        inputs[1].value = '5%';
        inputs[2].value = '₪1000';
        lastFeaturesRow.querySelector('select').value = 'plus';
      }
      
      // Add test registration adjustment
      addRegistrationAdjustment();
      const registrationContainer = document.getElementById('registrationAdjustmentsList');
      const lastRegistrationRow = registrationContainer.querySelector('div:last-child');
      if (lastRegistrationRow) {
        const inputs = lastRegistrationRow.querySelectorAll('input[type="text"]');
        inputs[0].value = 'עליה לכביש בדיקה';
        inputs[1].value = '10%';
        inputs[2].value = '₪2000';
        lastRegistrationRow.querySelector('select').value = 'plus';
      }
      
      // Trigger the update
      updateHelperFromAdjustments();
    }
    
    // Expose test function globally
    window.addTestAdjustments = addTestAdjustments;
    
    // CRITICAL FIX: Add function to completely reset adjustment data
    function resetAdjustmentData() {
      console.log('🧹 RESET: Completely clearing all adjustment data');
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Clear all adjustment data
      if (helper.levi_report) {
        helper.levi_report.adjustments = [];
      }
      if (helper.levi) {
        helper.levi.custom_adjustments = [];
      }
      
      // Clear DOM
      // Final report adjustments container was removed - no action needed
      
      // Save cleaned helper
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      console.log('✅ RESET: All adjustment data cleared');
    }
    
    // Expose reset function globally for testing
    window.resetAdjustmentData = resetAdjustmentData;
    
    
    // Calculate and update GROSS PRICE (car properties only: base + features + registration)
    function updateGrossMarketValueCalculation() {
      try {
        // Get base price from the visible field that shows ₪118,000
        let basicPrice = 0;
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Priority 1: Direct from the basicPrice field that shows ₪118,000
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField?.value) {
          basicPrice = parseFloat(basicPriceField.value.replace(/[₪,]/g, '')) || 0;
          console.log('🔍 Using basicPrice field:', basicPrice);
        }
        // Priority 2: Try the visible field in the ערך הרכב ע"פ מחירון section
        else {
          const allInputs = document.querySelectorAll('input[type="text"]');
          for (let input of allInputs) {
            const numericValue = parseFloat(input.value.replace(/[₪,]/g, ''));
            if (numericValue > 0) {
              basicPrice = numericValue;
              console.log('🔍 Found price in field:', input.id || 'unknown', 'value:', basicPrice);
              break;
            }
          }
        }
        
        // Fallback: Use helper base price or market value if available, otherwise 0
        if (basicPrice === 0) {
          basicPrice = helper.calculations?.base_market_value || helper.levisummary?.base_price || helper.valuation?.base_price || 0;
          console.log('🔍 FALLBACK: Using helper base price:', basicPrice);
        }
        
        console.log('🔍 DEBUG: Final basic price for calculation:', basicPrice);
        
        // Collect features adjustments (car properties)
        const featuresAdjustments = [];
        const featuresRows = document.querySelectorAll('#featuresAdjustmentsList > div');
        featuresRows.forEach(row => {
          const type = row.querySelector('select').value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const description = inputs[0]?.value || '';
          const percent = parseFloat(inputs[1]?.value) || 0;
          const rawValue = parseFloat(inputs[2]?.value.replace(/[₪,]/g, '')) || 0;
          // SIMPLE FIX: Treat values exactly as they are - if minus then minus, if without then positive
          const hasMinusSign = inputs[2]?.value.includes('-');
          const signedValue = (type === 'minus' || hasMinusSign) ? -Math.abs(rawValue) : Math.abs(rawValue);

          if (signedValue !== 0) {
            featuresAdjustments.push({
              description,
              type,
              percent,
              value: signedValue,
              category: 'features'
            });
          }
        });
        
        // Collect registration adjustments (car properties)
        const registrationAdjustments = [];
        const registrationRows = document.querySelectorAll('#registrationAdjustmentsList > div');
        registrationRows.forEach(row => {
          const type = row.querySelector('select').value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const description = inputs[0]?.value || '';
          const percent = parseFloat(inputs[1]?.value) || 0;
          const rawValue = parseFloat(inputs[2]?.value.replace(/[₪,]/g, '')) || 0;
          // SIMPLE FIX: Treat values exactly as they are - if minus then minus, if without then positive
          const hasMinusSign = inputs[2]?.value.includes('-');
          const signedValue = (type === 'minus' || hasMinusSign) ? -Math.abs(rawValue) : Math.abs(rawValue);

          if (signedValue !== 0) {
            registrationAdjustments.push({
              description,
              type,
              percent,
              value: signedValue,
              category: 'registration'
            });
          }
        });
        
        // USE EXACT SAME LOGIC AS WORKING updateFullMarketValueCalculation
        let currentValue = basicPrice;
        
        // Process features section - CORRECTED CALCULATION LOGIC
        const grossFeaturesRows = document.querySelectorAll('#featuresAdjustmentsList > div');
        grossFeaturesRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            // FIXED: Parse amount preserving sign, then apply dropdown type logic
            const amountText = (inputs[3].value || '').trim();
            let amount = parseFloat(amountText.replace(/[₪,\s]/g, '')) || 0;
            const type = inputs[1].value;
            
            // Apply type logic: if type is minus and amount is positive, make negative
            // If type is plus and amount is negative, use absolute value
            if (isReductionType(type) && amount > 0) {
              amount = -amount;
            } else if (!isReductionType(type) && amount < 0) {
              amount = Math.abs(amount);
            }
            
            currentValue += amount;
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update features cumulative
        const grossFeaturesCumulativeEl = document.getElementById('grossFeaturesCumulative');
        if (grossFeaturesCumulativeEl) {
          const span = grossFeaturesCumulativeEl.querySelector('span');
          if (span) {
            span.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
            span.style.color = currentValue >= basicPrice ? '#28a745' : '#dc3545';
          }
        }
        
        // Save features cumulative value
        const featuresCumulativeValue = Math.round(currentValue);
        saveAdjustmentCumulativeOnly('features', featuresCumulativeValue);
        
        // Process registration section - Add fixed values to cumulative
        const grossRegistrationRows = document.querySelectorAll('#registrationAdjustmentsList > div');
        grossRegistrationRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const type = inputs[1]?.value || 'plus';
            const valueInput = inputs[3]; // ערך field
            if (valueInput && valueInput.value) {
              const value = parseFloat(valueInput.value.replace(/[₪,\s-]/g, '')) || 0;
              const signedValue = isReductionType(type) ? -value : value;
              currentValue += signedValue;
            }
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update registration cumulative
        const grossRegistrationCumulativeEl = document.getElementById('grossRegistrationCumulative');
        if (grossRegistrationCumulativeEl) {
          const span = grossRegistrationCumulativeEl.querySelector('span');
          if (span) {
            span.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
            span.style.color = currentValue >= basicPrice ? '#28a745' : '#dc3545';
          }
        }
        
        // Save registration cumulative value
        const registrationCumulativeValue = Math.round(currentValue);
        saveAdjustmentCumulativeOnly('registration', registrationCumulativeValue);
        
        // Update result field
        const resultField = document.getElementById('grossMarketValueResult');
        if (resultField) {
          resultField.value = `₪${Math.round(currentValue).toLocaleString()}`;
        }
        
        const grossPrice = currentValue;
        
        console.log(`🏠 GROSS PRICE CALCULATION: Base ₪${basicPrice.toLocaleString()} → Final ₪${grossPrice.toLocaleString()}`);
        console.log('✅ Corrected calculation: Base + (Base × Features%) + Registration = Final');
        console.log('📋 Features adjustments:', featuresAdjustments);
        console.log('📋 Registration adjustments:', registrationAdjustments);
        
        // Save to helper.calculations.vehicle_value_gross
        if (!helper.calculations) helper.calculations = {};
        helper.calculations.vehicle_value_gross = grossPrice;
        
        // PHASE 6: Add totals structure to final_report.adjustments
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) helper.final_report.adjustments = {};
        if (!helper.final_report.adjustments.totals) {
          helper.final_report.adjustments.totals = {};
        }
        
        // Calculate and save features total
        let featuresTotalValue = 0;
        let featuresTotalPercent = 0;
        featuresAdjustments.forEach(adj => {
          featuresTotalValue += adj.value;
          if (adj.percent) {
            featuresTotalPercent += (adj.type === 'minus' ? -adj.percent : adj.percent);
          }
        });
        
        // Calculate and save registration total
        let registrationTotalValue = 0;
        let registrationTotalPercent = 0;
        registrationAdjustments.forEach(adj => {
          registrationTotalValue += adj.value;
          if (adj.percent) {
            registrationTotalPercent += (adj.type === 'minus' ? -adj.percent : adj.percent);
          }
        });
        
        // Save totals
        helper.final_report.adjustments.totals.features = {
          value: featuresTotalValue,
          percent: featuresTotalPercent,
          count: featuresAdjustments.length
        };
        
        helper.final_report.adjustments.totals.registration = {
          value: registrationTotalValue,
          percent: registrationTotalPercent,
          count: registrationAdjustments.length
        };
        
        helper.final_report.adjustments.totals.gross_total = {
          value: featuresTotalValue + registrationTotalValue,
          percent: featuresTotalPercent + registrationTotalPercent,
          final_value: grossPrice
        };
        
        // Update helper in window and session storage
        window.helper = helper;
        if (typeof updateHelper === 'function') {
          updateHelper('calculations', helper.calculations);
          updateHelper('final_report', helper.final_report);
        }
        // Calculate and restore adjustments_value
        if (typeof window.calculateValuationAdjustments === 'function') {
          window.calculateValuationAdjustments();
        }
        
        if (typeof saveHelperToStorage === 'function') {
          saveHelperToStorage();
        }
        
        console.log('✅ Saved gross value to helper.calculations.vehicle_value_gross:', grossPrice);
        
        // Update bridge fields in helper.calculations for consistency (base_price only)
        const rawBasePrice = helper.valuation?.base_price || 
                             helper.car_details?.base_price || 
                             helper.levi_report?.base_price || 0;
        const originalBasePrice = parseFloat(String(rawBasePrice).replace(/[₪,]/g, '')) || 0;
        helper.calculations.base_price = originalBasePrice;
        // Note: final_adjustments_value should only be updated by the final market value calculation
        
        // Update gross percentage calculation immediately
        setTimeout(() => {
          updateGrossPercentageFromGrossValue();
        }, 100);
        
        // Sync cumulative values to ensure they persist
        setTimeout(() => {
          syncGrossCumulativeValues();
        }, 200);
        
      } catch (error) {
        console.error('Error calculating gross price:', error);
      }
    }
    
    // Load data from helper for gross calculation
    function loadGrossCalculationData() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Load basic price from multiple sources
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField) {
          let basicPrice = 0;
          
          // Priority 1: Check carBasePrice field first
          const carBasePriceField = document.getElementById('carBasePrice');
          if (carBasePriceField && carBasePriceField.value) {
            const carBasePriceStr = carBasePriceField.value.replace(/[₪,]/g, '') || '0';
            basicPrice = parseFloat(carBasePriceStr) || 0;
          }
          
          // Priority 2: Try helper data sources if field is empty
          if (basicPrice === 0) {
            if (helper.valuation?.base_price) {
              basicPrice = parseFloat(helper.valuation.base_price.toString().replace(/[₪,]/g, ''));
            } else if (helper.levi_report?.base_price) {
              basicPrice = parseFloat(helper.levi_report.base_price);
            } else if (helper.expertise?.levi_report?.base_price) {
              basicPrice = parseFloat(helper.expertise.levi_report.base_price);
            } else if (helper.levisummary?.base_price) {
              basicPrice = parseFloat(helper.levisummary.base_price);
            } else if (helper.car_details?.base_price) {
              basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[₪,]/g, ''));
            }
          }
          
          if (basicPrice > 0) {
            basicPriceField.value = `₪${basicPrice.toLocaleString()}`;
          }
        }
        
        // DON'T clear containers or load Levi data here - loadGrossAdjustments() already handles that
        // This function now only handles manual entries to avoid duplication
        
        // Skip Levi data loading - already handled by loadGrossAdjustments()
        // Jump directly to manual entries
        if (featuresData && (featuresData.percent || featuresData.percentage || featuresData.amount)) {
          let percent = 0;
          if (featuresData.percent) {
            const percentStr = String(featuresData.percent).replace(/[%\s]/g, '');
            percent = parseFloat(percentStr) || 0;
          } else if (featuresData.percentage) {
            const percentStr = String(featuresData.percentage).replace(/[%\s]/g, '');
            percent = parseFloat(percentStr) || 0;
          }
          
          let amount = 0;
          if (featuresData.amount) {
            const amountStr = String(featuresData.amount).replace(/[₪,\sש]/g, '');
            amount = parseFloat(amountStr) || 0;
          }
          
          const description = featuresData.value || featuresData.description || 'תוספות מאפיינים';
          const isReduction = percent < 0 || amount < 0;
          
          addFeatureAdjustment();
          const lastRow = document.querySelector('#featuresAdjustmentsList > div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input[type="text"]');
            inputs[0].value = description;
            lastRow.querySelector('select').value = isReduction ? 'minus' : 'plus';
            
            // CRITICAL FIX: Display minus sign for negative values
            const displayPercent = isReduction ? `-${Math.abs(percent)}` : Math.abs(percent);
            const displayAmount = isReduction ? `-${Math.abs(amount)}` : Math.abs(amount);
            
            inputs[1].value = percent ? `${displayPercent}%` : '';
            inputs[2].value = amount ? `₪${displayAmount.toLocaleString()}` : '';
          }
        }
        
        // Load registration adjustments using EXACT working logic
        const registrationData = adjustments['registration'];
        if (registrationData && (registrationData.percent || registrationData.percentage || registrationData.amount)) {
          let percent = 0;
          if (registrationData.percent) {
            const percentStr = String(registrationData.percent).replace(/[%\s]/g, '');
            percent = parseFloat(percentStr) || 0;
          } else if (registrationData.percentage) {
            const percentStr = String(registrationData.percentage).replace(/[%\s]/g, '');
            percent = parseFloat(percentStr) || 0;
          }
          
          let amount = 0;
          if (registrationData.amount) {
            const amountStr = String(registrationData.amount).replace(/[₪,\sש]/g, '');
            amount = parseFloat(amountStr) || 0;
          }
          
          const description = registrationData.value || registrationData.description || 'עליה לכביש';
          const isReduction = percent < 0 || amount < 0;
          
          addRegistrationAdjustment();
          const lastRow = document.querySelector('#registrationAdjustmentsList > div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input[type="text"]');
            inputs[0].value = description;
            lastRow.querySelector('select').value = isReduction ? 'minus' : 'plus';
            
            // CRITICAL FIX: Display minus sign for negative values
            const displayPercent = isReduction ? `-${Math.abs(percent)}` : Math.abs(percent);
            const displayAmount = isReduction ? `-${Math.abs(amount)}` : Math.abs(amount);
            
            inputs[1].value = percent ? `${displayPercent}%` : '';
            inputs[2].value = amount ? `₪${displayAmount.toLocaleString()}` : '';
          }
        }
        
        // Also check for direct registration fields in levi_report (structured data)
        if (helper.expertise?.levi_report?.adjustments?.registration) {
          const regAdj = helper.expertise.levi_report.adjustments.registration;
          const registrationValue = parseFloat(regAdj.value || regAdj.total || 0);
          
          if (registrationValue !== 0) {
            console.log('🔧 Loading registration from expertise.levi_report.adjustments:', regAdj);
            addRegistrationAdjustment();
            const lastRow = document.querySelector('#registrationAdjustmentsList > div:last-child');
            if (lastRow) {
              lastRow.querySelector('input[type="text"]:first-of-type').value = 'עליה לכביש';
              lastRow.querySelector('select').value = registrationValue >= 0 ? 'plus' : 'minus';
              // CRITICAL FIX: Display minus sign for negative values
              const displayRegValue = registrationValue >= 0 ? Math.abs(registrationValue) : `-${Math.abs(registrationValue)}`;
              lastRow.querySelector('input[type="text"]:last-of-type').value = `₪${displayRegValue.toLocaleString()}`;
            }
          }
        }
        
        // Also check for features in structured data
        if (helper.expertise?.levi_report?.adjustments?.features) {
          const featAdj = helper.expertise.levi_report.adjustments.features;
          const featuresValue = parseFloat(featAdj.value || featAdj.total || 0);
          
          if (featuresValue !== 0) {
            console.log('🔧 Loading features from expertise.levi_report.adjustments:', featAdj);
            addFeatureAdjustment();
            const lastRow = document.querySelector('#featuresAdjustmentsList > div:last-child');
            if (lastRow) {
              lastRow.querySelector('input[type="text"]:first-of-type').value = 'מאפיינים';
              lastRow.querySelector('select').value = featuresValue >= 0 ? 'plus' : 'minus';
              // CRITICAL FIX: Display minus sign for negative values
              const displayFeatValue = featuresValue >= 0 ? Math.abs(featuresValue) : `-${Math.abs(featuresValue)}`;
              lastRow.querySelector('input[type="text"]:last-of-type').value = `₪${displayFeatValue.toLocaleString()}`;
            }
          }
        }
        
        // Check for additional adjustments from levisummary (backup structure) - Handle object or array
        if (helper.levisummary?.adjustments) {
          const adjustments = Array.isArray(helper.levisummary.adjustments) ? helper.levisummary.adjustments : Object.values(helper.levisummary.adjustments);
          adjustments.forEach(adj => {
            const desc = adj.description?.toLowerCase() || '';
            const value = parseFloat(adj.value || 0);
            
            if (value !== 0) {
              if (desc.includes('עליה לכביש') || desc.includes('registration')) {
                console.log('🔧 Loading registration from levisummary:', adj);
                addRegistrationAdjustment();
                const lastRow = document.querySelector('#registrationAdjustmentsList > div:last-child');
                if (lastRow) {
                  lastRow.querySelector('input[type="text"]:first-of-type').value = adj.description || 'עליה לכביש';
                  lastRow.querySelector('select').value = value >= 0 ? 'plus' : 'minus';
                  // CRITICAL FIX: Display minus sign for negative values
                  const displayValue = value >= 0 ? Math.abs(value) : `-${Math.abs(value)}`;
                  lastRow.querySelector('input[type="text"]:last-of-type').value = `₪${displayValue.toLocaleString()}`;
                }
              } else if (desc.includes('מאפיינים') || desc.includes('features')) {
                console.log('🔧 Loading features from levisummary:', adj);
                addFeatureAdjustment();
                const lastRow = document.querySelector('#featuresAdjustmentsList > div:last-child');
                if (lastRow) {
                  lastRow.querySelector('input[type="text"]:first-of-type').value = adj.description || 'מאפיינים';
                  lastRow.querySelector('select').value = value >= 0 ? 'plus' : 'minus';
                  // CRITICAL FIX: Display minus sign for negative values
                  const displayValue = value >= 0 ? Math.abs(value) : `-${Math.abs(value)}`;
                  lastRow.querySelector('input[type="text"]:last-of-type').value = `₪${displayValue.toLocaleString()}`;
                }
              }
            }
          });
        }
        
        // LOAD MANUAL ENTRIES from final_report.adjustments (after Levi data)
        if (helper.final_report?.adjustments) {
          const finalReportAdjustments = helper.final_report.adjustments;
          
          // Load manual features
          const manualFeatures = finalReportAdjustments.features?.filter(item => item.source === 'manual') || [];
          if (manualFeatures.length > 0) {
            console.log(`📝 Loading ${manualFeatures.length} manual features adjustments`);
            manualFeatures.forEach((item, index) => {
              addFeatureAdjustment();
              const rows = document.querySelectorAll('#featuresAdjustmentsList > div');
              const lastRow = rows[rows.length - 1];
              
              if (lastRow) {
                const inputs = lastRow.querySelectorAll('input, select');
                if (inputs.length >= 4) {
                  inputs[0].value = item.value || '';
                  inputs[1].value = item.type || 'plus';
                  inputs[2].value = item.percentage || item.percent || '';
                  // Check if it's a reduction type to preserve minus sign
                  const isReduction = item.type === 'minus' || item.type === 'הפחתה' || 
                                     item.type === 'הפחתה (-)' || item.type === 'הורדה';
                  let displayAmount = Math.abs(item.amount || 0);
                  if (isReduction && displayAmount > 0) {
                    displayAmount = -displayAmount;
                  }
                  inputs[3].value = item.amount_display || (item.amount ? `₪${displayAmount.toLocaleString()}` : '');
                  
                  // Keep as manual source
                  lastRow.setAttribute('data-source', 'manual');
                  
                  console.log(`✅ Loaded manual features item ${index}:`, {
                    description: inputs[0].value,
                    type: inputs[1].value,
                    percent: inputs[2].value,
                    amount: inputs[3].value
                  });
                }
              }
            });
          }
          
          // Load manual registration
          const manualRegistration = finalReportAdjustments.registration?.filter(item => item.source === 'manual') || [];
          if (manualRegistration.length > 0) {
            console.log(`📝 Loading ${manualRegistration.length} manual registration adjustments`);
            manualRegistration.forEach((item, index) => {
              addRegistrationAdjustment();
              const rows = document.querySelectorAll('#registrationAdjustmentsList > div');
              const lastRow = rows[rows.length - 1];
              
              if (lastRow) {
                const inputs = lastRow.querySelectorAll('input, select');
                if (inputs.length >= 4) {
                  inputs[0].value = item.value || '';
                  inputs[1].value = item.type || 'plus';
                  inputs[2].value = item.percentage || item.percent || '';
                  // Check if it's a reduction type to preserve minus sign
                  const isReduction = item.type === 'minus' || item.type === 'הפחתה' || 
                                     item.type === 'הפחתה (-)' || item.type === 'הורדה';
                  let displayAmount = Math.abs(item.amount || 0);
                  if (isReduction && displayAmount > 0) {
                    displayAmount = -displayAmount;
                  }
                  inputs[3].value = item.amount_display || (item.amount ? `₪${displayAmount.toLocaleString()}` : '');
                  
                  // Keep as manual source
                  lastRow.setAttribute('data-source', 'manual');
                  
                  console.log(`✅ Loaded manual registration item ${index}:`, {
                    description: inputs[0].value,
                    type: inputs[1].value,
                    percent: inputs[2].value,
                    amount: inputs[3].value
                  });
                }
              }
            });
          }
        }
        
        // Calculate initial gross market value
        updateGrossMarketValueCalculation();
        
        // Trigger calculation for all existing adjustment rows
        setTimeout(() => {
          const allPercentInputs = document.querySelectorAll('#featuresAdjustmentsList input[placeholder="אחוז"], #registrationAdjustmentsList input[placeholder="אחוז"]');
          allPercentInputs.forEach(input => {
            if (input.value) {
              calculateAdjustmentValue(input);
            }
          });
          
          // Recalculate final values
          updateGrossMarketValueCalculation();
        }, 300);
        
        // Load second bulk data if available
        setTimeout(() => {
          loadSecondBulkData();
        }, 500);
        
      } catch (error) {
        console.error('Error loading gross calculation data:', error);
      }
    }
    
    // Load data for second bulk (gross percentage)
    function loadSecondBulkData() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Load claims data if available
        if (helper.claims_data) {
          const totalClaimField = document.getElementById('totalClaim');
          const leviPriceListField = document.getElementById('leviPriceList');
          const grossPercentField = document.getElementById('grossPercent');
          
          if (totalClaimField && helper.claims_data.total_claim) {
            totalClaimField.value = helper.claims_data.total_claim;
          }
          
          
          if (leviPriceListField && helper.claims_data.gross_value) {
            leviPriceListField.value = helper.claims_data.gross_value;
          }
          
          if (grossPercentField && helper.claims_data.gross_percent) {
            grossPercentField.value = helper.claims_data.gross_percent;
          }
        }
        
        // If no saved data, calculate from current state
        if (!helper.claims_data?.total_claim) {
          updateGrossPercentageFromGrossValue();
        }
        
      } catch (error) {
        console.error('Error loading second bulk data:', error);
      }
    }
    
    // Update gross percentage when gross market value changes
    function updateGrossPercentageFromGrossValue() {
      // Get GROSS price (car properties only)
      let grossPrice = 0;
      
      if (window.CalculationInterface && typeof window.CalculationInterface.getGrossMarketValue === 'function') {
        grossPrice = window.CalculationInterface.getGrossMarketValue();
      } else {
        // Fallback: calculate gross price directly from fields
        const grossResultField = document.getElementById('grossMarketValueResult');
        if (grossResultField && grossResultField.value) {
          grossPrice = parseFloat(grossResultField.value.replace(/[₪,]/g, '')) || 0;
        } else {
          // Further fallback: use basic price
          const basicPriceField = document.getElementById('basicPrice');
          if (basicPriceField && basicPriceField.value) {
            grossPrice = parseFloat(basicPriceField.value.replace(/[₪,]/g, '')) || 0;
          }
        }
      }
      
      // Get total claim from damage centers calculation
      const totalClaim = calculateTotalClaimFromDamageCenters();
      
      console.log('🔍 Updating GROSS DAMAGE PERCENTAGE (using gross price, not market price):', {
        grossPrice,
        totalClaim
      });
      
      // Update the display fields
      const totalClaimField = document.getElementById('totalClaim');
      const leviPriceListField = document.getElementById('leviPriceList');
      
      if (totalClaimField && totalClaim > 0) {
        totalClaimField.value = `₪${totalClaim.toLocaleString()}`;
      }
      
      if (leviPriceListField && grossPrice > 0) {
        leviPriceListField.value = `₪${grossPrice.toLocaleString()}`;
      }
      
      // Get authorized claim instead of total claim
      const authorizedClaimField = document.getElementById('authorizedClaim');
      const authorizedClaimValue = authorizedClaimField?.value || '';
      const authorizedClaim = parseFloat(authorizedClaimValue.replace(/[₪,]/g, '')) || totalClaim; // fallback to totalClaim if no authorized claim
      
      // Calculate and update GROSS DAMAGE PERCENTAGE (authorized claim ÷ gross price)
      if (grossPrice > 0 && authorizedClaim > 0) {
        const grossDamagePercentage = (authorizedClaim / grossPrice) * 100;
        const grossPercentField = document.getElementById('grossPercent');
        if (grossPercentField) {
          const formattedPercentage = `${Math.round(grossDamagePercentage * 100) / 100}%`;
          grossPercentField.value = formattedPercentage;
          
          // Update helper with GROSS damage percentage (separate from market damage percentage)
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          helper.calculations = helper.calculations || {};
          helper.calculations.damage_percent_gross = grossDamagePercentage;
          helper.calculations.total_damage = totalClaim;
          
          // Update claims data for backward compatibility
          helper.claims_data = helper.claims_data || {};
          helper.claims_data.gross_percent = formattedPercentage;
          
          
          helper.claims_data.gross_value = `₪${grossPrice.toLocaleString()}`;
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          console.log(`📊 GROSS DAMAGE %: ${authorizedClaim.toLocaleString()} ÷ ${grossPrice.toLocaleString()} = ${formattedPercentage}`);
          console.log(`🏠 This uses GROSS PRICE (car properties only), not market price`);
        }
      }
    }
    
    // CALCULATE TOTAL CLAIM FROM DAMAGE CENTERS
    function calculateTotalClaimFromDamageCenters() {
      try {
        let totalClaim = 0;
        
        // Get damage centers from the summary or helper
        const damageCentersContent = document.getElementById('damageCentersContent');
        if (damageCentersContent) {
          const damageRows = damageCentersContent.querySelectorAll('.damage-center-row');
          damageRows.forEach(row => {
            const totalField = row.querySelector('.total-field');
            if (totalField && totalField.value) {
              const total = parseFloat(totalField.value.replace(/[₪,]/g, '')) || 0;
              totalClaim += total;
            }
          });
        }
        
        // Fallback: try to get from summary section
        if (totalClaim === 0) {
          const sumClaimField = document.getElementById('sumClaim');
          if (sumClaimField && sumClaimField.value) {
            totalClaim = parseFloat(sumClaimField.value.replace(/[₪,]/g, '')) || 0;
          }
        }
        
        // Fallback: try to get from helper
        if (totalClaim === 0) {
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          if (helper.expertise?.damage_blocks) {
            helper.expertise.damage_blocks.forEach(block => {
              totalClaim += (parseFloat(block.parts_cost) || 0) + 
                           (parseFloat(block.work_cost) || 0) + 
                           (parseFloat(block.repairs_cost) || 0);
            });
          }
        }
        
        console.log('💰 Total claim from damage centers:', totalClaim);
        return totalClaim;
      } catch (error) {
        console.error('Error calculating total claim from damage centers:', error);
        return 0;
      }
    }
    
    // SIMPLE CALCULATION FUNCTIONS FOR NEW SYSTEM
    /**
     * Calculate the final appraised vehicle value based on adjustments.
     * Implements the correct calculation order from todo.md lines 337-391
     */
    function calculateVehicleValue(basePrice, adjustments) {
      if (typeof basePrice !== 'number' || isNaN(basePrice)) {
        throw new Error('Invalid base price');
      }

      const safeAdj = (adj, current) => {
        if (!adj) return 0;
        if (adj.percent && typeof adj.percent === 'number') {
          return current * (adj.percent / 100);
        }
        if (adj.fixed && typeof adj.fixed === 'number') {
          return adj.fixed;
        }
        return 0;
      };

      // Step 1: Independent adjustments (Features + Registration) using Base Price
      const featuresAdj = safeAdj(adjustments.features, basePrice);
      const registrationAdj = safeAdj(adjustments.registration, basePrice);

      const grossValue = basePrice + featuresAdj + registrationAdj;

      // Step 2: Sequential adjustments (Ownership → Mileage → Number of Owners)
      let currentValue = grossValue;

      for (const key of ['ownershipType', 'mileage', 'numOwners']) {
        const adj = adjustments[key];
        if (!adj) continue; // skip if missing or zero
        const adjAmount = safeAdj(adj, currentValue);
        currentValue += adjAmount; // apply sequentially
      }

      return Math.round(currentValue); // round to nearest whole currency unit
    }

    function calculateGrossMarketValue() {
      updateGrossMarketValueCalculation();
    }
    
    function calculateGrossPercentage() {
      updateGrossPercentageFromGrossValue();
    }
    
    function calculateFullMarketValue() {
      // updateFullMarketValueCalculation() removed
    }
    
    // FULL MARKET VALUE CALCULATION FUNCTIONS
    
    // Add full market adjustment row
    // Add Full Features Adjustment
    function addFullFeaturesAdjustment() {
      const container = document.getElementById('fullFeaturesAdjustmentsList');
      const rowId = 'fullFeaturesAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור תוספת מאפיין" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));" title="">
              <option value="plus">תוספת (+)</option>
              <option value="minus">הפחתה (-)</option>
            </select></div>
            <div><input type="text" placeholder="אחוז" title="" oninput="calculateAdjustmentValueSimple(this); this.title = this.value;" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(this.value) || 0), safeParseAmount(inputs[3].value)); this.title = this.value;" /></div>
            <div><input type="text" placeholder="₪" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(this.value)); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Add Full Registration Adjustment
    function addFullRegistrationAdjustment() {
      const container = document.getElementById('fullRegistrationAdjustmentsList');
      const rowId = 'fullRegistrationAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור עליה לכביש" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');" /></div>
            <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));">
              <option value="plus">תוספת (+)</option>
              <option value="minus">הפחתה (-)</option>
            </select></div>
            <div><input type="text" placeholder="אחוז" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(this.value) || 0), safeParseAmount(inputs[3].value));" /></div>
            <div><input type="text" placeholder="₪" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(this.value));" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Add Mileage Adjustment
    function addMileageAdjustment() {
      const container = document.getElementById('mileageAdjustmentsList');
      const rowId = 'mileageAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור מס ק"מ" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'mileage'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'mileage'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));" title="">
              <option value="plus">תוספת (+)</option>
              <option value="minus">הפחתה (-)</option>
            </select></div>
            <div><input type="text" placeholder="אחוז" title="" oninput="calculateAdjustmentValueSimple(this); this.title = this.value;" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'mileage'); this.title = this.value;" /></div>
            <div><input type="text" placeholder="₪" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'mileage'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Add Ownership Type Adjustment
    function addOwnershipAdjustment() {
      const container = document.getElementById('ownershipAdjustmentsList');
      const rowId = 'ownershipAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור סוג בעלות" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_type'); this.title = this.value;" oninput="this.title = this.value;" /></div>
          <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_type'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));" title="">
            <option value="plus">תוספת (+)</option>
            <option value="minus">הפחתה (-)</option>
          </select></div>
            <div><input type="text" placeholder="אחוז" title="" oninput="calculateAdjustmentValueSimple(this); this.title = this.value;" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_type'); this.title = this.value;" /></div>
            <div><input type="text" placeholder="₪" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_type'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Add Number of Owners Adjustment
    function addOwnersAdjustment() {
      const container = document.getElementById('ownersAdjustmentsList');
      const rowId = 'ownersAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור מספר בעלים" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_history'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_history'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));" title="">
              <option value="plus">תוספת (+)</option>
              <option value="minus">הפחתה (-)</option>
            </select></div>
            <div><input type="text" placeholder="אחוז" title="" oninput="calculateAdjustmentValueSimple(this); this.title = this.value;" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_history'); this.title = this.value;" /></div>
            <div><input type="text" placeholder="₪" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_history'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Add General Full Market Adjustment (additional)
    function addFullMarketAdjustment() {
      const container = document.getElementById('allAdjustmentsList');
      const rowId = 'fullAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור התאמה נוספת" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(inputs[2].value) || 0, safeParseAmount(inputs[3].value));" /></div>
            <div><select onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, parseFloat(inputs[2].value) || 0, safeParseAmount(inputs[3].value));">
              <option value="plus">תוספת (+)</option>
              <option value="minus">הפחתה (-)</option>
            </select></div>
            <div><input type="text" placeholder="אחוז" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(this.value) || 0, safeParseAmount(inputs[3].value));" /></div>
            <div><input type="text" placeholder="₪" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(inputs[2].value) || 0, safeParseAmount(this.value));" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Remove full market adjustment row
    function removeFullMarketAdjustmentRow(rowId) {
      const row = document.getElementById(rowId);
      if (row) {
        row.remove();
        // updateFullMarketValueCalculation() removed
      }
    }
    
    // DELETED: updateFullMarketValueCalculation() function removed
    // Full market value now comes only from UI input, not automatic calculations
    
    // Update cumulative display for each section
    function updateCumulativeDisplay(sectionName, currentValue) {
      const nameMapping = {
        'תוספות מאפיינים': 'featuresCumulative',
        'עליה לכביש': 'registrationCumulative', 
        'מס ק"מ': 'mileageCumulative',
        'סוג בעלות': 'ownershipCumulative',
        'מספר בעלים': 'ownersCumulative'
      };
      
      const cumulativeId = nameMapping[sectionName];
      if (cumulativeId) {
        const cumulativeElement = document.getElementById(cumulativeId);
        if (cumulativeElement) {
          const span = cumulativeElement.querySelector('span');
          if (span) {
            span.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
            const minExpectedValue = helper.calculations?.base_market_value || helper.levisummary?.base_price || 100000;
            span.style.color = currentValue >= minExpectedValue ? '#28a745' : '#dc3545';
          }
        }
      }
    }
    
    // Calculate full market value with cumulative updates
    function updateFullMarketValueCalculation() {
      try {
        // Get helper object first
        const helper = window.helper || {};
        
        // Get base price from fullBasicPrice field
        let basicPrice = 0;
        const fullBasicPriceField = document.getElementById('fullBasicPrice');
        if (fullBasicPriceField?.value) {
          basicPrice = parseFloat(fullBasicPriceField.value.replace(/[₪,]/g, '')) || 0;
        }
        
        // Fallback: Use helper base price if field is empty
        if (basicPrice === 0) {
          basicPrice = helper.calculations?.base_market_value || helper.levisummary?.base_price || helper.valuation?.base_price || 0;
        }
        let currentValue = basicPrice;
        
        // 1. Process Features Adjustments
        const fullFeaturesRows = document.querySelectorAll('#fullFeaturesAdjustmentsList > div');
        fullFeaturesRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            // FIXED: Parse amount preserving sign, then apply dropdown type logic
            const amountText = (inputs[3].value || '').trim();
            let amount = parseFloat(amountText.replace(/[₪,\s]/g, '')) || 0;
            const type = inputs[1].value;
            
            // Apply type logic: if type is minus and amount is positive, make negative
            // If type is plus and amount is negative, use absolute value
            if (isReductionType(type) && amount > 0) {
              amount = -amount;
            } else if (!isReductionType(type) && amount < 0) {
              amount = Math.abs(amount);
            }
            
            currentValue += amount;
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update features cumulative - this shows currentValue after features
        updateCumulativeDisplay('תוספות מאפיינים', currentValue);
        const afterFeatures = currentValue; // Store value after features
        
        // 2. Process Registration Adjustments
        const fullRegistrationRows = document.querySelectorAll('#fullRegistrationAdjustmentsList > div');
        fullRegistrationRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            // FIXED: Parse amount preserving sign, then apply dropdown type logic
            const amountText = (inputs[3].value || '').trim();
            let amount = parseFloat(amountText.replace(/[₪,\s]/g, '')) || 0;
            const type = inputs[1].value;
            
            // Apply type logic: if type is minus and amount is positive, make negative
            // If type is plus and amount is negative, use absolute value
            if (isReductionType(type) && amount > 0) {
              amount = -amount;
            } else if (!isReductionType(type) && amount < 0) {
              amount = Math.abs(amount);
            }
            
            currentValue += amount;
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update registration cumulative - this shows currentValue after features + registration
        updateCumulativeDisplay('עליה לכביש', currentValue);
        const afterRegistration = currentValue; // This is the GROSS price that subsequent calculations use
        
        // 3. Process Mileage Adjustments
        const mileageRows = document.querySelectorAll('#mileageAdjustmentsList > div');
        mileageRows.forEach((row, index) => {
          const select = row.querySelector('select');
          const type = select?.value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const percentInput = inputs[1]; // Percentage field
          const valueInput = inputs[2];   // Value field
          
          // Conditional logic: percentage vs direct value
          if (percentInput && percentInput.value && parseFloat(percentInput.value) !== 0) {
            // HAS PERCENTAGE: Calculate SPECIFIC result from PREVIOUS CATEGORY CUMULATIVE
            const percent = parseFloat(percentInput.value);
            // For manual rows (index > 0), use previous category cumulative, not running cumulative
            let previousCumulative;
            if (index > 0) {
              // Manual row: use registration cumulative (previous category)
              previousCumulative = afterRegistration;
            } else {
              // First row: use current running cumulative
              previousCumulative = currentValue;
            }
            const specificResult = previousCumulative * (Math.abs(percent) / 100); // Calculate from correct base
            
            // Apply dropdown selection to get final cumulative
            if (type === 'minus') {
              currentValue = currentValue - specificResult;
            } else {
              currentValue = currentValue + specificResult;
            }
            
            // UPDATE THE UI: Set the correct specific value in the value field
            // Skip updating during page load to preserve manual amounts
            if (valueInput && !window.pageLoadInProgress) {
              const roundedResult = Math.round(specificResult);
              const displayAmount = roundedResult.toLocaleString();
              valueInput.value = (type === 'minus') ? `-₪${displayAmount}` : `₪${displayAmount}`;
            }
          } else if (valueInput && valueInput.value) {
            // FIXED: Parse amount considering it might already have a minus sign
            const amountText = (valueInput.value || '').trim();
            const hasMinusSign = amountText.includes('-');
            const value = Math.abs(parseFloat(amountText.replace(/[₪,\s-]/g, '')) || 0);
            const signedValue = (type === 'minus') ? -value : value;
            currentValue += signedValue;
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update mileage cumulative - this shows currentValue after mileage
        updateCumulativeDisplay('מס ק"מ', currentValue);
        const afterMileage = currentValue; // Store value after mileage
        
        // Removed saveAdjustmentAmount - syncAdjustmentToHelper handles row-level cumulative properly
        
        // 4. Process Ownership Adjustments
        const ownershipRows = document.querySelectorAll('#ownershipAdjustmentsList > div');
        ownershipRows.forEach((row, index) => {
          const select = row.querySelector('select');
          const type = select?.value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const percentInput = inputs[1]; // Percentage field
          const valueInput = inputs[2];   // Value field
          
          // Conditional logic: percentage vs direct value
          if (percentInput && percentInput.value && parseFloat(percentInput.value) !== 0) {
            // HAS PERCENTAGE: Calculate SPECIFIC result from PREVIOUS CATEGORY CUMULATIVE
            const percent = parseFloat(percentInput.value);
            // For manual rows (index > 0), use previous category cumulative, not running cumulative
            let previousCumulative;
            if (index > 0) {
              // Manual row: use mileage cumulative (previous category)
              previousCumulative = afterMileage;
            } else {
              // First row: use current running cumulative
              previousCumulative = currentValue;
            }
            const specificResult = previousCumulative * (Math.abs(percent) / 100); // Calculate from correct base
            
            // Apply dropdown selection to get final cumulative
            if (type === 'minus') {
              currentValue = currentValue - specificResult;
            } else {
              currentValue = currentValue + specificResult;
            }
            
            // UPDATE THE UI: Set the correct specific value in the value field
            // Skip updating during page load to preserve manual amounts
            if (valueInput && !window.pageLoadInProgress) {
              const roundedResult = Math.round(specificResult);
              const displayAmount = roundedResult.toLocaleString();
              valueInput.value = (type === 'minus') ? `-₪${displayAmount}` : `₪${displayAmount}`;
            }
          } else if (valueInput && valueInput.value) {
            // FIXED: Parse amount considering it might already have a minus sign
            const amountText = (valueInput.value || '').trim();
            const hasMinusSign = amountText.includes('-');
            const value = Math.abs(parseFloat(amountText.replace(/[₪,\s-]/g, '')) || 0);
            if (type === 'minus') {
              currentValue = currentValue - value;
            } else {
              currentValue = currentValue + value;
            }
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update ownership cumulative - this shows currentValue after ownership
        updateCumulativeDisplay('סוג בעלות', currentValue);
        const afterOwnership = currentValue; // Store value after ownership
        
        // Removed saveAdjustmentAmount - syncAdjustmentToHelper handles row-level cumulative properly
        
        // 5. Process Owners Adjustments
        const ownersRows = document.querySelectorAll('#ownersAdjustmentsList > div');
        ownersRows.forEach((row, index) => {
          const select = row.querySelector('select');
          const type = select?.value;
          
          // DEBUG: Log ownership_history type reading during calculation
          console.log(`🔍 updateFullMarketValueCalculation owners[${index}] type: ${type}, pageLoadInProgress: ${window.pageLoadInProgress}`);
          const inputs = row.querySelectorAll('input[type="text"]');
          const percentInput = inputs[1]; // Percentage field
          const valueInput = inputs[2];   // Value field
          
          // Conditional logic: percentage vs direct value
          if (percentInput && percentInput.value && parseFloat(percentInput.value) !== 0) {
            // HAS PERCENTAGE: Calculate SPECIFIC result from PREVIOUS CATEGORY CUMULATIVE
            const percent = parseFloat(percentInput.value);
            // For manual rows (index > 0), use previous category cumulative, not running cumulative
            let previousCumulative;
            if (index > 0) {
              // Manual row: use ownership cumulative (previous category)
              previousCumulative = afterOwnership;
            } else {
              // First row: use current running cumulative
              previousCumulative = currentValue;
            }
            const specificResult = previousCumulative * (Math.abs(percent) / 100); // Calculate from correct base
            
            // Apply dropdown selection to get final cumulative
            if (type === 'minus') {
              currentValue = currentValue - specificResult;
            } else {
              currentValue = currentValue + specificResult;
            }
            
            // UPDATE THE UI: Set the correct specific value in the value field
            // Skip updating during page load to preserve manual amounts
            if (valueInput && !window.pageLoadInProgress) {
              const roundedResult = Math.round(specificResult);
              const displayAmount = roundedResult.toLocaleString();
              valueInput.value = (type === 'minus') ? `-₪${displayAmount}` : `₪${displayAmount}`;
            }
          } else if (valueInput && valueInput.value) {
            // FIXED: Parse amount considering it might already have a minus sign
            const amountText = (valueInput.value || '').trim();
            const hasMinusSign = amountText.includes('-');
            const value = Math.abs(parseFloat(amountText.replace(/[₪,\s-]/g, '')) || 0);
            if (type === 'minus') {
              currentValue = currentValue - value;
            } else {
              currentValue = currentValue + value;
            }
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update owners cumulative
        updateCumulativeDisplay('מספר בעלים', currentValue);
        
        // Removed saveAdjustmentAmount - syncAdjustmentToHelper handles row-level cumulative properly
        
        // 6. Process Additional Market Adjustments
        const additionalRows = document.querySelectorAll('#allAdjustmentsList > div');
        additionalRows.forEach((row, index) => {
          const type = row.querySelector('select')?.value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const percentInput = inputs[1]; // Percentage field
          const valueInput = inputs[2];   // Value field
          
          if (percentInput && percentInput.value) {
            const percent = parseFloat(percentInput.value) || 0;
            if (percent !== 0) { // Changed from > 0 to !== 0 to handle negative percentages
              const adjustment = basicPrice * (Math.abs(percent) / 100);
              const signedAdjustment = (type === 'minus' || percent < 0) ? -adjustment : adjustment;
              currentValue += signedAdjustment;
            }
          } else if (valueInput && valueInput.value) {
            // FIXED: Parse amount considering it might already have a minus sign
            const amountText = (valueInput.value || '').trim();
            const hasMinusSign = amountText.includes('-');
            const value = Math.abs(parseFloat(amountText.replace(/[₪,\s-]/g, '')) || 0);
            const signedValue = (type === 'minus') ? -value : value;
            currentValue += signedValue;
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update final result field
        const resultField = document.getElementById('fullMarketValueResult');
        if (resultField) {
          resultField.value = `₪${Math.round(currentValue).toLocaleString()}`;
        }
        
        // Update bridge fields in helper.calculations for consistency (base_price only)
        if (helper.calculations) {
          const rawBasePrice = helper.valuation?.base_price || 
                               helper.car_details?.base_price || 
                               helper.levi_report?.base_price || 0;
          const originalBasePrice = parseFloat(String(rawBasePrice).replace(/[₪,]/g, '')) || 0;
          helper.calculations.base_price = originalBasePrice;
          helper.calculations.full_market_value = Math.round(currentValue);
          // Note: final_adjustments_value should only be updated by the main calculation function
        }
        
      } catch (error) {
        console.error('Error in FULL market value calculation:', error);
      }
    }
    
    // Load data from helper for full market value calculation
    function loadFullMarketValueData() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        
        // Load basic price (same as gross calculation)
        const fullBasicPriceField = document.getElementById('fullBasicPrice');
        const basicPriceField = document.getElementById('basicPrice');
        if (fullBasicPriceField && basicPriceField) {
          fullBasicPriceField.value = basicPriceField.value;
        } else if (fullBasicPriceField && helper.levi_report?.base_price) {
          fullBasicPriceField.value = `₪${parseFloat(helper.levi_report.base_price).toLocaleString()}`;
        }
        
        // AGGRESSIVE FIX: Clear container completely and verify it's empty
        const container = document.getElementById('allAdjustmentsList');
        if (container) {
          // Remove all child elements one by one to ensure proper cleanup
          while (container.firstChild) {
            container.removeChild(container.firstChild);
          }
          // Double-check with innerHTML as backup
          container.innerHTML = '';
          // Force DOM refresh
          container.offsetHeight;
          
          // Add a flag to prevent duplicate loading
          if (container.hasAttribute('data-loading')) {
            return;
          }
          container.setAttribute('data-loading', 'true');
        }
        
        // Create a unified adjustments array to prevent duplicates
        const allAdjustments = [];
        const seenAdjustments = new Set();
        
        // Add Levi adjustments first (these are the main ones)
        if (helper.levi_report?.adjustments) {
          helper.levi_report.adjustments.forEach(adj => {
            const adjustmentType = adj.value >= 0 ? 'plus' : 'minus';
            const key = `${adj.description}-${adj.percentage || adj.percent || 0}-${adjustmentType}`;
            if (!seenAdjustments.has(key)) {
              allAdjustments.push({
                description: adj.description || 'התאמה מלוי יצחק',
                percentage: adj.percentage || adj.percent || 0,
                value: adj.value || 0,
                type: adjustmentType,
                source: 'levi'
              });
              seenAdjustments.add(key);
            }
          });
        }
        
        // Add custom adjustments only if they're not duplicates
        if (helper.custom_adjustments?.full_market_adjustments) {
          helper.custom_adjustments.full_market_adjustments.forEach(adj => {
            const adjustmentType = adj.type || 'plus';
            const key = `${adj.description}-${adj.percentage || adj.percent || 0}-${adjustmentType}`;
            if (!seenAdjustments.has(key)) {
              allAdjustments.push({
                description: adj.description || 'התאמה מותאמת',
                percentage: adj.percentage || adj.percent || 0,
                value: adj.value || 0,
                type: adjustmentType,
                source: 'custom'
              });
              seenAdjustments.add(key);
            }
          });
        }
        
        // REMOVED: Auto-population of allAdjustmentsList (התאמות שוק נוספות)
        // These should be manual fields only, not auto-populated
        
        // Calculate initial full market value
        // updateFullMarketValueCalculation() removed
        
        // DISABLED: autoPopulateMarketAdjustments - causes override of final_report data
        // setTimeout(() => {
        //   autoPopulateMarketAdjustments();
        // }, 100);
        
        // Remove loading flag
        if (container) {
          container.removeAttribute('data-loading');
        }
        
        // Trigger calculation after data is loaded
        setTimeout(() => {
          updateFullMarketValueCalculation();
        }, 200);
        
      } catch (error) {
        console.error('Error loading full market value data:', error);
        // Remove loading flag on error too
        const container = document.getElementById('allAdjustmentsList');
        if (container) {
          container.removeAttribute('data-loading');
        }
      }
    }
    
    
    // FULL MARKET ADJUSTMENT CALCULATION - COPIED FROM WORKING DEPRECIATION
    function calculateFullMarketAdjustmentValue(percentInput) {
      const percent = parseFloat(percentInput.value) || 0;
      const row = percentInput.closest('.adjustment-row');
      
      if (!row) {
        console.log('❌ No adjustment row found for percentage input');
        return;
      }
      
      // Get market value from same sources as depreciation calculation
      let marketValue = 0;
      
      // First try the basic price field from the same section
      const basicPriceField = document.getElementById('fullBasicPrice');
      if (basicPriceField && basicPriceField.value) {
        marketValue = parseFloat(basicPriceField.value.replace(/[₪,]/g, '')) || 0;
        console.log('📊 Using fullBasicPrice:', marketValue);
      }
      
      // If no basic price, try summary market value (priority)
      if (marketValue === 0) {
        const sumMarketValueField = document.getElementById('sumMarketValue');
        if (sumMarketValueField && sumMarketValueField.value) {
          marketValue = parseFloat(sumMarketValueField.value.replace(/[₪,]/g, '')) || 0;
          console.log('📊 Using sumMarketValue:', marketValue);
        }
      }
      
      // If still no value, try car market value
      if (marketValue === 0) {
        const carMarketValueField = document.getElementById('carMarketValue');
        if (carMarketValueField && carMarketValueField.value) {
          marketValue = parseFloat(carMarketValueField.value.replace(/[₪,]/g, '')) || 0;
          console.log('📊 Using carMarketValue:', marketValue);
        }
      }
      
      if (marketValue === 0) {
        console.log('❌ No market value found for calculation');
      }
      
      // Calculate value exactly like working depreciation
      const calculatedValue = Math.round((marketValue * percent) / 100);
      console.log('💰 Calculation:', { marketValue, percent, calculatedValue });
      
      // Find value input (fourth column in the grid)
      const inputs = row.querySelectorAll('input');
      console.log('📝 Found inputs:', inputs.length);
      // Row structure: [description, select, percentage, value, button]
      // Input indices: [0=description, 1=percentage, 2=value]
      if (inputs.length >= 3) {
        const valueInput = inputs[2]; // Third input (value field)
        valueInput.value = calculatedValue ? `₪${calculatedValue.toLocaleString()}` : '';
        console.log('✅ Set value input to:', valueInput.value);
      } else {
        console.log('❌ Not enough inputs found, expected >= 3, got:', inputs.length);
      }
      
      // Trigger calculation update
      // updateFullMarketValueCalculation() removed
    }
    
    // FINAL REPORT ADJUSTMENTS FUNCTIONS
    
    // Add final report adjustment row
    
    // Calculate final report adjustment value from percentage
    function calculateFinalReportAdjustmentValue(percentageInput) {
      const row = percentageInput.closest('div');
      let basicPrice = parseFloat(document.getElementById('basicPrice')?.value.replace(/[₪,]/g, '')) || 0;
      const percentage = parseFloat(percentageInput.value) || 0;
      
      // Try alternative price sources if basicPrice is empty
      if (basicPrice === 0) {
        // Try grossMarketValue first (from calculations)
        const grossMarketValue = parseFloat(document.getElementById('grossMarketValue')?.value.replace(/[₪,]/g, '')) || 0;
        if (grossMarketValue > 0) {
          basicPrice = grossMarketValue;
          console.log('📊 Using grossMarketValue for final report adjustment calculation:', basicPrice);
        }
      }
      
      // If still no price, try to get from helper
      if (basicPrice === 0) {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        if (helper.levi_report?.base_price) {
          basicPrice = parseFloat(helper.levi_report.base_price);
        } else if (helper.expertise?.levi_report?.base_price) {
          basicPrice = parseFloat(helper.expertise.levi_report.base_price);
        } else if (helper.car_details?.base_price) {
          basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[₪,]/g, ''));
        }
        console.log('📊 Using helper price for final report adjustment calculation:', basicPrice);
      }
      
      if (percentage && basicPrice) {
        const calculatedValue = basicPrice * percentage / 100;
        const inputs = row.querySelectorAll('input');
        if (inputs.length > 2) {
          const valueInput = inputs[2]; // value field is the third input
          valueInput.value = `₪${Math.round(calculatedValue).toLocaleString()}`;
          console.log(`💰 Calculated final report adjustment value: ${percentage}% × ₪${basicPrice.toLocaleString()} = ₪${Math.round(calculatedValue).toLocaleString()}`);
          
          // Trigger change event to update other calculations
          valueInput.dispatchEvent(new Event('change', { bubbles: true }));
        } else {
          console.error('Cannot find value input field for final report adjustment calculation');
        }
      } else {
        console.warn(`⚠️ Cannot calculate final report adjustment value - basicPrice: ${basicPrice}, percentage: ${percentage}`);
        if (basicPrice === 0) {
          console.warn('⚠️ No car price found. Please set the basic price first.');
        }
      }
    }
    
    // Update final report adjustments in helper
    function updateFinalReportAdjustments() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      // Final report container removed - will return empty NodeList
      const adjustmentRows = document.querySelectorAll('#allAdjustmentsRows-final-report div[data-source="custom"]');
      const adjustments = [];
      
      adjustmentRows.forEach(row => {
        const inputs = row.querySelectorAll('input');
        const description = inputs[0].value;
        const type = row.querySelector('select').value;
        const percentage = parseFloat(inputs[1].value) || 0;
        const value = parseFloat(inputs[2].value.replace(/[₪,]/g, '')) || 0;
        
        if (description && (percentage || value)) {
          adjustments.push({ description, type, percentage, value });
        }
      });
      
      // Save to helper
      if (!helper.levi) helper.levi = {};
      helper.levi.custom_adjustments = adjustments;
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      console.log('final report adjustments updated:', adjustments);
      
      // REMOVED: updateHelperFromAdjustments() to prevent overwriting calculated amounts during bulk updates
    }
    
    // REFRESH SECOND BULK FIELDS
    function refreshSecondBulkFields() {
      updateGrossPercentageFromGrossValue();
    }
    
    // UPDATE AUTHORIZED CLAIM DATA
    function updateAuthorizedClaim(element) {
      try {
        const helper = window.helper || {};
        let value = element.value;
        
        // Parse the numeric value from the input
        const numericValue = parseFloat(value.replace(/[₪,]/g, '')) || 0;
        
        // Format currency display
        if (numericValue > 0) {
          value = `₪${numericValue.toLocaleString()}`;
          element.value = value;
        }
        
        // Initialize helper sections if they don't exist
        if (!helper.claims_data) helper.claims_data = {};
        if (!helper.calculations) helper.calculations = {};
        
        // Write to both locations
        helper.claims_data.total_claim = value;
        helper.calculations.total_damage = numericValue;
        
        // Save to session storage and window.helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        console.log(`💰 Updated authorizedClaim: claims_data.total_claim = "${value}", calculations.total_damage = ${numericValue}`);
        console.log(`🔍 DEBUG: helper.calculations after update:`, helper.calculations);
        console.log(`🔍 DEBUG: sessionStorage updated successfully`);
        
      } catch (error) {
        console.error('Error updating authorized claim:', error);
      }
    }

    // UPDATE GROSS PERCENTAGE FIELD
    function updateGrossPercentageField() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        let vehicleValueGross = helper.calculations?.vehicle_value_gross;
        
        // Get AUTHORIZED claim from the field (סה"כ תביעה מאושר) instead of total claim
        const authorizedClaimField = document.getElementById('authorizedClaim');
        const authorizedClaimValue = authorizedClaimField?.value || '';
        const authorizedClaim = parseFloat(authorizedClaimValue.replace(/[₪,]/g, '')) || 0;
        
        // If vehicle_value_gross is missing, try to get it from the leviPriceList field
        if (!vehicleValueGross) {
          const leviPriceListField = document.getElementById('leviPriceList');
          if (leviPriceListField && leviPriceListField.value) {
            vehicleValueGross = parseFloat(leviPriceListField.value.replace(/[₪,]/g, '')) || 0;
            console.log(`🔧 Got vehicle_value_gross from leviPriceList field: ${vehicleValueGross}`);
          }
        }
        
        console.log('🔍 Gross percentage calculation:', {
          vehicleValueGross: vehicleValueGross,
          authorizedClaim: authorizedClaim,
          authorizedClaimRaw: authorizedClaimValue,
          helperCalculations: helper.calculations
        });
        
        if (vehicleValueGross && vehicleValueGross > 0 && authorizedClaim > 0) {
          // Calculate gross percentage: (Authorized Claim ÷ Gross Market Value) × 100
          const grossPercentage = (authorizedClaim / vehicleValueGross) * 100;
          const formattedPercentage = `${Math.round(grossPercentage * 100) / 100}%`;
          
          const grossPercentField = document.getElementById('grossPercent');
          if (grossPercentField) {
            grossPercentField.value = formattedPercentage;
            
            // Update helper claims data to maintain consistency
            helper.claims_data = helper.claims_data || {};
            helper.claims_data.gross_percent = formattedPercentage;
            
            // Also update expertise.calculations for system compatibility
            helper.expertise = helper.expertise || {};
            helper.expertise.calculations = helper.expertise.calculations || {};
            helper.expertise.calculations.damage_percent = Math.round(grossPercentage * 100) / 100;
            
            sessionStorage.setItem('helper', JSON.stringify(helper));
            
            console.log(`📊 Updated gross percentage: ${authorizedClaim.toLocaleString()} ÷ ${vehicleValueGross.toLocaleString()} = ${formattedPercentage}`);
          }
        } else {
          console.log('ℹ️ Gross percentage calculation skipped - values not ready:', {
            vehicleValueGross: vehicleValueGross,
            authorizedClaim: authorizedClaim
          });
          
          // Do NOT call updateGrossMarketValueField here to avoid infinite loop
        }
      } catch (error) {
        console.error('Error updating gross percentage field:', error);
      }
    }
    
    // UPDATE GROSS MARKET VALUE FIELD
    function updateGrossMarketValueField() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        let vehicleValueGross = helper.calculations?.vehicle_value_gross;
        
        console.log('🔍 Updating gross market value field:', {
          vehicleValueGross: vehicleValueGross,
          helperCalculations: helper.calculations
        });
        
        // If no vehicle_value_gross, try to calculate from current gross calculation
        if (!vehicleValueGross) {
          const grossMarketValueField = document.getElementById('grossMarketValueResult');
          if (grossMarketValueField && grossMarketValueField.value) {
            vehicleValueGross = parseFloat(grossMarketValueField.value.replace(/[₪,]/g, '')) || 0;
            console.log(`🔧 Got vehicle_value_gross from grossMarketValueResult field: ${vehicleValueGross}`);
          }
        }
        
        // If still no value, try to get from gross value field  
        if (!vehicleValueGross) {
          const leviPriceListField = document.getElementById('leviPriceList');
          if (leviPriceListField && leviPriceListField.value) {
            vehicleValueGross = parseFloat(leviPriceListField.value.replace(/[₪,]/g, '')) || 0;
            console.log(`🔧 Got vehicle_value_gross from gross value field: ${vehicleValueGross}`);
          }
        }
        
        // Update the leviPriceList field with the gross market value
        const leviPriceListField = document.getElementById('leviPriceList');
        if (leviPriceListField && vehicleValueGross > 0) {
          leviPriceListField.value = `₪${vehicleValueGross.toLocaleString()}`;
          console.log(`📊 Updated leviPriceList field with gross market value: ${vehicleValueGross}`);
        }
        
        // Update helper if we found a value
        if (vehicleValueGross > 0) {
          helper.calculations = helper.calculations || {};
          helper.calculations.vehicle_value_gross = vehicleValueGross;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          console.log(`✅ Updated helper with vehicle_value_gross: ${vehicleValueGross}`);
        } else {
          console.log('ℹ️ vehicle_value_gross not found - will be calculated when needed');
        }
        
      } catch (error) {
        console.error('Error updating gross market value field:', error);
      }
    }
    
    // DEBUG CALCULATIONS
    function debugCalculations() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        console.log('🐛 DEBUG CALCULATIONS:', {
          helper_calculations: helper.calculations,
          helper_expertise_calculations: helper.expertise?.calculations,
          helper_claims_data: helper.claims_data,
          grossMarketValueResult: document.getElementById('grossMarketValueResult')?.value,
          fullMarketValueResult: document.getElementById('fullMarketValueResult')?.value,
          totalClaim: document.getElementById('totalClaim')?.value,
          leviPriceList: document.getElementById('leviPriceList')?.value,
          grossPercent: document.getElementById('grossPercent')?.value,
          basicPrice: document.getElementById('basicPrice')?.value,
          carMarketValue: document.getElementById('carMarketValue')?.value,
          sumMarketValue: document.getElementById('sumMarketValue')?.value,
          sumClaim: document.getElementById('sumClaim')?.value,
          sumTotalClaim: document.getElementById('sumTotalClaim')?.value
        });
        
      } catch (error) {
        console.error('Error in debug calculations:', error);
      }
    }
    
    // CALCULATE DAMAGE PERCENTAGE
    function calculateDamagePercentage() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Get total claim from damage centers or helper
        let totalClaim = 0;
        const totalClaimField = document.getElementById('totalClaim');
        if (totalClaimField && totalClaimField.value) {
          totalClaim = parseFloat(totalClaimField.value.replace(/[₪,]/g, '')) || 0;
        } else {
          totalClaim = calculateTotalClaimFromDamageCenters();
        }
        
        // Get gross market value from helper or DOM
        let grossMarketValue = helper.calculations?.vehicle_value_gross || 0;
        if (!grossMarketValue) {
          const grossMarketValueField = document.getElementById('grossMarketValueResult');
          if (grossMarketValueField && grossMarketValueField.value) {
            grossMarketValue = parseFloat(grossMarketValueField.value.replace(/[₪,]/g, '')) || 0;
          }
        }
        
        // Calculate damage percentage
        let damagePercentage = 0;
        if (grossMarketValue > 0 && totalClaim > 0) {
          damagePercentage = (totalClaim / grossMarketValue) * 100;
        }
        
        console.log('🔢 Damage percentage calculation:', {
          totalClaim,
          grossMarketValue,
          damagePercentage
        });
        
        return damagePercentage;
        
      } catch (error) {
        console.error('Error calculating damage percentage:', error);
        return 0;
      }
    }

    // TRIGGER GLOBAL DEPRECIATION CALCULATION
    function triggerGlobalDepreciationCalc() {
      const globalDepInput = document.getElementById('globalDep1');
      if (globalDepInput && globalDepInput.value) {
        const event = new Event('input', { bubbles: true });
        globalDepInput.dispatchEvent(event);
      }
    }

    // 🏛️ ADMIN HUB COMMUNICATION SETUP
    function initAdminHubCommunication() {
      console.log('🔌 Initializing admin hub communication...');
      
      // Listen for messages from admin hub (parent frame)
      window.addEventListener('message', function(event) {
        // Security: Check origin if needed
        // if (event.origin !== 'https://yaron-cayouf-portal.netlify.app') return;
        
        console.log('📨 Received message from admin hub:', event.data);
        
        if (event.data && event.data.type) {
          switch (event.data.type) {
            case 'VAT_RATE_UPDATED':
              // Admin hub notifies us of VAT rate change
              const newVatRate = event.data.vatRate;
              console.log('📢 Received VAT rate update from admin hub:', newVatRate + '%');
              
              // Check if we should ignore admin updates due to recent manual override
              const now = Date.now();
              if (window.ignoreAdminVatUntil && now < window.ignoreAdminVatUntil) {
                const remainingTime = Math.ceil((window.ignoreAdminVatUntil - now) / 1000);
                console.log(`🛡️ IGNORING admin hub VAT update due to recent manual override (${remainingTime}s remaining) (final-report)`);
                console.log('💡 Manual session override takes precedence');
                break; // Exit without updating
              }
              
              // Clear protection flags if expired
              if (window.ignoreAdminVatUntil && now >= window.ignoreAdminVatUntil) {
                window.ignoreAdminVatUntil = null;
                window.lastManualVatUpdate = null;
                console.log('🔓 Manual VAT override protection expired, admin updates allowed (final-report)');
              }
              
              // CRITICAL: Update helper.calculations.vat_rate directly (source of truth)
              console.log('🔍 Checking setHelperVatRateFromAdmin availability:', typeof window.setHelperVatRateFromAdmin);
              
              if (typeof window.setHelperVatRateFromAdmin === 'function') {
                console.log('🎯 Calling setHelperVatRateFromAdmin with rate:', newVatRate);
                const success = window.setHelperVatRateFromAdmin(newVatRate, 'admin_hub');
                console.log(success ? '✅ Helper VAT rate updated successfully' : '❌ Failed to update helper VAT rate');
                
                // Verify the change
                setTimeout(() => {
                  const currentHelperVat = window.helper?.calculations?.vat_rate;
                  console.log('🔍 Verified helper.calculations.vat_rate:', currentHelperVat);
                  console.log('🔍 getHelperVatRate() returns:', window.getHelperVatRate ? window.getHelperVatRate() : 'function not available');
                }, 100);
                
              } else {
                console.warn('⚠️ setHelperVatRateFromAdmin function not available');
                console.log('🔍 Available window functions:', Object.keys(window).filter(k => k.includes('Helper') || k.includes('Vat')));
              }
              
              // Refresh VAT display
              if (window.initVatDisplay) {
                window.initVatDisplay();
              }
              
              // Refresh all calculations
              if (typeof refreshAllCalculations === 'function') {
                refreshAllCalculations();
              }
              
              break;
              
            case 'GET_VAT_RATE':
              // Admin hub requests current VAT rate
              const currentVat = window.getHelperVatRate ? window.getHelperVatRate() : 18;
              event.source.postMessage({
                type: 'VAT_RATE_RESPONSE',
                vatRate: currentVat
              }, event.origin);
              break;
              
            default:
              console.log('📨 Unknown message from admin hub:', event.data);
          }
        }
      });
      
      // Try to establish connection with admin hub
      if (window.parent && window.parent !== window) {
        console.log('🔗 Attempting to connect to admin hub...');
        
        // Request current VAT rate from admin hub
        setTimeout(() => {
          window.parent.postMessage({ type: 'GET_VAT_RATE' }, '*');
        }, 500);
        
        // Notify admin hub that we're ready
        window.parent.postMessage({ 
          type: 'MODULE_READY', 
          module: 'final-report-builder',
          timestamp: Date.now()
        }, '*');
      } else {
        console.log('ℹ️ No parent frame detected (not in admin hub iframe)');
      }
    }

    // Cleanup function to remove deprecated data structures
    function cleanupDeprecatedData() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        let updated = false;
        
        // Keep final_report.adjustments - it's now the primary data structure
        
        if (updated) {
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
      } catch (error) {
        console.error('Error cleaning deprecated data:', error);
      }
    }

    // Cleanup function to fix duplicated damage center numbers
    function cleanupDamageCenterNumbers() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        if (helper.centers && Array.isArray(helper.centers)) {
          let updated = false;
          
          helper.centers.forEach((center, index) => {
            if (center["Damage center Number"] && typeof center["Damage center Number"] === 'string') {
              // Check if it contains duplicated text
              if (center["Damage center Number"].includes('מוקד')) {
                // Extract just the number
                const match = center["Damage center Number"].match(/\d+$/);
                const cleanNumber = match ? match[0] : String(index + 1);
                center["Damage center Number"] = cleanNumber;
                updated = true;
              }
            }
          });
          
          if (updated) {
            sessionStorage.setItem('helper', JSON.stringify(helper));
            // Also update window.helper if it exists
            if (window.helper && window.helper.centers) {
              window.helper.centers = helper.centers;
            }
            console.log('Cleaned up damage center numbers');
          }
        }
      } catch (error) {
        console.error('Error cleaning damage center numbers:', error);
      }
    }

    async function initializeDamageCenterIds() {
      try {
        console.log('🔍 SESSION 56: Initializing damage center IDs from Supabase...');
        
        const helper = window.helper || {};
        
        if (!helper.centers || helper.centers.length === 0) {
          console.log('ℹ️ SESSION 56: No damage centers in helper, skipping ID initialization');
          return;
        }
        
        console.log(`📊 SESSION 56: Found ${helper.centers.length} centers in helper:`, helper.centers);
        
        const centersNeedingIds = helper.centers.filter((center, index) => {
          const hasId = !!(center.Id || center.id || center.code);
          if (!hasId) {
            console.log(`⚠️ SESSION 56: Center ${index} missing ID:`, center);
          }
          return !hasId;
        });
        
        if (centersNeedingIds.length === 0) {
          console.log('✅ SESSION 56: All damage centers already have IDs');
          return;
        }
        
        console.log(`🔧 SESSION 56: ${centersNeedingIds.length} centers need IDs, querying Supabase...`);
        
        const plate = helper.meta?.plate || helper.vehicle?.plate || helper.car_details?.plate;
        if (!plate) {
          console.warn('⚠️ SESSION 56: No plate number found, cannot query Supabase');
          return;
        }
        
        const normalizedPlate = plate.replace(/-/g, '');
        
        if (!window.supabase) {
          console.warn('⚠️ SESSION 56: Supabase not available, cannot load damage center IDs');
          return;
        }
        
        const { data: partsData, error } = await window.supabase
          .from('parts_required')
          .select('damage_center_code, part_name, plate')
          .eq('plate', normalizedPlate);
        
        if (error) {
          console.error('❌ SESSION 56: Error querying Supabase parts_required:', error);
          return;
        }
        
        if (!partsData || partsData.length === 0) {
          console.log('ℹ️ SESSION 56: No parts found in Supabase for this plate');
          return;
        }
        
        const uniqueCenterCodes = [...new Set(partsData.map(p => p.damage_center_code).filter(Boolean))];
        console.log(`📋 SESSION 56: Found ${uniqueCenterCodes.length} unique damage center codes in Supabase:`, uniqueCenterCodes);
        
        uniqueCenterCodes.sort();
        
        helper.centers.forEach((center, index) => {
          if (center.Id || center.id || center.code) {
            return;
          }
          
          if (uniqueCenterCodes[index]) {
            center.Id = uniqueCenterCodes[index];
            console.log(`✅ SESSION 56: Assigned ID to center ${index}: ${center.Id}`);
          } else {
            console.warn(`⚠️ SESSION 56: No matching Supabase ID for center ${index}, will generate on save`);
          }
        });
        
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        console.log('✅ SESSION 56: Damage center IDs initialized successfully');
        
      } catch (error) {
        console.error('❌ SESSION 56: Error initializing damage center IDs:', error);
      }
    }

    // ============================================================================
    // SESSION 88: INVOICE ASSIGNMENT BANNER SYSTEM
    // ============================================================================

    /**
     * Check for available invoices and show assignment banner if any exist
     */
    async function checkForAvailableInvoices() {
      console.log('🎯 SESSION 88: checkForAvailableInvoices() FUNCTION ENTRY - Starting execution...');
      try {
        console.log('📄 SESSION 88: Checking for available invoices (replicating invoice upload.html logic)...');
        
        const helper = window.helper || {};
        const caseId = helper.case_info?.supabase_case_id;
        const plateNumber = helper.case_info?.plate;
        
        console.log('🔍 SESSION 88 COMPREHENSIVE DEBUG:');
        console.log('  helper keys:', Object.keys(helper));
        console.log('  helper.case_info:', helper.case_info);
        console.log('  caseId:', caseId);
        console.log('  plateNumber:', plateNumber);
        console.log('  window.supabase available:', !!window.supabase);
        console.log('  window.invoiceService available:', !!window.invoiceService);
        
        if (!caseId) {
          console.log('❌ SESSION 88: No case_id found - cannot check invoices');
          console.log('  helper.case_info?.supabase_case_id:', helper.case_info?.supabase_case_id);
          console.log('  helper.case_id:', helper.case_id);
          console.log('  helper.meta?.case_id:', helper.meta?.case_id);
          hideInvoiceAssignmentBanner();
          return;
        }
        
        if (!plateNumber) {
          console.log('❌ SESSION 88: No plate number found - cannot filter invoices');
          hideInvoiceAssignmentBanner();
          return;
        }
        
        if (!window.supabase) {
          console.warn('⚠️ SESSION 88: Supabase not available for invoice check');
          return;
        }
        
        // Try direct Supabase query first (fallback if invoiceService not available)
        if (!window.invoiceService) {
          console.warn('⚠️ SESSION 88: invoiceService not available, trying direct Supabase query...');
          
          const { data: allInvoices, error } = await window.supabase
            .from('invoices')
            .select('*')
            .eq('case_id', caseId);
          
          if (error) {
            console.error('❌ SESSION 88: Error querying invoices directly:', error);
            return;
          }
          
          console.log('📦 SESSION 88: Direct Supabase query - all invoices:', allInvoices);
          
          if (!allInvoices || allInvoices.length === 0) {
            console.log('ℹ️ SESSION 88: No invoices found in database for this case');
            hideInvoiceAssignmentBanner();
            return;
          }
          
          // Filter by plate
          const plateInvoices = allInvoices.filter(inv => {
            console.log(`  Direct query - Comparing: "${inv.plate}" === "${plateNumber}" → ${inv.plate === plateNumber}`);
            return inv.plate === plateNumber;
          });
          
          console.log(`📊 SESSION 88: Direct query - Found ${plateInvoices.length} invoices for this plate`);
          
          if (plateInvoices.length === 0) {
            console.log('ℹ️ SESSION 88: No invoices found for this plate');
            hideInvoiceAssignmentBanner();
            return;
          }
          
          // Show these invoices (even without mappings for now)
          console.log('📋 SESSION 88: Showing available invoices (direct query):', plateInvoices);
          showInvoiceAssignmentBanner(plateInvoices.map(inv => ({ ...inv, assignment_count: 0 })));
          return;
        }
        
        console.log(`📂 SESSION 88: Loading invoices via invoiceService for case: ${caseId}, plate: ${plateNumber}`);
        
        // Get all invoices for this case (same as invoice upload.html)
        const allInvoices = await window.invoiceService.getInvoicesByCase(caseId);
        console.log('📦 SESSION 88: invoiceService result - all invoices:', allInvoices);
        
        if (!allInvoices || allInvoices.length === 0) {
          console.log('ℹ️ SESSION 88: No invoices returned by invoiceService');
          hideInvoiceAssignmentBanner();
          return;
        }
        
        // Filter by plate (same as invoice upload.html)
        const plateInvoices = allInvoices.filter(inv => {
          console.log(`  invoiceService - Comparing: "${inv.plate}" === "${plateNumber}" → ${inv.plate === plateNumber}`);
          return inv.plate === plateNumber;
        });
        
        console.log(`📊 SESSION 88: invoiceService - Found ${plateInvoices.length} invoices for this case and plate`);
        
        if (!plateInvoices || plateInvoices.length === 0) {
          console.log('ℹ️ SESSION 88: No invoices found for this plate via invoiceService');
          hideInvoiceAssignmentBanner();
          return;
        }
        
        // Check which invoices have mappings in the database that haven't been applied yet
        const invoicesWithPendingAssignments = [];
        
        for (const invoice of plateInvoices) {
          // Query invoice_damage_center_mappings table for this invoice
          const { data: mappings, error: mappingError } = await window.supabase
            .from('invoice_damage_center_mappings')
            .select('id, mapping_status, field_type, damage_center_id')
            .eq('invoice_id', invoice.id)
            .eq('case_id', caseId)
            .eq('mapping_status', 'active'); // Only active mappings
          
          if (mappingError) {
            console.error(`❌ SESSION 88: Error querying mappings for invoice ${invoice.id}:`, mappingError);
            continue;
          }
          
          console.log(`🔍 SESSION 88: Invoice ${invoice.supplier_name} has ${mappings?.length || 0} active mappings`);
          
          if (mappings && mappings.length > 0) {
            // Check if these mappings have been applied to damage centers already
            // For now, assume if mapping_status = 'active', they need to be applied
            invoicesWithPendingAssignments.push({
              ...invoice,
              assignment_count: mappings.length,
              mappings: mappings
            });
          }
        }
        
        console.log(`📋 SESSION 88: Found ${invoicesWithPendingAssignments.length} invoices with pending assignments:`, invoicesWithPendingAssignments);
        
        if (invoicesWithPendingAssignments.length === 0) {
          console.log('ℹ️ SESSION 88: No invoices with pending assignments');
          hideInvoiceAssignmentBanner();
          return;
        }
        
        showInvoiceAssignmentBanner(invoicesWithPendingAssignments);
        
      } catch (error) {
        console.error('❌ SESSION 88: Error checking for invoices:', error);
        console.error('❌ SESSION 88: Error stack:', error.stack);
        console.error('❌ SESSION 88: Error name:', error.name);
        console.error('❌ SESSION 88: Error message:', error.message);
        hideInvoiceAssignmentBanner();
      } finally {
        console.log('🏁 SESSION 88: checkForAvailableInvoices() FUNCTION EXIT - Execution completed');
      }
    }

    /**
     * Show the invoice assignment banner with available invoices
     */
    function showInvoiceAssignmentBanner(invoices) {
      const banner = document.getElementById('invoiceAssignmentBanner');
      const content = document.getElementById('invoiceAssignmentContent');
      
      if (!banner || !content) {
        console.warn('⚠️ SESSION 88: Invoice banner elements not found');
        return;
      }
      
      // Build invoice list HTML (matching invoice upload.html format)
      let invoiceListHtml = `
        <div style="margin-bottom: 10px; font-weight: 600; color: #1565c0;">
          נמצאו ${invoices.length} חשבוניות עם הקצאות ממתינות להחלה:
        </div>
      `;
      
      invoices.forEach((invoice, index) => {
        // Extract invoice date following same pattern as other invoice fields (supplier_name, etc.)
        let invoiceDate = null;
        
        // Primary source: invoice.invoice_date field (if exists in database)
        if (invoice.invoice_date) {
          invoiceDate = invoice.invoice_date;
        }
        
        // Secondary source: OCR structured data with Hebrew field name
        if (!invoiceDate && invoice.ocr_structured_data && invoice.ocr_structured_data['תאריך']) {
          invoiceDate = invoice.ocr_structured_data['תאריך'];
        }
        
        // Tertiary source: helper.invoices array (legacy data)
        if (!invoiceDate) {
          const helperInvoice = helper.invoices?.find(inv => 
            inv.id === invoice.id || 
            (inv.invoice_number && inv.invoice_number === invoice.invoice_number)
          );
          if (helperInvoice) {
            invoiceDate = helperInvoice['תאריך'] || helperInvoice.date || helperInvoice.invoice_date;
          }
        }
        
        // Format date for display (same pattern as other fields)
        let displayDate;
        if (invoiceDate) {
          try {
            // Handle various date formats
            const dateObj = new Date(invoiceDate);
            if (!isNaN(dateObj.getTime())) {
              displayDate = dateObj.toLocaleDateString('he-IL');
            } else {
              // If parsing fails, use string as-is (might be Hebrew date)
              displayDate = invoiceDate.toString();
            }
          } catch (e) {
            displayDate = invoiceDate.toString();
          }
        } else {
          // Final fallback: upload date (same as supplier_name pattern: 'לא צוין')
          displayDate = new Date(invoice.created_at).toLocaleDateString('he-IL');
        }
        
        const supplierName = invoice.supplier_name || 'לא צוין';
        const displayTitle = `${supplierName} - ${displayDate}`;
        const assignmentCount = invoice.assignment_count || 0;
        
        invoiceListHtml += `
          <div style="
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 8px;
            background: #fafafa;
            display: flex;
            justify-content: space-between;
            align-items: center;
          ">
            <div>
              <div style="font-weight: 600; color: #333;">
                ${displayTitle}
              </div>
              <div style="font-size: 13px; color: #666;">
                ${assignmentCount} הקצאות | ₪${invoice.total_amount?.toLocaleString() || '0'}
              </div>
            </div>
            <div>
              <input type="checkbox" 
                     id="invoice_${invoice.id}" 
                     data-invoice-id="${invoice.id}"
                     style="transform: scale(1.2);">
            </div>
          </div>
        `;
      });
      
      content.innerHTML = invoiceListHtml;
      banner.style.display = 'block';
      
      // Store invoices data for later use
      window.availableInvoices = invoices;
      
      console.log('✅ SESSION 88: Invoice assignment banner displayed');
    }

    /**
     * Hide the invoice assignment banner
     */
    function hideInvoiceAssignmentBanner() {
      const banner = document.getElementById('invoiceAssignmentBanner');
      if (banner) {
        banner.style.display = 'none';
      }
    }

    /**
     * Dismiss the invoice assignment banner (user clicked X)
     */
    function dismissInvoiceAssignmentBanner() {
      hideInvoiceAssignmentBanner();
      
      // Mark as dismissed in session storage
      sessionStorage.setItem('invoiceAssignmentDismissed', 'true');
      
      console.log('ℹ️ SESSION 88: Invoice assignment banner dismissed by user');
    }

    /**
     * Show invoices differentials in a popup
     */
    async function showInvoicesDifferentials() {
      try {
        console.log('📊 SESSION 88: Showing invoice differentials...');
        
        const checkedInvoices = getSelectedInvoices();
        if (checkedInvoices.length === 0) {
          alert('אנא בחר לפחות חשבונית אחת להצגת הפרשים');
          return;
        }
        
        // Calculate differentials between wizard centers and invoice data
        const differentials = await calculateInvoiceDifferentials(checkedInvoices);
        
        // Show in popup or floating screen
        displayDifferentialsPopup(differentials);
        
      } catch (error) {
        console.error('❌ SESSION 88: Error showing differentials:', error);
        alert('שגיאה בהצגת הפרשי חשבוניות');
      }
    }

    /**
     * Accept invoice assignment and perform center duplication
     */
    async function acceptInvoiceAssignment() {
      try {
        console.log('🚀 SESSION 88: Processing invoice assignment acceptance...');
        console.log('📋 Getting selected invoices...');
        
        const checkedInvoices = getSelectedInvoices();
        console.log('📋 Selected invoices:', checkedInvoices);
        
        if (checkedInvoices.length === 0) {
          console.warn('⚠️ No invoices selected');
          alert('אנא בחר לפחות חשבונית אחת לאישור הקצאה');
          return;
        }
        
        console.log(`✅ Found ${checkedInvoices.length} selected invoices, showing confirmation...`);
        
        if (!confirm(`האם אתה בטוח שברצונך לאשר הקצאת ${checkedInvoices.length} חשבוניות? פעולה זו תדרוס את נתוני המוקדים הקיימים.`)) {
          console.log('❌ User cancelled confirmation');
          return;
        }
        
        console.log('✅ User confirmed, starting process...');
        
        // Show loading state
        const acceptBtn = document.getElementById('acceptInvoiceAssignment');
        if (acceptBtn) {
          acceptBtn.disabled = true;
          acceptBtn.textContent = 'מעבד...';
        }
        
        // Phase 1: Archive entire helper to helper_versions (one-time per case)
        await archiveEntireHelper();
        
        // Phase 2: Archive parts_search.required_parts before invoice import
        await archivePartsSearchData();
        
        // Phase 3: Convert invoice mappings to helper format (no calculations)
        await convertInvoiceMappingsToHelperFormat(checkedInvoices);
        
        // Phase 4: Save updated helper.centers back to Supabase and sessionStorage
        await saveUpdatedHelper();
        
        // Phase 5: Update mapping status to 'applied' for tracking
        await updateMappingStatus(checkedInvoices, 'applied');
        
        // Phase 6: Hide banner and refresh view
        hideInvoiceAssignmentBanner();
        
        // Reload the page or refresh damage centers display
        if (typeof loadDataFromHelper === 'function') {
          loadDataFromHelper();
        }
        
        alert('הקצאת חשבוניות הושלמה בהצלחה!');
        
      } catch (error) {
        console.error('❌ SESSION 88: Error accepting invoice assignment:', error);
        alert('שגיאה בעיבוד הקצאת חשבוניות');
        
        // Reset button state
        const acceptBtn = document.getElementById('acceptInvoiceAssignment');
        if (acceptBtn) {
          acceptBtn.disabled = false;
          acceptBtn.textContent = 'אשר הקצאת חשבוניות';
        }
      }
    }

    /**
     * Get selected invoices from checkboxes
     */
    function getSelectedInvoices() {
      const checkboxes = document.querySelectorAll('[data-invoice-id]:checked');
      const selectedIds = Array.from(checkboxes).map(cb => cb.getAttribute('data-invoice-id'));
      
      return (window.availableInvoices || []).filter(invoice => 
        selectedIds.includes(invoice.id)
      );
    }

    /**
     * Archive entire helper before invoice assignment (one-time per case)
     */
    async function archiveEntireHelper() {
      const helper = window.helper || {};
      
      // Check if archive already exists for this case
      if (helper.parts_search?.has_archived) {
        console.log('ℹ️ SESSION 88: Archive already exists - skipping duplicate archive');
        return;
      }
      
      if (!helper.centers || helper.centers.length === 0) {
        console.log('ℹ️ SESSION 88: No centers to archive');
        return;
      }
      
      // Save ENTIRE helper using the existing version saving system
      if (typeof window.saveHelperVersion === 'function') {
        await window.saveHelperVersion('Pre-Invoice Assignment Archive', {
          trigger_event: 'before_invoice_import',
          is_pre_invoice_wizard: true,  // Special flag for querying original wizard data
          centers_count: helper.centers.length,
          notes: 'Complete helper archived before invoice assignment - wizard data preserved'
        });
        
        // Mark as archived to prevent duplicate archives
        if (!helper.parts_search) helper.parts_search = {};
        helper.parts_search.has_archived = true;
        
        console.log('✅ SESSION 88: Entire helper archived to helper_versions with pre-invoice flag');
      } else {
        console.warn('⚠️ SESSION 88: saveHelperVersion not available, skipping archive');
      }
    }

    /**
     * Archive parts_search.required_parts before invoice import
     */
    async function archivePartsSearchData() {
      try {
        console.log('📦 SESSION 88: Archiving parts_search.required_parts...');
        
        const helper = window.helper || {};
        
        if (!helper.parts_search?.required_parts || helper.parts_search.required_parts.length === 0) {
          console.log('ℹ️ SESSION 88: No parts_search.required_parts to archive');
          return;
        }
        
        const partsCount = helper.parts_search.required_parts.length;
        console.log(`📋 SESSION 88: Archiving ${partsCount} parts from parts_search.required_parts`);
        
        // Calculate total value of parts being archived
        const totalPartsValue = helper.parts_search.required_parts.reduce((sum, part) => {
          return sum + (parseFloat(part.total_cost) || 0);
        }, 0);
        
        // Archive parts data to Supabase using required_parts_archive table
        if (window.supabase) {
          try {
            console.log('📦 SESSION 88: Archiving parts to required_parts_archive table...');
            
            // Prepare archive records from parts_search.required_parts
            const archiveRecords = helper.parts_search.required_parts.map(part => {
              // Ensure all records have exactly the same structure
              const baseRecord = {
                // Archive metadata
                archive_type: 'pre_invoice_assignment',
                archive_reason: 'Parts archived before invoice assignment to preserve wizard data',
                archived_by: helper.user?.id || null,
                
                // Case identification
                case_id: helper.case_info?.supabase_case_id || null,
                plate: helper.case_info?.plate || null,
                damage_center_code: part.damage_center_code || null,
                
                // Part information
                part_name: part.part_name || null,
                quantity: part.quantity || 1,
                status: 'ARCHIVED',
                metadata: {
                  source: 'parts_search.required_parts',
                  original_status: part.status || null,
                  session: 'SESSION_88',
                  ...(part.metadata || {})
                },
                
                // Vehicle information
                make: part.make || helper.vehicle?.make || null,
                model: part.model || helper.vehicle?.model || null,
                trim: part.trim || helper.vehicle?.trim || null,
                year: part.year || helper.vehicle?.year || null,
                engine_volume: part.engine_volume || helper.vehicle?.engine_volume || null,
                engine_code: part.engine_code || helper.vehicle?.engine_code || null,
                engine_type: part.engine_type || helper.vehicle?.engine_type || null,
                vin: part.vin || helper.vehicle?.vin || null,
                
                // Part details
                pcode: part.pcode || null,
                cat_num_desc: part.cat_num_desc || null,
                source: part.source || null,
                oem: part.oem || null,
                availability: part.availability || null,
                location: part.location || null,
                comments: part.comments || null,
                supplier_name: part.supplier_name || null,
                part_family: part.part_family || null,
                description: part.description || null,
                
                // Pricing (ensure consistent types)
                price_per_unit: part.price_per_unit ? parseFloat(part.price_per_unit) : null,
                reduction_percentage: part.reduction_percentage ? parseFloat(part.reduction_percentage) : 0,
                wear_percentage: part.wear_percentage ? parseFloat(part.wear_percentage) : 0,
                updated_price: part.updated_price ? parseFloat(part.updated_price) : null,
                total_cost: part.total_cost ? parseFloat(part.total_cost) : null,
                
                // Original identifiers
                original_row_uuid: part.row_uuid || null,
                original_created_at: part.created_at || null,
                original_updated_at: part.updated_at || null,
                original_created_by: part.created_by || null,
                original_updated_by: part.updated_by || null
              };
              
              return baseRecord;
            });
            
            if (archiveRecords.length > 0) {
              console.log('🔍 SESSION 88: Archive records structure:', {
                count: archiveRecords.length,
                firstRecord: archiveRecords[0],
                allKeysMatch: archiveRecords.every(record => 
                  Object.keys(record).length === Object.keys(archiveRecords[0]).length
                )
              });
              
              const { data: archiveData, error: archiveError } = await window.supabase
                .from('required_parts_archive')
                .insert(archiveRecords)
                .select();
              
              if (archiveError) {
                console.error('❌ SESSION 88: Error archiving to Supabase:', archiveError);
                console.log('🔍 Debug: Failed record structure:', archiveRecords[0]);
              } else {
                console.log(`✅ SESSION 88: ${archiveData.length} parts archived to required_parts_archive table`);
              }
            } else {
              console.log('ℹ️ SESSION 88: No parts to archive');
            }
            
          } catch (supabaseError) {
            console.error('❌ SESSION 88: Supabase archive failed:', supabaseError);
          }
        } else {
          console.log('ℹ️ SESSION 88: Supabase not available for parts archive');
        }
        
        // Also save version using existing version saving system for redundancy
        if (typeof window.saveHelperVersion === 'function') {
          await window.saveHelperVersion('Pre-Invoice Parts Archive', {
            trigger_event: 'parts_archive_before_invoice',
            archive_type: 'parts_search_required_parts',
            parts_count: partsCount,
            total_parts_value: totalPartsValue,
            notes: 'parts_search.required_parts archived before invoice assignment'
          });
          
          console.log('✅ SESSION 88: Parts also archived to helper_versions for redundancy');
        }
        
        console.log(`✅ SESSION 88: Successfully archived ${partsCount} parts (₪${totalPartsValue.toLocaleString()})`);
        
      } catch (error) {
        console.error('❌ SESSION 88: Error archiving parts_search data:', error);
        // Don't throw - this shouldn't block the invoice assignment process
      }
    }

    /**
     * Convert invoice mappings to helper format (no calculations - UI handles those)
     */
    async function convertInvoiceMappingsToHelperFormat(selectedInvoices) {
      try {
        console.log('🔄 SESSION 88: Converting invoice mappings to helper format...');
        console.log('📋 Selected invoices:', selectedInvoices);
        
        const helper = window.helper || {};
        console.log('🔍 Helper case_info:', helper.case_info);
        const caseId = helper.case_info?.supabase_case_id;
        console.log('🔍 Case ID:', caseId);
        
        if (!caseId) {
          console.error('❌ No case_id found in helper');
          throw new Error('No case_id found in helper');
        }
        
        if (!window.supabase) {
          console.error('❌ Supabase not available');
          throw new Error('Supabase not available');
        }
        
        if (!helper.centers) {
          console.log('⚠️ No helper.centers found, initializing empty array');
          helper.centers = [];
        }
        console.log('🔍 Current helper.centers count:', helper.centers.length);
        
        for (const invoice of selectedInvoices) {
          console.log(`📋 Processing mappings for invoice ${invoice.invoice_number}...`);
          
          // Get all mappings for this invoice from invoice_damage_center_mappings table
          console.log(`🔍 Querying mappings for invoice_id: ${invoice.id}, case_id: ${caseId}`);
          
          const { data: mappings, error } = await window.supabase
            .from('invoice_damage_center_mappings')
            .select(`
              *,
              invoice_line:invoice_lines!inner(*)
            `)
            .eq('invoice_id', invoice.id)
            .eq('case_id', caseId)
            .eq('mapping_status', 'active');  // Only get active mappings
          
          console.log(`📋 Query result - mappings:`, mappings, 'error:', error);
          
          if (error) {
            console.error('❌ Error fetching mappings:', error);
            continue;
          }
          
          if (!mappings || mappings.length === 0) {
            console.warn(`⚠️ No mappings found for invoice ${invoice.invoice_number}`);
            
            // Debug: Check what mappings exist for this case/invoice without status filter
            console.log(`🔍 DEBUG: Checking ALL mappings for invoice ${invoice.id}...`);
            const { data: allMappings } = await window.supabase
              .from('invoice_damage_center_mappings')
              .select('*')
              .eq('invoice_id', invoice.id)
              .eq('case_id', caseId);
            console.log(`🔍 DEBUG: All mappings found:`, allMappings);
            
            continue;
          }
          
          console.log(`📊 Found ${mappings.length} mappings for invoice ${invoice.invoice_number}:`, mappings);
          console.log(`🔍 Available centers in helper.centers:`, helper.centers?.map(c => ({ Id: c.Id, name: c.Description || c.Location })));
          
          // Convert each mapping to UI format and add to helper.centers
          mappings.forEach((mapping, index) => {
            console.log(`🔄 Processing mapping ${index + 1}/${mappings.length}:`, mapping);
            
            const centerCode = mapping.damage_center_id;
            const center = helper.centers?.find(c => 
              c.Id === centerCode || c.code === centerCode
            );
            
            console.log(`🔍 Looking for center '${centerCode}', found:`, center);
            
            if (!center) {
              console.warn(`⚠️ Center ${centerCode} not found in helper.centers`);
              console.log(`Available center IDs:`, helper.centers?.map(c => c.Id));
              return;
            }
            
            // Convert mapping to UI format based on field_type (no calculations)
            console.log(`🔧 Converting ${mapping.field_type} mapping to UI format for center ${centerCode}`);
            
            switch (mapping.field_type) {
              case 'parts':
                const partItem = convertMappingToPart(mapping, invoice);
                if (!center.Parts) center.Parts = { parts_required: [] };
                if (!center.Parts.parts_required) center.Parts.parts_required = [];
                center.Parts.parts_required.push(partItem);
                console.log(`✅ Added part to center. Total parts now: ${center.Parts.parts_required.length}`);
                break;
                
              case 'works':
                const workItem = convertMappingToWork(mapping, invoice);
                if (!center.Works) center.Works = { works: [] };
                if (!center.Works.works) center.Works.works = [];
                center.Works.works.push(workItem);
                console.log(`✅ Added work to center. Total works now: ${center.Works.works.length}`);
                break;
                
              case 'repairs':
                const repairItem = convertMappingToRepair(mapping, invoice);
                if (!center.Repairs) center.Repairs = { repairs: [] };
                if (!center.Repairs.repairs) center.Repairs.repairs = [];
                center.Repairs.repairs.push(repairItem);
                console.log(`✅ Added repair to center. Total repairs now: ${center.Repairs.repairs.length}`);
                break;
            }
          });
        }
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        // Try to refresh the damage centers display
        if (typeof loadDataFromHelper === 'function') {
          console.log('🔄 Refreshing damage centers display...');
          loadDataFromHelper();
        } else if (typeof refreshDamageCenters === 'function') {
          refreshDamageCenters();
        } else {
          console.log('ℹ️ No refresh function found - page may need manual refresh');
        }
        
        console.log('✅ SESSION 88: Invoice mappings applied to damage centers');
        
      } catch (error) {
        console.error('❌ SESSION 88: Error applying invoice mappings:', error);
        throw error;
      }
    }

    /**
     * Save updated helper to Supabase and sessionStorage
     */
    async function saveUpdatedHelper() {
      try {
        console.log('💾 SESSION 88: Saving updated helper...');
        
        const helper = window.helper || {};
        
        if (!helper.centers || helper.centers.length === 0) {
          console.log('ℹ️ SESSION 88: No centers to save');
          return;
        }
        
        // Update sessionStorage first
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        console.log('✅ Updated helper in sessionStorage');
        
        // Save to case_helper table (correct structure)
        if (window.supabase && helper.case_info?.supabase_case_id) {
          const caseId = helper.case_info.supabase_case_id;
          
          // Update current helper in case_helper table
          const { error } = await window.supabase
            .from('case_helper')
            .update({ 
              helper_json: helper,
              updated_at: new Date().toISOString()
            })
            .eq('case_id', caseId)
            .eq('is_current', true);
          
          if (error) {
            console.error('❌ Error saving helper to case_helper:', error);
          } else {
            console.log('✅ Helper saved to case_helper table');
          }
        } else {
          console.log('ℹ️ Supabase not available or no case_id - only saved to sessionStorage');
        }
        
        // Save helper version for backup
        if (typeof window.saveHelperVersion === 'function') {
          await window.saveHelperVersion('Post-Invoice Assignment', {
            trigger_event: 'invoice_assignment_completed',
            centers_count: helper.damage_centers.length,
            notes: 'Helper saved after invoice assignment - invoice data applied'
          });
          console.log('✅ Version saved to helper_versions for backup');
        }
        
        console.log(`✅ SESSION 88: Saved ${helper.centers.length} updated centers`);
        
      } catch (error) {
        console.error('❌ SESSION 88: Error saving updated damage centers:', error);
        // Don't throw - this shouldn't block the assignment process
      }
    }

    /**
     * Update mapping status for invoice tracking (instead of invoice 'PAID' status)
     */
    async function updateMappingStatus(invoices, status) {
      if (!window.supabase) {
        console.warn('⚠️ SESSION 88: Supabase not available for mapping status update');
        return;
      }
      
      const helper = window.helper || {};
      const caseId = helper.case_info?.supabase_case_id;
      
      if (!caseId) {
        console.warn('⚠️ SESSION 88: No case_id found for mapping status update');
        return;
      }
      
      const invoiceIds = invoices.map(i => i.id);
      
      // Update mapping status for each invoice
      for (const invoiceId of invoiceIds) {
        const { error } = await window.supabase
          .from('invoice_damage_center_mappings')
          .update({ 
            mapping_status: status,
            updated_at: new Date().toISOString()
          })
          .eq('invoice_id', invoiceId)
          .eq('case_id', caseId);
        
        if (error) {
          console.error(`❌ Error updating mapping status for invoice ${invoiceId}:`, error);
        } else {
          console.log(`✅ Updated mapping status to '${status}' for invoice ${invoiceId}`);
        }
      }
      
      console.log(`✅ SESSION 88: Updated mapping status for ${invoiceIds.length} invoices to '${status}'`);
    }

    /**
     * Convert mapping to part format (follows UI structure exactly)
     */
    function convertMappingToPart(mapping, invoice) {
      const helper = window.helper || {};
      
      return {
        row_uuid: window.generateUUID ? window.generateUUID() : 'part_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        case_id: helper.case_info?.supabase_case_id || mapping.case_id,
        plate: helper.case_info?.plate || '',
        damage_center_code: mapping.damage_center_id,
        part_name: mapping.mapped_data?.description || mapping.invoice_line?.description || '',
        description: mapping.mapped_data?.description || mapping.invoice_line?.description || '',
        pcode: mapping.mapped_data?.part_code || mapping.invoice_line?.metadata?.part_code || '',
        oem: mapping.mapped_data?.oem || mapping.invoice_line?.metadata?.oem || '',
        supplier_name: mapping.mapped_data?.supplier_name || invoice?.supplier_name || '',
        price_per_unit: mapping.mapped_data?.unit_price || mapping.invoice_line?.unit_price || 0,
        reduction_percentage: mapping.user_modifications?.reduction_percentage || 0,
        wear_percentage: mapping.user_modifications?.wear_percentage || 0,
        updated_price: mapping.mapped_data?.updated_price || mapping.mapped_data?.unit_price || mapping.invoice_line?.unit_price || 0,
        total_cost: mapping.mapped_data?.line_total || mapping.invoice_line?.line_total || 0,
        quantity: mapping.mapped_data?.quantity || mapping.invoice_line?.quantity || 1,
        source: 'invoice',
        _invoice_line_id: mapping.invoice_line_id,
        _invoice_id: mapping.invoice_id,
        make: helper.vehicle?.make || '',
        model: helper.vehicle?.model || '',
        year: helper.vehicle?.year || '',
        מחיר: mapping.mapped_data?.updated_price || mapping.mapped_data?.unit_price || mapping.invoice_line?.unit_price || 0,
        מיקום: 'ישראל',
        הערות: mapping.user_modifications?.notes || '',
        זמינות: 'זמין',
        metadata: mapping.original_field_data || {},
        updated_at: new Date().toISOString()
      };
    }

    /**
     * Convert mapping to work format (follows UI structure exactly)
     */
    function convertMappingToWork(mapping, invoice) {
      return {
        category: mapping.mapped_data?.description || mapping.invoice_line?.description || '',
        cost: mapping.mapped_data?.line_total || mapping.invoice_line?.line_total || 0,
        comments: mapping.user_modifications?.notes || '',
        added_at: new Date().toISOString(),
        source: 'invoice',
        _invoice_line_id: mapping.invoice_line_id,
        _invoice_id: mapping.invoice_id
      };
    }

    /**
     * Convert mapping to repair format (follows UI structure exactly)
     */
    function convertMappingToRepair(mapping, invoice) {
      return {
        name: mapping.mapped_data?.description || mapping.invoice_line?.description || '',
        cost: mapping.mapped_data?.line_total || mapping.invoice_line?.line_total || 0,
        description: mapping.user_modifications?.notes || '',
        added_at: new Date().toISOString(),
        source: 'invoice',
        _invoice_line_id: mapping.invoice_line_id,
        _invoice_id: mapping.invoice_id
      };
    }

    /**
     * Calculate differentials between wizard and invoice data
     */
    async function calculateInvoiceDifferentials(invoices) {
      try {
        console.log('📊 SESSION 88: Calculating invoice differentials...');
        
        const helper = window.helper || {};
        const differentials = [];
        
        // Get wizard data from helper.damage_centers for comparison
        const wizardCenters = helper.damage_centers || [];
        
        for (const invoice of invoices) {
          console.log(`📄 Processing invoice ${invoice.invoice_number}...`);
          
          for (const line of invoice.lines || []) {
            const centerCode = line.metadata?.damage_center_code;
            if (!centerCode) continue;
            
            // Find corresponding wizard center
            const wizardCenter = wizardCenters.find(c => 
              c.Id === centerCode || c.code === centerCode
            );
            
            if (!wizardCenter) {
              // Invoice line has no corresponding wizard center
              differentials.push({
                type: 'new_invoice_item',
                center_code: centerCode,
                invoice_id: invoice.id,
                invoice_number: invoice.invoice_number,
                line_id: line.id,
                description: line.description,
                category: line.metadata?.category,
                invoice_amount: line.line_total || 0,
                wizard_amount: 0,
                difference: line.line_total || 0,
                status: 'invoice_only'
              });
              continue;
            }
            
            // Compare invoice line with wizard center data
            const differential = await compareInvoiceLineWithWizardData(
              line, wizardCenter, invoice
            );
            
            if (differential) {
              differentials.push(differential);
            }
          }
        }
        
        // Check for wizard items not in invoices
        wizardCenters.forEach(center => {
          const centerInvoiceLines = [];
          invoices.forEach(invoice => {
            invoice.lines?.forEach(line => {
              if (line.metadata?.damage_center_code === center.Id || 
                  line.metadata?.damage_center_code === center.code) {
                centerInvoiceLines.push(line);
              }
            });
          });
          
          if (centerInvoiceLines.length === 0) {
            // Wizard center has no corresponding invoice lines
            const wizardTotal = calculateWizardCenterTotal(center);
            if (wizardTotal > 0) {
              differentials.push({
                type: 'wizard_only_center',
                center_code: center.Id || center.code,
                center_description: center.name || center.description,
                invoice_amount: 0,
                wizard_amount: wizardTotal,
                difference: -wizardTotal,
                status: 'wizard_only'
              });
            }
          }
        });
        
        console.log(`📊 SESSION 88: Found ${differentials.length} differentials`);
        return differentials;
        
      } catch (error) {
        console.error('❌ SESSION 88: Error calculating differentials:', error);
        return [];
      }
    }

    /**
     * Compare invoice line with wizard center data
     */
    async function compareInvoiceLineWithWizardData(line, wizardCenter, invoice) {
      try {
        const lineCategory = line.metadata?.category;
        let wizardAmount = 0;
        let comparison = null;
        
        // Calculate wizard amount based on category
        switch (lineCategory) {
          case 'part':
            wizardAmount = calculateWizardPartsTotal(wizardCenter);
            comparison = 'parts';
            break;
          case 'work':
            wizardAmount = calculateWizardWorksTotal(wizardCenter);
            comparison = 'works';
            break;
          case 'repair':
            wizardAmount = calculateWizardRepairsTotal(wizardCenter);
            comparison = 'repairs';
            break;
          default:
            // Unknown category - treat as general
            wizardAmount = calculateWizardCenterTotal(wizardCenter);
            comparison = 'total';
        }
        
        const invoiceAmount = line.line_total || 0;
        const difference = invoiceAmount - wizardAmount;
        
        // Only create differential if there's a significant difference (> 1 ₪)
        if (Math.abs(difference) > 1) {
          return {
            type: 'amount_difference',
            center_code: wizardCenter.Id || wizardCenter.code,
            center_description: wizardCenter.name || wizardCenter.description,
            invoice_id: invoice.id,
            invoice_number: invoice.invoice_number,
            line_id: line.id,
            description: line.description,
            category: lineCategory,
            comparison_type: comparison,
            invoice_amount: invoiceAmount,
            wizard_amount: wizardAmount,
            difference: difference,
            status: difference > 0 ? 'invoice_higher' : 'wizard_higher'
          };
        }
        
        return null;
        
      } catch (error) {
        console.error('❌ SESSION 88: Error comparing line with wizard:', error);
        return null;
      }
    }

    /**
     * Calculate total for wizard center parts
     */
    function calculateWizardPartsTotal(center) {
      try {
        if (!center.Parts?.parts_required) return 0;
        
        return center.Parts.parts_required.reduce((sum, part) => {
          return sum + (parseFloat(part.total_cost) || 0);
        }, 0);
      } catch (error) {
        console.error('❌ Error calculating wizard parts total:', error);
        return 0;
      }
    }

    /**
     * Calculate total for wizard center works
     */
    function calculateWizardWorksTotal(center) {
      try {
        if (!center.Works?.works_required) return 0;
        
        return center.Works.works_required.reduce((sum, work) => {
          return sum + (parseFloat(work.total_cost) || 0);
        }, 0);
      } catch (error) {
        console.error('❌ Error calculating wizard works total:', error);
        return 0;
      }
    }

    /**
     * Calculate total for wizard center repairs
     */
    function calculateWizardRepairsTotal(center) {
      try {
        if (!center.Repairs?.repairs_required) return 0;
        
        return center.Repairs.repairs_required.reduce((sum, repair) => {
          return sum + (parseFloat(repair.total_cost) || 0);
        }, 0);
      } catch (error) {
        console.error('❌ Error calculating wizard repairs total:', error);
        return 0;
      }
    }

    /**
     * Calculate total cost for entire wizard center
     */
    function calculateWizardCenterTotal(center) {
      try {
        const partsTotal = calculateWizardPartsTotal(center);
        const worksTotal = calculateWizardWorksTotal(center);
        const repairsTotal = calculateWizardRepairsTotal(center);
        
        return partsTotal + worksTotal + repairsTotal;
      } catch (error) {
        console.error('❌ Error calculating wizard center total:', error);
        return 0;
      }
    }

    /**
     * Display differentials in popup
     */
    function displayDifferentialsPopup(differentials) {
      try {
        console.log('📊 SESSION 88: Displaying differentials popup...');
        
        if (differentials.length === 0) {
          alert('לא נמצאו הפרשים בין נתוני האשף לחשבוניות');
          return;
        }
        
        // Create popup overlay
        const overlay = document.createElement('div');
        overlay.id = 'differentialsOverlay';
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.5);
          z-index: 10000;
          display: flex;
          justify-content: center;
          align-items: center;
        `;
        
        // Create popup content
        const popup = document.createElement('div');
        popup.style.cssText = `
          background: white;
          border-radius: 12px;
          padding: 20px;
          max-width: 90vw;
          max-height: 90vh;
          overflow-y: auto;
          box-shadow: 0 4px 20px rgba(0,0,0,0.3);
          direction: rtl;
          font-family: sans-serif;
        `;
        
        // Build popup HTML
        let popupHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #e0e0e0; padding-bottom: 15px;">
            <h2 style="margin: 0; color: #1565c0; font-size: 20px;">הפרשי חשבוניות מול אשף</h2>
            <button onclick="document.getElementById('differentialsOverlay').remove()" style="
              background: none;
              border: none;
              font-size: 24px;
              cursor: pointer;
              color: #666;
              padding: 0;
              width: 30px;
              height: 30px;
              display: flex;
              align-items: center;
              justify-content: center;
            ">×</button>
          </div>
          
          <div style="margin-bottom: 15px; font-size: 14px; color: #666;">
            נמצאו ${differentials.length} הפרשים בין נתוני האשף לחשבוניות
          </div>
          
          <div style="max-height: 60vh; overflow-y: auto;">
        `;
        
        // Add each differential
        differentials.forEach((diff, index) => {
          const statusColor = diff.status === 'invoice_higher' ? '#ff5722' : 
                             diff.status === 'wizard_higher' ? '#2196f3' : 
                             diff.status === 'invoice_only' ? '#ff9800' :
                             diff.status === 'wizard_only' ? '#607d8b' : '#666';
          
          const statusText = diff.status === 'invoice_higher' ? 'חשבונית גבוהה' :
                            diff.status === 'wizard_higher' ? 'אשף גבוה' :
                            diff.status === 'invoice_only' ? 'רק בחשבונית' :
                            diff.status === 'wizard_only' ? 'רק באשף' : 'הפרש';
          
          popupHTML += `
            <div style="
              border: 1px solid #e0e0e0;
              border-radius: 8px;
              padding: 15px;
              margin-bottom: 10px;
              background: #fafafa;
            ">
              <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                <div>
                  <div style="font-weight: 600; color: #333; margin-bottom: 5px;">
                    ${diff.description || diff.center_description || 'פריט לא מזוהה'}
                  </div>
                  <div style="font-size: 13px; color: #666;">
                    מוקד: ${diff.center_code} | 
                    ${diff.invoice_number ? `חשבונית: ${diff.invoice_number}` : ''} |
                    קטגוריה: ${diff.category || 'כללי'}
                  </div>
                </div>
                <div style="
                  background: ${statusColor};
                  color: white;
                  padding: 4px 8px;
                  border-radius: 4px;
                  font-size: 12px;
                  font-weight: 600;
                ">
                  ${statusText}
                </div>
              </div>
              
              <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; font-size: 14px;">
                <div style="text-align: center; padding: 8px; background: white; border-radius: 4px;">
                  <div style="color: #666; font-size: 12px; margin-bottom: 2px;">חשבונית</div>
                  <div style="font-weight: 600; color: #ff5722;">₪${diff.invoice_amount.toLocaleString()}</div>
                </div>
                <div style="text-align: center; padding: 8px; background: white; border-radius: 4px;">
                  <div style="color: #666; font-size: 12px; margin-bottom: 2px;">אשף</div>
                  <div style="font-weight: 600; color: #2196f3;">₪${diff.wizard_amount.toLocaleString()}</div>
                </div>
                <div style="text-align: center; padding: 8px; background: white; border-radius: 4px;">
                  <div style="color: #666; font-size: 12px; margin-bottom: 2px;">הפרש</div>
                  <div style="font-weight: 600; color: ${diff.difference > 0 ? '#ff5722' : '#2196f3'};">
                    ${diff.difference > 0 ? '+' : ''}₪${diff.difference.toLocaleString()}
                  </div>
                </div>
              </div>
            </div>
          `;
        });
        
        popupHTML += `
          </div>
          
          <div style="margin-top: 20px; text-align: center; border-top: 1px solid #e0e0e0; padding-top: 15px;">
            <button onclick="document.getElementById('differentialsOverlay').remove()" style="
              background: #6c757d;
              color: white;
              border: none;
              padding: 10px 20px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 14px;
            ">סגור</button>
          </div>
        `;
        
        popup.innerHTML = popupHTML;
        overlay.appendChild(popup);
        document.body.appendChild(overlay);
        
        console.log('✅ SESSION 88: Differentials popup displayed');
        
      } catch (error) {
        console.error('❌ SESSION 88: Error displaying differentials popup:', error);
        alert('שגיאה בהצגת הפרשים');
      }
    }

    // ============================================================================
    // SESSION 88: DEBUG AND TESTING FUNCTIONS
    // ============================================================================

    /**
     * Manual test function to force show banner with sample data
     */
    window.testInvoiceBanner = function() {
      const sampleInvoices = [
        {
          id: 'test-invoice-1',
          invoice_number: 'INV-001',
          supplier_name: 'ספק לדוגמה',
          total_amount: 5000,
          status: 'pending_assignment',
          lines: [
            { id: 'line1', description: 'חלק דוגמה', line_total: 2500, metadata: { category: 'part' } },
            { id: 'line2', description: 'עבודה דוגמה', line_total: 2500, metadata: { category: 'work' } }
          ]
        }
      ];
      
      console.log('🧪 SESSION 88: Testing banner with sample data');
      showInvoiceAssignmentBanner(sampleInvoices);
    };

    /**
     * Manual function to refresh invoice check
     */
    window.refreshInvoiceCheck = function() {
      console.log('🔄 SESSION 88: Manual refresh of invoice check');
      sessionStorage.removeItem('invoiceAssignmentDismissed');
      checkForAvailableInvoices();
    };

    /**
     * Debug function to show current helper invoice assignments
     */
    /**
     * Manual trigger for testing invoice banner
     */
    window.testInvoiceBanner = async function() {
      console.log('🧪 MANUAL TEST: Triggering invoice banner check...');
      console.log('🧪 MANUAL TEST: checkForAvailableInvoices function type:', typeof checkForAvailableInvoices);
      console.log('🧪 MANUAL TEST: Function available:', typeof checkForAvailableInvoices === 'function');
      console.log('🧪 MANUAL TEST: Function in window?', typeof window.checkForAvailableInvoices);
      console.log('🧪 MANUAL TEST: All functions in scope:', Object.getOwnPropertyNames(window).filter(name => name.includes('Invoice')));
      
      if (typeof checkForAvailableInvoices === 'function') {
        console.log('🧪 MANUAL TEST: Calling function...');
        await checkForAvailableInvoices();
      } else {
        console.error('❌ MANUAL TEST: checkForAvailableInvoices function not available!');
        console.log('🧪 Trying to call as window.checkForAvailableInvoices...');
        if (typeof window.checkForAvailableInvoices === 'function') {
          await window.checkForAvailableInvoices();
        }
      }
    };

    window.debugInvoiceAssignments = async function() {
      const helper = window.helper || {};
      const caseId = helper.case_info?.supabase_case_id;
      
      console.log('🔍 SESSION 88 DEBUG REPORT:');
      console.log('  Case ID:', caseId);
      console.log('  Plate:', helper.meta?.plate || helper.vehicle?.plate || helper.car_details?.plate);
      console.log('  helper.final_report?.invoice_assignments:', helper.final_report?.invoice_assignments);
      console.log('  helper.invoices:', helper.invoices);
      console.log('  Number of invoices in helper:', helper.invoices?.length || 0);
      
      if (helper.invoices && helper.invoices.length > 0) {
        helper.invoices.forEach((invoice, index) => {
          console.log(`  Helper Invoice ${index + 1}:`, {
            id: invoice.id,
            invoice_number: invoice.invoice_number,
            supplier_name: invoice.supplier_name,
            status: invoice.status
          });
        });
      }
      
      // Check Supabase data
      if (window.supabase && caseId) {
        try {
          console.log('🔍 Checking Supabase invoices table...');
          const { data: allInvoices, error: invoicesError } = await window.supabase
            .from('invoices')
            .select('id, invoice_number, supplier_name, status, case_id')
            .eq('case_id', caseId);
          
          if (invoicesError) {
            console.error('❌ Error querying invoices:', invoicesError);
          } else {
            console.log(`  Found ${allInvoices?.length || 0} invoices in Supabase for case_id ${caseId}:`, allInvoices);
          }
          
          console.log('🔍 Checking invoice_damage_center_mappings table...');
          const { data: mappings, error: mappingsError } = await window.supabase
            .from('invoice_damage_center_mappings')
            .select('invoice_id, mapping_status, case_id')
            .eq('case_id', caseId);
          
          if (mappingsError) {
            console.error('❌ Error querying mappings:', mappingsError);
          } else {
            console.log(`  Found ${mappings?.length || 0} mappings in Supabase for case_id ${caseId}:`, mappings);
          }
        } catch (error) {
          console.error('❌ Error in debug query:', error);
        }
      }
      
      return {
        invoice_assignments: helper.final_report?.invoice_assignments,
        invoices: helper.invoices,
        case_id: caseId,
        case_info: helper.case_info,
        plate: helper.meta?.plate || helper.vehicle?.plate || helper.car_details?.plate
      };
    };

    // Initialize on load - FIXED ORDER
    console.log('🔍 SCRIPT DEBUG: About to add DOMContentLoaded listener...');
    console.log('🔍 SCRIPT DEBUG: document.readyState:', document.readyState);
    
    // Test checkForAvailableInvoices function immediately
    console.log('🧪 IMMEDIATE TEST: checkForAvailableInvoices type:', typeof checkForAvailableInvoices);
    console.log('🧪 IMMEDIATE TEST: checkForAvailableInvoices exists:', typeof checkForAvailableInvoices === 'function');
    
    // Create immediate test function available globally
    window.immediateInvoiceTest = function() {
      console.log('🧪 MANUAL IMMEDIATE TEST: Starting...');
      console.log('🧪 checkForAvailableInvoices available:', typeof checkForAvailableInvoices === 'function');
      
      if (typeof checkForAvailableInvoices === 'function') {
        console.log('🧪 Calling checkForAvailableInvoices now...');
        checkForAvailableInvoices().catch(e => console.error('🧪 Error:', e));
      } else {
        console.error('🧪 Function not available yet');
      }
    };
    
    // Check if DOM is already loaded
    if (document.readyState === 'loading') {
      console.log('🔍 SCRIPT DEBUG: DOM still loading, adding event listener...');
      document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
      console.log('🔍 SCRIPT DEBUG: DOM already loaded, calling initializeApp immediately...');
      initializeApp();
    }
    
    // Since DOMContentLoaded isn't firing, use timer-based approach
    console.log('🔧 FALLBACK: Using timer-based approach since DOMContentLoaded may not fire...');
    
    // Try multiple approaches to ensure invoice check runs
    setTimeout(() => {
      console.log('🕐 TIMER 1000ms: Checking invoice system...');
      if (typeof checkForAvailableInvoices === 'function' && window.helper) {
        console.log('🚀 TIMER: Calling checkForAvailableInvoices...');
        checkForAvailableInvoices().catch(e => console.error('🔧 Timer error:', e));
      } else {
        console.log('❌ TIMER: Function or helper not ready yet');
      }
    }, 1000);
    
    setTimeout(() => {
      console.log('🕐 TIMER 3000ms: Secondary check for invoice system...');
      if (typeof checkForAvailableInvoices === 'function' && window.helper) {
        console.log('🚀 TIMER: Secondary call to checkForAvailableInvoices...');
        checkForAvailableInvoices().catch(e => console.error('🔧 Timer 2 error:', e));
      }
    }, 3000);
    
    // Also add a direct event listener for when DOM loads to test
    document.addEventListener('DOMContentLoaded', function() {
      console.log('🔥 DIRECT DOMContentLoaded FIRED! Now testing invoice functions...');
      console.log('🔥 checkForAvailableInvoices type after DOM loaded:', typeof checkForAvailableInvoices);
      
      // Try to call the function directly
      if (typeof checkForAvailableInvoices === 'function') {
        console.log('🔥 Calling checkForAvailableInvoices directly from DOMContentLoaded...');
        setTimeout(() => {
          checkForAvailableInvoices().catch(e => console.error('🔥 Error calling function:', e));
        }, 1000);
      }
    });
    
    async function initializeApp() {
      console.log('🚀 SCRIPT DEBUG: initializeApp called!');
      
      // Initialize window.helper from sessionStorage FIRST
      window.helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('🚀 Initialized window.helper from sessionStorage:', window.helper);
      
      await initializeDamageCenterIds();
      
      // Debug depreciation data locations
      console.log('🔍 DEBUG - Depreciation data locations:');
      console.log('  helper.depreciation:', window.helper.depreciation);
      console.log('  helper.final_report?.depreciation:', window.helper.final_report?.depreciation);
      console.log('  helper.expertise?.depreciation:', window.helper.expertise?.depreciation);
      
      // Clean up deprecated data structures
      cleanupDeprecatedData();
      
      // First clean up any duplicated damage center numbers in helper
      // cleanupDamageCenterNumbers(); // Commented out - leave existing data as is
      
      // First initialize the FinalReportCalculations object
      console.log('🚀 Initializing FinalReportCalculations object first');
      
      // Then load data from helper after FinalReportCalculations is available
      setTimeout(() => {
        try {
          console.log('🔍 DEBUG STEP 1: setTimeout started, calling loadDataFromHelper...');
          loadDataFromHelper();
        } catch (error) {
          console.error('❌ FATAL ERROR in loadDataFromHelper:', error);
        }
        console.log('🔍 DEBUG STEP 2: loadDataFromHelper completed, calling loadAttachmentsData...');
        loadAttachmentsData();
        console.log('🔍 DEBUG STEP 3: loadAttachmentsData completed, calling loadClaimsDataToUI...');
        loadClaimsDataToUI(); // Load claims data to UI fields
        console.log('🔍 DEBUG STEP 4: loadClaimsDataToUI completed, calling loadLegalText...');
        loadLegalText().catch(console.error);
        console.log('🔍 DEBUG STEP 5: loadLegalText completed, calling updateGlobalDepreciationCalculation...');
        updateGlobalDepreciationCalculation();
        console.log('🔍 DEBUG STEP 6: updateGlobalDepreciationCalculation completed');
        
        // Load additional notes field and summary fields IMMEDIATELY
        console.log('🔍 DEBUG STEP 7: calling loadAdditionalNotesField...');
        loadAdditionalNotesField();
        console.log('🔍 DEBUG STEP 8: getting helper data...');
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        console.log('🔍 DEBUG STEP 9: calling loadSummaryFieldsFromHelper...');
        loadSummaryFieldsFromHelper(helper);
        console.log('🔍 DEBUG STEP 10: loadSummaryFieldsFromHelper completed');
        
        // Initialize summary fields and manual inputs immediately
        console.log('🔍 DEBUG STEP 11: calling initializeSummaryFieldsFix...');
        initializeSummaryFieldsFix();
        console.log('🔍 DEBUG STEP 12: calling initializeHelperDataSafeguards...');
        initializeHelperDataSafeguards();
        console.log('🔍 DEBUG STEP 13: initializeHelperDataSafeguards completed');
        
        // Calculate totals after fields are populated
        setTimeout(() => {
          calculateSummaryTotals();
        }, 100);
        
        console.log('🔍 PRE-SESSION 88: About to set setTimeout for invoice check...');
        console.log('🔍 PRE-SESSION 88: checkForAvailableInvoices function exists:', typeof checkForAvailableInvoices === 'function');
        
        // Test immediate function availability
        try {
          if (typeof checkForAvailableInvoices === 'function') {
            console.log('✅ PRE-SESSION 88: Function available immediately');
          } else {
            console.log('❌ PRE-SESSION 88: Function NOT available immediately');
          }
        } catch (e) {
          console.error('❌ PRE-SESSION 88: Error testing function:', e);
        }
        
        // SESSION 88: Check for available invoices after data loads
        setTimeout(() => {
          console.log('🚀 SESSION 88 DEBUG: setTimeout function triggered!');
          console.log('🔍 SESSION 88: sessionStorage invoiceAssignmentDismissed:', sessionStorage.getItem('invoiceAssignmentDismissed'));
          console.log('🔍 SESSION 88: typeof checkForAvailableInvoices:', typeof checkForAvailableInvoices);
          console.log('🔍 SESSION 88: checkForAvailableInvoices function exists:', typeof checkForAvailableInvoices === 'function');
          
          if (!sessionStorage.getItem('invoiceAssignmentDismissed')) {
            console.log('🔍 SESSION 88: Checking for invoice assignments...');
            console.log('  helper.final_report?.invoice_assignments:', window.helper?.final_report?.invoice_assignments);
            console.log('🚀 SESSION 88: About to call checkForAvailableInvoices()...');
            checkForAvailableInvoices();
            console.log('✅ SESSION 88: checkForAvailableInvoices() call completed');
          } else {
            console.log('ℹ️ SESSION 88: Invoice assignment banner dismissed by user');
          }
        }, 200);
        
        // DO NOT initialize admin hub communication here - wait for helper.js to load first
        console.log('ℹ️ Waiting for helper.js to load before initializing admin hub communication...');
        
        // Wait for MathEngine to be ready before initializing VAT display
        if (typeof window.MathEngine !== 'undefined') {
          // MathEngine already loaded
          if (typeof window.initVatDisplay === 'function') {
            window.initVatDisplay();
          }
        } else {
          // Wait for MathEngine ready event
          window.addEventListener('mathEngineReady', function() {
            console.log('🎯 MathEngine ready, initializing VAT display...');
            if (typeof window.initVatDisplay === 'function') {
              window.initVatDisplay();
            }
          });
        }
        
        // Log that admin hub functions are now available
        console.log('🔧 Admin hub functions loaded. Try: verifyAdminHubFunctions() or testAdminHubConnection()');
        
        // Automatically verify functions are loaded (after MathEngine loads)
        setTimeout(() => {
          if (typeof window.verifyAdminHubFunctions === 'function') {
            window.verifyAdminHubFunctions();
          }
        }, 200);
      }, 100);
      
      // Initialize adjustment system with event listeners
      setTimeout(() => {
        console.log('🚀 Initializing adjustment system on page load');
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // DISABLED: Legacy loadAllAdjustments that overrides new configuration
        // if (helper.levi?.custom_adjustments || helper.levi?.adjustments) {
        //   loadAllAdjustments(helper);
        // }
        console.log('⚠️ Legacy loadAllAdjustments disabled - using new loadTotalValueSectionAdjustments instead');
        
        // Ensure event listeners are attached
        addAdjustmentEventListeners();
        
        // Trigger initial auto-calculation for existing adjustments
        if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments.length > 0) {
          console.log('🔄 Running initial auto-calculation for existing adjustments');
          helper.levi.custom_adjustments.forEach((adjustment, index) => {
            if (adjustment.percentage && adjustment.percentage !== 0) {
              calculateAdjustmentValue('custom', index, adjustment.percentage);
            }
          });
        }
      }, 400);
      
      // Trigger initial calculation after page loads
      setTimeout(triggerGlobalDepreciationCalc, 500);
      
      // Add listener to garage days field
      const garageDaysField = document.getElementById('garageDays');
      if (garageDaysField) {
        garageDaysField.addEventListener('input', loadLegalText);
      }
      
      // Add listener to payment method field
      const paymentMethodField = document.getElementById('paymentMethod');
      if (paymentMethodField) {
        paymentMethodField.addEventListener('input', loadLegalText);
      }
      
      // Add listener to legal text textarea to save changes
      const legalTextArea = document.getElementById('legal-text-content');
      if (legalTextArea) {
        // Function to save legal text to helper
        function saveLegalTextToHelper() {
          const helper = window.helper || {};
          
          // Initialize final_report object if it doesn't exist
          if (!helper.final_report) {
            helper.final_report = {};
          }
          helper.final_report.legal_text = legalTextArea.value;
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          // ✅ BIDIRECTIONAL INTEGRATION: Update builder state in real-time
          updateBuilderCurrentState('final_report.legal_text', legalTextArea.value);
        }
        
        // Save on input
        legalTextArea.addEventListener('input', saveLegalTextToHelper);
        
        // Save on change (when user finishes editing)
        legalTextArea.addEventListener('change', saveLegalTextToHelper);
        
        // Initial save if there's already content (after page load)
        setTimeout(() => {
          if (legalTextArea.value && legalTextArea.value.trim() !== '') {
            saveLegalTextToHelper();
            console.log('✅ Initial legal text saved to helper:', legalTextArea.value.substring(0, 100) + '...');
          }
        }, 1000);
      }
      
      // Add listener to additional notes textarea to save comments
      const additionalNotesArea = document.getElementById('additional-notes');
      if (additionalNotesArea) {
        // Function to save comments to helper
        function saveCommentsToHelper() {
          const helper = window.helper || {};
          
          // Initialize final_report object if it doesn't exist
          if (!helper.final_report) {
            helper.final_report = {};
          }
          // Save to both 'comments' and 'notes' for consistency
          helper.final_report.comments = additionalNotesArea.value;
          helper.final_report.notes = additionalNotesArea.value;
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          // ✅ BIDIRECTIONAL INTEGRATION: Update builder state in real-time
          updateBuilderCurrentState('final_report.comments', additionalNotesArea.value);
          updateBuilderCurrentState('final_report.notes', additionalNotesArea.value);
        }
        
        // Save on input
        additionalNotesArea.addEventListener('input', saveCommentsToHelper);
        
        // Save on change (when user finishes editing)
        additionalNotesArea.addEventListener('change', saveCommentsToHelper);
        
        // Initial save if there's already content (after page load)
        setTimeout(() => {
          if (additionalNotesArea.value && additionalNotesArea.value.trim() !== '') {
            saveCommentsToHelper();
            console.log('✅ Initial comments saved to helper:', additionalNotesArea.value.substring(0, 50) + '...');
          }
        }, 1000);
      }
      
      // Capture all summary fields to helper.final_report.summary
      function captureSummaryFields() {
        const helper = window.helper || {};
        
        // Initialize final_report object if it doesn't exist
        if (!helper.final_report) {
          helper.final_report = {};
        }
        if (!helper.final_report.summary) {
          helper.final_report.summary = {};
        }
        
        // Get all summary input fields from all summary blocks
        const summaryInputs = document.querySelectorAll('.summary-block input[type="text"], .summary-block input[type="date"], .summary-block input[type="number"]');
        
        summaryInputs.forEach(input => {
          if (input.id && input.value) {
            helper.final_report.summary[input.id] = input.value;
          }
        });
        
        // Save to sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('✅ Summary fields captured:', helper.final_report.summary);
      }
      
      // Add event listeners to all summary fields (EXCLUDING calculated fields that get overridden)
      function addSummaryFieldListeners() {
        const summaryInputs = document.querySelectorAll('.summary-block input[type="text"]:not(#afterSaleDamage):not(#afterSaleTotal):not(#afterSaleLegal), .summary-block input[type="date"], .summary-block input[type="number"]');
        
        summaryInputs.forEach(input => {
          // Save on input
          input.addEventListener('input', captureSummaryFields);
          // Save on change
          input.addEventListener('change', captureSummaryFields);
        });
        
        console.log(`✅ Added listeners to ${summaryInputs.length} summary fields`);
      }
      
      // Initialize summary field listeners
      setTimeout(() => {
        addSummaryFieldListeners();
        // Capture initial values
        captureSummaryFields();
      }, 1000);
      
      // AUTO-SAVE ATTACHMENTS ON INPUT
      const attachmentsArea = document.getElementById('attachments-content');
      if (attachmentsArea) {
        attachmentsArea.addEventListener('input', function() {
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          if (!helper.final_report) helper.final_report = {};
          helper.final_report.attachments = this.value;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          // ✅ BIDIRECTIONAL INTEGRATION: Update builder state in real-time
          updateBuilderCurrentState('final_report.attachments', this.value);
        });
      }
      
      // Combined report type change handler
      const reportTypeSelect = document.getElementById('reportType');
      if (reportTypeSelect) {
        reportTypeSelect.addEventListener('change', function() {
          const selectedType = this.value;
          
          // Save dropdown selection to helper AND sessionStorage for persistence
          const helper = window.helper || {};
          if (!helper.final_report) helper.final_report = {};
          helper.final_report.dropdown_type = selectedType;
          window.helper = helper;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          sessionStorage.setItem('selectedReportVariant', selectedType);
          console.log('💾 Saved dropdown report type to helper and sessionStorage:', selectedType);
          
          updateReportType();
          loadLegalText().catch(console.error);
          
          // Re-initialize summary field listeners after report type changes
          setTimeout(() => {
            addSummaryFieldListeners();
            captureSummaryFields();
          }, 500); // Wait for summary blocks to update
        });
      }
    } // End of initializeApp function

    // PARTS SEARCH FUNCTIONALITY
    function showPartSuggestions(input, centerIndex, partIndex) {
      const query = input.value.toLowerCase().trim();
      const suggestionsDiv = input.nextElementSibling;
      
      if (query.length < 2) {
        suggestionsDiv.style.display = 'none';
        return;
      }
      
      // Get stored search results from helper
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const storedResults = helper.parts_search?.results || [];
      
      // Filter results based on query
      const filteredResults = storedResults.filter(part => 
        part.name?.toLowerCase().includes(query) || 
        part.desc?.toLowerCase().includes(query)
      );
      
      if (filteredResults.length > 0) {
        let suggestionsHTML = '';
        filteredResults.slice(0, 10).forEach(part => {
          suggestionsHTML += `
            <div onclick="selectPartSuggestion('${part.name}', '${part.desc}', '${part.price || 0}', '${part.source || ''}', ${centerIndex}, ${partIndex})" 
                 style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 13px;"
                 onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='white'">
              <strong>${part.name}</strong><br>
              <small style="color: #666;">${part.desc || ''} ${part.price ? '- ₪' + part.price : ''}</small>
            </div>
          `;
        });
        
        // Add option to search for new parts
        suggestionsHTML += `
          <div onclick="openPartsSearchModule('${query}', ${centerIndex}, ${partIndex})" 
               style="padding: 8px; cursor: pointer; background: #e3f2fd; border-top: 1px solid #ddd; font-size: 13px; color: #1976d2;"
               onmouseover="this.style.background='#bbdefb'" onmouseout="this.style.background='#e3f2fd'">
            🔍 חפש חלקים חדשים עבור: "${query}"
          </div>
        `;
        
        suggestionsDiv.innerHTML = suggestionsHTML;
        suggestionsDiv.style.display = 'block';
      } else {
        // Show only search option if no stored results
        suggestionsDiv.innerHTML = `
          <div onclick="openPartsSearchModule('${query}', ${centerIndex}, ${partIndex})" 
               style="padding: 8px; cursor: pointer; background: #e3f2fd; font-size: 13px; color: #1976d2;"
               onmouseover="this.style.background='#bbdefb'" onmouseout="this.style.background='#e3f2fd'">
            🔍 חפש חלקים עבור: "${query}"
          </div>
        `;
        suggestionsDiv.style.display = 'block';
      }
    }

    // SELECT PART FROM SUGGESTIONS
    function selectPartSuggestion(name, desc, price, source, centerIndex, partIndex) {
      const partRow = document.querySelector(`.part-row[data-center="${centerIndex}"][data-part="${partIndex}"]`);
      if (partRow) {
        partRow.querySelector('.part-name').value = name;
        const descField = partRow.querySelector('.part-description');
        if (descField) descField.value = desc;
        
        // SESSION 46 FIX: Set price_per_unit instead of old part-price
        const priceField = partRow.querySelector('.part-price-per-unit');
        if (priceField) {
          priceField.value = price;
          // Trigger calculation with new price
          calculatePartPriceFields(partRow);
        }
        
        const sourceField = partRow.querySelector('.part-source');
        if (sourceField) sourceField.value = source;
        
        // Hide suggestions
        const suggestions = partRow.querySelector('.part-suggestions');
        if (suggestions) suggestions.style.display = 'none';
        
        // Trigger save and recalculation
        saveDamageCenterChanges();
      }
    }

    // OPEN PARTS SEARCH MODULE
    function openPartsSearchModule(query, centerIndex, partIndex) {
      // Store the target location for the search result
      sessionStorage.setItem('partSearchTarget', JSON.stringify({
        centerIndex,
        partIndex,
        query
      }));
      
      // Open independent parts search module
      const partsSearchUrl = 'parts search.html?query=' + encodeURIComponent(query);
      window.open(partsSearchUrl, 'partsSearch', 'width=1000,height=700,scrollbars=yes,resizable=yes');
    }

    // CALCULATE PART PRICE FIELDS - SESSION 46: Auto-calculate updated price and totals (ROUNDED)
    function calculatePartPriceFields(partRow) {
      if (!partRow) return;
      
      // Get input values
      const pricePerUnit = parseFloat(partRow.querySelector('.part-price-per-unit')?.value) || 0;
      const reduction = parseFloat(partRow.querySelector('.part-reduction')?.value) || 0;
      const wear = parseFloat(partRow.querySelector('.part-wear')?.value) || 0;
      const quantity = parseInt(partRow.querySelector('.part-quantity')?.value) || 1;
      
      // Step 1: Apply reduction (discount)
      const afterReduction = pricePerUnit * (1 - reduction / 100);
      
      // Step 2: Apply wear
      const updatedPrice = afterReduction * (1 - wear / 100);
      
      // Step 3: Calculate total cost - SESSION 46: ROUND all values (no decimals)
      const totalCost = Math.round(updatedPrice * quantity);
      
      // Update hidden updated-price field
      const updatedPriceField = partRow.querySelector('.part-updated-price');
      if (updatedPriceField) {
        updatedPriceField.value = Math.round(updatedPrice);
      }
      
      // Update visible total cost field
      const totalCostField = partRow.querySelector('.part-total-cost');
      if (totalCostField) {
        totalCostField.value = `₪${totalCost.toLocaleString()}`;
      }
      
      // Recalculate center totals
      const centerBlock = partRow.closest('.damage-center-block');
      if (centerBlock) {
        recalculateCenterCosts(centerBlock);
      }
      
      // Auto-save changes
      autoSaveDamageCenterChanges(partRow);
    }
    
    // SESSION 50: Auto-save damage center part changes to helper AND Supabase (like floating screen)
    async function autoSaveDamageCenterChanges(partRow) {
      if (!partRow) return;
      
      try {
        const centerIndex = parseInt(partRow.dataset.center);
        const partIndex = parseInt(partRow.dataset.part);
        
        // Get updated values from form
        // ✅ SESSION 54 FIX: Use correct class name .part-catalog-code-visible (not .part-code)
        const pcode = partRow.querySelector('.part-catalog-code-visible')?.value || '';
        const partName = partRow.querySelector('.part-name')?.value || '';
        const quantity = parseInt(partRow.querySelector('.part-quantity')?.value) || 1;
        const pricePerUnit = parseFloat(partRow.querySelector('.part-price-per-unit')?.value) || 0;
        const reduction = parseFloat(partRow.querySelector('.part-reduction')?.value) || 0;
        const wear = parseFloat(partRow.querySelector('.part-wear')?.value) || 0;
        const updatedPrice = parseFloat(partRow.querySelector('.part-updated-price')?.value) || 0;
        const totalCostText = partRow.querySelector('.part-total-cost')?.value || '₪0';
        const totalCost = parseFloat(totalCostText.replace(/[₪,]/g, '')) || 0;
        
        // Update helper.centers[].Parts.parts_required[]
        if (window.helper?.centers?.[centerIndex]?.Parts?.parts_required?.[partIndex]) {
          const part = window.helper.centers[centerIndex].Parts.parts_required[partIndex];
          
          part.pcode = pcode;
          part.oem = pcode;
          part.catalog_code = pcode;
          part.part_name = partName;
          part.name = partName;
          part.quantity = quantity;
          part.qty = quantity;
          part.price_per_unit = pricePerUnit;
          part.price = pricePerUnit;
          part.cost = pricePerUnit;
          part.expected_cost = pricePerUnit;
          part.reduction_percentage = reduction;
          part.reduction = reduction;
          part.wear_percentage = wear;
          part.wear = wear;
          part.updated_price = updatedPrice;
          part.total_cost = totalCost;
        }
        
        // ✅ SESSION 54 FIX: Upsert to Supabase (INSERT new parts, UPDATE existing)
        if (window.supabase && window.helper?.meta?.plate) {
          const plate = window.helper.meta.plate;
          const normalizedPlate = plate.replace(/-/g, '');
          
          const centerCard = partRow.closest('.editable-damage-card');
          const centerIdFromDOM = centerCard?.dataset?.centerId || '';
          
          const center = window.helper?.centers?.[centerIndex] || {};
          const centerIdFromHelper = center.Id || center.id || center.code || '';
          
          const centerId = centerIdFromDOM || centerIdFromHelper;
          
          console.log(`🔍 SESSION 56 FIX: Saving part to center ${centerIndex}:`, {
            centerIdFromDOM,
            centerIdFromHelper,
            finalCenterId: centerId,
            centerObject: center
          });
          
          if (!centerId) {
            console.error('❌ SESSION 56: Cannot save part - no damage center ID found in DOM or helper');
            console.error('  DOM data-center-id:', centerIdFromDOM);
            console.error('  Helper center:', center);
            return;
          }
          
          // ✅ SESSION 60 EMERGENCY FIX 1: Don't use || {} - check if part actually exists
          const part = window.helper.centers[centerIndex]?.Parts?.parts_required?.[partIndex];
          
          if (!part) {
            console.error('❌ SESSION 60: Part not found in helper.centers at index', centerIndex, partIndex);
            console.error('  Available parts:', window.helper.centers[centerIndex]?.Parts?.parts_required);
            return; // Exit early - can't save part that doesn't exist
          }
          
          // Get case UUID from Supabase cases table (not filing_case_id string)
          let caseUuid = part.case_id || ''; // Preserve if already exists
          if (!caseUuid) {
            try {
              const { data: caseData } = await window.supabase
                .from('cases')
                .select('id')
                .eq('plate', normalizedPlate)
                .order('created_at', { ascending: false })
                .limit(1)
                .single();
              caseUuid = caseData?.id || '';
            } catch (err) {
              console.warn('Could not lookup case UUID, skipping case_id field');
            }
          }
          
          // ✅ SESSION 60 FINAL FIX: Simple - preserve existing or generate new
          let rowUuid = part.row_uuid;
          
          if (!rowUuid) {
            rowUuid = crypto.randomUUID();
            part.row_uuid = rowUuid;
            window.helper.centers[centerIndex].Parts.parts_required[partIndex].row_uuid = rowUuid;
            console.log('✅ SESSION 60: Generated UUID for new/existing part without one:', partName, rowUuid);
          }
          
          const supabaseData = {
            // ✅ SESSION 54 FIX: row_uuid is the PRIMARY KEY for upsert
            row_uuid: rowUuid || part.row_uuid,
            
            // Required fields
            plate: normalizedPlate,
            damage_center_code: centerId,
            part_name: partName,
            
            // All other fields (only columns that exist in Supabase schema)
            pcode: pcode,
            oem: pcode,
            quantity: quantity,
            price_per_unit: pricePerUnit,
            price: pricePerUnit,
            reduction_percentage: reduction,
            wear_percentage: wear,
            updated_price: updatedPrice,
            total_cost: totalCost,
            
            // Preserve existing fields
            description: part.description || part.desc || '',
            source: part.source || part.מקור || '',
            case_id: caseUuid || null,
            
            // Vehicle context
            make: window.helper?.vehicle?.manufacturer || '',
            model: window.helper?.vehicle?.model || '',
            year: window.helper?.vehicle?.year || '',
            
            // Timestamp
            updated_at: new Date().toISOString()
          };
          
          // ❌ SESSION 60 TASK 3: REMOVED - Don't update helper.row_uuid here (already done above if needed)
          // This code block was causing duplicate UUIDs by updating helper after Supabase save
          
          // Use upsert with row_uuid as conflict key (as per Session 39 docs)
          const { error } = await window.supabase
            .from('parts_required')
            .upsert(supabaseData, { 
              onConflict: 'row_uuid',
              ignoreDuplicates: false 
            });
          
          if (error) {
            console.error('❌ Supabase upsert error:', error);
          } else {
            console.log('✅ Part upserted to Supabase:', partName, '(center:', centerId, ')');
          }
        }
        
      } catch (error) {
        console.error('❌ Auto-save error:', error);
      }
    }
    
    // RECALCULATE CENTER COSTS - SESSION: Updated to use new total_cost field
    function recalculateCenterCosts(centerBlock) {
      if (!centerBlock) return;
      
      const centerIndex = centerBlock.dataset.center;
      
      // Calculate parts total from total-cost fields
      let partsCosts = 0;
      centerBlock.querySelectorAll('.part-row').forEach(row => {
        const totalCostText = row.querySelector('.part-total-cost')?.value || '₪0';
        const cost = parseFloat(totalCostText.replace(/[₪,]/g, '')) || 0;
        partsCosts += cost;
      });
      
      // Calculate works total
      let workCosts = 0;
      centerBlock.querySelectorAll('.work-row').forEach(row => {
        const cost = parseFloat(row.querySelector('.work-cost')?.value) || 0;
        workCosts += cost;
      });
      
      // Calculate repairs total
      let repairsCosts = 0;
      centerBlock.querySelectorAll('.repair-row').forEach(row => {
        const cost = parseFloat(row.querySelector('.repair-cost')?.value) || 0;
        repairsCosts += cost;
      });
      
      // Calculate totals
      const subtotal = partsCosts + workCosts + repairsCosts;
      const vatRate = 17; // Standard VAT rate
      const totalWithVAT = subtotal * (1 + vatRate / 100);
      
      // Update display fields
      const partsDisplay = centerBlock.querySelector('.parts-costs-display');
      const worksDisplay = centerBlock.querySelector('.work-costs-display');
      const repairsDisplay = centerBlock.querySelector('.repairs-costs-display');
      const totalDisplay = centerBlock.querySelector('.total-with-vat-display');
      
      if (partsDisplay) partsDisplay.textContent = `₪${Math.round(partsCosts).toLocaleString()}`;
      if (worksDisplay) worksDisplay.textContent = `₪${Math.round(workCosts).toLocaleString()}`;
      if (repairsDisplay) repairsDisplay.textContent = `₪${Math.round(repairsCosts).toLocaleString()}`;
      if (totalDisplay) totalDisplay.textContent = `₪${Math.round(totalWithVAT).toLocaleString()}`;
    }

    // ADD/REMOVE ROW FUNCTIONS
    function addPartRow(centerIndex) {
      const partsList = document.querySelector(`.parts-list[data-center="${centerIndex}"]`);
      const newPartIndex = partsList.children.length;
      const newPartHTML = createEditablePartRow({}, centerIndex, newPartIndex);
      partsList.insertAdjacentHTML('beforeend', newPartHTML);
      
      // Add event listeners to new row
      setTimeout(addDamageCenterEventListeners, 50);
    }

    function addWorkRow(centerIndex) {
      const worksList = document.querySelector(`.works-list[data-center="${centerIndex}"]`);
      const newWorkIndex = worksList.children.length;
      const newWorkHTML = createEditableWorkRow('', centerIndex, newWorkIndex);
      worksList.insertAdjacentHTML('beforeend', newWorkHTML);
      
      // Add event listeners to new row
      setTimeout(addDamageCenterEventListeners, 50);
    }

    function addRepairRow(centerIndex) {
      const repairsList = document.querySelector(`.repairs-list[data-center="${centerIndex}"]`);
      const newRepairIndex = repairsList.children.length;
      const newRepairHTML = createEditableRepairRow('', centerIndex, newRepairIndex);
      repairsList.insertAdjacentHTML('beforeend', newRepairHTML);
      
      // Add event listeners to new row
      setTimeout(addDamageCenterEventListeners, 50);
    }

    async function removePartRow(centerIndex, partIndex) {
      const partRow = document.querySelector(`.part-row[data-center="${centerIndex}"][data-part="${partIndex}"]`);
      if (!partRow) return;
      
      // SESSION 56 FIX: Delete from Supabase BEFORE removing from DOM
      const helper = window.helper || {};
      const part = helper.centers?.[centerIndex]?.Parts?.parts_required?.[partIndex];
      
      if (part && part.row_uuid && window.supabase) {
        console.log(`🗑️ SESSION 56: Deleting part from Supabase, row_uuid: ${part.row_uuid}`);
        
        try {
          const { error } = await window.supabase
            .from('parts_required')
            .delete()
            .eq('row_uuid', part.row_uuid);
          
          if (error) {
            console.error('❌ SESSION 56: Error deleting part from Supabase:', error);
          } else {
            console.log('✅ SESSION 56: Part deleted from Supabase successfully');
          }
        } catch (err) {
          console.error('❌ SESSION 56: Exception deleting part:', err);
        }
      } else {
        console.warn('⚠️ SESSION 56: No row_uuid found for part, skipping Supabase delete');
      }
      
      // Remove from DOM
      partRow.remove();
      
      // Update helper
      saveDamageCenterChanges();
    }

    function removeWorkRow(centerIndex, workIndex) {
      const workRow = document.querySelector(`.work-row[data-center="${centerIndex}"][data-work="${workIndex}"]`);
      if (workRow) {
        workRow.remove();
        saveDamageCenterChanges();
      }
    }

    function removeRepairRow(centerIndex, repairIndex) {
      const repairRow = document.querySelector(`.repair-row[data-center="${centerIndex}"][data-repair="${repairIndex}"]`);
      if (repairRow) {
        repairRow.remove();
        saveDamageCenterChanges();
      }
    }

    function removeDamageCenter(centerIndex) {
      if (confirm('האם אתה בטוח שברצונך למחוק את מוקד הנזק הזה?')) {
        const centerCard = document.querySelector(`.editable-damage-card[data-center-index="${centerIndex}"]`);
        if (centerCard) {
          centerCard.remove();
          saveDamageCenterChanges();
        }
      }
    }

    function addNewDamageCenter() {
      const container = document.getElementById('editableDamageCenters');
      if (!container) {
        // If no container exists, create it
        document.getElementById('damageCentersContent').innerHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters"></div>';
      }
      
      const newIndex = document.querySelectorAll('.editable-damage-card').length;
      const newBlock = {
        damage_center_name: `מוקד נזק ${newIndex + 1}`,
        parts: [],
        works: [],
        repairs: [],
        work_cost: 0,
        parts_cost: 0
      };
      
      const newCardHTML = createEditableDamageCenterCard(newBlock, newIndex);
      document.getElementById('editableDamageCenters').insertAdjacentHTML('beforeend', newCardHTML);
      
      setTimeout(addDamageCenterEventListeners, 100);
    }

    // 🔍 SESSION 61: Save guard variables for final-report
    let isSavingDamageCentersFinalReport = false;
    let lastSaveTimeFinalReport = 0;
    
    // SAVE DAMAGE CENTER CHANGES TO HELPER
    function saveDamageCenterChanges() {
      // 🔍 SESSION 61 FIX: Prevent duplicate saves within 2 seconds
      const now = Date.now();
      if (isSavingDamageCentersFinalReport) {
        console.warn('⚠️ SESSION 61 FINAL-REPORT: Save already in progress, skipping');
        return false;
      }
      if (now - lastSaveTimeFinalReport < 2000) {
        console.warn(`⚠️ SESSION 61 FINAL-REPORT: Last save was ${Math.round((now - lastSaveTimeFinalReport) / 1000)}s ago, skipping (2s debounce)`);
        return false;
      }
      
      isSavingDamageCentersFinalReport = true;
      lastSaveTimeFinalReport = now;
      console.log('✅ SESSION 61 FINAL-REPORT: Starting save operation');
      
      try {
        // 🔧 2-WAY DATA FLOW: Save back to helper.centers (the source of truth)
        const helper = window.helper || {};
        
        // Initialize centers if not exists
        if (!helper.centers) helper.centers = [];
        
        // Clean up any redundant damage_assessment.centers (duplicate section)
        if (helper.damage_assessment?.centers) {
          console.log('🧹 Cleaning up redundant damage_assessment.centers');
          delete helper.damage_assessment.centers;
          if (Object.keys(helper.damage_assessment).length === 0) {
            delete helper.damage_assessment;
          }
        }
        
        // Also maintain expertise.damage_blocks for backward compatibility
        if (!helper.expertise) helper.expertise = {};
        if (!helper.expertise.damage_blocks) helper.expertise.damage_blocks = [];
        
        // Clear both structures
        helper.centers = [];
        helper.expertise.damage_blocks = [];
        
        // Store damage center names for depreciation section
        const damageCenterNames = [];
        
        // Collect data from all damage center cards
        document.querySelectorAll('.editable-damage-card').forEach((card, index) => {
          // Extract just the number from the damage center number field
          const centerNumberField = card.querySelector('.damage-center-number').value;
          // Extract the number (e.g., "מוקד נזק מס' 1" -> "1")
          const numberMatch = centerNumberField.match(/\d+$/);
          const centerNumber = numberMatch ? numberMatch[0] : String(index + 1);
          const centerLocation = card.querySelector('.damage-center-location').value;
          const centerDescription = card.querySelector('.damage-center-description').value;
          const centerRepairNature = card.querySelector('.damage-center-repair-nature')?.value || '';
          
          // SESSION 54 FIX: Get existing center data once for reuse
          const existingCenter = helper.centers ? helper.centers[index] : null;
          
          // Collect parts - SESSION 54 FIX: PRESERVE existing data like repairs
          const parts = [];
          const existingParts = existingCenter?.Parts?.parts_required || [];
          
          card.querySelectorAll('.part-row').forEach((row, partIndex) => {
            const name = row.querySelector('.part-name')?.value || '';
            const catalogCode = row.querySelector('.part-catalog-code-visible')?.value || '';
            const descField = row.querySelector('.part-description');
            const desc = descField ? descField.value : '';
            
            const pricePerUnit = parseFloat(row.querySelector('.part-price-per-unit')?.value) || 0;
            const reduction = parseFloat(row.querySelector('.part-reduction')?.value) || 0;
            const wear = parseFloat(row.querySelector('.part-wear')?.value) || 0;
            const quantity = parseInt(row.querySelector('.part-quantity')?.value) || 1;
            
            const totalCostField = row.querySelector('.part-total-cost');
            const totalCostText = totalCostField ? totalCostField.value : '₪0';
            const totalCost = Math.round(parseFloat(totalCostText.replace(/[₪,]/g, '')) || 0);
            
            // SESSION 61: Don't read source from UI (field doesn't exist) - preserve from existing data instead
            // const source = row.querySelector('.part-source')?.value || '';  // REMOVED
            
            if (name.trim()) {
              // 🔍 SESSION 61 FIX: Get UUID from DOM and validate
              const rowUuidFromDOM = row.getAttribute('data-row-uuid') || row.dataset.rowUuid;
              
              console.log(`🔍 SESSION 61 FINAL-REPORT: Processing part "${name}" (index ${partIndex})`);
              console.log(`  rowUuidFromDOM: "${rowUuidFromDOM}" (empty: ${!rowUuidFromDOM || rowUuidFromDOM === ''})`);
              
              // CRITICAL: Skip parts without UUID
              if (!rowUuidFromDOM || rowUuidFromDOM === '') {
                console.error(`❌ SESSION 61 FINAL-REPORT: SKIPPING part "${name}" - no UUID in DOM!`);
                return;
              }
              
              // Match by UUID (not index!)
              const existingPart = existingParts.find(p => p.row_uuid === rowUuidFromDOM) || {};
              
              if (existingPart && existingPart.row_uuid) {
                console.log(`  ✅ Matched existing part by UUID: ${existingPart.row_uuid}`);
              } else {
                console.warn(`  ⚠️ UUID "${rowUuidFromDOM}" from DOM but NO matching part - this is a NEW part`);
              }
              
              // ✅ SESSION 54 FIX: Merge existing data with new data (preserve all fields)
              // 🔍 SESSION 61 CRITICAL FIX: Use UUID from DOM (already validated above)
              const partObject = {
                ...existingPart,                    // Preserve ALL existing fields first
                row_uuid: rowUuidFromDOM,           // ✅ SESSION 61: Use UUID from DOM
                name: name,                         // Update from UI
                part_name: name,
                catalog_code: catalogCode,          // Update from UI
                pcode: catalogCode,
                oem: catalogCode,
                desc: desc,                         // Update from UI
                description: desc,
                price_per_unit: pricePerUnit,       // Update from UI
                reduction_percentage: reduction,    // Update from UI
                reduction: reduction,
                wear_percentage: wear,              // Update from UI
                wear: wear,
                quantity: quantity,                 // Update from UI
                qty: quantity,
                total_cost: totalCost,              // Update from UI
                cost: totalCost,
                price: pricePerUnit,                // For backward compatibility
                // SESSION 61: Don't overwrite source/manufacturer/supplier_name (not in UI) - preserved via ...existingPart
                updated_at: new Date().toISOString()
              };
              
              parts.push(partObject);
            }
          });
          
          // Collect works
          const works = [];
          card.querySelectorAll('.work-row').forEach(row => {
            let type = row.querySelector('.work-type').value;
            const note = row.querySelector('.work-note').value;
            const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
            
            // If "אחר" is selected, get the custom text from the input
            if (type === 'אחר') {
              const otherInput = row.querySelector('.work-type-other');
              if (otherInput && otherInput.value.trim()) {
                type = otherInput.value.trim();
              }
            }
            
            if (type) {
              works.push({ category: type, comments: note, cost });
            }
          });
          
          // Collect repairs - PRESERVE EXISTING DATA
          const repairs = [];
          const existingRepairs = existingCenter?.Repairs?.repairs || [];
          
          card.querySelectorAll('.repair-row').forEach((row, repairIndex) => {
            const name = row.querySelector('.repair-name').value;
            const text = row.querySelector('.repair-text').value;
            const hours = parseFloat(row.querySelector('.repair-hours').value) || 0;
            const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
            
            if (text.trim() || name.trim()) {
              // Get existing repair data to preserve all fields
              const existingRepair = existingRepairs[repairIndex] || {};
              
              // Merge existing data with new data (preserve all fields)
              const repairObject = {
                ...existingRepair,           // Preserve all existing fields
                name: name,                  // Update name from UI
                description: text,           // Update description from UI
                hours: hours,                // Update hours from UI
                cost: cost                   // Update cost from UI
              };
              
              repairs.push(repairObject);
            }
          });
          
          // Calculate costs using individual cost fields
          const partsCost = parts.reduce((sum, part) => sum + (parseFloat(part.price) || 0), 0);
          const workCost = works.reduce((sum, work) => sum + (parseFloat(work.cost) || 0), 0);
          const repairsCost = repairs.reduce((sum, repair) => sum + (parseFloat(repair.cost) || 0), 0);
          const totalCost = partsCost + workCost + repairsCost;
          
          const centerIdFromDOM = card.dataset?.centerId || '';
          const centerIdFromHelper = existingCenter?.Id || existingCenter?.id || existingCenter?.code || '';
          let centerId = centerIdFromDOM || centerIdFromHelper;
          
          if (!centerId) {
            console.warn(`⚠️ SESSION 56: Center ${index} has NO ID from DOM or helper.`);
            console.warn('  Checking if this center already has parts in helper with damage_center_code...');
            
            const existingParts = existingCenter?.Parts?.parts_required || [];
            if (existingParts.length > 0 && existingParts[0].damage_center_code) {
              centerId = existingParts[0].damage_center_code;
              console.log(`✅ SESSION 56: Found ID from existing parts: ${centerId}`);
            } else {
              console.warn(`⚠️ SESSION 56: No existing parts with ID. Center ${index} will not be saved to prevent phantom centers.`);
              console.warn('  This center must be created/edited in wizard first to get a proper ID.');
              return;
            }
          }
          
          console.log(`🆔 SESSION 56: saveDamageCenterChanges center ${index} ID resolution:`, {
            fromDOM: centerIdFromDOM,
            fromHelper: centerIdFromHelper,
            final: centerId
          });
          
          // Create center object in helper.centers format (source of truth)
          const centerObject = {
            Id: centerId,
            "Damage center Number": centerNumber || (index + 1),
            Location: centerLocation,
            Description: centerDescription,
            RepairNature: centerRepairNature,
            Parts: {
              parts_required: parts,
              parts_meta: {
                total_items: parts.length,
                total_cost: partsCost
              }
            },
            Works: {
              works: works,
              works_meta: {
                total_items: works.length,
                total_cost: workCost
              }
            },
            Repairs: {
              repairs: repairs,
              repairs_meta: {
                total_items: repairs.length,
                total_cost: repairsCost
              }
            },
            Summary: {
              "Total with VAT": totalCost * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100)
            }
          };
          
          // Save to helper.centers (primary source)
          helper.centers.push(centerObject);
          
          // Also save to damage_blocks for backward compatibility
          helper.expertise.damage_blocks.push({
            damage_center_name: centerLocation,
            damage_center_number: index + 1,
            center_header: centerNumber,
            description: centerDescription,
            repair_nature: centerRepairNature,
            parts,
            works,
            repairs,
            parts_cost: partsCost,
            work_cost: workCost,
            repairs_cost: repairsCost
          });
          
          
          // Store damage center data for depreciation section (complete object)
          if (centerLocation.trim()) {
            damageCenterNames.push({
              name: centerLocation.trim(),
              number: centerNumber || (index + 1),
              description: centerDescription || '',
              RepairNature: centerRepairNature
            });
          }
          
          // Update cost display for this card
          updateCostDisplay(card, partsCost, workCost, repairsCost);
        });
        
        // 🆕 UPDATE SPECIFIC DESTINATIONS (like estimator does)
        
        // 1. Update damage_centers array with ALL data + source = 'final_report'
        helper.damage_centers = helper.centers.map((center, index) => ({
          "Id": center.Id || `dc_${Date.now()}_${index + 1}`,
          "Damage center Number": center["Damage center Number"] || (index + 1).toString(),
          "Location": center.Location || '',
          "Description": center.Description || '',
          "RepairNature": center.RepairNature || '',
          "Parts": center.Parts || {
            "parts_required": [],
            "parts_meta": { "total_items": 0, "total_cost": 0 }
          },
          "Works": center.Works || {
            "works": [],
            "works_meta": { "total_items": 0, "total_cost": 0 }
          },
          "Repairs": center.Repairs || {
            "repairs": [],
            "repairs_meta": { "total_items": 0, "total_cost": 0 }
          },
          "Summary": center.Summary || { "Total with VAT": 0 },
          source: 'final_report',
          last_updated: new Date().toISOString()
        }));
        console.log('✅ Updated damage_centers from final_report with source tracking');
        
        // 2. Recreate damage_assessment.damage_centers with id + repair_nature + source
        if (!helper.damage_assessment) helper.damage_assessment = {};
        helper.damage_assessment.damage_centers = helper.centers.map(center => ({
          Id: center.Id || `dc_${Date.now()}_${Math.random()}`,
          repair_nature: center.RepairNature || '',
          source: 'final_report',
          last_updated: new Date().toISOString()
        }));
        console.log('✅ Recreated damage_assessment.damage_centers from final_report');
        
        // 3. Recreate damage_assessment.comprehensive.centers with descriptions only + source
        if (!helper.damage_assessment.comprehensive) helper.damage_assessment.comprehensive = {};
        helper.damage_assessment.comprehensive.centers = helper.centers.map(center => ({
          location: center.Location || '',
          description: center.Description || '',
          RepairNature: center.RepairNature || '',
          repair_nature: center.RepairNature || '', // Duplicate field for compatibility
          source: 'final_report',
          last_updated: new Date().toISOString()
        }));
        console.log('✅ Recreated damage_assessment.comprehensive.centers from final_report');
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // DON'T auto-update depreciation - preserve manual entries
        // updateDepreciationFromDamageCenters(damageCenterNames);
        
        // Update/recreate damage_assessment summary sections with current data
        updateDamageAssessmentSummary(helper);
        
        // Trigger floating screen refresh
        triggerFloatingScreenRefresh();
        
        console.log('Damage centers saved:', helper.expertise.damage_blocks);
        console.log('✅ SESSION 61 FINAL-REPORT: Save operation completed successfully');
        
      } catch (error) {
        console.error('❌ SESSION 61 FINAL-REPORT: Error saving damage center changes:', error);
      } finally {
        // 🔍 SESSION 61: Reset save guard
        isSavingDamageCentersFinalReport = false;
        console.log('🔓 SESSION 61 FINAL-REPORT: Save guard released');
      }
    }
    
    // UPDATE DEPRECIATION SECTION FROM DAMAGE CENTERS
    function updateDepreciationFromDamageCenters(damageCenterNames) {
      try {
        
        // If no data provided, get current data from helper.centers
        if (!damageCenterNames || damageCenterNames.length === 0) {
          const helper = window.helper || {};
          damageCenterNames = [];
          
          if (helper.centers && helper.centers.length > 0) {
            helper.centers.forEach((center, index) => {
              // Get the actual location and center number properly
              const location = center.Location || center.damage_center_name || '';
              
              // Extract just the number from "Damage center Number" field
              // e.g., "מוקד נזק מס' מוקד נזק מס' 1" -> "1"
              let centerNum = center["Damage center Number"] || String(index + 1);
              // Extract all numbers and take the last one
              const numberMatch = String(centerNum).match(/\d+/g);
              centerNum = numberMatch ? numberMatch[numberMatch.length - 1] : String(index + 1);
              
              damageCenterNames.push({
                name: location,  // The actual location/part name
                number: centerNum,  // Just the number (1, 2, 3, etc.)
                description: center.Description || '',
                RepairNature: center.RepairNature || ''
              });
            });
          }
        }
        
        
        const depreciationTable = document.getElementById('depreciationBulkTable');
        if (!depreciationTable) {
          return;
        }
        
        // DON'T clear existing depreciation rows - preserve manual data!
        // Only add new rows if the table is empty
        const existingRows = depreciationTable.querySelectorAll('.dep-row');
        if (existingRows.length > 0) {
          console.log('⚠️ Depreciation table already has data - preserving existing manual entries');
          return;
        }
        
        // Add a row for each damage center
        damageCenterNames.forEach(centerData => {
          // Handle both old string format and new object format
          const centerName = (typeof centerData === 'string') ? centerData : centerData.name;
          const centerNumber = (typeof centerData === 'object') ? centerData.number : null;
          const centerDescription = (typeof centerData === 'object') ? centerData.description : '';
          const centerRepairNature = (typeof centerData === 'object') ? centerData.RepairNature : '';
          
          // ✅ FIXED: Correct field mapping for depreciation from damage centers
          // "מס' מוקד" should show the center number
          // "החלק הניזוק" should show LOCATION/PART (use centerName which contains the damage location)  
          // "מהות התיקון" should show REPAIR NATURE (use centerRepairNature which contains repair nature details)
          const centerNum = centerNumber || (damageCenterNames.indexOf(centerData) + 1); // Fallback to index + 1
          const damageLocation = centerName || ''; // This is the location/part that was damaged
          const workEssence = centerRepairNature || '';
          
          // Create row directly in the table
          const row = document.createElement('div');
          row.className = 'dep-row';
          row.style.cssText = 'display:grid; grid-template-columns:70px 2fr 2fr 80px 90px 80px; gap:10px; margin-bottom:8px;';
          
          row.innerHTML = `
            <div><input type="text" placeholder="מס' מוקד" value="${centerNum || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" style="text-align: center;" title="${centerNum || ''}" /></div>
            <div><input type="text" placeholder="החלק הניזוק" value="${damageLocation}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="${damageLocation}" /></div>
            <div><input type="text" placeholder="מהות התיקון" value="${workEssence}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="${workEssence}" /></div>
            <div><input type="text" placeholder="ירידת ערך (מספר)" value="" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="" style="direction: ltr; text-align: right;" /></div>
            <div><input type="text" placeholder="ערך ב-₪" value="" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="" /></div>
            <div><button class="btn remove" onclick="removeDepField('${row.id || 'depRow_' + Date.now()}')">מחק</button></div>
          `;
          
          // Set unique ID for the row
          row.id = 'depRow_' + Date.now() + '_' + (damageCenterNames.indexOf(centerData));
          
          // Append to table
          depreciationTable.appendChild(row);
          
          // Add tooltip update listeners to all input fields
          const inputs = row.querySelectorAll('input');
          inputs.forEach(input => {
            input.addEventListener('input', function() {
              this.title = this.value;
            });
          });
          
          // Add auto-calculation functionality to the percentage field
          const percentInput = row.querySelector('input[placeholder="ירידת ערך (מספר)"]');
          const valueInput = row.querySelector('input[placeholder="ערך ב-₪"]');
          
          if (percentInput && valueInput) {
            percentInput.addEventListener('input', function() {
              // Clean the value to extract the numeric part
              const cleanValue = this.value.replace('%', '').replace(/[^0-9.-]/g, '');
              let percent = parseFloat(cleanValue) || 0;
              
              // Keep value as clean decimal number without % sign
              this.value = cleanValue;
              
              // Calculate value from market price automatically
              const marketValueField = document.getElementById('carMarketValue') || document.getElementById('sumMarketValue');
              const marketValueStr = marketValueField?.value.replace(/[₪,]/g, '') || '0';
              const marketValue = parseFloat(marketValueStr) || 0;
              
              const calculatedValue = (marketValue * percent) / 100;
              valueInput.value = calculatedValue ? `₪${Math.round(calculatedValue).toLocaleString()}` : '';
              
              // Save data after calculation
              saveDepreciationData();
            });
          }
        });
        
        
      } catch (error) {
        console.error('Error updating depreciation from damage centers:', error);
      }
    }

    // ADD EVENT LISTENERS
    function addDamageCenterEventListeners() {
      // Remove existing listeners by cloning elements (prevents duplicates)
      document.querySelectorAll('.damage-center-number, .damage-center-location, .damage-center-name, .damage-center-area-name, .damage-center-description, .damage-center-repair-nature, .part-name, .part-desc, .part-price, .work-type, .work-type-other, .work-note, .work-cost, .repair-name, .repair-text, .repair-hours, .repair-cost').forEach(input => {
        // Check if already has listeners
        if (!input.hasAttribute('data-listeners-added')) {
          input.addEventListener('change', () => {
            saveDamageCenterChanges();
            updateAllCostDisplays();
          });
          input.addEventListener('blur', () => {
            saveDamageCenterChanges();
            updateAllCostDisplays();
          });
          input.addEventListener('input', () => {
            updateAllCostDisplays();
          });
          
          // Mark as having listeners to prevent duplicates
          input.setAttribute('data-listeners-added', 'true');
          console.log(`📝 Added event listeners to: ${input.className}`);
        }
      });
      
      // Hide suggestions when clicking outside
      document.addEventListener('click', function(e) {
        if (!e.target.closest('.part-row')) {
          document.querySelectorAll('.part-suggestions').forEach(div => {
            div.style.display = 'none';
          });
        }
      });
    }

    // UPDATE WORK COST FROM TYPE SELECTION
    function updateWorkCostFromType(selectElement, centerIndex, workIndex) {
      // REMOVED: Predefined work rates that were forcing costs
      // Work costs should be manually entered based on specific case requirements
      
      // Only trigger save and recalculation without changing cost
      saveDamageCenterChanges();
      updateAllCostDisplays();
      
      console.log(`🔧 Work type changed: ${selectElement.value} (cost remains manual)`);
    }

    function handleWorkTypeChange(selectElement, centerIndex, workIndex) {
      const workRow = selectElement.closest('.work-row');
      const otherInput = workRow.querySelector('.work-type-other');
      
      if (selectElement.value === 'אחר') {
        otherInput.style.display = 'block';
        otherInput.focus();
      } else {
        otherInput.style.display = 'none';
        otherInput.value = '';
      }
      
      // Call the original function
      updateWorkCostFromType(selectElement, centerIndex, workIndex);
    }

    // COST CALCULATION FUNCTIONS
    function calculateWorkCost(works) {
      return works.reduce((total, work) => {
        const cost = typeof work === 'object' ? (work.cost || 0) : 0;
        return total + parseFloat(cost);
      }, 0);
    }

    function calculateRepairsCost(repairs) {
      return repairs.reduce((total, repair) => {
        const cost = typeof repair === 'object' ? (repair.cost || 0) : 0;
        return total + parseFloat(cost);
      }, 0);
    }

    function calculatePartsCost(parts) {
      return parts.reduce((total, part) => {
        const cost = typeof part === 'object' ? (part.price || 0) : 0;
        return total + parseFloat(cost);
      }, 0);
    }

    function updateCostDisplay(card, partsCost, workCost, repairsCost) {
      const totalCost = partsCost + workCost + repairsCost;
      const totalWithVAT = totalCost * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100);
      
      // Update display elements
      const workDisplay = card.querySelector('.work-costs-display');
      const partsDisplay = card.querySelector('.parts-costs-display');
      const repairsDisplay = card.querySelector('.repairs-costs-display');
      const totalDisplay = card.querySelector('.total-with-vat-display');
      
      if (workDisplay) {
        workDisplay.textContent = `₪${workCost.toLocaleString()}`;
        console.log(`💼 Work costs updated: ₪${workCost.toLocaleString()}`);
      }
      if (partsDisplay) {
        partsDisplay.textContent = `₪${partsCost.toLocaleString()}`;
        console.log(`🔧 Parts costs updated: ₪${partsCost.toLocaleString()}`);
      }
      if (repairsDisplay) {
        repairsDisplay.textContent = `₪${repairsCost.toLocaleString()}`;
        console.log(`🔨 Repairs costs updated (ONLY repairs): ₪${repairsCost.toLocaleString()}`);
      }
      if (totalDisplay) {
        totalDisplay.textContent = `₪${Math.round(totalWithVAT).toLocaleString()}`;
        console.log(`💰 Total with VAT updated: ₪${Math.round(totalWithVAT).toLocaleString()}`);
      }
    }

    function updateAllCostDisplays() {
      document.querySelectorAll('.editable-damage-card').forEach(card => {
        // Recalculate costs for this card using individual cost fields
        let partsCost = 0;
        card.querySelectorAll('.part-row').forEach(row => {
          // SESSION 46 FIX: Use new .part-total-cost field instead of .part-price
          const totalCostField = row.querySelector('.part-total-cost');
          if (totalCostField) {
            const totalCostText = totalCostField.value || '₪0';
            const cost = parseFloat(totalCostText.replace(/[₪,]/g, '')) || 0;
            partsCost += cost;
          }
        });
        
        let workCost = 0;
        card.querySelectorAll('.work-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
          workCost += cost;
        });
        
        let repairsCost = 0;
        card.querySelectorAll('.repair-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
          repairsCost += cost;
        });
        
        updateCostDisplay(card, partsCost, workCost, repairsCost);
      });
      
      // Update summary section totals
      updateSummaryTotalsFromDamageCenters();
      
      // Update damage centers subtotal
      updateDamageCentersSubtotal();
    }

    function updateSummaryTotalsFromDamageCenters() {
      let totalClaimBeforeVAT = 0;
      
      document.querySelectorAll('.editable-damage-card').forEach(card => {
        // Calculate total cost for each damage center (parts + works + repairs)
        let partsCost = 0;
        card.querySelectorAll('.part-row').forEach(row => {
          // SESSION 46 FIX: Use new .part-total-cost field instead of .part-price
          const totalCostField = row.querySelector('.part-total-cost');
          if (totalCostField) {
            const totalCostText = totalCostField.value || '₪0';
            const cost = parseFloat(totalCostText.replace(/[₪,]/g, '')) || 0;
            partsCost += cost;
          }
        });
        
        let workCost = 0;
        card.querySelectorAll('.work-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
          workCost += cost;
        });
        
        let repairsCost = 0;
        card.querySelectorAll('.repair-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
          repairsCost += cost;
        });
        
        totalClaimBeforeVAT += partsCost + workCost + repairsCost;
      });
      
      // Calculate total claim with VAT (admin configured rate)
      const totalClaimWithVAT = Math.round(totalClaimBeforeVAT * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100));
      
      // Update summary fields
      const sumClaimField = document.getElementById('sumClaim');
      const totalClaimField = document.getElementById('totalClaim');
      
      if (totalClaimWithVAT > 0) {
        const formattedAmount = `₪${totalClaimWithVAT.toLocaleString()}`;
        
        // Update both summary claim and total claim fields WITH VAT
        if (sumClaimField) {
          sumClaimField.value = formattedAmount;
        }
        // Update main total claim field (div element)
        if (totalClaimField && totalClaimField.tagName === 'DIV') {
          totalClaimField.innerText = formattedAmount;
        } else if (totalClaimField) {
          totalClaimField.value = formattedAmount;
        }
        
        console.log(`💰 Updated total claim with VAT: ${totalClaimBeforeVAT.toLocaleString()} → ${totalClaimWithVAT.toLocaleString()}`);
        
        // SAFE SUMMARY UPDATE: Update helper directly instead of triggering events that cascade
        setTimeout(() => {
          if (sumClaimField) {
            // Update helper directly without triggering event cascade that overrides calculations
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            helper.final_report = helper.final_report || {};
            helper.final_report.summary = helper.final_report.summary || {};
            helper.final_report.summary.total_claim = formattedAmount;
            sessionStorage.setItem('helper', JSON.stringify(helper));
            console.log('🔒 SAFE UPDATE: Updated total_claim in helper without triggering calculation overrides');
          }
        }, 100);
        
        // New bulk system will handle gross calculations when total claim changes
      }
    }

    // Make functions global
    window.loadDataFromHelper = loadDataFromHelper;
    window.loadLegalText = loadLegalText;
    window.loadLegalTextFromVault = loadLegalTextFromVault;
    window.resetLegalText = resetLegalText;
    window.loadAttachmentsFromVault = loadAttachmentsFromVault;
    window.resetAttachments = resetAttachments;
    window.addDepField = addDepField;
    window.updateReportType = updateReportType;
    window.addCustomSummaryField = addCustomSummaryField;
    window.loadDamageCentersSummary = loadDamageCentersSummary;
    window.loadAllAdjustments = loadAllAdjustments;
    window.updateGlobalDepreciationCalculation = updateGlobalDepreciationCalculation;
    window.calculateDamagePercentage = calculateDamagePercentage;
    window.triggerGlobalDepreciationCalc = triggerGlobalDepreciationCalc;
    window.showPartSuggestions = showPartSuggestions;
    window.selectPartSuggestion = selectPartSuggestion;
    window.openPartsSearchModule = openPartsSearchModule;
    window.addPartRow = addPartRow;
    window.addWorkRow = addWorkRow;
    window.addRepairRow = addRepairRow;
    window.removePartRow = removePartRow;
    window.removeWorkRow = removeWorkRow;
    window.removeRepairRow = removeRepairRow;
    window.removeDamageCenter = removeDamageCenter;
    window.addNewDamageCenter = addNewDamageCenter;
    window.saveDamageCenterChanges = saveDamageCenterChanges;
    window.addDamageCenterEventListeners = addDamageCenterEventListeners;
    window.calculateWorkCost = calculateWorkCost;
    window.updateWorkCostFromType = updateWorkCostFromType;
    window.updateCostDisplay = updateCostDisplay;
    window.updateAllCostDisplays = updateAllCostDisplays;
    window.updateSummaryTotalsFromDamageCenters = updateSummaryTotalsFromDamageCenters;
    window.updateGrossMarketValueField = updateGrossMarketValueField;
    window.updateAuthorizedClaim = updateAuthorizedClaim;
    window.updateGrossPercentageField = updateGrossPercentageField;
    window.calculateGrossMarketValue = calculateGrossMarketValue;
    window.calculateGrossPercentage = calculateGrossPercentage;
    window.calculateFullMarketValue = calculateFullMarketValue;
    window.addFeatureAdjustment = addFeatureAdjustment;
    window.addRegistrationAdjustment = addRegistrationAdjustment;
    window.removeAdjustmentRow = removeAdjustmentRow;
    window.updateHelperFromContactField = updateHelperFromContactField;
    window.loadGrossAdjustments = loadGrossAdjustments;
    window.loadTotalValueSectionAdjustments = loadTotalValueSectionAdjustments;
    window.syncUISection = syncUISection;
    window.updateGrossMarketValueCalculation = updateGrossMarketValueCalculation;
    window.loadGrossCalculationData = loadGrossCalculationData;
    
    // loadGrossAdjustments is now properly called during data loading
    
    // FORCE MANUAL CALCULATION - Last resort function
    function forceManualCalculation() {
      console.log('🔧 === FORCE MANUAL CALCULATION ===');
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Manual gross market value calculation
      let vehicleValueGross = 0;
      const leviPriceListField = document.getElementById('leviPriceList');
      const grossPercentField = document.getElementById('grossPercent');
      const totalClaimField = document.getElementById('totalClaim');
      
      // Try to get a market value from anywhere
      if (helper.levi_report?.final_price) {
        vehicleValueGross = parseFloat(helper.levi_report.final_price);
        console.log('🔧 Using levi_report.final_price as vehicleValueGross:', vehicleValueGross);
      } else if (helper.calculations?.full_market_value) {
        vehicleValueGross = parseFloat(helper.calculations.full_market_value);
        console.log('🔧 Using calculations.full_market_value as vehicleValueGross:', vehicleValueGross);
      } else if (helper.levisummary?.final_price) {
        vehicleValueGross = parseFloat(helper.levisummary.final_price);
        console.log('🔧 Using levisummary.final_price as vehicleValueGross:', vehicleValueGross);
      }
      
      // If we have a value, populate the field
      if (vehicleValueGross > 0) {
        leviPriceListField.value = `₪${vehicleValueGross.toLocaleString()}`;
        
        // Update helper
        helper.calculations = helper.calculations || {};
        helper.calculations.vehicle_value_gross = vehicleValueGross;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('🔧 Manually set vehicleValueGross:', vehicleValueGross);
        
        // Now calculate percentage
        const totalClaim = parseFloat(totalClaimField?.value?.replace(/[₪,]/g, '') || '0');
        if (totalClaim > 0) {
          const grossPercentage = (totalClaim / vehicleValueGross) * 100;
          const formattedPercentage = `${Math.round(grossPercentage * 100) / 100}%`;
          
          grossPercentField.value = formattedPercentage;
          
          // Update helper
          helper.claims_data = helper.claims_data || {};
          helper.claims_data.gross_percent = formattedPercentage;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          console.log('🔧 Manually calculated gross percentage:', formattedPercentage);
        }
      } else {
        console.warn('⚠️ No market value found for manual calculation');
      }
      
      console.log('🔧 === FORCE MANUAL CALCULATION COMPLETE ===');
    }
    
    // DEBUG HELPER FUNCTION
    function debugCalculations() {
      console.log('🔍 === DEBUG CALCULATIONS ===');
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('Helper data:', helper);
      console.log('Calculations:', helper.calculations);
      console.log('Levi report:', helper.levi_report);
      console.log('Expertise:', helper.expertise);
      
      // Check current field values
      const leviPriceListField = document.getElementById('leviPriceList');
      const grossPercentField = document.getElementById('grossPercent');
      const totalClaimField = document.getElementById('totalClaim');
      
      console.log('🔍 Current field values:', {
        leviPriceList: leviPriceListField?.value || 'NOT FOUND',
        grossPercent: grossPercentField?.value || 'NOT FOUND',
        totalClaim: totalClaimField?.value || 'NOT FOUND'
      });
      
      // Force refresh all calculations
      updateAllCostDisplays();
      updateSummaryTotalsFromDamageCenters();
      // New bulk system will handle gross calculations
      
      // Check values after refresh
      setTimeout(() => {
        console.log('🔍 After refresh field values:', {
          leviPriceList: leviPriceListField?.value || 'NOT FOUND',
          grossPercent: grossPercentField?.value || 'NOT FOUND',
          totalClaim: totalClaimField?.value || 'NOT FOUND'
        });
        
        // If still empty, try force manual calculation
        if (!leviPriceListField?.value || !grossPercentField?.value) {
          console.log('🔧 Fields still empty, trying force manual calculation...');
          forceManualCalculation();
        }
      }, 100);
      
      console.log('🔍 === DEBUG CALCULATIONS COMPLETE ===');
    }
    window.debugCalculations = debugCalculations;
    window.forceManualCalculation = forceManualCalculation;
    
    // 🌍 GLOBAL CALCULATION INTERFACE FOR FINAL REPORT MODULES
    window.FinalReportCalculations = {
      // Main calculation functions
      updateGrossMarketValueField: updateGrossMarketValueField,
      updateGrossPercentageField: updateGrossPercentageField,
      updateSummaryTotalsFromDamageCenters: updateSummaryTotalsFromDamageCenters,
      updateAllCostDisplays: updateAllCostDisplays,
      calculateDamagePercentage: calculateDamagePercentage,
      
      // Cost calculation functions
      calculateRepairsCost: calculateRepairsCost,
      calculatePartsCost: calculatePartsCost,
      calculateWorkCost: calculateWorkCost,
      updateCostDisplay: updateCostDisplay,
      
      // Helper utilities
      updateHelperFromField: updateHelperFromField,
      loadDataFromHelper: loadDataFromHelper,
      saveDamageCenterChanges: saveDamageCenterChanges,
      debugCalculations: debugCalculations,
      
      // Get calculated values from 3-bulk system
      getGrossMarketValue: function() {
        try {
          // First try to get from the gross market value result field (Bulk 1)
          const grossMarketValueField = document.getElementById('grossMarketValueResult');
          if (grossMarketValueField && grossMarketValueField.value) {
            return parseFloat(grossMarketValueField.value.replace(/[₪,]/g, '')) || 0;
          }
          
          // Fallback to helper data
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          return helper.calculations?.vehicle_value_gross || 0;
        } catch (error) {
          console.error('Error getting gross market value:', error);
          return 0;
        }
      },
      
      getFullMarketValue: function() {
        try {
          // First try to get from the full market value result field (Bulk 3)
          const fullMarketValueField = document.getElementById('fullMarketValueResult');
          if (fullMarketValueField && fullMarketValueField.value) {
            return parseFloat(fullMarketValueField.value.replace(/[₪,]/g, '')) || 0;
          }
          
          // Fallback to helper data
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          return helper.calculations?.market_value || helper.calculations?.full_market_value || helper.levi_report?.final_price || 0;
        } catch (error) {
          console.error('Error getting full market value:', error);
          return 0;
        }
      },
      
      getTotalClaim: function() {
        try {
          // First try to get from the total claim field (Bulk 2)
          const totalClaimField = document.getElementById('totalClaim');
          if (totalClaimField && totalClaimField.value) {
            return parseFloat(totalClaimField.value.replace(/[₪,]/g, '')) || 0;
          }
          
          // Fallback: calculate from damage centers
          const totalFromDamageCenters = calculateTotalClaimFromDamageCenters();
          if (totalFromDamageCenters > 0) {
            return totalFromDamageCenters;
          }
          
          // Final fallback to helper data
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          return parseFloat(helper.claims_data?.total_claim?.replace(/[₪,]/g, '') || '0') || 
                 parseFloat(helper.calculations?.total_damage) || 0;
        } catch (error) {
          console.error('Error getting total claim:', error);
          return 0;
        }
      },
      
      getGrossPercentage: function() {
        try {
          // First try to get from the gross percentage field (Bulk 2)
          const grossPercentField = document.getElementById('grossPercent');
          if (grossPercentField && grossPercentField.value) {
            return parseFloat(grossPercentField.value.replace(/[%]/g, '')) || 0;
          }
          
          // Calculate from current values if not available
          const grossMarketValue = this.getGrossMarketValue();
          const totalClaim = this.getTotalClaim();
          if (grossMarketValue > 0 && totalClaim > 0) {
            return (totalClaim / grossMarketValue) * 100;
          }
          
          // Fallback to helper data
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          return parseFloat(helper.claims_data?.gross_percent?.replace(/[%]/g, '') || '0') || 
                 parseFloat(helper.calculations?.damage_percent) || 0;
        } catch (error) {
          console.error('Error getting gross percentage:', error);
          return 0;
        }
      },
      
      // Get damage centers data
      getDamageCentersData: function() {
        try {
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          return helper.expertise?.damage_centers || [];
        } catch (error) {
          console.error('Error getting damage centers data:', error);
          return [];
        }
      },
      
      // Calculate totals from damage centers
      calculateDamageCentersTotals: function() {
        const damageCenters = this.getDamageCentersData();
        let totalParts = 0;
        let totalWorks = 0;
        let totalRepairs = 0;
        
        damageCenters.forEach(center => {
          totalParts += this.calculatePartsCost(center.parts || []);
          totalWorks += this.calculateWorkCost(center.works || []);
          totalRepairs += this.calculateRepairsCost(center.repairs || []);
        });
        
        return {
          parts: totalParts,
          works: totalWorks,
          repairs: totalRepairs,
          total: totalParts + totalWorks + totalRepairs,
          totalWithVAT: (totalParts + totalWorks + totalRepairs) * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100)
        };
      },
      
      // Force refresh all calculations
      refreshAllCalculations: function() {
        this.updateAllCostDisplays();
        this.updateSummaryTotalsFromDamageCenters();
        
        // Refresh all 3 bulks
        setTimeout(() => {
          try {
            // Refresh Bulk 1 (Gross Market Value)
            if (typeof updateGrossMarketValueCalculation === 'function') {
              updateGrossMarketValueCalculation();
            }
            
            // Refresh Bulk 2 (Gross Percentage)
            if (typeof refreshSecondBulkFields === 'function') {
              refreshSecondBulkFields();
            }
            
            // Refresh Bulk 3 (Full Market Value)
            if (typeof updateFullMarketValueCalculation === 'function') {
              // updateFullMarketValueCalculation() removed
            }
            
            // Trigger floating screen refresh with updated calculations
            if (typeof triggerFloatingScreenRefresh === 'function') {
              triggerFloatingScreenRefresh();
            }
            
            console.log('✅ All 3-bulk calculations refreshed from FinalReportCalculations interface');
          } catch (error) {
            console.error('Error refreshing 3-bulk calculations:', error);
          }
        }, 100);
      }
    };
    
    // Make it also available via window for backward compatibility
    window.getFinalReportCalculations = () => window.FinalReportCalculations;
    // Maintain backward compatibility
    window.getFinalReportCalculations = () => window.FinalReportCalculations;

    // MESSAGE LISTENER FOR PARTS SEARCH RESULTS
    window.addEventListener('message', function(event) {
      if (event.data.type === 'PARTS_SELECTED') {
        try {
          const { parts, target } = event.data;
          const { centerIndex, partIndex } = target;
          
          // Find the specific part row
          const targetCard = document.querySelector(`.editable-damage-card[data-center-index="${centerIndex}"]`);
          if (targetCard) {
            const partRows = targetCard.querySelectorAll('.part-row');
            const targetRow = partRows[partIndex];
            
            if (targetRow && parts.length > 0) {
              // Fill the first selected part into the target row - SESSION 46 FIX
              const firstPart = parts[0];
              const nameInput = targetRow.querySelector('.part-name');
              const catalogInput = targetRow.querySelector('.part-catalog-code-visible');
              const descInput = targetRow.querySelector('.part-description');
              const priceInput = targetRow.querySelector('.part-price-per-unit');
              const sourceInput = targetRow.querySelector('.part-source');
              
              if (nameInput) nameInput.value = firstPart.name || '';
              if (catalogInput) catalogInput.value = firstPart.pcode || firstPart.catalog_code || '';
              if (descInput) descInput.value = firstPart.description || '';
              if (priceInput) {
                priceInput.value = firstPart.price || firstPart.price_per_unit || '';
                // Trigger calculation
                calculatePartPriceFields(targetRow);
              }
              if (sourceInput) sourceInput.value = firstPart.source || '';
              
              // Add additional parts if more than one selected
              if (parts.length > 1) {
                const partsList = targetCard.querySelector('.parts-list');
                for (let i = 1; i < parts.length; i++) {
                  const part = parts[i];
                  const newPartIndex = partsList.children.length;
                  const newPartHTML = createEditablePartRow(part, centerIndex, newPartIndex);
                  partsList.insertAdjacentHTML('beforeend', newPartHTML);
                }
              }
              
              // Save changes and update costs
              saveDamageCenterChanges();
              updateAllCostDisplays();
              
              console.log(`✅ Added ${parts.length} parts to damage center ${centerIndex + 1}`);
            }
          }
        } catch (error) {
          console.error('Error processing parts selection:', error);
        }
      }
    });
    
    // LOAD HELPER DATA AND POPULATE FIELDS
    function loadHelperData() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        // Ensure window.helper is initialized from sessionStorage
        if (!window.helper || Object.keys(window.helper).length === 0) {
          window.helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        }
        const helper = window.helper;
        
        console.log('📥 Loading helper data:', helper);
        
        // Load report type selection from helper
        const savedReportType = helper.final_report?.type || helper.manual_final_report_type?.finalReportType;
        if (savedReportType) {
          const radioButton = document.querySelector(`input[name="final-report-type"][value="${savedReportType}"]`);
          if (radioButton) {
            radioButton.checked = true;
            console.log('📋 Loaded report type from helper:', savedReportType);
            // Trigger change event to update legal text and attachments
            setTimeout(() => {
              loadLegalText().catch(console.error);
              loadAttachmentsFromVault();
            }, 100);
          }
        }
        
        // Load dropdown report type selection from helper
        const savedDropdownType = helper.final_report?.dropdown_type || helper.reportType;
        if (savedDropdownType) {
          const dropdown = document.getElementById('reportType');
          if (dropdown) {
            dropdown.value = savedDropdownType;
            console.log('📋 Loaded dropdown report type from helper:', savedDropdownType);
            // Trigger change to update summary visibility and legal text
            setTimeout(() => {
              updateReportType();
              loadLegalText().catch(console.error);
            }, 150);
          }
        }
        
        // Auto-fill basic price field from helper - ENHANCED
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField) {
          let basicPrice = 0;
          
          // Try multiple sources for BASE PRICE (not market value) - FIXED PRIORITY
          if (helper.levi_report?.base_price) {
            basicPrice = parseFloat(helper.levi_report.base_price);
            console.log('📄 Found BASE PRICE in helper.levi_report.base_price:', basicPrice);
          } else if (helper.expertise?.levi_report?.base_price) {
            basicPrice = parseFloat(helper.expertise.levi_report.base_price);
            console.log('📄 Found BASE PRICE in helper.expertise.levi_report.base_price:', basicPrice);
          } else if (helper.levisummary?.base_price) {
            basicPrice = parseFloat(helper.levisummary.base_price);
            console.log('📄 Found BASE PRICE in helper.levisummary.base_price:', basicPrice);
          } else if (helper.car_details?.base_price) {
            basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[₪,]/g, ''));
            console.log('📄 Found BASE PRICE in helper.car_details.base_price:', basicPrice);
          } else {
            // REMOVED market_value fallback - we need BASE price only
            console.warn('⚠️ No BASE PRICE found in helper - this field requires Levi base price, not market value');
          }
          
          if (basicPrice > 0) {
            basicPriceField.value = `₪${basicPrice.toLocaleString()}`;
            console.log('✅ Auto-filled basic price field:', basicPrice);
            
            // Trigger calculation after loading
            setTimeout(() => {
              updateGrossMarketValueCalculation();
            }, 100);
          } else {
            // Check if the field already has a value before warning
            const currentFieldValue = basicPriceField?.value;
            if (!currentFieldValue) {
              console.warn('⚠️ No base price found in helper, basic price field will be empty');
            } else {
              console.info('ℹ️ Basic price field already populated with:', currentFieldValue, '(not from helper data)');
            }
            console.log('Debug helper data:', {
              levi_report: helper.levi_report,
              expertise: helper.expertise,
              levisummary: helper.levisummary,
              car_details: helper.car_details
            });
            
            // Enhanced debugging: Log full helper structure
            console.group('🔍 FULL HELPER STRUCTURE DEBUG');
            console.log('Complete helper object keys:', Object.keys(helper));
            console.log('Helper size:', JSON.stringify(helper).length);
            
            // Check all possible base price locations
            console.log('All possible base price locations:');
            console.log('- helper.levi_report?.base_price:', helper.levi_report?.base_price);
            console.log('- helper.expertise?.levi_report?.base_price:', helper.expertise?.levi_report?.base_price);
            console.log('- helper.levisummary?.base_price:', helper.levisummary?.base_price);
            console.log('- helper.car_details?.base_price:', helper.car_details?.base_price);
            console.log('- helper.vehicle?.base_price:', helper.vehicle?.base_price);
            console.log('- helper.calculations?.base_price:', helper.calculations?.base_price);
            console.log('- helper.expertise?.calculations?.base_price:', helper.expertise?.calculations?.base_price);
            
            // Check vehicle_value_gross locations
            console.log('All possible vehicle_value_gross locations:');
            console.log('- helper.calculations?.vehicle_value_gross:', helper.calculations?.vehicle_value_gross);
            console.log('- helper.expertise?.calculations?.vehicle_value_gross:', helper.expertise?.calculations?.vehicle_value_gross);
            
            // Check damage data locations
            console.log('All possible damage data locations:');
            console.log('- helper.expertise?.damage_blocks:', helper.expertise?.damage_blocks);
            console.log('- helper.damage_centers:', helper.damage_centers);
            console.log('- helper.damage_sections:', helper.damage_sections);
            
            // Log sessionStorage raw data
            console.log('Raw sessionStorage helper:', sessionStorage.getItem('helper'));
            console.groupEnd();
          }
        }
        
        // Auto-fill car details fields
        const carFields = {
          carPlate: helper.meta?.plate || helper.car_details?.plate || '',
          carManufacturer: helper.car_details?.manufacturer || helper.vehicle?.manufacturer || '',
          carModel: helper.car_details?.model || helper.vehicle?.model || '',
          carYear: helper.car_details?.year || helper.vehicle?.year || '',
          carModelCode: helper.car_details?.model_code || helper.vehicle?.model_code || '',
          carBasePrice: helper.levi_report?.base_price || helper.expertise?.levi_report?.base_price || '',
          carMarketValue: helper.car_details?.market_value || helper.vehicle?.market_value || helper.levi_report?.final_price || '',
          carReportDate: convertToDateInputFormat(helper.car_details?.report_date || new Date().toISOString().split('T')[0])
        };
        
        Object.entries(carFields).forEach(([fieldId, value]) => {
          const field = document.getElementById(fieldId);
          if (field && !field.value && value) {
            field.value = value;
          }
        });
        
        // DEBUGGING: Check all possible damage center data locations
        console.log('🔍 DEBUG: Checking all damage center data sources...');
        console.log('helper.expertise?.damage_blocks:', helper.expertise?.damage_blocks);
        console.log('helper.centers:', helper.centers);
        console.log('helper.damage_centers:', helper.damage_centers);
        
        // Load damage centers from helper - PRIORITIZE helper.centers (has parts_required data)
        if (helper.centers && helper.centers.length > 0) {
          console.log('🔄 Loading from helper.centers (PRIMARY SOURCE - has parts_required data)');
          const normalizedBlocks = helper.centers.map((center, index) => adaptCenterToBlock(center, index));
          loadDamageCentersFromHelper(normalizedBlocks);
        } else if (helper.expertise?.damage_blocks && helper.expertise.damage_blocks.length > 0) {
          console.log('🔄 Loading from helper.expertise.damage_blocks (FALLBACK - may have empty parts)');
          const normalizedBlocks = helper.expertise.damage_blocks.map((center, index) => adaptCenterToBlock(center, index));
          loadDamageCentersFromHelper(normalizedBlocks);
        } else if (helper.damage_centers && helper.damage_centers.length > 0) {
          console.log('🔄 Loading from helper.damage_centers');
          const normalizedBlocks = helper.damage_centers.map((center, index) => adaptCenterToBlock(center, index));
          loadDamageCentersFromHelper(normalizedBlocks);
        } else {
          console.log('❌ No damage center data found in any location');
        }
        
        console.log('✅ Helper data loaded successfully');
        
      } catch (error) {
        console.error('Error loading helper data:', error);
      }
    }
    
    // UPDATE DAMAGE ASSESSMENT SUMMARY SECTIONS
    function updateDamageAssessmentSummary(helper) {
      try {
        // Calculate current totals from helper.centers
        let totalWorks = 0;
        let totalParts = 0; 
        let totalRepairs = 0;
        let totalCenters = 0;
        
        if (helper.centers && helper.centers.length > 0) {
          totalCenters = helper.centers.length;
          
          helper.centers.forEach(center => {
            // Sum from parts_required
            if (center.Parts?.parts_required) {
              center.Parts.parts_required.forEach(part => {
                // ✅ SESSION 54 FIX: Use total_cost (includes quantity, reductions, wear) not price (per unit)
                totalParts += parseFloat(part.total_cost) || 0;
              });
            }
            
            // Sum from works
            if (center.Works?.works) {
              center.Works.works.forEach(work => {
                totalWorks += parseFloat(work.cost) || 0;
              });
            }
            
            // Sum from repairs
            if (center.Repairs?.repairs) {
              center.Repairs.repairs.forEach(repair => {
                totalRepairs += parseFloat(repair.cost) || 0;
              });
            }
          });
        }
        
        const totalWithoutVAT = totalWorks + totalParts + totalRepairs;
        const totalWithVAT = totalWithoutVAT * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100);
        
        // Update or create damage_assessment section - PRESERVE comprehensive section
        if (!helper.damage_assessment) helper.damage_assessment = {};
        
        // Update only the specific sections, preserving comprehensive and other existing data
        helper.damage_assessment.total_centers = totalCenters;
        helper.damage_assessment.total_items = totalCenters;
        
        helper.damage_assessment.summary = {
          total_works: totalWorks,
          total_parts: totalParts,
          total_repairs: totalRepairs,
          total_without_vat: Math.round(totalWithoutVAT),
          total_with_vat: Math.round(totalWithVAT)
        };
        
        helper.damage_assessment.totals = {
          "Total works": totalWorks,
          "Total parts": totalParts,
          "Total repairs": totalRepairs,
          "Total without VAT": Math.round(totalWithoutVAT),
          "Total with VAT": Math.round(totalWithVAT)
        };
        
        helper.damage_assessment.last_updated = new Date().toISOString();
        
        // Preserve existing comprehensive section if it exists
        
        console.log('✅ Updated damage_assessment summary:', helper.damage_assessment);
        
      } catch (error) {
        console.error('❌ Error updating damage assessment summary:', error);
      }
    }
    
    // UPDATE DAMAGE CENTERS SUBTOTAL DISPLAY
    function updateDamageCentersSubtotal() {
      let totalWorks = 0;
      let totalParts = 0;
      let totalRepairs = 0;
      
      // Calculate totals from all damage center cards
      document.querySelectorAll('.editable-damage-card').forEach(card => {
        // Sum parts costs - SESSION 56 FIX: Use ORIGINAL price × quantity for RIGHT window (כללי)
        // RIGHT window shows original prices BEFORE discounts/wear
        // LEFT window (after differentials) will apply reductions separately
        card.querySelectorAll('.part-row').forEach(row => {
          const pricePerUnitField = row.querySelector('.part-price-per-unit');
          const quantityField = row.querySelector('.part-quantity');
          
          if (pricePerUnitField && quantityField) {
            const pricePerUnit = parseFloat(pricePerUnitField.value) || 0;
            const quantity = parseInt(quantityField.value) || 1;
            const originalCost = Math.round(pricePerUnit * quantity);
            totalParts += originalCost;
          }
        });
        
        // Sum work costs
        card.querySelectorAll('.work-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
          totalWorks += cost;
        });
        
        // Sum repair costs
        card.querySelectorAll('.repair-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
          totalRepairs += cost;
        });
      });
      
      let rawTotalWithoutVat = totalWorks + totalParts + totalRepairs;
      let rawTotalWithVat = rawTotalWithoutVat * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100);
      
      console.log('📊 SESSION 56: RIGHT window (כללי) calculation:');
      console.log('  Parts (original מחיר × כמות):', Math.round(totalParts));
      console.log('  Works:', Math.round(totalWorks));
      console.log('  Repairs:', Math.round(totalRepairs));
      console.log('  Total (no discounts applied):', Math.round(rawTotalWithoutVat));
      
      // SESSION 48: Save category totals BEFORE differentials to helper.final_report
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (!helper.final_report) helper.final_report = {};
      helper.final_report.category_totals_before_differentials = {
        Parts: Math.round(totalParts),
        Works: Math.round(totalWorks),
        Repairs: Math.round(totalRepairs)
      };
      sessionStorage.setItem('helper', JSON.stringify(helper));
      if (window.helper) {
        if (!window.helper.final_report) window.helper.final_report = {};
        window.helper.final_report.category_totals_before_differentials = helper.final_report.category_totals_before_differentials;
      }
      
      // Calculate category-specific differentials
      let finalTotalWorks = totalWorks;
      let finalTotalParts = totalParts;
      let finalTotalRepairs = totalRepairs;
      let finalTotalWithoutVat = rawTotalWithoutVat;
      let finalTotalWithVat = rawTotalWithVat;
      
      // SESSION 52: FIX - Extract ALL differential components from helper.final_report.differential
      if (helper.final_report?.differential?.has_differentials) {
        console.log('🔍 SESSION 52: Extracting all differential components...');
        
        // 1. Extract parts reductions (הנחת רכיב)
        const partsReductionsTotal = helper.final_report.differential.parts_reductions?.total || 0;
        console.log('   הנחת רכיב (Parts Reductions):', partsReductionsTotal);
        
        // 2. Extract parts wear (בלאי רכיב)
        const partsWearTotal = helper.final_report.differential.parts_wear?.total || 0;
        console.log('   בלאי רכיב (Parts Wear):', partsWearTotal);
        
        // 3. Extract category differentials and sum by category type
        const categoryDiffItems = helper.final_report.differential.category_differentials?.items || [];
        let categoryDiffForParts = 0;
        let categoryDiffForWorks = 0;
        let categoryDiffForRepairs = 0;
        
        categoryDiffItems.forEach(item => {
          // Extract the reduction value from category_value field (e.g., "₪134")
          const reductionValue = parseFloat(String(item.category_value || '0').replace(/[₪,]/g, '')) || 0;
          const categoryType = item.category_type || item.type || '';
          
          console.log(`   Category Diff: ${categoryType} = ₪${reductionValue}`);
          
          if (categoryType === 'Parts' || categoryType === 'חלקים') {
            categoryDiffForParts += reductionValue;
          } else if (categoryType === 'Works' || categoryType === 'עבודות') {
            categoryDiffForWorks += reductionValue;
          } else if (categoryType === 'Repairs' || categoryType === 'תיקונים') {
            categoryDiffForRepairs += reductionValue;
          }
        });
        
        console.log('   Category Differentials - Parts:', categoryDiffForParts, ', Works:', categoryDiffForWorks, ', Repairs:', categoryDiffForRepairs);
        
        // 4. Extract invoice differentials by nature
        const invoiceDiffItems = helper.final_report.differential.invoice_differentials?.items || [];
        let invoicePartsDiff = 0;
        let invoiceWorksDiff = 0;
        let invoiceRepairsDiff = 0;
        
        invoiceDiffItems.forEach(item => {
          const amount = item.amount_without_vat || item.amount || 0;
          const nature = item.nature || '';
          
          if (nature === 'parts' || nature === 'חלקים') {
            invoicePartsDiff += amount;
          } else if (nature === 'works' || nature === 'עבודות') {
            invoiceWorksDiff += amount;
          } else if (nature === 'repairs' || nature === 'תיקונים') {
            invoiceRepairsDiff += amount;
          }
        });
        
        console.log('   Invoice Differentials - Parts:', invoicePartsDiff, ', Works:', invoiceWorksDiff, ', Repairs:', invoiceRepairsDiff);
        
        // SESSION 52: Apply CORRECT formulas for each category
        // Parts = Original - הנחת רכיב - בלאי רכיב - Category Diff (Parts) - Invoice Diff (parts)
        finalTotalParts = Math.max(0, totalParts - partsReductionsTotal - partsWearTotal - categoryDiffForParts - invoicePartsDiff);
        
        // Works = Original - Category Diff (Works) - Invoice Diff (works)
        finalTotalWorks = Math.max(0, totalWorks - categoryDiffForWorks - invoiceWorksDiff);
        
        // Repairs = Original - Category Diff (Repairs) - Invoice Diff (repairs)
        finalTotalRepairs = Math.max(0, totalRepairs - categoryDiffForRepairs - invoiceRepairsDiff);
        
        // SESSION 52: FIX - Total Without VAT = sum of category finals (already includes all differentials)
        finalTotalWithoutVat = finalTotalParts + finalTotalWorks + finalTotalRepairs;
        
        // Apply VAT to the final amount
        const vatRate = window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18);
        finalTotalWithVat = Math.round(finalTotalWithoutVat * (1 + vatRate / 100));
        
        console.log('📉 SESSION 52: Applied ALL differentials correctly:');
        console.log('   Original - Parts:', totalParts, ', Works:', totalWorks, ', Repairs:', totalRepairs, ', Total:', rawTotalWithoutVat);
        console.log('   Differentials - Parts:', (partsReductionsTotal + partsWearTotal + categoryDiffForParts + invoicePartsDiff));
        console.log('                - Works:', (categoryDiffForWorks + invoiceWorksDiff));
        console.log('                - Repairs:', (categoryDiffForRepairs + invoiceRepairsDiff));
        console.log('   Final (after) - Parts:', finalTotalParts, ', Works:', finalTotalWorks, ', Repairs:', finalTotalRepairs);
        console.log('   Final Total Without VAT:', finalTotalWithoutVat, ', With VAT:', finalTotalWithVat);
      }
      
      // SESSION 48: Check if we're using dual container layout (updated for new structure)
      const hasDifferentials = helper.final_report?.differential?.has_differentials && 
                              helper.final_report?.differential?.grand_total &&
                              (helper.final_report.differential.grand_total.without_vat > 0 || 
                               helper.final_report.differential.grand_total.with_vat > 0);
      
      if (hasDifferentials) {
        // Update ORIGINAL values (left container - כללי)
        const totalWorksOriginal = document.getElementById('totalWorksOriginal');
        const totalPartsOriginal = document.getElementById('totalPartsOriginal');
        const totalRepairsOriginal = document.getElementById('totalRepairsOriginal');
        const totalWithoutVatOriginal = document.getElementById('totalWithoutVatOriginal');
        const totalWithVatOriginal = document.getElementById('totalWithVatOriginal');
        
        if (totalWorksOriginal) totalWorksOriginal.textContent = `₪${totalWorks.toLocaleString()}`;
        if (totalPartsOriginal) totalPartsOriginal.textContent = `₪${totalParts.toLocaleString()}`;
        if (totalRepairsOriginal) totalRepairsOriginal.textContent = `₪${totalRepairs.toLocaleString()}`;
        if (totalWithoutVatOriginal) totalWithoutVatOriginal.textContent = `₪${Math.round(rawTotalWithoutVat).toLocaleString()}`;
        if (totalWithVatOriginal) totalWithVatOriginal.textContent = `₪${Math.round(rawTotalWithVat).toLocaleString()}`;
        
        // Update AFTER DIFFERENTIALS values (right container - אחרי הפרשים)
        const totalWorksSubtotal = document.getElementById('totalWorksSubtotal');
        const totalPartsSubtotal = document.getElementById('totalPartsSubtotal');
        const totalRepairsSubtotal = document.getElementById('totalRepairsSubtotal');
        const totalWithoutVatSubtotal = document.getElementById('totalWithoutVatSubtotal');
        const totalWithVatSubtotal = document.getElementById('totalWithVatSubtotal');
        const totalDifferentialsDisplay = document.getElementById('totalDifferentialsDisplay');
        
        if (totalWorksSubtotal) totalWorksSubtotal.textContent = `₪${Math.round(finalTotalWorks).toLocaleString()}`;
        if (totalPartsSubtotal) totalPartsSubtotal.textContent = `₪${Math.round(finalTotalParts).toLocaleString()}`;
        if (totalRepairsSubtotal) totalRepairsSubtotal.textContent = `₪${Math.round(finalTotalRepairs).toLocaleString()}`;
        if (totalWithoutVatSubtotal) totalWithoutVatSubtotal.textContent = `₪${Math.round(finalTotalWithoutVat).toLocaleString()}`;
        if (totalWithVatSubtotal) totalWithVatSubtotal.textContent = `₪${Math.round(finalTotalWithVat).toLocaleString()}`;
        
        // SESSION 48: Display total differentials from helper
        if (totalDifferentialsDisplay && helper.final_report?.differential?.grand_total) {
          const differentialsTotal = helper.final_report.differential.grand_total.without_vat || 0;
          totalDifferentialsDisplay.textContent = `₪${Math.round(differentialsTotal).toLocaleString()}`;
        }
        
      } else {
        // Single container - use final values (which equals raw values when no differentials)
        const totalWorksElement = document.getElementById('totalWorksSubtotal');
        const totalPartsElement = document.getElementById('totalPartsSubtotal');
        const totalRepairsElement = document.getElementById('totalRepairsSubtotal');
        const totalWithoutVatElement = document.getElementById('totalWithoutVatSubtotal');
        const totalWithVatElement = document.getElementById('totalWithVatSubtotal');
        
        if (totalWorksElement) totalWorksElement.textContent = `₪${Math.round(finalTotalWorks).toLocaleString()}`;
        if (totalPartsElement) totalPartsElement.textContent = `₪${Math.round(finalTotalParts).toLocaleString()}`;
        if (totalRepairsElement) totalRepairsElement.textContent = `₪${Math.round(finalTotalRepairs).toLocaleString()}`;
        if (totalWithoutVatElement) totalWithoutVatElement.textContent = `₪${Math.round(finalTotalWithoutVat).toLocaleString()}`;
        if (totalWithVatElement) totalWithVatElement.textContent = `₪${Math.round(finalTotalWithVat).toLocaleString()}`;
      }
      
      // Update helper with after differentials totals
      if (!helper.damage_assessment) helper.damage_assessment = {};
      if (!helper.damage_assessment.totals_after_differentials) {
        helper.damage_assessment.totals_after_differentials = {};
      }
      
      helper.damage_assessment.totals_after_differentials = {
        "Total works": Math.round(finalTotalWorks),
        "Total parts": Math.round(finalTotalParts), 
        "Total repairs": Math.round(finalTotalRepairs),
        "Total without VAT": Math.round(finalTotalWithoutVat),
        "Total with VAT": Math.round(finalTotalWithVat),
        "last_updated": new Date().toISOString()
      };
      
      // Save updated helper
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Also update window.helper
      if (window.helper) {
        if (!window.helper.damage_assessment) window.helper.damage_assessment = {};
        window.helper.damage_assessment.totals_after_differentials = helper.damage_assessment.totals_after_differentials;
      }
      
      console.log('💰 Updated damage centers subtotal:', {
        originalWorks: totalWorks,
        originalParts: totalParts,
        originalRepairs: totalRepairs,
        finalWorks: finalTotalWorks,
        finalParts: finalTotalParts,
        finalRepairs: finalTotalRepairs,
        finalWithoutVat: finalTotalWithoutVat,
        finalWithVat: finalTotalWithVat,
        showingDifferentialsOverlay: hasDifferentials
      });
      
      console.log('📊 Saved totals_after_differentials to helper:', helper.damage_assessment.totals_after_differentials);
      
      // Update authorizedClaim field - ALWAYS use original totals (NOT after differentials)
      const authorizedClaimField = document.getElementById('authorizedClaim');
      if (authorizedClaimField) {
        // Always use original totals, same as totalClaimGross
        const claimTotal = helper.damage_assessment?.totals?.["Total with VAT"] || 0;
        const claimValue = claimTotal ? `₪${claimTotal.toLocaleString()}` : '';
        
        authorizedClaimField.value = claimValue;
        
        // Update helper data
        if (!helper.claims_data) helper.claims_data = {};
        if (!helper.calculations) helper.calculations = {};
        helper.claims_data.total_claim = claimValue;
        helper.calculations.total_damage = claimTotal;
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        if (window.helper) {
          if (!window.helper.claims_data) window.helper.claims_data = {};
          if (!window.helper.calculations) window.helper.calculations = {};
          window.helper.claims_data.total_claim = claimValue;
          window.helper.calculations.total_damage = claimTotal;
        }
        
        // Trigger gross percentage recalculation
        setTimeout(() => {
          if (typeof updateGrossPercentageField === 'function') {
            updateGrossPercentageField();
          }
        }, 100);
      }
    }
    
    // SESSION 47: CREATE הפרשים SECTION WITH 4 CATEGORIES
    function createDifferentialsSection() {
      return `
        <div class="form-section" id="differentialsSection" style="margin-top: 20px;">
          <h3>הנחות והפרשים</h3>
          <label style="margin-bottom:10px; display:flex; align-items:center; gap:6px;">
            <span style="background:#ff4444; color:white; padding:2px 6px; border-radius:3px; font-size:11px;">🔴</span>
            האם קיימים הנחות והפרשים?
            <input type="checkbox" id="hasDifferentials" style="width:auto; margin-right:6px;" onchange="toggleDifferentialsTable(); setTimeout(saveDifferentialsToHelper, 100);">
          </label>
          
          <div id="differentialsMainContainer" style="display:none; margin-top:15px;">
            
            <!-- CATEGORY 1: PARTS REDUCTIONS (AUTO-IMPORTED - RED) -->
            <div id="partsReductionsSection" style="margin-bottom:15px; border:2px solid #dc3545; border-radius:6px; padding:10px; background:#fff5f5;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; cursor:pointer;" onclick="toggleCollapsibleSection('partsReductionsContent')">
                <h4 style="margin:0; color:#dc3545; font-size:14px;">
                  <span style="background:#dc3545; color:white; padding:2px 6px; border-radius:3px; font-size:10px; margin-left:6px;">🔴</span>
                  הנחת רכיב
                </h4>
                <span id="partsReductionsToggle" style="font-size:18px; color:#dc3545;">▼</span>
              </div>
              <div id="partsReductionsContent" style="display:block;">
                <div id="partsReductionsList" style="font-size:12px; color:#666; margin-bottom:8px;">
                  <!-- Auto-populated from parts reduction breakdown -->
                </div>
                <div style="background:#f8f9fa; padding:8px; border-radius:4px; text-align:left; font-weight:bold;">
                  סה"כ הנחת רכיב: <span id="totalPartsReductions">₪0</span>
                </div>
              </div>
            </div>
            
            <!-- CATEGORY 2: PARTS WEAR (AUTO-IMPORTED - RED) -->
            <div id="partsWearSection" style="margin-bottom:15px; border:2px solid #dc3545; border-radius:6px; padding:10px; background:#fff5f5;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; cursor:pointer;" onclick="toggleCollapsibleSection('partsWearContent')">
                <h4 style="margin:0; color:#dc3545; font-size:14px;">
                  <span style="background:#dc3545; color:white; padding:2px 6px; border-radius:3px; font-size:10px; margin-left:6px;">🔴</span>
                  בלאי רכיב
                </h4>
                <span id="partsWearToggle" style="font-size:18px; color:#dc3545;">▼</span>
              </div>
              <div id="partsWearContent" style="display:block;">
                <div id="partsWearList" style="font-size:12px; color:#666; margin-bottom:8px;">
                  <!-- Auto-populated from parts wear breakdown -->
                </div>
                <div style="background:#f8f9fa; padding:8px; border-radius:4px; text-align:left; font-weight:bold;">
                  סה"כ בלאי רכיב: <span id="totalPartsWear">₪0</span>
                </div>
              </div>
            </div>
            
            <!-- CATEGORY 3: CATEGORY DIFFERENTIALS (MANUAL ENTRY - COLLAPSIBLE) -->
            <div id="categoryDifferentialsSection" style="margin-bottom:15px; border:2px solid #6c757d; border-radius:6px; padding:10px; background:#f8f9fa;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; cursor:pointer;" onclick="toggleCollapsibleSection('categoryDifferentialsContent')">
                <h4 style="margin:0; color:#6c757d; font-size:14px;">
                  הפרשי קטגוריה
                </h4>
                <span id="categoryDifferentialsToggle" style="font-size:18px; color:#6c757d;">▼</span>
              </div>
              <div id="categoryDifferentialsContent" style="display:none;">
                <div id="categoryDifferentialsList">
                  <!-- Manual category differentials rows -->
                </div>
                <button class="btn add" type="button" onclick="addCategoryDifferentialRow()" style="font-size:12px; padding:6px 12px;">הוסף הפרש קטגוריה</button>
              </div>
            </div>
            
            <!-- CATEGORY 4: INVOICE DIFFERENTIALS (EXISTING - GRAY) -->
            <div id="invoiceDifferentialsSection" style="margin-bottom:15px; border:2px solid #6c757d; border-radius:6px; padding:10px; background:#f1f1f1;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; cursor:pointer;" onclick="toggleCollapsibleSection('invoiceDifferentialsContent')">
                <h4 style="margin:0; color:#212529; font-size:14px;">
                  הפרשי חשבוניות
                </h4>
                <span id="invoiceDifferentialsToggle" style="font-size:18px; color:#212529;">▼</span>
              </div>
              <div id="invoiceDifferentialsContent" style="display:none;">
                <div id="differentialsRows"></div>
                <button class="btn add" type="button" onclick="addDifferentialRow()" style="font-size:12px; padding:6px 12px;">הוסף הפרש</button>
              </div>
            </div>
            
            <!-- SUBTOTALS SECTION -->
            <div id="differentialsSubtotalsSection" style="margin-top:20px;">
              <!-- Gray box: Total component differentials (reductions + wear + category) -->
              <div style="background:#6c757d; color:white; padding:10px; border-radius:6px; margin-bottom:10px; display:flex; justify-content:space-between; align-items:center;">
                <span style="font-size:14px; font-weight:bold;">סה"כ הפרשי רכיבים:</span>
                <span id="totalComponentWear" style="font-size:16px; font-weight:bold;">₪0</span>
              </div>
              
              <!-- SESSION 48: Changed to blue color matching section colors -->
              <div style="background:#17a2b8; color:white; padding:10px; border-radius:6px; margin-bottom:15px; display:flex; justify-content:space-between; align-items:center;">
                <span style="font-size:14px; font-weight:bold;">סה"כ הפרשי חשבוניות:</span>
                <span id="totalInvoiceDifferentials" style="font-size:16px; font-weight:bold;">₪0</span>
              </div>
              
              <!-- SESSION 48: Grand totals in a nice bordered box -->
              <div style="border:3px solid #000; border-radius:8px; padding:12px; background:#f8f9fa;">
                <div style="background:#343a40; color:white; padding:10px; border-radius:6px; margin-bottom:8px; display:flex; justify-content:space-between; align-items:center;">
                  <span style="font-size:14px; font-weight:bold;">סה"כ כללי הפרשים (ללא מע"מ):</span>
                  <span id="grandTotalDifferentialsWithoutVAT" style="font-size:16px; font-weight:bold;">₪0</span>
                </div>
                
                <div style="background:#495057; color:white; padding:10px; border-radius:6px; margin-bottom:8px; display:flex; justify-content:space-between; align-items:center;">
                  <span style="font-size:14px; font-weight:bold;">מע"מ:</span>
                  <span id="grandTotalDifferentialsVAT" style="font-size:16px; font-weight:bold;">₪0</span>
                </div>
                
                <div style="background:#000; color:white; padding:14px; border-radius:6px; display:flex; justify-content:space-between; align-items:center; border:2px solid #ffc107;">
                  <span style="font-size:16px; font-weight:bold;">סה"כ כללי הפרשים (כולל מע"מ):</span>
                  <span id="grandTotalDifferentialsWithVAT" style="font-size:20px; font-weight:bold;">₪0</span>
                </div>
              </div>
            </div>
            
            <!-- Save button -->
            <div style="margin-top:15px; text-align:center;">
              <button class="btn save" type="button" onclick="saveDifferentials()" style="background:#28a745; color:white; padding:10px 20px; border-radius:6px; border:none; font-size:14px; cursor:pointer;">שמור הפרשים</button>
            </div>
          </div>
        </div>
      `;
    }
    
    // ========================================
    // SESSION 62: CASE REDUCTION SECTION (הנחת תיק)
    // ========================================
    function createCaseReductionSection() {
      return `
        <!-- SESSION 62: Case Reduction Section (הנחת תיק) -->
        <div class="form-section" id="caseReductionSection" style="margin-top: 20px;">
          <h3>הנחת תיק</h3>
          
          <label style="margin-bottom:10px; display:flex; align-items:center; gap:6px;">
            <span style="background:#17a2b8; color:white; padding:2px 6px; border-radius:3px; font-size:11px;">💰</span>
            האם קיימת הנחת תיק?
            <input type="checkbox" id="hasCaseReduction" style="width:auto; margin-right:6px;" 
                   onchange="toggleCaseReductionTable();">
          </label>
          
          <div id="caseReductionContainer" style="display:none; margin-top:15px;">
            <div style="margin-bottom:15px; border:2px solid #17a2b8; border-radius:6px; padding:10px; background:#e7f4f9;">
              <table style="width:100%; border-collapse:collapse; font-size:13px;">
                <thead>
                  <tr style="background:#17a2b8; color:white;">
                    <th style="padding:8px; text-align:right;">שם שורה</th>
                    <th style="padding:8px; text-align:right; width:100px;">אחוז</th>
                    <th style="padding:8px; text-align:right; width:120px;">סכום מקורי</th>
                    <th style="padding:8px; text-align:right; width:120px;">ערך ההנחה</th>
                    <th style="padding:8px; text-align:right; width:120px;">סכום סופי</th>
                    <th style="padding:8px; text-align:right; width:140px;">כולל מע"מ</th>
                  </tr>
                </thead>
                <tbody>
                  <tr style="background:white;">
                    <td style="padding:8px; border:1px solid #ddd;">הנחת תיק</td>
                    <td style="padding:8px; border:1px solid #ddd;">
                      <input type="number" id="caseReductionPercentage" min="0" max="100" step="0.01" value="0" 
                             style="width:100%; text-align:center; padding:4px; border-radius:4px; border:1px solid #ccc;"
                             oninput="calculateCaseReduction();">
                    </td>
                    <td style="padding:8px; border:1px solid #ddd; font-weight:bold;" id="caseOriginalSum">₪0.00</td>
                    <td style="padding:8px; border:1px solid #ddd; font-weight:bold; color:#dc3545;" id="caseDiscountValue">₪0.00</td>
                    <td style="padding:8px; border:1px solid #ddd; font-weight:bold; color:#28a745;" id="caseTotalAfter">₪0.00</td>
                    <td style="padding:8px; border:1px solid #ddd; font-weight:bold; color:#17a2b8;" id="caseTotalWithVAT">₪0.00</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      `;
    }
    
    // SESSION 48: AUTO-CHECK DIFFERENTIALS CHECKBOX IF PARTS HAVE REDUCTIONS OR WEAR
    function autoCheckDifferentialsIfNeeded() {
      const breakdown = calculatePartsDifferentialsBreakdown();
      const hasDifferentialsCheckbox = document.getElementById('hasDifferentials');
      
      if (breakdown.reductions.length > 0 || breakdown.wear.length > 0) {
        if (hasDifferentialsCheckbox && !hasDifferentialsCheckbox.checked) {
          hasDifferentialsCheckbox.checked = true;
          toggleDifferentialsTable();
          console.log('✅ SESSION 48: Auto-checked הפרשים checkbox - found imported reductions/wear');
        }
      }
    }
    
    // SESSION 47: RENDER PARTS REDUCTIONS LIST
    function renderPartsReductionsSection() {
      const breakdown = calculatePartsDifferentialsBreakdown();
      const listContainer = document.getElementById('partsReductionsList');
      const totalContainer = document.getElementById('totalPartsReductions');
      
      if (!listContainer || !totalContainer) return;
      
      if (breakdown.reductions.length === 0) {
        listContainer.innerHTML = '<p style="color:#999; font-style:italic;">אין הנחות רכיב</p>';
        totalContainer.textContent = '₪0';
        return;
      }
      
      let html = '<div style="display:grid; gap:4px;">';
      breakdown.reductions.forEach(item => {
        html += `
          <div style="display:grid; grid-template-columns: 120px 1fr 60px 80px; gap:6px; padding:4px; background:white; border-radius:3px; font-size:11px; align-items:center;">
            <div style="color:#666;">${item.centerName}</div>
            <div style="color:#333;">${item.partName}</div>
            <div style="text-align:center; font-weight:bold; color:#dc3545; background:#fff5f5; padding:2px 4px; border-radius:3px;">${item.percentage}%</div>
            <div style="text-align:left; font-weight:bold; color:#dc3545;">₪${item.amount.toLocaleString()}</div>
          </div>
        `;
      });
      html += '</div>';
      
      listContainer.innerHTML = html;
      totalContainer.textContent = `₪${breakdown.totalReduction.toLocaleString()}`;
      
      // SESSION 48: Auto-check checkbox after rendering
      autoCheckDifferentialsIfNeeded();
    }
    
    // SESSION 47: RENDER PARTS WEAR LIST
    function renderPartsWearSection() {
      const breakdown = calculatePartsDifferentialsBreakdown();
      const listContainer = document.getElementById('partsWearList');
      const totalContainer = document.getElementById('totalPartsWear');
      
      if (!listContainer || !totalContainer) return;
      
      if (breakdown.wear.length === 0) {
        listContainer.innerHTML = '<p style="color:#999; font-style:italic;">אין בלאי רכיב</p>';
        totalContainer.textContent = '₪0';
        return;
      }
      
      let html = '<div style="display:grid; gap:4px;">';
      breakdown.wear.forEach(item => {
        html += `
          <div style="display:grid; grid-template-columns: 120px 1fr 60px 80px; gap:6px; padding:4px; background:white; border-radius:3px; font-size:11px; align-items:center;">
            <div style="color:#666;">${item.centerName}</div>
            <div style="color:#333;">${item.partName}</div>
            <div style="text-align:center; font-weight:bold; color:#dc3545; background:#fff5f5; padding:2px 4px; border-radius:3px;">${item.percentage}%</div>
            <div style="text-align:left; font-weight:bold; color:#dc3545;">₪${item.amount.toLocaleString()}</div>
          </div>
        `;
      });
      html += '</div>';
      
      listContainer.innerHTML = html;
      totalContainer.textContent = `₪${breakdown.totalWear.toLocaleString()}`;
    }
    
    // SESSION 47: TOGGLE COLLAPSIBLE SECTIONS
    function toggleCollapsibleSection(contentId) {
      const content = document.getElementById(contentId);
      const toggleIcon = document.getElementById(contentId.replace('Content', 'Toggle'));
      
      if (!content) return;
      
      if (content.style.display === 'none') {
        content.style.display = 'block';
        if (toggleIcon) toggleIcon.textContent = '▼';
      } else {
        content.style.display = 'none';
        if (toggleIcon) toggleIcon.textContent = '◀';
      }
    }
    
    // SESSION 47: ADD CATEGORY DIFFERENTIAL ROW
    window.addCategoryDifferentialRow = function addCategoryDifferentialRow() {
      const container = document.getElementById('categoryDifferentialsList');
      if (!container) return;
      
      const rowIndex = container.children.length;
      const rowHTML = `
        <div class="category-differential-row" data-index="${rowIndex}" style="background:white; border:1px solid #ddd; border-radius:4px; padding:8px; margin-bottom:8px;">
          <div style="display:grid; grid-template-columns: 1fr 80px 120px 100px; gap:8px; align-items:end;">
            <div>
              <label style="font-size:11px; color:#666;">בחר קטגוריה:</label>
              <select class="category-diff-type" style="width:100%; padding:4px; border:1px solid #ddd; border-radius:3px; font-size:12px;" onchange="updateCategoryDifferentialsTotal()">
                <option value="">בחר</option>
                <option value="Parts">חלקים</option>
                <option value="Works">עבודות</option>
                <option value="Repairs">תיקונים</option>
              </select>
            </div>
            <div>
              <label style="font-size:11px; color:#666;">אחוז:</label>
              <input type="text" class="category-diff-percentage" value="0%" placeholder="0%" style="width:100%; padding:4px; border:1px solid #ddd; border-radius:3px; font-size:12px; text-align:center;" oninput="updateCategoryDifferentialsTotal()">
            </div>
            <div>
              <label style="font-size:11px; color:#666;">ערך ההנחה:</label>
              <input type="text" class="category-diff-category-value" value="₪0" readonly style="width:100%; padding:4px; border:1px solid #ddd; border-radius:3px; font-size:12px; background:#f8f9fa; text-align:center;">
            </div>
            <div>
              <label style="font-size:11px; color:#666;">סכום (ללא מע"מ):</label>
              <input type="number" class="category-diff-amount" value="0" readonly style="width:100%; padding:4px; border:1px solid #ddd; border-radius:3px; font-size:12px; background:#f8f9fa; text-align:center;">
            </div>
          </div>
          <button type="button" onclick="removeCategoryDifferentialRow(this)" style="margin-top:6px; padding:4px 8px; font-size:11px; background:#dc3545; color:white; border:none; border-radius:3px; cursor:pointer;">מחק</button>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', rowHTML);
      
      // SESSION 48: Attach event listeners after row creation
      const newRow = container.lastElementChild;
      if (newRow) {
        const typeSelect = newRow.querySelector('.category-diff-type');
        const amountInput = newRow.querySelector('.category-diff-amount');
        
        if (typeSelect) {
          typeSelect.addEventListener('change', function() {
            console.log('🔄 Category dropdown changed to:', this.value);
            updateCategoryDifferentialsTotal();
          });
        }
        
        if (amountInput) {
          amountInput.addEventListener('input', function() {
            console.log('🔄 Amount input changed to:', this.value);
            updateCategoryDifferentialsTotal();
          });
        }
      }
    }
    
    // SESSION 47: REMOVE CATEGORY DIFFERENTIAL ROW
    window.removeCategoryDifferentialRow = function removeCategoryDifferentialRow(button) {
      button.closest('.category-differential-row').remove();
      updateCategoryDifferentialsTotal();
    }
    
    // SESSION 48: User enters percentage → calculate ערך ההנחה and סכום
    window.updateCategoryDifferentialsTotal = function updateCategoryDifferentialsTotal() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // SESSION 48: Read from final_report.category_totals_before_differentials (built from UI)
      const categoryTotalsFromUI = helper.final_report?.category_totals_before_differentials || {};
      
      const categoryOriginalCosts = {
        'Parts': parseFloat(categoryTotalsFromUI.Parts || 0),
        'Works': parseFloat(categoryTotalsFromUI.Works || 0),
        'Repairs': parseFloat(categoryTotalsFromUI.Repairs || 0)
      };
      
      const rows = document.querySelectorAll('.category-differential-row');
      let total = 0;
      
      rows.forEach(row => {
        const typeSelect = row.querySelector('.category-diff-type');
        const percentageInput = row.querySelector('.category-diff-percentage');
        const reductionValueInput = row.querySelector('.category-diff-category-value'); // ערך ההנחה
        const updatedCostInput = row.querySelector('.category-diff-amount'); // סכום (ללא מע"מ)
        
        const categoryType = typeSelect?.value || '';
        const percentageText = percentageInput?.value || '0%';
        const percentageNum = parseFloat(percentageText.replace('%', '')) || 0;
        
        if (categoryType && categoryOriginalCosts[categoryType] > 0) {
          const originalCost = categoryOriginalCosts[categoryType];
          
          // ערך ההנחה = percentage × original cost
          const reductionValue = Math.round((percentageNum / 100) * originalCost);
          
          // סכום (ללא מע"מ) = original cost - ערך ההנחה
          const updatedCost = Math.round(originalCost - reductionValue);
          
          if (reductionValueInput) reductionValueInput.value = `₪${reductionValue.toLocaleString()}`;
          if (updatedCostInput) updatedCostInput.value = updatedCost;
          
          total += updatedCost;
        } else {
          if (reductionValueInput) reductionValueInput.value = '₪0';
          if (updatedCostInput) updatedCostInput.value = 0;
        }
      });
      
      updateAllDifferentialsSubtotals();
      setTimeout(saveDifferentialsToHelper, 100);
    }
    
    // SESSION 47: POPULATE DAMAGE CENTERS DROPDOWN
    function populateDamageCentersDropdown(selectElement) {
      if (!selectElement) return;
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const centers = helper.centers || [];
      
      let options = '<option value="">בחר מוקד נזק</option>';
      centers.forEach((center, index) => {
        const centerName = center["Damage center Name"] || center.name || `מוקד נזק ${index + 1}`;
        options += `<option value="${index}">${centerName}</option>`;
      });
      
      selectElement.innerHTML = options;
    }
    
    // SESSION 47: CALCULATE PARTS DIFFERENTIALS BREAKDOWN (REDUCTION VS WEAR)
    function calculatePartsDifferentialsBreakdown() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const centers = helper.centers || [];
      
      const breakdown = {
        reductions: [],
        wear: [],
        totalReduction: 0,
        totalWear: 0
      };
      
      centers.forEach((center, centerIndex) => {
        const centerName = center["Damage center Name"] || center.name || `מוקד נזק ${centerIndex + 1}`;
        const partsRequired = center.Parts?.parts_required || [];
        
        partsRequired.forEach((part, partIndex) => {
          const pricePerUnit = parseFloat(part.price_per_unit || part.unit_price || part.price || 0);
          const reductionPct = parseFloat(part.reduction_percentage || part.reduction || 0);
          const wearPct = parseFloat(part.wear_percentage || part.wear || 0);
          const quantity = parseInt(part.quantity || part.כמות || 1);
          const partName = part.name || part.part_name || `חלק ${partIndex + 1}`;
          
          if (reductionPct > 0) {
            const priceAfterReduction = pricePerUnit * (1 - reductionPct / 100);
            const reductionAmount = Math.round((pricePerUnit - priceAfterReduction) * quantity);
            
            if (reductionAmount > 0) {
              breakdown.reductions.push({
                centerName,
                partName,
                amount: reductionAmount,
                percentage: reductionPct
              });
              breakdown.totalReduction += reductionAmount;
            }
          }
          
          if (wearPct > 0) {
            const priceAfterReduction = pricePerUnit * (1 - reductionPct / 100);
            const priceAfterWear = priceAfterReduction * (1 - wearPct / 100);
            const wearAmount = Math.round((priceAfterReduction - priceAfterWear) * quantity);
            
            if (wearAmount > 0) {
              breakdown.wear.push({
                centerName,
                partName,
                amount: wearAmount,
                percentage: wearPct
              });
              breakdown.totalWear += wearAmount;
            }
          }
        });
      });
      
      breakdown.totalReduction = Math.round(breakdown.totalReduction);
      breakdown.totalWear = Math.round(breakdown.totalWear);
      
      console.log('📊 SESSION 47: Parts differentials breakdown:', breakdown);
      return breakdown;
    }

    // CREATE DAMAGE CENTERS SUBTOTAL SECTION
    function createDamageCentersSubtotal(hasDifferentials = false) {
      if (!hasDifferentials) {
        // Single container when no differentials
        return `
          <div id="damageCentersSubtotal" style="background: #f8f9fa; border: 2px solid #28a745; border-radius: 6px; padding: 12px; margin-top: 15px;">
            <h4 style="margin: 0 0 10px 0; color: #28a745; text-align: center; font-size: 14px; font-weight: bold;">🧮 סיכום כללי - מרכזי נזק</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 8px;">
              <div style="background: #17a2b8; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                <div style="font-size: 16px; font-weight: bold;" id="totalWorksSubtotal">₪0</div>
                <div style="font-size: 10px; opacity: 0.9;">סה"כ עבודות</div>
              </div>
              <div style="background: #28a745; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                <div style="font-size: 16px; font-weight: bold;" id="totalPartsSubtotal">₪0</div>
                <div style="font-size: 10px; opacity: 0.9;">סה"כ חלקים</div>
              </div>
              <div style="background: #ffc107; color: #212529; padding: 8px; border-radius: 4px; text-align: center;">
                <div style="font-size: 16px; font-weight: bold;" id="totalRepairsSubtotal">₪0</div>
                <div style="font-size: 10px; opacity: 0.9;">סה"כ תיקונים</div>
              </div>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
              <div style="background: #6c757d; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                <div style="font-size: 18px; font-weight: bold;" id="totalWithoutVatSubtotal">₪0</div>
                <div style="font-size: 11px; opacity: 0.9;">סה"כ ללא מע"מ</div>
              </div>
              <div style="background: #dc3545; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                <div style="font-size: 18px; font-weight: bold;" id="totalWithVatSubtotal">₪0</div>
                <div style="font-size: 11px; opacity: 0.9;">סה"כ כולל מע"מ</div>
              </div>
            </div>
          </div>
        `;
      } else {
        // Dual containers when differentials exist (50/50)
        return `
          <div id="damageCentersSubtotal" style="margin-top: 15px;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
              
              <!-- Left Container: כללי -->
              <div style="background: #f8f9fa; border: 2px solid #28a745; border-radius: 6px; padding: 12px;">
                <h4 style="margin: 0 0 10px 0; color: #28a745; text-align: center; font-size: 14px; font-weight: bold;">כללי</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 6px; margin-bottom: 6px;">
                  <div style="background: #17a2b8; color: white; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalWorksOriginal">₪0</div>
                    <div style="font-size: 9px; opacity: 0.9;">עבודות</div>
                  </div>
                  <div style="background: #28a745; color: white; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalPartsOriginal">₪0</div>
                    <div style="font-size: 9px; opacity: 0.9;">חלקים</div>
                  </div>
                  <div style="background: #ffc107; color: #212529; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalRepairsOriginal">₪0</div>
                    <div style="font-size: 9px; opacity: 0.9;">תיקונים</div>
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                  <div style="background: #6c757d; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold;" id="totalWithoutVatOriginal">₪0</div>
                    <div style="font-size: 10px; opacity: 0.9;">ללא מע"מ</div>
                  </div>
                  <div style="background: #dc3545; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold;" id="totalWithVatOriginal">₪0</div>
                    <div style="font-size: 10px; opacity: 0.9;">כולל מע"מ</div>
                  </div>
                </div>
              </div>
              
              <!-- Right Container: אחרי הפרשים -->
              <div style="background: #f8f9fa; border: 2px solid #dc3545; border-radius: 6px; padding: 12px;">
                <h4 style="margin: 0 0 10px 0; color: #dc3545; text-align: center; font-size: 14px; font-weight: bold;">אחרי הפרשים</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 6px; margin-bottom: 6px;">
                  <div style="background: #17a2b8; color: white; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalWorksSubtotal">₪0</div>
                    <div style="font-size: 9px; opacity: 0.9;">עבודות</div>
                  </div>
                  <div style="background: #28a745; color: white; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalPartsSubtotal">₪0</div>
                    <div style="font-size: 9px; opacity: 0.9;">חלקים</div>
                  </div>
                  <div style="background: #ffc107; color: #212529; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalRepairsSubtotal">₪0</div>
                    <div style="font-size: 9px; opacity: 0.9;">תיקונים</div>
                  </div>
                  <!-- SESSION 48: Add differentials total field after repairs -->
                  <div style="background: #fd7e14; color: white; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalDifferentialsDisplay">₪0</div>
                    <div style="font-size: 9px; opacity: 0.9;">הפרשים</div>
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                  <div style="background: #6c757d; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold;" id="totalWithoutVatSubtotal">₪0</div>
                    <div style="font-size: 10px; opacity: 0.9;">ללא מע"מ</div>
                  </div>
                  <div style="background: #dc3545; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold;" id="totalWithVatSubtotal">₪0</div>
                    <div style="font-size: 10px; opacity: 0.9;">כולל מע"מ</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;
      }
    }
    
    // HANDLE NATURE DROPDOWN CHANGES - SHOW/HIDE OTHER TEXT FIELD
    function toggleNatureOtherField(dropdown) {
      const row = dropdown.closest('.differential-row');
      const otherField = row.querySelector('.diff-nature-other');
      const hiddenField = row.querySelector('.diff-nature');
      
      if (dropdown.value === 'other') {
        otherField.style.display = 'block';
        otherField.focus();
        hiddenField.value = otherField.value;
      } else {
        otherField.style.display = 'none';
        hiddenField.value = dropdown.value;
      }
      
      console.log('🔄 Nature changed to:', dropdown.value);
      setTimeout(saveDifferentialsToHelper, 100);
    }
    
    // REFRESH DAMAGE CENTERS CONTAINER LAYOUT WHEN DIFFERENTIALS TOGGLE
    function refreshDamageCentersContainerLayout() {
      console.log('🔄 Refreshing damage centers container layout...');
      
      // Check current differential state
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      // SESSION 48: Check using new grand_total structure
      const hasDifferentials = helper.final_report?.differential?.has_differentials && 
                              helper.final_report?.differential?.grand_total &&
                              (helper.final_report.differential.grand_total.without_vat > 0 || 
                               helper.final_report.differential.grand_total.with_vat > 0);
      
      // Find existing subtotal container and replace it
      const existingSubtotal = document.getElementById('damageCentersSubtotal');
      if (existingSubtotal) {
        const newSubtotalHTML = createDamageCentersSubtotal(hasDifferentials);
        existingSubtotal.outerHTML = newSubtotalHTML;
        
        // Update calculations with new layout
        setTimeout(() => {
          updateDamageCentersSubtotal();
        }, 100);
        
        console.log('✅ Container layout refreshed - hasDifferentials:', hasDifferentials);
      }
    }
    
    // REPOSITION DAMAGE CENTERS SAVE BUTTON TO APPEAR BEFORE SUMMARY
    function repositionDamageCentersSaveButton() {
      try {
        const damageCentersSection = document.getElementById('damageCentersSummary');
        const saveButton = damageCentersSection?.querySelector('.section-save-button');
        const subtotal = damageCentersSection?.querySelector('#damageCentersSubtotal');
        
        if (saveButton && subtotal) {
          const buttonContainer = saveButton.parentElement;
          // Move button container to before the subtotal
          subtotal.parentNode.insertBefore(buttonContainer, subtotal);
          console.log('✅ Repositioned damage centers save button before summary');
        }
      } catch (error) {
        console.error('Error repositioning damage centers save button:', error);
      }
    }
    
    // LOAD DAMAGE CENTERS FROM HELPER
    function loadDamageCentersFromHelper(damageBlocksOrHelper) {
      try {
        const damageCentersContent = document.getElementById('damageCentersContent');
        if (!damageCentersContent) return;
        
        // Handle two cases: called with damageBlocks array OR helper object (from refresh)
        let damageBlocks;
        if (Array.isArray(damageBlocksOrHelper)) {
          // Called with damage blocks directly
          damageBlocks = damageBlocksOrHelper;
        } else {
          // Called with helper object (from refresh system) - extract and normalize damage centers
          const helper = damageBlocksOrHelper || {};
          if (helper.centers && helper.centers.length > 0) {
            damageBlocks = helper.centers.map((center, index) => adaptCenterToBlock(center, index));
          } else if (helper.expertise?.damage_blocks && helper.expertise.damage_blocks.length > 0) {
            damageBlocks = helper.expertise.damage_blocks.map((center, index) => adaptCenterToBlock(center, index));
          } else {
            damageBlocks = [];
          }
        }
        
        console.log('🔄 loadDamageCentersFromHelper: Loading', damageBlocks.length, 'damage centers');
        
        // Clear existing content
        damageCentersContent.innerHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters"></div>';
        
        // Add each damage center from helper
        damageBlocks.forEach((block, index) => {
          const newCardHTML = createEditableDamageCenterCard(block, index);
          document.getElementById('editableDamageCenters').insertAdjacentHTML('beforeend', newCardHTML);
        });
        
        // Add הפרשים section before subtotal
        const differentialsHTML = createDifferentialsSection();
        document.getElementById('editableDamageCenters').insertAdjacentHTML('afterend', differentialsHTML);
        
        // Check if differentials exist to determine layout
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        // SESSION 48: Check using new grand_total structure
        const hasDifferentials = helper.final_report?.differential?.has_differentials && 
                                helper.final_report?.differential?.grand_total &&
                                (helper.final_report.differential.grand_total.without_vat > 0 || 
                                 helper.final_report.differential.grand_total.with_vat > 0);
        
        // Add subtotal section after differentials
        const subtotalHTML = createDamageCentersSubtotal(hasDifferentials);
        document.getElementById('differentialsSection').insertAdjacentHTML('afterend', subtotalHTML);
        
        // SESSION 62: Add case reduction section before נתוני תביעה
        const caseReductionHTML = createCaseReductionSection();
        document.getElementById('caseReductionPlaceholder').insertAdjacentHTML('afterend', caseReductionHTML);
        
        // Reposition save button after subtotal is added
        setTimeout(repositionDamageCentersSaveButton, 100);
        
        // Add event listeners
        setTimeout(() => {
          addDamageCenterEventListeners();
          updateAllCostDisplays();
          
          // DON'T auto-update depreciation - preserve manual entries
          // updateDepreciationFromDamageCenters([]);
          // Update damage assessment totals
          updateDamageAssessmentSummary(window.helper || {});
        }, 100);
        
        
      } catch (error) {
        console.error('Error loading damage centers from helper:', error);
      }
    }
    
    // ADD FIELD CHANGE LISTENERS - CRITICAL FOR HELPER UPDATES
    function addFieldChangeListeners() {
      try {
        console.log('🔗 Adding field change listeners...');
        
        // Car details fields
        const carFields = [
          'carPlate', 'carManufacturer', 'carModel', 'carYear', 'carModelCode',
          'carBasePrice', 'carMarketValue', 'carReportDate', 'carMileage'
        ];
        
        carFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
              
              // Recalculate adjustment values when base price changes
              if (fieldId === 'carBasePrice') {
                console.log('📊 Base price changed, recalculating all adjustment values');
                setTimeout(() => {
                  recalculateAllAdjustmentValues();
                }, 100);
              }
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Contact/communication fields
        const contactFields = [
          'ownerName', 'ownerPhone', 'ownerAddress', 'ownerEmail',
          'insuranceAgent', 'agentPhone', 'agentEmail',
          'insuranceCompany', 'insuranceEmail'
        ];
        
        contactFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Claims data fields
        const claimsFields = ['totalClaim'];
        
        claimsFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
              
              // Update gross percentage when total claim changes
              if (fieldId === 'totalClaim') {
                updateGrossPercentageFromGrossValue();
              }
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Basic price field with special handling for 3-bulk system
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField) {
          basicPriceField.addEventListener('change', function() {
            updateHelperFromField({ target: this });
            updateGrossMarketValueCalculation();
            recalculateAllAdjustmentValues();
          });
          basicPriceField.addEventListener('blur', function() {
            updateHelperFromField({ target: this });
            updateGrossMarketValueCalculation();
          });
        }
        
        // Full basic price field
        const fullBasicPriceField = document.getElementById('fullBasicPrice');
        if (fullBasicPriceField) {
          fullBasicPriceField.addEventListener('change', function() {
            updateHelperFromField({ target: this });
            // updateFullMarketValueCalculation() removed
          });
        }
        
        // Summary data fields
        const summaryFields = ['sumMarketValue', 'sumClaim', 'sumVAT', 'sumTotalClaim', 'depCompensation', 'salvageValue', 'garageDays'];
        
        summaryFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Legal text field
        const legalTextField = document.getElementById('legal-text-content');
        if (legalTextField) {
          legalTextField.addEventListener('change', function() {
            updateHelperFromField({ target: this });
          });
        }
        
        // Final report type change listener
        document.querySelectorAll('input[name="final-report-type"]').forEach(radio => {
          radio.addEventListener('change', function() {
            updateReportType();
            loadLegalText().catch(console.error);
          });
        });
        
        console.log('✅ Field change listeners added successfully');
        
      } catch (error) {
        console.error('Error adding field change listeners:', error);
      }
    }
    
    // INITIALIZE 3-BULK SYSTEM ON PAGE LOAD
    document.addEventListener('DOMContentLoaded', function() {
      console.log('🚀 Initializing 3-bulk system...');
      
      // Wait for all objects to be initialized before loading data
      setTimeout(() => {
        // Load saved helper data first
        loadHelperData();
        
        // Add field change listeners - CRITICAL FOR HELPER UPDATES
        addFieldChangeListeners();
      }, 200);
      
      // Initialize gross calculation data
      setTimeout(() => {
        // loadGrossCalculationData(); // DISABLED - causes duplicate Levi data
        console.log('✅ Bulk 1 & 2 initialized');
        
        // REMOVED: Auto-call updateHelperFromAdjustments on page load to prevent duplication
        // updateHelperFromAdjustments should only be called when user makes actual changes
        // setTimeout(() => {
        //   updateHelperFromAdjustments();
        //   console.log('🔧 Initial helper update completed for Levi floating screen');
        // }, 500);
      }, 500);
      
      // Initialize full market value calculation
      setTimeout(() => {
        loadFullMarketValueData();
        console.log('✅ Bulk 3 initialized');
        console.log('✅ Complete 3-bulk system initialized');
        
        // Restore saved adjustment amounts after data is loaded
        setTimeout(() => {
          console.log('🎯 About to call restoreAdjustmentAmounts...');
          restoreAdjustmentAmounts();
          console.log('✅ Adjustment amounts restored');
          
          // Load additional adjustments UI
          loadAdditionalAdjustments();
          console.log('✅ Additional adjustments loaded');
          
          // Clear flag after restoration is complete
          setTimeout(() => {
            window.pageLoadInProgress = false;
            console.log('✅ Page load complete, sync enabled');
            
            // Trigger final calculations to update cumulative values
            console.log('🔄 Running final calculations to update cumulative values...');
            updateGrossMarketValueCalculation();
            updateFullMarketValueCalculation();
            
            // Sync all adjustments to ensure cumulative values are saved
            setTimeout(() => {
              console.log('🔄 Syncing all adjustment data to helper...');
              
              // CRITICAL: Now safe to run updateFullMarketValueToFinalReportAndValuation after page load
              const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
              updateFullMarketValueToFinalReportAndValuation(helper);
              console.log('💾 Safe to update final_report after page load complete');
              const categories = ['features', 'registration', 'mileage', 'ownership_type', 'ownership_history', 'additional'];
              categories.forEach(category => {
                const containers = {
                  'features': ['featuresAdjustmentsList', 'fullFeaturesAdjustmentsList'],
                  'registration': ['registrationAdjustmentsList', 'fullRegistrationAdjustmentsList'],
                  'mileage': ['mileageAdjustmentsList'],
                  'ownership_type': ['ownershipAdjustmentsList'],
                  'ownership_history': ['ownersAdjustmentsList'],
                  'additional': ['allAdjustmentsList']
                };
                
                const categoryContainers = containers[category] || [];
                categoryContainers.forEach(containerId => {
                  const container = document.getElementById(containerId);
                  if (container) {
                    const firstInput = container.querySelector('input');
                    if (firstInput) {
                      syncAdjustmentToHelper(firstInput, category);
                    }
                  }
                });
              });
              console.log('✅ All adjustments synced with cumulative values');
            }, 100);
          }, 500);
        }, 200);
      }, 700);
      
      // Add event listeners for damage center changes
      const damageCentersContent = document.getElementById('damageCentersContent');
      if (damageCentersContent) {
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'childList' || mutation.type === 'subtree') {
              // When damage centers change, update second bulk
              setTimeout(() => {
                refreshSecondBulkFields();
              }, 100);
            }
          });
        });
        
        observer.observe(damageCentersContent, {
          childList: true,
          subtree: true
        });
      }
    });
    
    // ENHANCED SAVE DAMAGE CENTER CHANGES TO TRIGGER BULK UPDATES
    const originalSaveDamageCenterChanges = saveDamageCenterChanges;
    saveDamageCenterChanges = function() {
      originalSaveDamageCenterChanges.call(this);
      
      // After saving damage centers, update second bulk
      setTimeout(() => {
        refreshSecondBulkFields();
      }, 100);
    };
    
    // ENHANCED UPDATE ALL COST DISPLAYS TO TRIGGER BULK UPDATES
    const originalUpdateAllCostDisplays = updateAllCostDisplays;
    updateAllCostDisplays = function() {
      originalUpdateAllCostDisplays.call(this);
      
      // After updating costs, update second bulk
      setTimeout(() => {
        refreshSecondBulkFields();
      }, 100);
    };
    
    // ENHANCED CALCULATE SUMMARY TOTALS TO TRIGGER BULK UPDATES
    const originalCalculateSummaryTotals = calculateSummaryTotals;
    calculateSummaryTotals = function() {
      originalCalculateSummaryTotals.call(this);
      
      // After calculating summary totals, update second bulk
      setTimeout(() => {
        refreshSecondBulkFields();
      }, 100);
    };
    
    // GLOBAL FUNCTIONS FOR EXTERNAL ACCESS
    window.calculateGrossMarketValue = calculateGrossMarketValue;
    window.calculateGrossPercentage = calculateGrossPercentage;
    window.calculateFullMarketValue = calculateFullMarketValue;
    window.refreshSecondBulkFields = refreshSecondBulkFields;
    window.updateGrossMarketValueCalculation = updateGrossMarketValueCalculation;
    window.updateGrossPercentageFromGrossValue = updateGrossPercentageFromGrossValue;
    window.updateFullMarketValueCalculation = updateFullMarketValueCalculation;
    window.testFullCalculation = updateFullMarketValueCalculation; // Easy test function
    
    // Test function to verify dropdown functionality
    window.testDropdowns = function() {
      console.log('🔧 Testing all dropdowns in FULL section...');
      const containers = ['mileageAdjustmentsList', 'ownershipAdjustmentsList', 'ownersAdjustmentsList'];
      
      containers.forEach(containerId => {
        const container = document.getElementById(containerId);
        if (container) {
          const dropdowns = container.querySelectorAll('select');
          dropdowns.forEach((dropdown, index) => {
            console.log(`🔧 ${containerId} dropdown[${index}]:`, dropdown.value, 'onchange:', dropdown.onchange ? 'EXISTS' : 'MISSING');
            
            // Test changing the dropdown
            const originalValue = dropdown.value;
            const newValue = originalValue === 'plus' ? 'minus' : 'plus';
            console.log(`🔧 Changing ${containerId} dropdown[${index}] from ${originalValue} to ${newValue}`);
            dropdown.value = newValue;
            dropdown.dispatchEvent(new Event('change', { bubbles: true }));
            
            // Change it back
            setTimeout(() => {
              dropdown.value = originalValue;
              dropdown.dispatchEvent(new Event('change', { bubbles: true }));
            }, 100);
          });
        }
      });
    };
    window.loadFullMarketValueData = loadFullMarketValueData;
    window.addFullMarketAdjustment = addFullMarketAdjustment;
    window.debugCalculations = debugCalculations;
    
    // Global debug function for helper data structure investigation
    window.debugHelperDataStructure = function() {
      console.group('🔍 HELPER DATA STRUCTURE INVESTIGATION');
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      console.log('=== HELPER OVERVIEW ===');
      console.log('Helper keys:', Object.keys(helper));
      console.log('Helper size:', JSON.stringify(helper).length, 'characters');
      
      console.log('\n=== BASE PRICE INVESTIGATION ===');
      const basePriceLocations = {
        'helper.levi_report?.base_price': helper.levi_report?.base_price,
        'helper.expertise?.levi_report?.base_price': helper.expertise?.levi_report?.base_price,
        'helper.levisummary?.base_price': helper.levisummary?.base_price,
        'helper.car_details?.base_price': helper.car_details?.base_price,
        'helper.vehicle?.base_price': helper.vehicle?.base_price,
        'helper.calculations?.base_price': helper.calculations?.base_price,
        'helper.expertise?.calculations?.base_price': helper.expertise?.calculations?.base_price
      };
      
      Object.entries(basePriceLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`✅ FOUND: ${path} = ${value}`);
        } else {
          console.log(`❌ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== VEHICLE VALUE GROSS INVESTIGATION ===');
      const vehicleValueLocations = {
        'helper.calculations?.vehicle_value_gross': helper.calculations?.vehicle_value_gross,
        'helper.expertise?.calculations?.vehicle_value_gross': helper.expertise?.calculations?.vehicle_value_gross,
        'helper.levi_report?.final_price': helper.levi_report?.final_price,
        'helper.expertise?.levi_report?.final_price': helper.expertise?.levi_report?.final_price,
        'helper.levisummary?.final_price': helper.levisummary?.final_price
      };
      
      Object.entries(vehicleValueLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`✅ FOUND: ${path} = ${value}`);
        } else {
          console.log(`❌ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== DAMAGE DATA INVESTIGATION ===');
      const damageLocations = {
        'helper.expertise?.damage_blocks': helper.expertise?.damage_blocks,
        'helper.damage_centers': helper.damage_centers,
        'helper.damage_sections': helper.damage_sections,
        'helper.expertise?.damage_sections': helper.expertise?.damage_sections
      };
      
      Object.entries(damageLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`✅ FOUND: ${path} = ${Array.isArray(value) ? value.length + ' items' : typeof value}`);
          if (Array.isArray(value) && value.length > 0) {
            console.log(`  First item keys:`, Object.keys(value[0]));
          }
        } else {
          console.log(`❌ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== CALCULATION INVESTIGATION ===');
      const calculationLocations = {
        'helper.calculations': helper.calculations,
        'helper.expertise?.calculations': helper.expertise?.calculations
      };
      
      Object.entries(calculationLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`✅ FOUND: ${path} =`, value);
        } else {
          console.log(`❌ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== LEVI DATA INVESTIGATION ===');
      const leviLocations = {
        'helper.levi_report': helper.levi_report,
        'helper.expertise?.levi_report': helper.expertise?.levi_report,
        'helper.levisummary': helper.levisummary
      };
      
      Object.entries(leviLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`✅ FOUND: ${path} =`, value);
        } else {
          console.log(`❌ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== RAW SESSION STORAGE ===');
      console.log('sessionStorage.getItem("helper"):', sessionStorage.getItem('helper'));
      
      console.groupEnd();
      
      return helper;
    };
    
    // Manual trigger for all calculations
    window.forceCalculateAllAdjustments = function() {
      console.log('🔄 Forcing calculation of all adjustments...');
      
      // First ensure basic price is loaded
      loadHelperData();
      
      setTimeout(() => {
        // Calculate all adjustment values
        const allPercentInputs = document.querySelectorAll('#featuresAdjustmentsList input[placeholder="אחוז"], #registrationAdjustmentsList input[placeholder="אחוז"]');
        console.log(`Found ${allPercentInputs.length} percentage inputs`);
        
        allPercentInputs.forEach((input, index) => {
          if (input.value) {
            console.log(`Calculating adjustment ${index + 1}: ${input.value}`);
            calculateAdjustmentValue(input);
          }
        });
        
        // Update gross market value calculation
        updateGrossMarketValueCalculation();
        
        console.log('✅ All adjustment calculations completed');
      }, 200);
    };
    
    console.log('🎯 3-bulk system functions loaded and ready');
    
    // SECTION-SPECIFIC SAVE AND REFRESH FUNCTIONALITY
    
    // Section configuration mapping - Updated to include ALL sections with editable fields
    const sectionConfig = {
      'final-report-type': {
        helperKey: 'manual_final_report_type',
        fields: ['final-report-type'],
        loadFunction: null,
        name: 'סוג אומדן'
      },
      'vehicle-data': {
        helperKey: 'manual_vehicle_data',
        fields: ['carPlate', 'carManufacturer', 'carModel', 'carYear', 'carModelCode', 'carBasePrice', 'carMarketValue', 'carReportDate'],
        loadFunction: 'loadVehicleData',
        name: 'נתוני הרכב'
      },
      'contact-data': {
        helperKey: 'manual_contact_data',
        fields: ['ownerName', 'ownerAddress', 'ownerPhone', 'insuranceCompany', 'insuranceEmail', 'insuranceAgent', 'insuranceAgentPhone', 'insuranceAgentEmail'],
        loadFunction: 'loadContactData',
        name: 'פרטי קשר'
      },
      'damage-centers': {
        helperKey: 'manual_damage_centers',
        fields: [],
        loadFunction: 'loadDamageCentersFromHelper',
        name: 'מרכזי נזק',
        dynamicContent: true
      },
      'gross-calculation': {
        helperKey: 'manual_gross_calculation',
        fields: ['basicPrice'],
        loadFunction: 'loadGrossCalculationData',
        name: 'חישוב אחוז נזק ברוטו',
        dynamicContent: true
      },
      'gross-result': {
        helperKey: 'manual_gross_result',
        fields: ['grossMarketValueResult', 'totalClaim', 'grossPercent'],
        loadFunction: null,
        name: 'תוצאת חישוב ברוטו'
      },
      'full-market-value': {
        helperKey: 'manual_full_market_value',
        fields: ['fullBasicPrice', 'fullMarketValueResult'],
        loadFunction: 'loadFullMarketValueData',
        name: 'חישוב ערך השוק המלא',
        dynamicContent: true
      },
      'depreciation': {
        helperKey: 'depreciation',
        fields: ['globalDep1', 'globalDepValue', 'garageDays'],
        loadFunction: 'loadDepreciationData',
        name: 'חישוב ירידת ערך',
        dynamicContent: true
      },
      'summary': {
        helperKey: 'manual_summary',
        fields: ['sumMarketValue', 'sumClaim', 'sumGrossPercent', 'sumAuthorizedClaim', 'sumTotalVat', 'sumSalvageValue', 'sumNetClaim'],
        loadFunction: 'loadSummaryData',
        name: 'סיכום חוות הדעת'
      },
      'notes': {
        helperKey: 'manual_notes',
        fields: ['additional-notes'],
        loadFunction: null,
        name: 'הערות נוספות'
      },
      'legal-text': {
        helperKey: 'manual_legal_text',
        fields: ['legal-text'],
        loadFunction: 'loadLegalText',
        name: 'טקסט משפטי'
      }
    };
    
    // Generic save function for any section
    function saveSectionData(sectionId) {
      try {
        const config = sectionConfig[sectionId];
        if (!config) {
          console.error(`Unknown section: ${sectionId}`);
          return;
        }
        
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        const sectionData = {};
        
        // Collect data from all fields in the section
        config.fields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            if (field.type === 'radio') {
              const checked = document.querySelector(`input[name="${field.name}"]:checked`);
              sectionData[fieldId] = checked ? checked.value : '';
            } else {
              sectionData[fieldId] = field.value;
            }
          }
        });
        
        // Handle special cases for dynamic content
        if (sectionId === 'final-report-type') {
          const checkedRadio = document.querySelector('input[name="final-report-type"]:checked');
          sectionData.finalReportType = checkedRadio ? checkedRadio.value : '';
        } else if (sectionId === 'damage-centers') {
          sectionData.damageCenters = collectDamageCentersData();
        } else if (sectionId === 'gross-calculation') {
          sectionData.featuresAdjustments = collectAdjustmentData('#featuresAdjustmentsList');
          sectionData.registrationAdjustments = collectAdjustmentData('#registrationAdjustmentsList');
        } else if (sectionId === 'full-market-value') {
          // CRITICAL FIX: Save ALL adjustment categories, not just additional
          // Use the proven syncAdjustmentToHelper pattern to preserve user edits
          console.log('💾 FULL-MARKET-VALUE SAVE: Using syncAdjustmentToHelper to preserve all user edits');
          
          const categories = [
            { category: 'features', containerId: 'fullFeaturesAdjustmentsList' },
            { category: 'registration', containerId: 'fullRegistrationAdjustmentsList' },
            { category: 'mileage', containerId: 'mileageAdjustmentsList' },
            { category: 'ownership_type', containerId: 'ownershipAdjustmentsList' },
            { category: 'ownership_history', containerId: 'ownersAdjustmentsList' },
            { category: 'additional', containerId: 'allAdjustmentsList' }
          ];
          
          categories.forEach(({ category, containerId }) => {
            const container = document.getElementById(containerId);
            if (container && container.children.length > 0) {
              // Trigger syncAdjustmentToHelper for each category to preserve user edits
              const firstInput = container.children[0].querySelector('input');
              if (firstInput) {
                console.log(`💾 Saving ${category} from ${containerId} using syncAdjustmentToHelper`);
                syncAdjustmentToHelper(firstInput, category);
              }
            }
          });
          
          // Also collect for backward compatibility
          sectionData.allAdjustments = collectAdjustmentData('#allAdjustmentsList');
        } else if (sectionId === 'depreciation') {
          // ✅ FIX: Use saveDepreciationData() instead of collectDepreciationData() to avoid conflicts
          saveDepreciationData();
          return; // Exit early, saveDepreciationData handles everything
        }
        
        // Save to helper with timestamp
        helper[config.helperKey] = {
          ...sectionData,
          lastSaved: new Date().toISOString(),
          isManualSave: true
        };
        
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        
        // Show success message
        showSectionMessage(sectionId, `✅ ${config.name} נשמר בהצלחה`, 'success');
        
        // Trigger refresh for related screens
        triggerFloatingScreenRefresh();
        
        console.log(`✅ Section ${sectionId} saved successfully`);
        
      } catch (error) {
        console.error(`Error saving section ${sectionId}:`, error);
        showSectionMessage(sectionId, `❌ שגיאה בשמירת ${config.name}`, 'error');
      }
    }
    
    // Update depreciation calculations for all fields
    function updateDepreciationCalculation() {
      try {
        // Trigger calculation for global depreciation
        const globalDepInput = document.getElementById('globalDep1');
        if (globalDepInput && globalDepInput.value) {
          const event = new Event('input', { bubbles: true });
          globalDepInput.dispatchEvent(event);
        }
        
        // Trigger calculation for all bulk depreciation rows
        const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
        depRows.forEach(row => {
          const percentInput = row.querySelector('input[placeholder="ירידת ערך (מספר)"]');
          if (percentInput && percentInput.value) {
            const event = new Event('input', { bubbles: true });
            percentInput.dispatchEvent(event);
          }
        });
        
        console.log('📊 Depreciation calculations updated');
      } catch (error) {
        console.error('Error updating depreciation calculations:', error);
      }
    }
    
    // Refresh system - SIMPLE VERSION: Just reload page
    function refreshSectionData(sectionId) {
      console.log(`🔄 Refreshing section ${sectionId} by reloading page...`);
      window.location.reload();
    }
    
    // Helper function to collect adjustment data from dynamic tables
    function collectAdjustmentData(containerSelector) {
      const container = document.querySelector(containerSelector);
      if (!container) return [];
      
      const adjustments = [];
      container.querySelectorAll('div[class*="adjustment-row"], div[id*="Adj_"]').forEach(row => {
        const inputs = row.querySelectorAll('input');
        const select = row.querySelector('select');
        
        if (inputs.length >= 2) {
          adjustments.push({
            description: inputs[0].value,
            percentage: inputs[1].value,
            value: inputs[2] ? inputs[2].value : '',
            type: select ? select.value : 'plus'
          });
        }
      });
      
      return adjustments;
    }
    
    // Helper function to collect depreciation data
    function collectDepreciationData(containerSelector) {
      const container = document.querySelector(containerSelector);
      if (!container) return [];
      
      console.log('🔄 Collecting depreciation data from container:', containerSelector);
      const depreciations = [];
      container.querySelectorAll('div[class*="dep-row"], div[id*="depRow_"]').forEach(row => {
        const inputs = row.querySelectorAll('input');
        
        // Depreciation rows have 5 inputs: center_number, damaged_part, repair_type, percent, value
        if (inputs.length >= 5) {
          depreciations.push({
            center_number: inputs[0].value,
            damaged_part: inputs[1].value,
            repair_type: inputs[2].value,
            percent: inputs[3].value,
            value: inputs[4].value
          });
        } else if (inputs.length >= 4) {
          // Fallback for older format (missing center_number)
          depreciations.push({
            center_number: '',
            damaged_part: inputs[0].value,
            repair_type: inputs[1].value,
            percent: inputs[2].value,
            value: inputs[3].value
          });
        }
      });
      
      console.log('🔄 Collected depreciation data:', depreciations);
      return depreciations;
    }
    
    // Helper function to collect damage centers data
    function collectDamageCentersData() {
      const container = document.getElementById('damageCentersContent');
      if (!container) return [];
      
      const damageCenters = [];
      container.querySelectorAll('div[class*="damage-center-card"], div[id*="damage-center-"]').forEach(card => {
        const nameInput = card.querySelector('input[id*="damage-center-name"]');
        const center = {
          name: nameInput ? nameInput.value : '',
          parts: [],
          works: [],
          repairs: []
        };
        
        // Collect parts
        card.querySelectorAll('div[id*="parts-"] input').forEach((input, index) => {
          if (index % 2 === 0) { // Name inputs
            const priceInput = card.querySelector(`div[id*="parts-"] input:nth-child(${index + 2})`);
            center.parts.push({
              name: input.value,
              price: priceInput ? priceInput.value : ''
            });
          }
        });
        
        // Collect works
        card.querySelectorAll('div[id*="works-"] input').forEach((input, index) => {
          if (index % 2 === 0) { // Name inputs
            const priceInput = card.querySelector(`div[id*="works-"] input:nth-child(${index + 2})`);
            center.works.push({
              name: input.value,
              price: priceInput ? priceInput.value : ''
            });
          }
        });
        
        // Collect repairs
        card.querySelectorAll('div[id*="repairs-"] input').forEach((input, index) => {
          if (index % 2 === 0) { // Name inputs
            const priceInput = card.querySelector(`div[id*="repairs-"] input:nth-child(${index + 2})`);
            center.repairs.push({
              name: input.value,
              price: priceInput ? priceInput.value : ''
            });
          }
        });
        
        damageCenters.push(center);
      });
      
      return damageCenters;
    }
    
    // Helper function to restore damage centers data from manual save
    function restoreDamageCentersData(damageCenters) {
      try {
        console.log('🔄 Restoring damage centers data from manual save:', damageCenters);
        
        if (!damageCenters || !Array.isArray(damageCenters)) {
          console.log('❌ No valid damage centers data to restore');
          return;
        }
        
        const container = document.getElementById('damageCentersContent');
        if (!container) {
          console.error('❌ Damage centers container not found');
          return;
        }
        
        // Clear existing content
        container.innerHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters"></div>';
        const editableContainer = document.getElementById('editableDamageCenters');
        
        // Restore each damage center
        damageCenters.forEach((centerData, index) => {
          // Create simplified damage center structure for restoration
          const adaptedCenter = {
            damage_center_name: centerData.name || `מוקד נזק ${index + 1}`,
            damage_center_number: index + 1,
            description: '',
            parts: centerData.parts || [],
            works: centerData.works || [],
            repairs: centerData.repairs || []
          };
          
          // Use existing function to create the card
          const newCardHTML = createEditableDamageCenterCard(adaptedCenter, index);
          editableContainer.insertAdjacentHTML('beforeend', newCardHTML);
        });
        
        // Add event listeners and update calculations
        setTimeout(() => {
          addDamageCenterEventListeners();
          updateAllCostDisplays();
          // DON'T auto-update depreciation - preserve manual entries
          // updateDepreciationFromDamageCenters([]);
          // Update damage assessment totals
          updateDamageAssessmentSummary(window.helper || {});
        }, 100);
        
        
      } catch (error) {
        console.error('❌ Error restoring damage centers data:', error);
      }
    }
    
    // Helper function to restore adjustment data to dynamic tables
    function restoreAdjustmentData(containerSelector, adjustments) {
      const container = document.querySelector(containerSelector);
      if (!container) return;
      
      // Clear existing rows
      container.innerHTML = '';
      
      // Add each adjustment
      adjustments.forEach(adj => {
        // Use existing add functions
        if (containerSelector.includes('features')) {
          addFeatureAdjustment();
        } else if (containerSelector.includes('registration')) {
          addRegistrationAdjustment();
        } else if (containerSelector.includes('allAdjustments')) {
          addFullMarketAdjustment();
        }
        
        // Fill the last added row
        const lastRow = container.querySelector('div:last-child');
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input');
          const select = lastRow.querySelector('select');
          
          if (inputs[0]) inputs[0].value = adj.description;
          if (inputs[1]) inputs[1].value = adj.percentage;
          if (inputs[2]) inputs[2].value = adj.value;
          if (select) select.value = adj.type;
        }
      });
    }
    
    // Helper function to restore depreciation data
    function restoreDepreciationData(containerSelector, depreciations) {
      try {
        console.log('🔄 Restoring depreciation data:', depreciations);
        
        const container = document.querySelector(containerSelector);
        if (!container) {
          console.error('❌ Depreciation container not found:', containerSelector);
          return;
        }
        
        // Clear existing rows
        container.innerHTML = '';
        
        // Add each depreciation
        if (Array.isArray(depreciations)) {
          depreciations.forEach(dep => {
            console.log('🔄 Restoring depreciation item:', dep);
            addDepField(dep);
          });
        }
        
        
      } catch (error) {
        console.error('❌ Error restoring depreciation data:', error);
      }
    }
    
    
    // Helper function to show section messages
    function showSectionMessage(sectionId, message, type) {
      const messageId = `section-message-${sectionId}`;
      let messageDiv = document.getElementById(messageId);
      
      if (!messageDiv) {
        messageDiv = document.createElement('div');
        messageDiv.id = messageId;
        messageDiv.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 10px 15px;
          border-radius: 5px;
          font-size: 14px;
          font-weight: bold;
          z-index: 9999;
          box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          transition: all 0.3s ease;
        `;
        document.body.appendChild(messageDiv);
      }
      
      // Set message style based on type
      const colors = {
        success: { bg: '#d4edda', text: '#155724', border: '#c3e6cb' },
        error: { bg: '#f8d7da', text: '#721c24', border: '#f5c6cb' },
        info: { bg: '#d1ecf1', text: '#0c5460', border: '#bee5eb' }
      };
      
      const color = colors[type] || colors.info;
      messageDiv.style.backgroundColor = color.bg;
      messageDiv.style.color = color.text;
      messageDiv.style.border = `1px solid ${color.border}`;
      messageDiv.textContent = message;
      
      // Auto-hide after 3 seconds
      setTimeout(() => {
        if (messageDiv.parentNode) {
          messageDiv.parentNode.removeChild(messageDiv);
        }
      }, 3000);
    }
    
    // Function to add Save and Refresh buttons to sections with editable fields
    function addSectionButtons() {
      // Define sections that should have save buttons with auto-refresh
      const sections = [
        { id: 'vehicle-data', selector: '#vehicleData', name: 'נתוני הרכב', collapsible: true },
        { id: 'contact-data', selector: '#contactData', name: 'פרטי קשר', collapsible: true },
        { id: 'damage-centers', selector: '#damageCentersContent', name: 'מרכזי נזק', collapsible: true },
        { id: 'gross-calculation', selector: '#grossCalc', name: 'חישוב אחוז נזק ברוטו', collapsible: true },
        { id: 'gross-result', selector: '#grossPercentageResult', name: 'תוצאת חישוב ברוטו', collapsible: true },
        { id: 'full-market-value', selector: '#fullMarketValue', name: 'חישוב ערך השוק המלא', collapsible: true },
        { id: 'depreciation', selector: '#depreciationContent', name: 'חישוב ירידת ערך לפי מוקדי נזק', collapsible: true },
        { id: 'summary', selector: '#sumMarketValue', name: 'סיכום חוות הדעת', collapsible: false },
        { id: 'notes', selector: '#additional-notes', name: 'הערות נוספות', collapsible: false },
        { id: 'legal-text', selector: '#legal-text-content', name: 'טקסט משפטי', collapsible: false }
      ];
      
      sections.forEach(section => {
        let sectionElement = null;
        
        // For collapsible sections, find by ID
        if (section.collapsible) {
          sectionElement = document.getElementById(section.selector.replace('#', ''));
        } else {
          // For non-collapsible sections, find by selector and get parent form-section
          const keyElement = document.querySelector(section.selector);
          if (keyElement) {
            sectionElement = keyElement.closest('.form-section');
            if (!sectionElement) {
              sectionElement = keyElement.parentElement;
              while (sectionElement && !sectionElement.classList.contains('form-section')) {
                sectionElement = sectionElement.parentElement;
              }
            }
          }
        }
        
        if (sectionElement) {
          // Check if save button already exists
          if (sectionElement.querySelector('.section-save-button')) {
            return; // Skip if button already exists
          }
          
          // Create a container for both buttons
          const buttonContainer = document.createElement('div');
          buttonContainer.style.cssText = `
            display: flex;
            gap: 10px;
            margin-top: 12px;
            margin-bottom: 8px;
            justify-content: flex-start;
            margin-left: 15px;
          `;
          
          // Create save button with auto-refresh functionality
          const saveButton = document.createElement('button');
          saveButton.className = 'btn section-save-button';
          saveButton.textContent = 'שמור';
          saveButton.style.cssText = `
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            display: inline-block;
            width: auto;
            transition: background-color 0.3s;
          `;
          saveButton.onmouseover = function() { this.style.background = '#218838'; };
          saveButton.onmouseout = function() { this.style.background = '#28a745'; };
          saveButton.onclick = function() { 
            console.log('💾 Saving section to helper:', section.id);
            saveSectionData(section.id);
            console.log('✅ Section saved successfully - no page refresh');
          };
          
          // Create collapse button
          const collapseButton = document.createElement('button');
          collapseButton.className = 'btn section-collapse-button';
          collapseButton.textContent = 'כווץ';
          collapseButton.style.cssText = `
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            display: inline-block;
            width: auto;
            transition: background-color 0.3s;
          `;
          collapseButton.onmouseover = function() { this.style.background = '#5a6268'; };
          collapseButton.onmouseout = function() { this.style.background = '#6c757d'; };
          collapseButton.onclick = function() {
            // Get the section ID from the selector
            let sectionToToggle = '';
            if (section.id === 'vehicle-data') {
              sectionToToggle = 'vehicleData';
            } else if (section.id === 'contact-data') {
              sectionToToggle = 'contactData';
            } else if (section.id === 'damage-centers') {
              sectionToToggle = 'damageCentersSummary';
            } else if (section.id === 'gross-calculation') {
              sectionToToggle = 'grossCalc';
            } else if (section.id === 'gross-result') {
              sectionToToggle = 'grossPercentageResult';
            } else if (section.id === 'full-market-value') {
              sectionToToggle = 'fullMarketValue';
            } else if (section.id === 'depreciation') {
              sectionToToggle = 'depreciationContent';
            }
            
            if (sectionToToggle && window.toggleSection) {
              window.toggleSection(sectionToToggle);
            }
          };
          
          // Add buttons to container
          buttonContainer.appendChild(saveButton);
          
          // Only add collapse button if the section is collapsible
          if (section.collapsible) {
            buttonContainer.appendChild(collapseButton);
          }
          
          // Add button container to section
          if (section.collapsible) {
            // For collapsible sections, add the button to the collapsible content div
            const contentDiv = sectionElement.querySelector('#damageCentersSummary, #priceData, #contactData, #grossCalc, #grossPercentageResult, #fullMarketValue');
            if (contentDiv) {
              // Special handling for damage centers - insert before summary if it exists
              if (section.id === 'damage-centers') {
                const damageCentersSubtotal = contentDiv.querySelector('#damageCentersSubtotal');
                if (damageCentersSubtotal) {
                  // Insert button before the summary section
                  damageCentersSubtotal.parentNode.insertBefore(buttonContainer, damageCentersSubtotal);
                } else {
                  const damageCentersContent = contentDiv.querySelector('#damageCentersContent');
                  if (damageCentersContent) {
                    // Insert button right after damageCentersContent if no summary exists
                    damageCentersContent.parentNode.insertBefore(buttonContainer, damageCentersContent.nextSibling);
                  } else {
                    contentDiv.appendChild(buttonContainer);
                  }
                }
              } else {
                contentDiv.appendChild(buttonContainer);
              }
            } else {
              sectionElement.appendChild(buttonContainer);
            }
          } else {
            sectionElement.appendChild(buttonContainer);
          }
          
          console.log(`✅ Added Save button with auto-refresh to section: ${section.name} (collapsible: ${section.collapsible})`);
        }
      });
    }
    
    // Initialize section buttons when page loads
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(() => {
        addSectionButtons();
        
        // Restore damage centers section state (default collapsed)
        const damageCentersState = sessionStorage.getItem('damageCentersSection') || 'collapsed';
        const damageCentersSection = document.getElementById('damageCentersSummary');
        const damageCentersToggleBtn = document.getElementById('damageCentersToggleBtn');
        if (damageCentersSection && damageCentersToggleBtn) {
          if (damageCentersState === 'collapsed') {
            damageCentersSection.style.display = 'none';
            damageCentersToggleBtn.innerHTML = '🔼 פתח';
            damageCentersToggleBtn.style.background = '#28a745';
          } else {
            damageCentersSection.style.display = 'block';
            damageCentersToggleBtn.innerHTML = '🔽 סגור';
            damageCentersToggleBtn.style.background = '#6c757d';
          }
          console.log(`🔄 Restored damage centers section as ${damageCentersState}`);
        }
        
        // Initialize vehicle data and depreciation sections as collapsed (using standard toggleSection logic)
        const vehicleDataSection = document.getElementById('vehicleData');
        if (vehicleDataSection) {
          vehicleDataSection.style.display = 'none';
          console.log('🔄 Vehicle data section initialized as collapsed');
        }
        
        const depreciationContentSection = document.getElementById('depreciationContent');
        if (depreciationContentSection) {
          depreciationContentSection.style.display = 'none';
          console.log('🔄 Depreciation section initialized as collapsed');
        }
      }, 1000);
    });
    
    console.log('📄 Section Save/Refresh functionality initialized');
    
    // =========================
    // PLATE INPUT AND DOCUMENT ACTIONS FUNCTIONALITY
    // =========================
    
    // Load existing case for builder
    window.loadExistingCaseForBuilder = async function() {
      const plateNumber = document.getElementById('builderPlateInput').value.trim();
      
      if (!plateNumber) {
        alert('אנא הכנס מספר רכב');
        return;
      }
      
      // Validate Supabase authentication
      const authData = sessionStorage.getItem("auth");
      if (!authData) {
        alert('אין אימות - אנא התחבר מחדש');
        window.location.href = 'index.html';
        return;
      }
      
      try {
        const auth = JSON.parse(authData);
        if (!auth.user || !auth.session) {
          alert('אימות לא תקין - אנא התחבר מחדש');
          window.location.href = 'index.html';
          return;
        }
        console.log('✅ Supabase auth validated for report load');
      } catch (error) {
        console.error('Error validating auth:', error);
        alert('שגיאה באימות - אנא התחבר מחדש');
        window.location.href = 'index.html';
        return;
      }
      
      const loadBtn = document.getElementById('builderLoadCaseBtn');
      const originalText = loadBtn.textContent;
      
      try {
        loadBtn.disabled = true;
        loadBtn.textContent = 'טוען תיק...';
        
        // Check if main selection page has loaded a case
        const existingHelper = sessionStorage.getItem('helper');
        const existingPlate = sessionStorage.getItem('plate');
        
        if (existingHelper && existingPlate === plateNumber) {
          // Use existing data
          const caseData = JSON.parse(existingHelper);
          
          document.getElementById('builderPlateStatus').style.display = 'block';
          document.getElementById('builderPlateStatus').textContent = '✓ נתוני הרכב נטענו בהצלחה';
          document.getElementById('builderPlateStatus').style.color = '#059669';
          
          // Update car details from helper
          if (caseData.car_details) {
            document.getElementById('carPlate').value = caseData.car_details.plate || caseData.meta?.plate || '';
            document.getElementById('carManufacturer').value = caseData.car_details.manufacturer || '';
            document.getElementById('carModel').value = caseData.car_details.model || '';
            document.getElementById('carYear').value = caseData.car_details.year || '';
            document.getElementById('carModelCode').value = caseData.car_details.model_code || '';
            document.getElementById('carReportDate').value = convertToDateInputFormat(caseData.car_details.report_date || '');
          }
          
          // Update page title
          // Standardize plate format
          const standardizedPlateNumber = String(plateNumber).replace(/[-\s]/g, '');
          document.getElementById('pageTitle').textContent = `רכב מס. ${standardizedPlateNumber}`;
          
          return;
        }
        
        // Make webhook call to load case
        const payload = { plate: plateNumber };
        if (password) {
          payload.password = password;
        }
        
        // Import webhook function
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('ADMIN_FETCH_CASE', payload);
        
        if (response?.success && response?.data) {
          const caseData = response.data;
          
          // Store the data
          sessionStorage.setItem('helper', JSON.stringify(caseData));
          sessionStorage.setItem('plate', plateNumber);
          sessionStorage.setItem('caseLoaded', 'true');
          
          document.getElementById('builderPlateStatus').style.display = 'block';
          document.getElementById('builderPlateStatus').textContent = '✓ נתוני הרכב נטענו בהצלחה';
          document.getElementById('builderPlateStatus').style.color = '#059669';
          
          // Update car details from helper
          if (caseData.car_details) {
            document.getElementById('carPlate').value = caseData.car_details.plate || caseData.meta?.plate || '';
            document.getElementById('carManufacturer').value = caseData.car_details.manufacturer || '';
            document.getElementById('carModel').value = caseData.car_details.model || '';
            document.getElementById('carYear').value = caseData.car_details.year || '';
            document.getElementById('carModelCode').value = caseData.car_details.model_code || '';
            document.getElementById('carReportDate').value = convertToDateInputFormat(caseData.car_details.report_date || '');
          }
          
          // Update page title
          // Standardize plate format
          const standardizedPlateNumber = String(plateNumber).replace(/[-\s]/g, '');
          document.getElementById('pageTitle').textContent = `רכב מס. ${standardizedPlateNumber}`;
          
          // Reload data from helper
          loadDataFromHelper();
          
        } else {
          document.getElementById('builderPlateStatus').style.display = 'block';
          document.getElementById('builderPlateStatus').textContent = '❌ תיק לא נמצא במערכת';
          document.getElementById('builderPlateStatus').style.color = '#dc2626';
        }
        
      } catch (error) {
        console.error('Error loading case:', error);
        document.getElementById('builderPlateStatus').style.display = 'block';
        document.getElementById('builderPlateStatus').textContent = '❌ שגיאה בטעינת התיק';
        document.getElementById('builderPlateStatus').style.color = '#dc2626';
      } finally {
        loadBtn.disabled = false;
        loadBtn.textContent = originalText;
      }
    };
    
    // Request expertise for builder
    window.requestExpertiseForBuilder = async function() {
      const plateNumber = document.getElementById('builderPlateInput').value.trim();
      const helper = sessionStorage.getItem('helper');
      
      if (!plateNumber) {
        alert('אנא הכנס מספר רכב');
        return;
      }
      
      if (!helper) {
        alert('נתוני התיק לא נמצאו במערכת');
        return;
      }
      
      const requestBtn = document.getElementById('builderRequestExpertiseBtn');
      const originalText = requestBtn.textContent;
      
      try {
        requestBtn.disabled = true;
        requestBtn.textContent = 'מבקש אקספירטיזה...';
        
        const caseData = JSON.parse(helper);
        const payload = {
          plate: plateNumber,
          case_id: caseData.meta?.case_id,
          helper: caseData
        };
        
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('CALL_EXPERTISE', payload);
        
        if (response?.success) {
          const successMessage = response.message || 'האקספירטיזה נשלחה בהצלחה! בדוק את האימייל שלך לקבלת הקובץ.';
          alert(successMessage);
          
          if (response.pdf_url) {
            showFloatingPDF(response.pdf_url, 'אקספירטיזה PDF');
            
            // Update helper with expertise data
            // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
            if (!helper.expertise) helper.expertise = {};
            helper.expertise.document_url = response.pdf_url;
            helper.expertise.requested_at = new Date().toISOString();
            sessionStorage.setItem('helper', JSON.stringify(helper));
            
            // Update button states
            initializeExpertiseButtonState();
          }
        } else {
          alert('שגיאה בשליחת בקשה לאקספירטיזה. אנא נסה שוב.');
        }
        
      } catch (error) {
        console.error('Error requesting expertise:', error);
        alert('שגיאה בשליחת בקשה לאקספירטיזה. אנא נסה שוב.');
      } finally {
        requestBtn.disabled = false;
        requestBtn.textContent = originalText;
      }
    };
    
    // Fetch expertise PDF for builder
    window.fetchExpertisePDFForBuilder = async function() {
      const plateNumber = document.getElementById('builderPlateInput').value.trim();
      const helper = sessionStorage.getItem('helper');
      
      if (!plateNumber) {
        alert('אנא הכנס מספר רכב');
        return;
      }
      
      const fetchBtn = document.getElementById('builderFetchExpertiseBtn');
      const originalText = fetchBtn.textContent;
      
      try {
        fetchBtn.disabled = true;
        fetchBtn.textContent = 'טוען PDF...';
        
        const caseData = helper ? JSON.parse(helper) : null;
        const payload = {
          plate: plateNumber,
          case_id: caseData?.meta?.case_id,
          document_type: 'expertise'
        };
        
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('FETCH_EXPERTISE_PDF', payload);
        
        if (response?.success && response?.pdf_url) {
          showFloatingPDF(response.pdf_url, 'אקספירטיזה PDF');
        } else {
          alert('אקספירטיזה לא נמצאה במערכת או לא הופקה עדיין');
        }
        
      } catch (error) {
        console.error('Error fetching expertise PDF:', error);
        alert('שגיאה בטעינת אקספירטיזה PDF');
      } finally {
        fetchBtn.disabled = false;
        fetchBtn.textContent = originalText;
      }
    };
    
    // Show floating PDF display
    function showFloatingPDF(pdfUrl, title) {
      const overlay = document.getElementById('floatingPdfOverlay');
      const titleElement = document.getElementById('floatingPdfTitle');
      const iframe = document.getElementById('pdfViewer');
      
      titleElement.textContent = title;
      
      console.log(`🔍 Attempting to display PDF: ${pdfUrl}`);
      
      // Try to load PDF in iframe
      iframe.src = pdfUrl;
      
      // Add error handling for iframe loading
      iframe.onload = function() {
        console.log('✅ PDF loaded successfully in iframe');
      };
      
      iframe.onerror = function() {
        console.error('❌ Failed to load PDF in iframe');
        // Fallback: show link to open in new tab
        iframe.style.display = 'none';
        const fallbackDiv = document.createElement('div');
        fallbackDiv.style.cssText = 'padding: 20px; text-align: center; direction: rtl;';
        fallbackDiv.innerHTML = `
          <h3 style="color: #1e3a8a; margin-bottom: 15px;">לא ניתן להציג את הPDF בחלון זה</h3>
          <p style="margin-bottom: 15px;">אנא לחץ על הקישור להצגת הקובץ:</p>
          <a href="${pdfUrl}" target="_blank" style="display: inline-block; padding: 10px 20px; background: #1e3a8a; color: white; text-decoration: none; border-radius: 6px;">
            פתח PDF בחלון חדש
          </a>
        `;
        iframe.parentNode.appendChild(fallbackDiv);
      };
      
      overlay.style.display = 'flex';
      
      // Setup event listeners for controls
      setupFloatingPDFControls();
    }
    
    
    // Setup floating PDF controls with mobile optimization
    function setupFloatingPDFControls() {
      const toggleBtn = document.getElementById('togglePdfBtn');
      const closeBtn = document.getElementById('closePdfBtn');
      const content = document.getElementById('floatingPdfContent');
      const container = document.querySelector('.floating-pdf-container');
      
      // Add touch-friendly event handlers
      function addTouchFriendlyHandler(button, callback) {
        // Handle both click and touch events
        button.addEventListener('click', callback);
        button.addEventListener('touchend', function(e) {
          e.preventDefault();
          callback();
        });
        
        // Add touch visual feedback
        button.addEventListener('touchstart', function() {
          this.style.backgroundColor = 'rgba(255, 255, 255, 0.4)';
        });
        
        button.addEventListener('touchend', function() {
          this.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
        });
      }
      
      // Toggle minimize/maximize with touch support
      addTouchFriendlyHandler(toggleBtn, function() {
        content.classList.toggle('minimized');
        container.classList.toggle('minimized');
        toggleBtn.textContent = content.classList.contains('minimized') ? '□' : '_';
      });
      
      // Close PDF display with touch support
      addTouchFriendlyHandler(closeBtn, function() {
        const overlay = document.getElementById('floatingPdfOverlay');
        const iframe = document.getElementById('pdfViewer');
        overlay.style.display = 'none';
        iframe.src = '';
        
        // Reset minimize state
        content.classList.remove('minimized');
        container.classList.remove('minimized');
        toggleBtn.textContent = '_';
      });
      
      // Close on overlay click
      document.getElementById('floatingPdfOverlay').onclick = function(e) {
        if (e.target === this) {
          closeBtn.click();
        }
      };
    }
    
    // Initialize plate input and password prefill
    document.addEventListener('DOMContentLoaded', function() {
      // Prefill plate from session storage
      const existingPlate = sessionStorage.getItem('plate');
      if (existingPlate) {
        document.getElementById('builderPlateInput').value = existingPlate;
      }
      
      // Prefill password from session storage
      const prefillPassword = sessionStorage.getItem('prefillPassword') || 
                              sessionStorage.getItem('mainGatePassword') || 
                              sessionStorage.getItem('originalPassword');
      if (prefillPassword) {
        document.getElementById('builderPasswordInput').value = prefillPassword;
      }
      
      // Initialize expertise button state
      initializeExpertiseButtonState();
    });

    // Initialize expertise button state based on existing data
    function initializeExpertiseButtonState() {
      const fetchBtn = document.getElementById('builderFetchExpertiseBtn');
      const requestBtn = document.getElementById('builderRequestExpertiseBtn');
      
      if (!fetchBtn || !requestBtn) return;
      
      // Check if expertise exists in helper data
      const helper = sessionStorage.getItem('helper');
      let expertiseExists = false;
      
      if (helper) {
        try {
          const helperData = JSON.parse(helper);
          expertiseExists = helperData.expertise_data?.completed || 
                           helperData.documents?.expertise_pdf || 
                           helperData.expertise?.document_url ||
                           helperData.expertise_pdf;
        } catch (error) {
          console.error('Error parsing helper data:', error);
        }
      }
      
      // Set button states based on expertise existence
      if (expertiseExists) {
        // Enable fetch button
        fetchBtn.disabled = false;
        fetchBtn.style.opacity = '1';
        fetchBtn.style.cursor = 'pointer';
        
        // Change request button to "re-request" style
        requestBtn.textContent = 'בקש אקספירטיזה מחדש';
        requestBtn.style.background = '#f59e0b'; // Orange for re-request
      } else {
        // Disable fetch button
        fetchBtn.disabled = true;
        fetchBtn.style.opacity = '0.5';
        fetchBtn.style.cursor = 'not-allowed';
        
        // Set request button to normal style
        requestBtn.textContent = 'בקש אקספירטיזה';
        requestBtn.style.background = '#059669'; // Green for new request
      }
      
      console.log('🔘 Expertise button state initialized:', { expertiseExists });
    }
    
    // ✅ BIDIRECTIONAL INTEGRATION: Builder State Management
    // This allows validation page to read current builder state instead of helper directly
    function updateBuilderCurrentState(key, value) {
      try {
        let builderState = {};
        
        // Get existing builder state
        const existingState = sessionStorage.getItem('builderCurrentState');
        if (existingState) {
          builderState = JSON.parse(existingState);
        }
        
        // Update the specific key
        builderState[key] = value;
        builderState.last_update = new Date().toISOString();
        builderState.source = 'final-report-builder';
        
        // Save updated state
        sessionStorage.setItem('builderCurrentState', JSON.stringify(builderState));
        
        console.log(`✅ Builder state updated: ${key}`, value);
        
        // Trigger broadcast to validation pages
        if (typeof broadcastBuilderStateUpdate === 'function') {
          broadcastBuilderStateUpdate(key, value);
        }
        
      } catch (error) {
        console.error('❌ Error updating builder state:', error);
      }
    }
    
    // Initialize builder state when page loads
    function initializeBuilderState() {
      try {
        console.log('📝 Final Report Builder: Initializing with ENHANCED helper integration...');
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // ENHANCED: Create initial builder state from proper helper paths
        const initialState = {
          // Car details - use proper vehicle section
          plate: helper.vehicle?.plate || helper.meta?.plate,
          manufacturer: helper.vehicle?.manufacturer || helper.car_details?.manufacturer,
          model: helper.vehicle?.model || helper.car_details?.model,
          year: helper.vehicle?.year || helper.car_details?.year,
          
          // Owner details - use stakeholders section
          owner_name: helper.stakeholders?.owner?.name || helper.client?.name || helper.owner,
          owner_address: helper.stakeholders?.owner?.address,
          owner_phone: helper.stakeholders?.owner?.phone,
          insurance_company: helper.stakeholders?.insurance?.company || helper.client?.insurance_company || helper.insurance_company,
          
          // Final report data - use final report section
          final_report_type: helper.final_report?.type || helper.final_report_type,
          final_report_notes: helper.final_report?.notes || helper.final_report_notes,
          final_report_work_days: helper.final_report?.work_days || helper.final_report_work_days,
          // Legal text for final report comes from final_report object
          final_report_legal_text: helper.final_report?.legal_text || '',
          final_report_depreciation: helper.final_report?.depreciation,
          
          // Calculations
          calculations: helper.calculations,
          claims_data: helper.claims_data,
          
          // Metadata
          initialized_at: new Date().toISOString(),
          source: 'final-report-builder',
          version: '1.0'
        };
        
        sessionStorage.setItem('builderCurrentState', JSON.stringify(initialState));
        console.log('🏗️ Builder state initialized from helper data');
        
      } catch (error) {
        console.error('❌ Error initializing builder state:', error);
      }
    }
    
    // Initialize builder state when page loads
    document.addEventListener('DOMContentLoaded', initializeBuilderState);
    
    
    
    // Update helper structure from contact field changes using field mapping dictionary
    function updateHelperFromContactField(element) {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        const fieldId = element.id;
        const value = element.value;
        
        console.log(`📝 Contact field change: ${fieldId} = "${value}"`);
        
        // Set nested value helper function
        const setNestedValue = (obj, path, val) => {
          const keys = path.split('.');
          let current = obj;
          for (let i = 0; i < keys.length - 1; i++) {
            const key = keys[i];
            if (!(key in current) || typeof current[key] !== 'object') {
              current[key] = {};
            }
            current = current[key];
          }
          current[keys[keys.length - 1]] = val;
        };
        
        // Map field IDs to helper structure paths using field mapping dictionary
        const fieldMappings = {
          'ownerName': 'stakeholders.owner.name',
          'ownerAddress': 'stakeholders.owner.address', 
          'ownerPhone': 'stakeholders.owner.phone',
          'insuranceCompany': 'stakeholders.insurance.company',
          'insuranceEmail': 'stakeholders.insurance.email',
          'insuranceAgent': 'stakeholders.insurance.agent.name',
          'agentPhone': 'stakeholders.insurance.agent.phone',
          'agentEmail': 'stakeholders.insurance.agent.email',
          'garageName': 'stakeholders.garage.name',
          'garagePhone': 'stakeholders.garage.phone',
          'garageEmail': 'stakeholders.garage.email',
          'carReportDate': 'case_info.issue_date'
        };
        
        // Update standardized helper structure
        if (fieldMappings[fieldId]) {
          setNestedValue(helper, fieldMappings[fieldId], value);
          console.log(`✅ Updated ${fieldMappings[fieldId]} = "${value}"`);
        }
        
        // Also maintain legacy structure for backward compatibility
        helper.client = helper.client || {};
        helper.car_details = helper.car_details || {};
        
        const legacyMappings = {
          'ownerName': () => {
            helper.client.name = value;
            helper.car_details.owner = value;
          },
          'ownerAddress': () => {
            helper.client.address = value;
            helper.car_details.ownerAddress = value;
          },
          'ownerPhone': () => {
            helper.client.phone = value;
            helper.car_details.ownerPhone = value;
          },
          'insuranceCompany': () => {
            helper.client.insurance_company = value;
            helper.car_details.insuranceCompany = value;
          },
          'insuranceEmail': () => {
            helper.client.insurance_email = value;
          },
          'insuranceAgent': () => {
            helper.client.insurance_agent = value;
            helper.car_details.agentName = value;
          },
          'agentPhone': () => {
            helper.client.insurance_agent_phone = value;
            helper.car_details.insurance_agent_phone = value;
          },
          'agentEmail': () => {
            helper.client.insurance_agent_email = value;
            helper.car_details.insurance_agent_email = value;
          }
        };
        
        if (legacyMappings[fieldId]) {
          legacyMappings[fieldId]();
        }
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        localStorage.setItem('helper', JSON.stringify(helper));
        
        console.log(`💾 Helper updated for field: ${fieldId}`);
        
      } catch (error) {
        console.error('❌ Error updating helper from contact field:', error);
      }
    }
    
    // Update helper structure from vehicle field changes using field mapping dictionary
    function updateHelperFromVehicleField(element) {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        const fieldId = element.id;
        let value = element.value;
        
        console.log(`📝 Vehicle field change: ${fieldId} = "${value}"`);
        
        // Set nested value helper function
        const setNestedValue = (obj, path, val) => {
          const keys = path.split('.');
          let current = obj;
          for (let i = 0; i < keys.length - 1; i++) {
            const key = keys[i];
            if (!(key in current) || typeof current[key] !== 'object') {
              current[key] = {};
            }
            current = current[key];
          }
          current[keys[keys.length - 1]] = val;
        };
        
        // Process price fields - remove currency symbol and commas
        if (fieldId === 'carBasePrice' || fieldId === 'carMarketValue') {
          value = value.replace(/[₪,]/g, '').trim();
          if (value && !isNaN(value)) {
            value = parseInt(value);
          }
        }
        
        // Map field IDs to helper structure paths
        const fieldMappings = {
          'carBasePrice': 'valuation.base_price',
          'carMarketValue': 'vehicle.market_value', 
          'carReportDate': 'case_info.issue_date'
        };
        
        // Update standardized helper structure
        if (fieldMappings[fieldId]) {
          setNestedValue(helper, fieldMappings[fieldId], value);
          console.log(`✅ Updated ${fieldMappings[fieldId]} = "${value}"`);
        }
        
        // Also maintain legacy structure for backward compatibility
        helper.car_details = helper.car_details || {};
        helper.levi_report = helper.levi_report || {};
        helper.expertise = helper.expertise || {};
        helper.expertise.calculations = helper.expertise.calculations || {};
        
        const legacyMappings = {
          'carBasePrice': () => {
            helper.car_details.base_price = value;
            helper.levi_report.base_price = value;
          },
          'carMarketValue': () => {
            helper.car_details.market_value = value;
            helper.expertise.calculations.market_value = value;
          },
          'carReportDate': () => {
            helper.car_details.report_date = value;
            // Do NOT update levi_report.report_date - this is for final report only
          }
        };
        
        if (legacyMappings[fieldId]) {
          legacyMappings[fieldId]();
        }
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        localStorage.setItem('helper', JSON.stringify(helper));
        
        console.log(`💾 Helper updated for vehicle field: ${fieldId}`);
        
      } catch (error) {
        console.error('❌ Error updating helper from vehicle field:', error);
      }
    }
    
    // DEPRECIATION MODULE INTEGRATION - COMPLETE DYNAMIC SYSTEM
    
    // Initialize depreciation functionality on page load
    document.addEventListener('DOMContentLoaded', function() {
      console.log('🚀 Initializing complete dynamic depreciation system...');
      console.log('🔄 DOMContentLoaded event fired - about to initialize summary');
      
      // Initialize report type handler
      const reportTypeSelect = document.getElementById('reportType');
      if (reportTypeSelect) {
        reportTypeSelect.addEventListener('change', function() {
          const selectedType = this.value;
          console.log('Report type changed to:', selectedType);
          
          // Save dropdown selection to helper AND sessionStorage for persistence
          const helper = window.helper || {};
          if (!helper.final_report) helper.final_report = {};
          helper.final_report.dropdown_type = selectedType;
          window.helper = helper;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          sessionStorage.setItem('selectedReportVariant', selectedType);
          console.log('💾 Saved dropdown report type to helper and sessionStorage:', selectedType);
          
          updateReportType();
          loadLegalText().catch(console.error); // Update legal text when report type changes
          loadAttachmentsFromVault(); // Update attachments when report type changes
          saveAndRefreshComplete(); // Save and refresh calculations
        });
        
        // Initialize with current selection
        console.log('🔄 About to call updateSummaryVisibility() on page load');
        updateSummaryVisibility();
        console.log('✅ updateSummaryVisibility() called on page load');
      }
      
      // Initialize company selection for VAT calculation
      const companySelect = document.getElementById('isCompanyClient');
      if (companySelect) {
        companySelect.addEventListener('change', function() {
          console.log('Company selection changed:', this.value);
          saveAndRefreshComplete();
        });
      }
      
      // Initialize global depreciation field
      const globalDep1 = document.getElementById('globalDep1');
      if (globalDep1) {
        globalDep1.addEventListener('input', function() {
          // Clean the value to allow decimal numbers
          let value = this.value;
          
          // Remove % for processing
          value = value.replace('%', '');
          
          // Allow only numbers, decimal point, and minus sign
          value = value.replace(/[^0-9.-]/g, '');
          
          // Ensure only one decimal point
          const parts = value.split('.');
          if (parts.length > 2) {
            value = parts[0] + '.' + parts.slice(1).join('');
          }
          
          // Keep as clean number during input
          this.value = value;
          
          console.log('Global depreciation changed:', this.value);
          
          // Call the functions that were in the inline handlers
          saveDepreciationData();
          updateHelperDepreciationField(this, 'global_percentage');
          
          calculateGlobalDepreciationValue();
          triggerMathCalculation();
          saveAndRefreshComplete();
        });
        
        // Allow decimal input on keypress
        globalDep1.addEventListener('keypress', function(e) {
          // Allow: numbers (0-9), decimal point (.), minus (-), navigation keys
          const allowedKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '-', 'Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab'];
          
          if (!allowedKeys.includes(e.key) && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
          }
        });
        
        // Add % sign when user finishes editing (on blur) 
        globalDep1.addEventListener('blur', function() {
          if (this.value && !this.value.includes('%') && this.value !== '') {
            const numValue = parseFloat(this.value);
            if (!isNaN(numValue)) {
              this.value = this.value + '%';
            }
          }
        });
      }
      
      // Initialize work days field
      const workDays = document.getElementById('workDays');
      if (workDays) {
        workDays.addEventListener('input', function() {
          console.log('Work days changed:', this.value);
          saveAndRefreshComplete();
        });
      }
      
      // Initialize agreement checkbox
      const isAgreement = document.getElementById('isAgreement');
      if (isAgreement) {
        isAgreement.addEventListener('change', function() {
          console.log('Agreement checkbox changed:', this.checked);
          saveAndRefreshComplete();
        });
      }
      
      // Initialize differentials checkbox
      const differentialsCheckbox = document.getElementById('hasDifferentials');
      if (differentialsCheckbox) {
        differentialsCheckbox.addEventListener('change', function() {
          console.log('Differentials checkbox changed:', this.checked);
          toggleDifferentials();
          saveAndRefreshComplete();
        });
      }
      
      // Add dynamic event listeners to all value fields that affect calculations
      const dynamicFields = [
        'saleValueDamage', 'salvageValueTotal', 'salvageValueLegal', 'storageValueTotal'
      ];
      
      dynamicFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field) {
          field.addEventListener('input', function() {
            console.log(`${fieldId} changed:`, this.value);
            calculateSubtotals();
            saveAndRefreshComplete();
          });
        }
      });
      
      // Initialize differentials display
      toggleDifferentials();
      
      // Load existing data from helper
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const dep = helper.expertise?.depreciation || {};
      
      // TEMPORARILY DISABLE loading existing differentials data to fix corruption
      // Load existing differentials data - DISABLED to clear corrupted data
      // if (dep.differentials && dep.differentials.length > 0) {
      //   renderDifferentials(dep.differentials);
      // }
      console.log('⚠️ Differential loading temporarily disabled to clear corrupted data');
      
      // Load existing form values
      if (dep.global_percent && globalDep1) {
        globalDep1.value = dep.global_percent;
      }
      if (dep.work_days && workDays) {
        workDays.value = dep.work_days;
      }
      if (dep.is_agreement !== undefined && isAgreement) {
        isAgreement.checked = !!dep.is_agreement;
      }
      if (dep.has_differentials !== undefined && differentialsCheckbox) {
        differentialsCheckbox.checked = !!dep.has_differentials;
      }
      
      // Load company selection
      if (helper.client?.is_company_client !== undefined && companySelect) {
        companySelect.value = helper.client.is_company_client ? 'yes' : 'no';
      }
      
      // Load report type
      if (helper.meta?.report_type_display && reportTypeSelect) {
        reportTypeSelect.value = helper.meta.report_type_display;
      }
      
      // Initial complete calculation refresh
      setTimeout(() => {
        calculateGlobalDepreciationValue();
        triggerMathCalculation();
        refreshSummary();
        console.log('✅ Complete dynamic system initialized');
      }, 100);
    });
    
    // Update summary visibility based on report type
    function updateSummaryVisibility() {
      console.log('🔄 updateSummaryVisibility() STARTED');
      const reportTypeSelect = document.getElementById('reportType');
      const reportType = reportTypeSelect?.value || 'חוות דעת פרטית';
      console.log('📋 Report type:', reportType);
      
      // Hide all summary sections first
      const summaryBlocks = document.querySelectorAll('.summary-block');
      summaryBlocks.forEach(block => block.style.display = 'none');
      
      // Show the correct summary section based on selected type
      let summaryId = '';
      switch(reportType) {
        case 'חוות דעת פרטית':
          summaryId = 'summaryPrivate';
          break;
        case 'חוות דעת גלובלית':
          summaryId = 'summaryGlobal';
          break;
        case 'חוות דעת מכירה מצבו הניזוק':
          summaryId = 'summaryDamage';
          break;
        case 'חוות דעת טוטלוסט':
          summaryId = 'summaryTotalLoss';
          break;
        case 'חוות דעת אובדן להלכה':
          summaryId = 'summaryLegalLoss';
          break;
        default:
          summaryId = 'summaryPrivate';
      }
      
      // Show the selected summary section
      const selectedSummary = document.getElementById(summaryId);
      console.log('🔍 Selected summary element:', summaryId, !!selectedSummary);
      if (selectedSummary) {
        selectedSummary.style.display = 'block';
        console.log('✅ Summary section displayed:', summaryId);
        
        // Populate the fields with correct data mapping
        console.log('🔄 About to call refreshSummary()');
        refreshSummary();
        console.log('✅ refreshSummary() completed');
        
        // Additional refresh for salvage sale variant to ensure calculations work
        if (summaryId === 'summaryDamage') {
          setTimeout(() => {
            console.log('🔄 Additional salvage sale variant refresh');
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = helper.calculations?.full_market_value || 0;
            
            // Ensure market value field is populated
            const damageMarketField = document.getElementById('sumMarketValueDamage');
            if (damageMarketField && marketValue > 0) {
              damageMarketField.value = `₪${marketValue.toLocaleString()}`;
            }
            
            // Trigger calculation again
            const salvageSaleField = document.getElementById('saleValueDamage');
            if (salvageSaleField) {
              const salvagePrice = parseFloat(salvageSaleField.value.replace(/[₪,]/g, '')) || 0;
              const salvageSaleResult = marketValue - salvagePrice;
              
              const resultField = document.getElementById('afterSaleDamage');
              if (resultField) {
                resultField.value = `₪${salvageSaleResult.toLocaleString()}`;
                console.log(`🔄 Re-calculated salvage sale: ${marketValue} - ${salvagePrice} = ${salvageSaleResult}`);
              }
            }
          }, 200);
        }
        
        // Additional refresh for total loss variant to ensure calculations work
        if (summaryId === 'summaryTotalLoss') {
          // First, ensure fields are loaded from helper
          const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
          
          // Immediately load manual fields from helper
          const salvageField = document.getElementById('salvageValueTotal');
          const towingField = document.getElementById('storageValueTotal');
          
          if (salvageField && helper.final_report?.summary?.salvage_value_total) {
            salvageField.value = helper.final_report.summary.salvage_value_total;
            console.log(`📥 Immediately loaded salvage value: ${salvageField.value}`);
          }
          
          if (towingField && helper.final_report?.summary?.storage_towing_value_total) {
            towingField.value = helper.final_report.summary.storage_towing_value_total;
            console.log(`📥 Immediately loaded towing value: ${towingField.value}`);
          }
          
          // Then trigger calculation after a delay
          setTimeout(() => {
            console.log('🔄 Additional total loss variant refresh');
            const marketValue = helper.calculations?.full_market_value || 0;
            
            // Ensure market value field is populated
            const totalMarketField = document.getElementById('sumMarketValueTotal');
            if (totalMarketField && marketValue > 0) {
              totalMarketField.value = `₪${marketValue.toLocaleString()}`;
            }
            
            // Trigger calculation with loaded values
            const resultField = document.getElementById('afterSaleTotal');
            
            if (resultField && marketValue > 0) {
              const salvageValue = parseFloat(salvageField?.value?.replace(/[₪,]/g, '')) || 0;
              const towingValue = parseFloat(towingField?.value?.replace(/[₪,]/g, '')) || 0;
              const result = marketValue - salvageValue + towingValue;
              
              resultField.value = `₪${result.toLocaleString()}`;
              console.log(`🔄 Re-calculated total loss: ${marketValue} - ${salvageValue} + ${towingValue} = ${result}`);
            }
          }, 300);
          
          // Extra safety - call variant calculations after longer delay
          setTimeout(() => {
            ensureTotalLossCalculation();
            ensureLegalLossCalculation();
          }, 800);
        }
      } else {
        console.error('❌ Summary section not found:', summaryId);
      }

      // Control depreciation section visibility
      const depreciationSection = document.getElementById('depreciationSection');
      if (depreciationSection) {
        const hideDepreciation = (reportType === 'חוות דעת טוטלוסט' || 
                                reportType === 'חוות דעת מכירה מצבו הניזוק' || 
                                reportType === 'חוות דעת אובדן להלכה');
        depreciationSection.style.display = hideDepreciation ? 'none' : 'block';
      }

      // Control differentials section visibility for special report types
      const differentialsSection = document.getElementById('differentialsSection');
      if (differentialsSection) {
        const hideDifferentials = (reportType === 'חוות דעת טוטלוסט' || 
                                 reportType === 'חוות דעת מכירה מצבו הניזוק' || 
                                 reportType === 'חוות דעת אובדן להלכה');
        if (hideDifferentials) {
          differentialsSection.style.display = 'none';
          // Also uncheck the differentials checkbox
          const differentialsCheckbox = document.getElementById('hasDifferentials');
          if (differentialsCheckbox) {
            differentialsCheckbox.checked = false;
          }
        } else {
          differentialsSection.style.display = 'block';
        }
      }
    }
    
    // Refresh summary with correct field mapping as specified
    function refreshSummary() {
      console.log('🚀 refreshSummary() STARTED');
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('📊 Helper data:', helper.calculations?.full_market_value);
      
      // Get values from YOUR specified sources - NO FALLBACKS
      const marketValue = helper.calculations?.full_market_value || 0;
      
      let totalClaim = 0;
      if (helper.claims_data?.total_claim) {
        const claimValue = helper.claims_data.total_claim;
        totalClaim = typeof claimValue === 'string' ? 
          parseFloat(claimValue.replace(/[₪,]/g, '')) || 0 : 
          parseFloat(claimValue) || 0;
      }
      
      let depCompensation = 0;
      if (helper.depreciation?.globalDepValue) {
        const depValue = helper.depreciation.globalDepValue;
        depCompensation = typeof depValue === 'string' ? 
          parseFloat(depValue.replace(/[₪,]/g, '')) || 0 : 
          parseFloat(depValue) || 0;
      }
      
      // Update market value fields across all variants
      const marketFields = [
        'sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 
        'sumMarketValueTotal', 'sumMarketValueLegal', 'sumMarketValuePrivate',
        'sumMarketValueDefault'
      ];
      marketFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        console.log(`🔍 Field ${fieldId}: exists=${!!field}, marketValue=${marketValue}`);
        if (field && marketValue > 0) {
          field.value = `₪${marketValue.toLocaleString()}`;
          console.log(`✅ Set ${fieldId} = ${field.value}`);
          
          // Add protection: re-set the field after helper system loads for all market value fields
          setTimeout(() => {
            if (field.value !== `₪${marketValue.toLocaleString()}`) {
              field.value = `₪${marketValue.toLocaleString()}`;
              console.log(`🔧 RESTORED ${fieldId} = ${field.value} (was cleared by helper system)`);
            }
          }, 1000); // Wait for helper system to finish
        }
      });
      
      // Update total claim fields for private and global variants
      const claimFields = [
        'sumClaim', 'sumClaimGlobal', 'sumClaimPrivate', 'sumClaimDefault'
      ];
      claimFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field && totalClaim > 0) {
          field.value = `₪${totalClaim.toLocaleString()}`;
        }
      });
      
      // Update depreciation compensation fields for private and global variants
      const depFields = [
        'depCompensation', 'sumDepreciation', 'depCompensationPrivate', 'sumDepreciationDefault'
      ];
      depFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field && depCompensation > 0) {
          field.value = `₪${depCompensation.toLocaleString()}`;
        }
      });
      
      // Calculate totals for private and global variants
      const privateTotal = totalClaim + depCompensation;
      const privateTotalFields = ['sumTotalPrivate', 'sumTotalDefault', 'sumTotalGlobal'];
      privateTotalFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field && privateTotal > 0) {
          field.value = `₪${privateTotal.toLocaleString()}`;
        }
      });

      // TOTAL LOSS CALCULATION: Market Value - Salvage + Towing
      const salvageField = document.getElementById('salvageValueTotal');
      const towingField = document.getElementById('storageValueTotal');
      const totalLossResultField = document.getElementById('afterSaleTotal');
      
      // Load manual fields from helper if they're empty
      if (salvageField && !salvageField.value && helper.final_report?.summary?.salvage_value_total) {
        salvageField.value = helper.final_report.summary.salvage_value_total;
        console.log(`📥 Loaded salvage value from helper in refreshSummary: ${salvageField.value}`);
      }
      
      if (towingField && !towingField.value && helper.final_report?.summary?.storage_towing_value_total) {
        towingField.value = helper.final_report.summary.storage_towing_value_total;
        console.log(`📥 Loaded towing value from helper in refreshSummary: ${towingField.value}`);
      }
      
      // Always perform calculation even if some values are 0
      if (totalLossResultField && marketValue > 0) {
        const salvageValue = parseFloat(salvageField?.value.replace(/[₪,]/g, '')) || 0;
        const towingValue = parseFloat(towingField?.value.replace(/[₪,]/g, '')) || 0;
        const totalLossResult = marketValue - salvageValue + towingValue;
        
        totalLossResultField.value = `₪${totalLossResult.toLocaleString()}`;
        console.log(`🧮 Total Loss calculation: ${marketValue} - ${salvageValue} + ${towingValue} = ${totalLossResult}`);
        
        // Ensure the result persists after a delay
        setTimeout(() => {
          if (totalLossResultField.value !== `₪${totalLossResult.toLocaleString()}`) {
            totalLossResultField.value = `₪${totalLossResult.toLocaleString()}`;
            console.log(`🔧 Re-applied total loss result after delay`);
          }
        }, 500);
      }

      // SALVAGE SALE CALCULATION: Market Value - Salvage Price
      const salvageSaleField = document.getElementById('saleValueDamage');
      
      // Load manual field from helper if empty
      if (salvageSaleField && !salvageSaleField.value && helper.final_report?.summary?.sale_value_damaged) {
        salvageSaleField.value = helper.final_report.summary.sale_value_damaged;
        console.log(`📥 Loaded salvage sale value from helper in refreshSummary: ${salvageSaleField.value}`);
      }
      
      if (salvageSaleField && marketValue > 0) {
        const salvageSaleValue = parseFloat(salvageSaleField.value.replace(/[₪,]/g, '')) || 0;
        const salvageSaleResult = marketValue - salvageSaleValue;
        
        // Update the result field
        const resultField = document.getElementById('afterSaleDamage');
        if (resultField) {
          resultField.value = `₪${salvageSaleResult.toLocaleString()}`;
          console.log(`🧮 Salvage Sale calculation: ₪${marketValue.toLocaleString()} - ₪${salvageSaleValue.toLocaleString()} = ₪${salvageSaleResult.toLocaleString()}`);
          
          // Save to helper
          helper.final_report = helper.final_report || {};
          helper.final_report.summary = helper.final_report.summary || {};
          helper.final_report.summary.total_after_sale_damage = resultField.value;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          // Ensure the result persists after a delay
          setTimeout(() => {
            if (resultField.value !== `₪${salvageSaleResult.toLocaleString()}`) {
              resultField.value = `₪${salvageSaleResult.toLocaleString()}`;
              console.log(`🔧 Re-applied salvage sale result after delay`);
            }
          }, 500);
        } else {
          console.warn('⚠️ Result field afterSaleDamage not found');
        }
      }

      // LEGAL LOSS CALCULATION: Market Value - Salvage Price
      const salvageLegalField = document.getElementById('salvageValueLegal');
      const legalLossResultField = document.getElementById('afterSaleLegal');
      
      // Load manual field from helper if empty
      if (salvageLegalField && !salvageLegalField.value && helper.final_report?.summary?.salvage_value_legal) {
        salvageLegalField.value = helper.final_report.summary.salvage_value_legal;
        console.log(`📥 Loaded salvage legal value from helper in refreshSummary: ${salvageLegalField.value}`);
      }
      
      if (legalLossResultField && marketValue > 0) {
        const salvageLegalValue = parseFloat(salvageLegalField?.value.replace(/[₪,]/g, '')) || 0;
        const legalLossResult = marketValue - salvageLegalValue;
        
        legalLossResultField.value = `₪${legalLossResult.toLocaleString()}`;
        console.log(`🧮 Legal Loss calculation: ₪${marketValue.toLocaleString()} - ₪${salvageLegalValue.toLocaleString()} = ₪${legalLossResult.toLocaleString()}`);
        
        // Save to helper
        helper.final_report = helper.final_report || {};
        helper.final_report.summary = helper.final_report.summary || {};
        helper.final_report.summary.total_after_salvage_legal = legalLossResultField.value;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Ensure the result persists after a delay
        setTimeout(() => {
          if (legalLossResultField.value !== `₪${legalLossResult.toLocaleString()}`) {
            legalLossResultField.value = `₪${legalLossResult.toLocaleString()}`;
            console.log(`🔧 Re-applied legal loss result after delay`);
          }
        }, 500);
      }
    }
    
    // Dynamic summary content based on report type
    function updateSummaryContent(reportType) {
      const summaryContent = document.querySelector('#summaryPrivate .form-grid');
      if (!summaryContent) return;
      
      // Clear existing content
      summaryContent.innerHTML = '';
      
      // Create different summary structures based on report type
      switch(reportType) {
        case 'חוות דעת פרטית':
          summaryContent.innerHTML = `
            <div><label style="color: #333;">ערך השוק של הרכב:</label><input type="text" id="sumMarketValuePrivate" style="background: white; color: #333;" readonly /></div>
            <div><label style="color: #333;">סה״כ תביעה:</label><input type="text" id="sumClaimPrivate" style="background: white; color: #333;" readonly /></div>
            <div><label style="color: #333;">פיצוי בגין ירידת ערך:</label><input type="text" id="depCompensationPrivate" style="background: white; color: #333;" readonly /></div>
            <div><label style="color: #333;">תוספות והורדות (מידע בלבד):</label><input type="text" id="adjustmentsInfoPrivate" style="background: #f0f0f0; color: #666;" readonly /></div>
          `;
          break;
          
        case 'חוות דעת גלובלית':
          summaryContent.innerHTML = `
            <div><label style="color: #333;">ערך השוק של הרכב:</label><input type="text" id="sumMarketValueGlobal" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">סה״כ תביעה:</label><input type="text" id="sumClaimGlobal" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">פיצוי בגין ירידת ערך:</label><input type="text" id="sumDepreciation" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">תוספות והורדות:</label><input type="text" id="sumAdjustments" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">סה״כ נכלל בחוות הדעת:</label><input type="text" id="sumTotalGlobalDynamic" style="background: white; color: #333;" /></div>
          `;
          
          // IMMEDIATE POPULATION FOR GLOBAL VARIANT - DIRECT FROM HELPER
          setTimeout(() => {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            
            // Market Value - from helper.calculations.full_market_value
            const marketValue = helper.calculations?.full_market_value || 0;
            const marketField = document.getElementById('sumMarketValueGlobal');
            if (marketField && marketValue > 0) {
              marketField.value = `₪${marketValue.toLocaleString()}`;
            }
            
            // Total Claim - directly from helper.claims_data.total_claim
            let totalClaim = 0;
            if (helper.claims_data?.total_claim) {
              const claimValue = helper.claims_data.total_claim;
              if (typeof claimValue === 'string') {
                totalClaim = parseFloat(claimValue.replace(/[₪,]/g, '')) || 0;
              } else {
                totalClaim = parseFloat(claimValue) || 0;
              }
            }
            const claimField = document.getElementById('sumClaimGlobal');
            if (claimField && totalClaim > 0) {
              claimField.value = `₪${totalClaim.toLocaleString()}`;
            }
            
            // Depreciation - from helper.depreciation.globalDepValue
            let depCompensation = 0;
            if (helper.depreciation?.globalDepValue) {
              const depValue = helper.depreciation.globalDepValue;
              if (typeof depValue === 'string') {
                depCompensation = parseFloat(depValue.replace(/[₪,]/g, '')) || 0;
              } else {
                depCompensation = parseFloat(depValue) || 0;
              }
            }
            const depField = document.getElementById('sumDepreciation');
            if (depField && depCompensation > 0) {
              depField.value = `₪${depCompensation.toLocaleString()}`;
            }
          }, 0);
          break;
          
        case 'חוות דעת טוטלוסט':
          summaryContent.innerHTML = `
            <div><label style="color: #333;">ערך השוק של הרכב:</label><input type="text" id="sumMarketValueTotal" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">ערך שרידי הרכב:</label><input type="text" id="sumScrapValue" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">תוספת בגין גרירה ואחסנה:</label><input type="text" id="sumTowingStorage" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">סה״כ לאחר מכירת שרידים:</label><input type="text" id="sumTotalTotalLoss" style="background: white; color: #333;" /></div>
          `;
          
          // IMMEDIATE POPULATION FOR TOTAL LOSS VARIANT
          setTimeout(() => {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = helper.calculations?.full_market_value || 0;
            const marketField = document.getElementById('sumMarketValueTotal');
            if (marketField && marketValue > 0) {
              marketField.value = `₪${marketValue.toLocaleString()}`;
            }
          }, 0);
          break;
          
        case 'חוות דעת מכירה מצבו הניזוק':
          summaryContent.innerHTML = `
            <div><label style="color: #333;">ערך השוק של הרכב:</label><input type="text" id="sumMarketValueDamage" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">ערך המכירה במצבו הניזוק:</label><input type="text" id="sumDamagedSaleValue" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">שיטת תשלום:</label><input type="text" id="paymentMethod" style="background: white; color: #333;" placeholder="מזומן, צ'ק, העברה בנקאית..." /></div>
            <div><label style="color: #333;">סה״כ לאחר מכירה:</label><input type="text" id="sumTotalDamagedSale" style="background: white; color: #333;" /></div>
          `;
          
          // IMMEDIATE POPULATION FOR DAMAGED STATE VARIANT
          setTimeout(() => {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = helper.calculations?.full_market_value || 0;
            const marketField = document.getElementById('sumMarketValueDamage');
            if (marketField && marketValue > 0) {
              marketField.value = `₪${marketValue.toLocaleString()}`;
              console.log(`✅ Set sumMarketValueDamage to ${marketField.value}`);
            }
            
            // Add event listener to the newly created salvage sale input field
            const salvageSaleField = document.getElementById('sumDamagedSaleValue');
            if (salvageSaleField) {
              salvageSaleField.addEventListener('input', function() {
                console.log('🎯 Direct event listener triggered for Salvage Sale field');
                refreshSummary();
              });
              console.log('✅ Added direct event listener to sumDamagedSaleValue field');
              
              // Immediately trigger the calculation if salvage field has a value
              const salvageValue = parseFloat(salvageSaleField.value.replace(/[₪,]/g, '')) || 0;
              if (marketValue > 0) {
                const result = marketValue - salvageValue;
                const resultField = document.getElementById('sumTotalDamagedSale');
                if (resultField) {
                  resultField.value = `₪${result.toLocaleString()}`;
                  console.log(`🎯 Initial salvage calculation: ${marketValue} - ${salvageValue} = ${result}`);
                }
              }
            }
            
            // Call refreshSummary after a short delay to ensure DOM is ready
            setTimeout(() => {
              console.log('🔄 Calling refreshSummary after dynamic content creation');
              refreshSummary();
            }, 100);
          }, 50);
          break;
          
        case 'חוות דעת אובדן להלכה':
          summaryContent.innerHTML = `
            <div><label style="color: #333;">ערך השוק של הרכב:</label><input type="text" id="sumMarketValueLegal" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">ערך שרידי הרכב:</label><input type="text" id="sumScrapValueLegal" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">סה״כ לאחר מכירת שרידים:</label><input type="text" id="sumAfterScrapLegal" style="background: white; color: #333;" /></div>
          `;
          
          // IMMEDIATE POPULATION FOR LEGAL LOSS VARIANT
          setTimeout(() => {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            
            // Market Value - from helper.calculations.full_market_value
            const marketValue = helper.calculations?.full_market_value || 0;
            const marketField = document.getElementById('sumMarketValueLegal');
            if (marketField && marketValue > 0) {
              marketField.value = `₪${marketValue.toLocaleString()}`;
            }
            
            // Check if we have depreciation value (158,901) which might be used as after scrap value
            let depCompensation = 0;
            if (helper.depreciation?.globalDepValue) {
              const depValue = helper.depreciation.globalDepValue;
              if (typeof depValue === 'string') {
                depCompensation = parseFloat(depValue.replace(/[₪,]/g, '')) || 0;
              } else {
                depCompensation = parseFloat(depValue) || 0;
              }
            }
            
            // Fill the after scrap value field
            const afterScrapField = document.getElementById('sumAfterScrapLegal');
            if (afterScrapField && depCompensation > 0) {
              afterScrapField.value = `₪${depCompensation.toLocaleString()}`;
            }
          }, 0);
          break;
          
        default:
          // Default to private report structure
          summaryContent.innerHTML = `
            <div><label style="color: #333;">ערך השוק של הרכב:</label><input type="text" id="sumMarketValueDefault" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">סה״כ תביעה:</label><input type="text" id="sumClaimDefault" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">פיצוי בגין ירידת ערך:</label><input type="text" id="sumDepreciationDefault" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">תוספות והורדות:</label><input type="text" id="sumAdjustmentsDefault" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">סה״כ נכלל בחוות הדעת:</label><input type="text" id="sumTotalDefault" style="background: white; color: #333;" /></div>
          `;
      }
      
      // Load data from helper for the new summary structure IMMEDIATELY
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Populate the global claim field with the correct value
      const sumClaimGlobal = document.getElementById('sumClaimGlobal');
      if (sumClaimGlobal && totalClaim > 0) {
        sumClaimGlobal.value = `₪${totalClaim.toLocaleString()}`;
      }
      
      // Also populate private claim field if it exists
      const sumClaimPrivate = document.getElementById('sumClaimPrivate');
      if (sumClaimPrivate && totalClaim > 0) {
        sumClaimPrivate.value = `₪${totalClaim.toLocaleString()}`;
      }
      
      // Also populate default claim field if it exists
      const sumClaimDefault = document.getElementById('sumClaimDefault');
      if (sumClaimDefault && totalClaim > 0) {
        sumClaimDefault.value = `₪${totalClaim.toLocaleString()}`;
      }
      
      // 3. AUTO-FILL DEPRECIATION - Get from helper
      let depCompensation = 0;
      if (helper.depreciation?.globalDepValue) {
        const depValue = helper.depreciation.globalDepValue;
        if (typeof depValue === 'string') {
          depCompensation = parseFloat(depValue.replace(/[₪,]/g, '')) || 0;
        } else {
          depCompensation = parseFloat(depValue) || 0;
        }
      }
      
      // Populate depreciation fields
      const sumDepreciation = document.getElementById('sumDepreciation');
      if (sumDepreciation && depCompensation > 0) {
        sumDepreciation.value = `₪${depCompensation.toLocaleString()}`;
      }
      
      const depCompensationPrivate = document.getElementById('depCompensationPrivate');
      if (depCompensationPrivate && depCompensation > 0) {
        depCompensationPrivate.value = `₪${depCompensation.toLocaleString()}`;
      }
      
      const sumDepreciationDefault = document.getElementById('sumDepreciationDefault');
      if (sumDepreciationDefault && depCompensation > 0) {
        sumDepreciationDefault.value = `₪${depCompensation.toLocaleString()}`;
      }
      
      loadSummaryFieldsFromHelper(helper);
      
      // Add event listeners immediately
      addSummaryCalculationListeners();
      
      // Calculate totals AFTER all fields are populated
      setTimeout(() => {
        calculateSummaryTotals();
      }, 100);
      
      // Re-add event listeners for newly created fields and reload values
      setTimeout(() => {
        // ENHANCED: Use targeted market value population based on current report type
        const currentReportType = document.getElementById('reportType')?.value || 'חוות דעת פרטית';
        populateMarketValueForCurrentVariant(helper, currentReportType);
        
        const paymentMethodField = document.getElementById('paymentMethod');
        if (paymentMethodField) {
          // Load saved value explicitly
          const savedPayment = helper.final_report?.summary?.paymentMethod;
          if (savedPayment) {
            paymentMethodField.value = savedPayment;
          }
          
          paymentMethodField.addEventListener('input', loadLegalText);
        }
      }, 100);
    }
    
    // ENHANCED VARIANT-SPECIFIC CALCULATION ENGINE - Based on User Mappings
    function calculateSummaryTotals() {
      try {
        console.log('🧮 Starting enhanced variant-specific calculations');
        const reportType = document.getElementById('reportType')?.value || 'חוות דעת פרטית';
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Get market value from standardized source (helper.calculations.full_market_value)
        let marketValue = helper.calculations?.full_market_value || 0;
        
        // If not available, try to get from visible fields
        if (marketValue === 0) {
          const marketFields = ['sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 'sumMarketValueTotal', 'sumMarketValueLegal'];
          for (const fieldId of marketFields) {
            const field = document.getElementById(fieldId);
            if (field && field.value) {
              marketValue = parseFloat(field.value.replace(/[₪,]/g, '')) || 0;
              break;
            }
          }
        }
        
        console.log(`💰 Market value: ₪${marketValue.toLocaleString()}`);
        
        // VARIANT-SPECIFIC CALCULATION LOGIC (Based on User Mappings)
        switch(reportType) {
          case 'חוות דעת פרטית':
            calculatePrivateReport(helper, marketValue);
            break;
            
          case 'חוות דעת גלובלית':  
            calculateGlobalReport(helper, marketValue);
            break;
            
          case 'חוות דעת טוטלוסט':
            calculateTotalLossReport(helper, marketValue);
            break;
            
          case 'חוות דעת מכירה מצבו הניזוק':
            calculateDamagedSaleReport(helper, marketValue).catch(console.error);
            break;
            
          case 'חוות דעת אובדן להלכה':
            calculateLegalLossReport(helper, marketValue);
            break;
            
          default:
            calculatePrivateReport(helper, marketValue); // Default to private
        }
        
        // Save calculations back to helper
        helper.final_report = helper.final_report || {};
        helper.final_report.summary = helper.final_report.summary || {};
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('✅ Variant-specific calculations completed');
        
      } catch (error) {
        console.error('❌ Error in calculateSummaryTotals:', error);
      }
    }
    
    // PRIVATE REPORT CALCULATION (Based on User Mapping)
    function calculatePrivateReport(helper, marketValue) {
      console.log('📊 Calculating Private Report');
      
      // Get values - simplified calculation: only Total Claim + Depreciation
      let totalClaim = 0;
      if (helper.claims_data?.total_claim) {
        totalClaim = parseFloat(String(helper.claims_data.total_claim).replace(/[₪,]/g, '')) || 0;
      }
      
      let depCompensation = 0;
      if (helper.depreciation?.globalDepValue) {
        depCompensation = parseFloat(String(helper.depreciation.globalDepValue).replace(/[₪,]/g, '')) || 0;
      } else if (helper.depreciation?.globalDep1) {
        depCompensation = parseFloat(String(helper.depreciation.globalDep1).replace(/[₪,%]/g, '')) || 0;
      }
      
      // Calculation: Total Claim + Depreciation Compensation ONLY
      const calculatedTotal = totalClaim + depCompensation;
      
      // Update UI fields - use the static field instead
      const totalField = document.getElementById('sumTotalBeforeDifferentials');
      if (totalField) {
        totalField.value = `₪${calculatedTotal.toLocaleString()}`;
        totalField.style.backgroundColor = '#e8f5e8'; // Show it's calculated
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.summary) helper.final_report.summary = {};
        helper.final_report.summary.private_total = totalField.value;
      }
      
      console.log(`Private calculation: ${totalClaim} + ${depCompensation} = ${calculatedTotal}`);
      return calculatedTotal;
    }
    
    // GLOBAL REPORT CALCULATION (Based on User Mapping)  
    function calculateGlobalReport(helper, marketValue) {
      console.log('📊 Calculating Global Report');
      
      // Get values using proper parsing like Private report
      let totalClaim = 0;
      if (helper.claims_data?.total_claim) {
        totalClaim = parseFloat(String(helper.claims_data.total_claim).replace(/[₪,]/g, '')) || 0;
      }
      
      let depCompensation = 0;
      if (helper.depreciation?.globalDepValue) {
        depCompensation = parseFloat(String(helper.depreciation.globalDepValue).replace(/[₪,]/g, '')) || 0;
      } else if (helper.depreciation?.globalDep1) {
        depCompensation = parseFloat(String(helper.depreciation.globalDep1).replace(/[₪,%]/g, '')) || 0;
      }
      
      // 1. BEFORE DIFFERENTIALS: Total Claim + Depreciation Compensation (like Private)
      const beforeDifferentials = totalClaim + depCompensation;
      
      // 2. Get total differentials value from the correct source
      let totalDifferentials = 0;
      
      // Check helper.final_report.differential (where differentials are actually saved)
      if (helper.final_report?.differential?.summary?.total_amount_with_vat) {
        totalDifferentials = parseFloat(String(helper.final_report.differential.summary.total_amount_with_vat).replace(/[₪,]/g, '')) || 0;
      }
      // Also check the alternative field name
      else if (helper.final_report?.differential?.summary?.total_with_vat) {
        totalDifferentials = parseFloat(String(helper.final_report.differential.summary.total_with_vat).replace(/[₪,]/g, '')) || 0;
      }
      // Fallback to DOM elements if helper data not available
      else {
        const totalDiffField = document.getElementById('totalDifferentialsWithVAT');
        if (totalDiffField && totalDiffField.textContent) {
          totalDifferentials = parseFloat(String(totalDiffField.textContent).replace(/[₪,]/g, '')) || 0;
        }
      }
      
      // 3. AFTER DIFFERENTIALS: Before Differentials - Total Differentials  
      const afterDifferentials = beforeDifferentials - totalDifferentials;
      
      // Update "Before Differentials" field (לפני הפרשים)
      const beforeField = document.getElementById('sumTotalGlobal');
      if (beforeField) {
        beforeField.value = `₪${beforeDifferentials.toLocaleString()}`;
        beforeField.style.backgroundColor = '#e8f5e8'; // Show it's calculated
      }
      
      
      // Update helper structure
      if (!helper.final_report) helper.final_report = {};
      if (!helper.final_report.summary) helper.final_report.summary = {};
      helper.final_report.summary.global_before_differentials = `₪${beforeDifferentials.toLocaleString()}`;
      helper.final_report.summary.global_after_differentials = `₪${afterDifferentials.toLocaleString()}`;
      
      console.log(`Global calculation: Before=${totalClaim} + ${depCompensation} = ${beforeDifferentials}, After=${beforeDifferentials} - ${totalDifferentials} = ${afterDifferentials}`);
      console.log(`Total differentials source: helper.final_report.differential.summary.total_with_vat = ${totalDifferentials}`);
      return { beforeDifferentials, afterDifferentials };
    }
    
    // FIELD VALUE HELPER WITH RETRY MECHANISM AND HELPER FALLBACK
    function getFieldValueWithRetry(fieldId, maxRetries = 3, delayMs = 100) {
      return new Promise((resolve) => {
        let attempts = 0;
        
        function attemptGetValue() {
          attempts++;
          console.log(`🔄 Attempt ${attempts}/${maxRetries} to get value for ${fieldId}`);
          
          const field = document.getElementById(fieldId);
          console.log(`🔍 Field check - exists: ${!!field}, hasValue: ${!!(field && field.value)}, value: "${field?.value}"`);
          
          if (field && field.value && field.value.trim() !== '') {
            const rawValue = field.value || '';
            const cleanValue = rawValue.replace(/[₪,]/g, '');
            const parsedValue = parseFloat(cleanValue) || 0;
            if (parsedValue > 0) {
              console.log(`✅ Successfully got ${fieldId} DOM value: ${parsedValue}`);
              resolve(parsedValue);
              return;
            }
          }
          
          if (attempts < maxRetries) {
            console.log(`⏳ Retrying ${fieldId} in ${delayMs}ms...`);
            setTimeout(attemptGetValue, delayMs);
          } else {
            // Final fallback: try to get value from helper data
            console.log(`🔄 Trying helper data fallback for ${fieldId}`);
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const helperKey = getHelperMappingKey ? getHelperMappingKey(fieldId) : null;
            console.log(`🔍 Helper fallback - fieldId: ${fieldId}, helperKey: ${helperKey}`);
            
            if (helperKey && helper.final_report?.summary?.[helperKey]) {
              const helperRawValue = helper.final_report.summary[helperKey];
              const helperValue = String(helperRawValue).replace(/[₪,]/g, '');
              const parsedHelper = parseFloat(helperValue) || 0;
              console.log(`✅ Got ${fieldId} from helper fallback: raw="${helperRawValue}", clean="${helperValue}", parsed=${parsedHelper}`);
              resolve(parsedHelper);
            } else {
              console.warn(`❌ Failed to get valid value for ${fieldId} after ${maxRetries} attempts and helper fallback`);
              console.log(`🔍 Helper debug - helperKey exists: ${!!helperKey}, helper.final_report exists: ${!!helper.final_report}, helper.final_report.summary exists: ${!!helper.final_report?.summary}`);
              if (helperKey && helper.final_report?.summary) {
                console.log(`🔍 Available helper keys: ${Object.keys(helper.final_report.summary)}`);
              }
              resolve(0);
            }
          }
        }
        
        attemptGetValue();
      });
    }
    
    // TEST FUNCTION FOR FIELD VALUE READING FIX
    async function testFieldValueReading() {
      console.log('🧪 Testing field value reading fix...');
      
      // Test the retry mechanism
      const testValue = await getFieldValueWithRetry('saleValueDamage');
      console.log(`🧪 Test result: saleValueDamage = ${testValue}`);
      
      // Test helper data access
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const helperValue = helper.final_report?.summary?.sale_value_damaged;
      console.log(`🧪 Helper data: helper.final_report.summary.sale_value_damaged = ${helperValue}`);
      
      // Test DOM element access
      const field = document.getElementById('saleValueDamage');
      console.log(`🧪 DOM element: exists=${!!field}, value="${field?.value}", type="${field?.type}"`);
      
      return { testValue, helperValue, domExists: !!field };
    }
    
    // Expose test function globally for debugging
    window.testFieldValueReading = testFieldValueReading;
    
    // DAMAGED SALE REPORT CALCULATION (Based on User Mapping) - ASYNC WITH RETRY
    async function calculateDamagedSaleReport(helper, marketValue) {
      console.log('📊 Calculating Damaged Sale Report');
      
      // 1. Auto-populate market value for Damaged Sale variant
      const marketValueField = document.getElementById('sumMarketValueDamage');
      if (marketValueField) {
        marketValueField.value = `₪${marketValue.toLocaleString()}`;
        marketValueField.style.backgroundColor = '#e8f5e8'; // Show it's auto-populated
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.summary) helper.final_report.summary = {};
        helper.final_report.summary.market_value_damage = marketValueField.value;
      }
      
      // 2. Get sale value from manual input with retry mechanism - ENHANCED WITH VALIDATION
      console.log('🔍 Starting field value retrieval for saleValueDamage');
      const saleValue = await getFieldValueWithRetry('saleValueDamage');
      console.log(`📋 Final sale value used in calculation: ${saleValue}`);
      
      // 3. Calculation: Market Value - Sale Value (from user mapping)
      const calculatedTotal = marketValue - saleValue;
      
      // 4. Update total field
      const totalField = document.getElementById('afterSaleDamage');
      if (totalField) {
        totalField.value = `₪${calculatedTotal.toLocaleString()}`;
        totalField.style.backgroundColor = '#e8f5e8'; // Show it's calculated
        helper.final_report.summary.total_after_sale_damage = totalField.value;
      }
      
      console.log(`Damage sale calculation: Market Value=${marketValue}, Sale Value=${saleValue}, Total=${calculatedTotal}`);
      return calculatedTotal;
    }
    
    // TOTAL LOSS REPORT CALCULATION (Based on User Mapping)
    function calculateTotalLossReport(helper, marketValue) {
      console.log('📊 Calculating Total Loss Report');
      
      // Get manual input values (user specified as manual inputs)
      const salvageField = document.getElementById('salvageValueTotal');
      const storageField = document.getElementById('storageValueTotal');
      
      const salvageValue = salvageField ? parseFloat(salvageField.value.replace(/[₪,]/g, '') || '0') : 0;
      const storageValue = storageField ? parseFloat(storageField.value.replace(/[₪,]/g, '') || '0') : 0;
      
      // Calculation: Market Value - Salvage + Storage/Towing (from user mapping)
      const calculatedTotal = marketValue - salvageValue + storageValue;
      
      // Update UI fields
      const totalField = document.getElementById('afterSaleTotal');
      if (totalField) {
        totalField.value = `₪${calculatedTotal.toLocaleString()}`;
        helper.final_report.summary.total_after_salvage_total = totalField.value;
      }
      
      console.log(`Total loss calculation: ${marketValue} - ${salvageValue} + ${storageValue} = ${calculatedTotal}`);
    }
    
    // LEGAL LOSS REPORT CALCULATION (Based on User Mapping)
    function calculateLegalLossReport(helper, marketValue) {
      console.log('📊 Calculating Legal Loss Report');
      
      // Load salvage field from helper if empty (same logic as refreshSummary)
      const salvageField = document.getElementById('salvageValueLegal');
      if (salvageField && !salvageField.value && helper.final_report?.summary?.salvage_value_legal) {
        salvageField.value = helper.final_report.summary.salvage_value_legal;
        console.log(`📥 Loaded salvage legal value from helper in calculateLegalLossReport: ${salvageField.value}`);
      }
      
      // Get salvage value from manual input (user specified as manual)
      const salvageValue = salvageField ? parseFloat(salvageField.value.replace(/[₪,]/g, '') || '0') : 0;
      
      // Calculation: Market Value - Salvage Value (from user mapping)
      const calculatedTotal = marketValue - salvageValue;
      
      // Update UI fields
      const totalField = document.getElementById('afterSaleLegal');
      if (totalField) {
        totalField.value = `₪${calculatedTotal.toLocaleString()}`;
        helper.final_report.summary.total_after_salvage_legal = totalField.value;
      }
      
      console.log(`🧮 Legal loss calculation: ₪${marketValue.toLocaleString()} - ₪${salvageValue.toLocaleString()} = ₪${calculatedTotal.toLocaleString()}`);
    }
    
    // ENHANCED MANUAL INPUT FIELD LISTENERS - Real-time persistence and calculations
    function addManualInputFieldListeners() {
      console.log('🔗 Setting up enhanced manual input field listeners');
      
      // Manual input fields for all 5 report variants
      const manualInputFields = [
        // Damaged Sale variant
        'saleValueDamage',
        
        // Total Loss variant
        'salvageValueTotal',
        'storageValueTotal', 
        
        // Legal Loss variant
        'salvageValueLegal',
        
        // Common fields that might be manually adjusted
        'salvageValue'
      ];
      
      // Add listeners to all manual input fields
      manualInputFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field) {
          // Input event for real-time updates
          field.addEventListener('input', function() {
            console.log(`📝 Manual field change: ${fieldId} = ${this.value}`);
            
            // Update helper immediately using comprehensive mapping
            updateHelperFromManualField(fieldId, this.value);
            
            // Trigger real-time calculations
            calculateSummaryTotals();
          });
          
          // Change event for when user finishes editing
          field.addEventListener('change', function() {
            console.log(`✅ Manual field completed: ${fieldId} = ${this.value}`);
            
            // Save to sessionStorage
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            sessionStorage.setItem('helper', JSON.stringify(helper));
          });
          
          // Focus/blur events for user experience
          field.addEventListener('focus', function() {
            this.style.borderColor = '#007bff';
            this.style.boxShadow = '0 0 0 0.2rem rgba(0, 123, 255, 0.25)';
          });
          
          field.addEventListener('blur', function() {
            this.style.borderColor = '';
            this.style.boxShadow = '';
          });
          
          console.log(`✅ Listeners added to manual field: ${fieldId}`);
        }
      });
    }
    
    // Update helper from manual field using comprehensive mapping
    function updateHelperFromManualField(fieldId, value) {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      helper.final_report = helper.final_report || {};
      helper.final_report.summary = helper.final_report.summary || {};
      
      // Get the helper key using our comprehensive mapping
      const mappingKey = getHelperMappingKey(fieldId);
      if (mappingKey) {
        helper.final_report.summary[mappingKey] = value;
        console.log(`📊 Updated helper: ${mappingKey} = ${value}`);
        
        // Update window.helper for immediate access
        window.helper = helper;
      } else {
        console.warn(`⚠️ No mapping found for manual field: ${fieldId}`);
      }
    }
    
    // Real-time field synchronization across all variants
    function synchronizeSummaryFields() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Auto-populate fields that should sync across variants
      const marketValue = helper.calculations?.full_market_value || 0;
      if (marketValue > 0) {
        const marketValueFields = ['sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 'sumMarketValueTotal', 'sumMarketValueLegal'];
        marketValueFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field && !field.value) { // Only update if empty
            field.value = `₪${marketValue.toLocaleString()}`;
          }
        });
      }
    }
    
    // CRITICAL FIX: Initialize Summary Fields and Manual Inputs
    function initializeSummaryFieldsFix() {
      console.log('🚨 CRITICAL FIX: Initializing summary fields and manual inputs');
      
      try {
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // TASK 1: Fix market value auto-population - Direct mapping from calculations.full_market_value
        const marketValue = helper.calculations?.full_market_value || 0;
        
        if (marketValue > 0) {
          console.log(`💰 Found market value: ₪${marketValue.toLocaleString()} (source: ${
            helper.calculations?.full_market_value ? 'calculations.full_market_value' :
            helper.valuation?.calculations?.full_price?.total ? 'valuation.calculations.full_price.total' :
            'levi_report.final_price'
          })`);
          
          // Populate ALL market value fields across variants
          const allMarketFields = [
            'sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 
            'sumMarketValueTotal', 'sumMarketValueLegal', 'sumMarketValuePrivate',
            'sumMarketValueDefault'
          ];
          
          allMarketFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
              field.value = `₪${marketValue.toLocaleString()}`;
              field.style.backgroundColor = '#e8f5e8'; // Show it's auto-populated
              console.log(`✅ Populated ${fieldId} with ₪${marketValue.toLocaleString()}`);
            }
          });
          
          // Update helper structure using consolidated key
          if (!helper.final_report) helper.final_report = {};
          if (!helper.final_report.summary) helper.final_report.summary = {};
          helper.final_report.summary.market_value = `₪${marketValue.toLocaleString()}`;
          
        } else {
          console.warn('⚠️ No market value found in helper');
        }
        
        // TASK 2: Fix Total Claim field population for ALL variants
        // Extract numeric value from total_claim which may be formatted
        let totalClaim = 0;
        if (helper.claims_data?.total_claim) {
          totalClaim = parseFloat(String(helper.claims_data.total_claim).replace(/[₪,]/g, '')) || 0;
        } else if (helper.damage_centers_summary?.total_cost) {
          totalClaim = parseFloat(String(helper.damage_centers_summary.total_cost).replace(/[₪,]/g, '')) || 0;
        } else if (helper.calculations?.total_damage) {
          totalClaim = parseFloat(String(helper.calculations.total_damage).replace(/[₪,]/g, '')) || 0;
        } else if (helper.damage_assessment?.totals?.Total_with_VAT) {
          totalClaim = parseFloat(String(helper.damage_assessment.totals.Total_with_VAT).replace(/[₪,]/g, '')) || 0;
        }
        
        if (totalClaim > 0) {
          console.log(`💰 Found total claim: ₪${totalClaim.toLocaleString()}`);
          
          // Populate ALL total claim fields across variants  
          const allClaimFields = [
            'sumClaim',          // Static Private report
            'sumClaimPrivate',   // Dynamic Private report  
            'sumClaimGlobal',    // Dynamic Global report (FIXED)
            'sumClaimDefault'    // Dynamic Default report
          ];
          
          allClaimFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
              field.value = `₪${totalClaim.toLocaleString()}`;
              field.style.backgroundColor = '#e8f5e8'; // Show it's auto-populated
              console.log(`✅ Populated ${fieldId} with ₪${totalClaim.toLocaleString()}`);
            } else {
              // Field doesn't exist - this is normal for variant-specific fields
            }
          });
          
          // Update helper structure using consolidated key
          if (!helper.final_report) helper.final_report = {};
          if (!helper.final_report.summary) helper.final_report.summary = {};
          helper.final_report.summary.total_claim = `₪${totalClaim.toLocaleString()}`;
          
        } else {
          console.warn('⚠️ No total claim found in helper');
        }
        
        // TASK 3: Fix Depreciation Compensation field population for ALL variants
        // Extract numeric value from globalDep1 which contains formatted value like "1,972₪"
        let depCompensation = 0;
        if (helper.depreciation?.globalDepValue) {
          depCompensation = parseFloat(String(helper.depreciation.globalDepValue).replace(/[₪,]/g, '')) || 0;
        } else if (helper.depreciation?.globalDep1) {
          depCompensation = parseFloat(String(helper.depreciation.globalDep1).replace(/[₪,%]/g, '')) || 0;
        } else if (helper.depreciation?.total_compensation) {
          depCompensation = parseFloat(String(helper.depreciation.total_compensation).replace(/[₪,]/g, '')) || 0;
        }
        
        if (depCompensation > 0) {
          console.log(`💰 Found depreciation compensation: ₪${depCompensation.toLocaleString()}`);
          
          // Populate ALL depreciation compensation fields across variants  
          const allDepFields = [
            'depCompensation',        // Static Private report
            'depCompensationPrivate', // Dynamic Private report  
            'depCompensationGlobal',  // Global report
            'sumDepreciation',        // Global dynamic report
            'sumDepreciationDefault'  // Default report
          ];
          
          allDepFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
              field.value = `₪${depCompensation.toLocaleString()}`;
              field.style.backgroundColor = '#e8f5e8'; // Show it's auto-populated
              console.log(`✅ Populated ${fieldId} with ₪${depCompensation.toLocaleString()}`);
            } else {
              // Field doesn't exist - this is normal for variant-specific fields
            }
          });
          
          // Update helper structure using consolidated key
          if (!helper.final_report) helper.final_report = {};
          if (!helper.final_report.summary) helper.final_report.summary = {};
          helper.final_report.summary.depreciation_compensation = `₪${depCompensation.toLocaleString()}`;
          
        } else {
          console.warn('⚠️ No depreciation compensation found in helper');
        }
        
        // TASK 4: Ensure manual input fields are enabled and working
        const manualInputFields = [
          'saleValueDamage',    // ערך המכירה במצבו הניזוק
          'salvageValueTotal',  // ערך שרידי הרכב (Total Loss)
          'salvageValueLegal',  // ערך שרידי הרכב (Legal Loss)
          'storageValueTotal',  // תוספת גרירה ואחסנה
          'salvageValue'        // General salvage value
        ];
        
        manualInputFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            console.log(`🔧 Processing manual field: ${fieldId}`, field);
            
            // Remove any readonly attributes
            field.removeAttribute('readonly');
            field.removeAttribute('disabled');
            
            // Ensure the field is editable
            field.style.backgroundColor = 'white';
            field.style.color = '#333';
            field.style.cursor = 'text';
            field.contentEditable = false; // Fix: contentEditable should be false for input elements
            
            // Ensure proper input attributes
            field.type = 'text';
            field.style.pointerEvents = 'auto';
            field.readOnly = false;
            
            // Add placeholder if empty
            if (!field.placeholder) {
              field.placeholder = 'הזן ערך...';
            }
            
            // Test typing capability
            if (!field.hasAttribute('data-typing-enabled')) {
              field.setAttribute('data-typing-enabled', 'true');
              
              // Test if field accepts input
              setTimeout(() => {
                field.focus();
                field.value = 'test';
                if (field.value === 'test') {
                  field.value = ''; // Clear test
                  console.log(`✅ ${fieldId} accepts input successfully`);
                } else {
                  console.error(`❌ ${fieldId} CANNOT accept input - investigating...`);
                  // Force clear all potential blockers
                  field.removeAttribute('readonly');
                  field.removeAttribute('disabled'); 
                  field.readOnly = false;
                  field.disabled = false;
                  field.style.pointerEvents = 'auto';
                  field.style.userSelect = 'text';
                  field.contentEditable = false;
                }
              }, 100);
              
              // Add enhanced event listeners
              field.addEventListener('input', function(e) {
                console.log(`📝 ${fieldId} input: ${e.target.value}`);
                updateHelperFromManualField(fieldId, e.target.value);
                calculateSummaryTotals();
                
                // Trigger Damaged Sale calculation if this is the sale value field
                if (fieldId === 'saleValueDamage') {
                  const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[₪,]/g, '')) || 0;
                  calculateDamagedSaleReport(helper, marketValue).catch(console.error);
                }
              });
              
              field.addEventListener('focus', function(e) {
                console.log(`🎯 ${fieldId} focused`);
                e.target.style.borderColor = '#007bff';
                e.target.style.boxShadow = '0 0 0 0.2rem rgba(0, 123, 255, 0.25)';
              });
              
              field.addEventListener('blur', function(e) {
                e.target.style.borderColor = '';
                e.target.style.boxShadow = '';
                console.log(`💾 ${fieldId} saved: ${e.target.value}`);
              });
              
              console.log(`✅ Manual input field enabled: ${fieldId}`);
            }
          } else {
            // Field doesn't exist - this is normal for variant-specific fields
          }
        });
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        // Trigger calculations and private report total calculation
        setTimeout(() => {
          calculateSummaryTotals();
          
          // NOTE: Removed all duplicate calculation function calls to prevent overrides
          // All calculations are now handled centrally by calculateSummaryTotals() based on selected report type
          // This prevents race conditions and duplicate calculations that were overriding correct values
        }, 500);
        
        console.log('✅ CRITICAL FIX: Summary fields initialization completed');
        
      } catch (error) {
        console.error('❌ CRITICAL FIX ERROR:', error);
      }
    }
    
    // HELPER DATA PERSISTENCE SAFEGUARDS
    function initializeHelperDataSafeguards() {
      console.log('🛡️ Initializing helper data persistence safeguards');
      
      try {
        // Create backup of helper data every time it changes
        const originalSetItem = sessionStorage.setItem;
        sessionStorage.setItem = function(key, value) {
          if (key === 'helper') {
            try {
              const helperData = JSON.parse(value);
              if (helperData && Object.keys(helperData).length > 0) {
                // Create backup with timestamp
                const backupKey = `helper_backup_${Date.now()}`;
                sessionStorage.setItem(backupKey, value);
                
                // Keep only last 3 backups
                const backupKeys = [];
                for (let i = 0; i < sessionStorage.length; i++) {
                  const storageKey = sessionStorage.key(i);
                  if (storageKey && storageKey.startsWith('helper_backup_')) {
                    backupKeys.push(storageKey);
                  }
                }
                
                // Sort by timestamp and remove old backups
                backupKeys.sort().slice(0, -3).forEach(oldBackup => {
                  sessionStorage.removeItem(oldBackup);
                });
                
                console.log('💾 Helper backup created:', backupKey);
              }
            } catch (e) {
              console.warn('⚠️ Could not backup helper data:', e);
            }
          }
          
          // Call original setItem
          return originalSetItem.call(this, key, value);
        };
        
        // Recovery function
        window.recoverHelperData = function() {
          const backupKeys = [];
          for (let i = 0; i < sessionStorage.length; i++) {
            const key = sessionStorage.key(i);
            if (key && key.startsWith('helper_backup_')) {
              backupKeys.push(key);
            }
          }
          
          if (backupKeys.length > 0) {
            // Get the most recent backup
            const latestBackup = backupKeys.sort().pop();
            const backupData = sessionStorage.getItem(latestBackup);
            
            if (backupData) {
              sessionStorage.setItem('helper', backupData);
              window.helper = JSON.parse(backupData);
              console.log('🔄 Helper data recovered from backup:', latestBackup);
              
              // Refresh the page to reload the data
              if (confirm('Helper data recovered! Refresh page to see changes?')) {
                location.reload();
              }
              return true;
            }
          }
          
          console.warn('⚠️ No helper backup found');
          return false;
        };
        
        // Add recovery button to console
        console.log('🆘 To recover helper data, run: window.recoverHelperData()');
        
        // Check if helper data is empty and offer recovery
        const currentHelper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        const helperKeys = Object.keys(currentHelper);
        
        if (helperKeys.length < 3) { // Helper seems empty or minimal
          console.warn('⚠️ Helper data appears to be cleared or minimal');
          console.log('🔍 Current helper keys:', helperKeys);
          
          // Try to recover automatically
          setTimeout(() => {
            if (window.recoverHelperData) {
              console.log('🚨 Attempting automatic helper data recovery...');
              window.recoverHelperData();
            }
          }, 1000);
        }
        
        console.log('✅ Helper data safeguards initialized');
        
      } catch (error) {
        console.error('❌ Error initializing helper safeguards:', error);
      }
    }
    
    // COMPREHENSIVE TESTING SYSTEM FOR ALL 5 REPORT VARIANTS
    function testSummaryFieldMappings() {
      console.log('🧪 Starting comprehensive summary field mapping tests...');
      
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const testResults = {
        passed: 0,
        failed: 0,
        details: []
      };
      
      // Test 1: Comprehensive Mapping Dictionary
      const mappingTest = testComprehensiveMapping();
      testResults.details.push(mappingTest);
      mappingTest.passed ? testResults.passed++ : testResults.failed++;
      
      // Test 2: Auto-population System
      const autoPopTest = testAutoPopulation();
      testResults.details.push(autoPopTest);
      autoPopTest.passed ? testResults.passed++ : testResults.failed++;
      
      // Test 3: Manual Input Persistence
      const persistenceTest = testManualInputPersistence();
      testResults.details.push(persistenceTest);
      persistenceTest.passed ? testResults.passed++ : testResults.failed++;
      
      // Test 4: Variant-specific Calculations
      const calcTest = testVariantCalculations();
      testResults.details.push(calcTest);
      calcTest.passed ? testResults.passed++ : testResults.failed++;
      
      // Test 5: Helper Structure Integrity
      const helperTest = testHelperStructure();
      testResults.details.push(helperTest);
      helperTest.passed ? testResults.passed++ : testResults.failed++;
      
      // Display results
      console.log(`🧪 Test Results: ${testResults.passed} passed, ${testResults.failed} failed`);
      testResults.details.forEach(test => {
        const icon = test.passed ? '✅' : '❌';
        console.log(`${icon} ${test.name}: ${test.message}`);
      });
      
      return testResults;
    }
    
    function testComprehensiveMapping() {
      const requiredFields = [
        'sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 
        'sumMarketValueTotal', 'sumMarketValueLegal', 'saleValueDamage',
        'salvageValueTotal', 'storageValueTotal', 'salvageValueLegal'
      ];
      
      const missingMappings = requiredFields.filter(fieldId => !getHelperMappingKey(fieldId));
      
      return {
        name: 'Comprehensive Mapping Dictionary',
        passed: missingMappings.length === 0,
        message: missingMappings.length === 0 ? 
          'All fields have proper mappings' : 
          `Missing mappings for: ${missingMappings.join(', ')}`
      };
    }
    
    function testAutoPopulation() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const marketValue = helper.calculations?.full_market_value || 0;
      
      if (marketValue === 0) {
        return {
          name: 'Auto-population System',
          passed: false,
          message: 'No market value found in helper.calculations.full_market_value'
        };
      }
      
      const marketFields = document.querySelectorAll('#sumMarketValue, #sumMarketValueGlobal');
      const populatedFields = Array.from(marketFields).filter(field => field.value.includes(marketValue.toLocaleString()));
      
      return {
        name: 'Auto-population System',
        passed: populatedFields.length > 0,
        message: populatedFields.length > 0 ? 
          'Market value fields are properly auto-populated' :
          'Market value auto-population failed'
      };
    }
    
    function testManualInputPersistence() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const summaryExists = helper.final_report?.summary;
      
      if (!summaryExists) {
        return {
          name: 'Manual Input Persistence',
          passed: false,
          message: 'helper.final_report.summary structure not initialized'
        };
      }
      
      // Test if manual fields have mappings in helper
      const manualFields = ['saleValueDamage', 'paymentMethod', 'salvageValueTotal', 'storageValueTotal', 'salvageValueLegal'];
      const mappedFields = manualFields.filter(fieldId => {
        const key = getHelperMappingKey(fieldId);
        return key && helper.final_report.summary.hasOwnProperty(key);
      });
      
      return {
        name: 'Manual Input Persistence',
        passed: mappedFields.length >= manualFields.length / 2,
        message: `${mappedFields.length}/${manualFields.length} manual fields properly mapped`
      };
    }
    
    function testVariantCalculations() {
      // Test calculation functions exist
      const calcFunctions = [
        'calculatePrivateReport',
        'calculateGlobalReport', 
        'calculateDamagedSaleReport',
        'calculateTotalLossReport',
        'calculateLegalLossReport'
      ];
      
      const existingFunctions = calcFunctions.filter(funcName => typeof window[funcName] === 'function');
      
      return {
        name: 'Variant-specific Calculations',
        passed: existingFunctions.length === calcFunctions.length,
        message: `${existingFunctions.length}/${calcFunctions.length} calculation functions available`
      };
    }
    
    function testHelperStructure() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      const requiredStructures = [
        'final_report',
        'final_report.summary'
      ];
      
      const existingStructures = requiredStructures.filter(path => {
        return path.split('.').reduce((obj, key) => obj && obj[key], helper) !== undefined;
      });
      
      return {
        name: 'Helper Structure Integrity',
        passed: existingStructures.length === requiredStructures.length,
        message: `${existingStructures.length}/${requiredStructures.length} required structures present`
      };
    }
    
    // Depreciation functionality 
    function addDepreciationRow() {
      alert('הוסף שורת ירידת ערך - יטען עם מודול depreciation_module.js');
    }
    
    // Real differential row functionality
    // SESSION 47: SIMPLIFIED INVOICE DIFFERENTIAL ROW (NO VAT, NO DAMAGE CENTER)
    function createDifferentialRow(data = {}) {
      const div = document.createElement('div');
      div.className = 'differential-row';
      div.style.marginBottom = '20px';
      div.style.padding = '15px';
      div.style.background = '#f8fafc';
      div.style.borderRadius = '8px';
      div.style.border = '1px solid #e2e8f0';
      
      const amount = data.amount_without_vat || data.amount || 0;
      
      console.log('🔍 SESSION 47: Creating differential row with data:', data);

      div.innerHTML = `
        <!-- SESSION 88: Invoice Lines Dropdown -->
        <div style="margin-bottom: 15px; padding: 10px; background: #e3f2fd; border-radius: 6px; border: 1px solid #2196f3;">
          <label style="display: block; font-size: 12px; color: #1565c0; margin-bottom: 4px; font-weight: 600;">חשבונית - בחר פריט</label>
          <select class="diff-invoice-line" onchange="populateFromInvoiceLine(this)" style="width:100%; padding:10px; border-radius:6px; border:1px solid #2196f3; font-size:14px; background: white;">
            <option value="">בחר פריט מחשבונית...</option>
          </select>
          <div style="font-size: 11px; color: #666; margin-top: 4px;">
            בחירת פריט תמלא אוטומטית את כל השדות בשורה
          </div>
        </div>
        
        <!-- Row 1: Details (3 fields) - Responsive -->
        <div class="diff-details-row" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px;">
          <div>
            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">חלק</label>
            <input type="text" class="diff-part" placeholder="הזן חלק" value="${data.part || ''}" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px;">
          </div>
          <div>
            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">מהות ההפרש</label>
            <select class="diff-nature-dropdown" onchange="toggleNatureOtherField(this)" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px; margin-bottom: 5px;">
              <option value="">בחר מהות</option>
              <option value="parts" ${data.nature === 'parts' ? 'selected' : ''}>חלקים</option>
              <option value="works" ${data.nature === 'works' ? 'selected' : ''}>עבודות</option>
              <option value="repairs" ${data.nature === 'repairs' ? 'selected' : ''}>תיקונים</option>
              <option value="other" ${data.nature && !['parts', 'works', 'repairs'].includes(data.nature) ? 'selected' : ''}>אחר</option>
            </select>
            <input type="text" class="diff-nature-other" placeholder="פרט מהות אחרת" value="${data.nature && !['parts', 'works', 'repairs'].includes(data.nature) ? data.nature : ''}" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px; display: ${data.nature && !['parts', 'works', 'repairs'].includes(data.nature) ? 'block' : 'none'};">
            <input type="hidden" class="diff-nature" value="${data.nature || ''}">
          </div>
          <div>
            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">סיבת ההפרש</label>
            <input type="text" class="diff-reason" placeholder="הזן סיבה" value="${data.reason || ''}" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px;">
          </div>
        </div>
        
        <!-- Row 2: Amount (1 field) - Responsive -->
        <div class="diff-costs-row" style="display: grid; grid-template-columns: 1fr; gap: 10px;">
          <div>
            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">סכום (ללא מע״מ)</label>
            <input type="number" class="diff-amount" placeholder="0" value="${amount}" onchange="updateDifferentialsSummary()" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px;">
          </div>
        </div>
        
        <!-- Remove button -->
        <div style="text-align: center; margin-top: 15px;">
          <button type="button" class="btn-remove" style="background:#ef4444; color:white; border:none; padding:8px 16px; border-radius:6px; cursor:pointer; font-size:14px; transition: all 0.2s;">🗑️ הסר הפרש</button>
        </div>
        
        <!-- Mobile-specific CSS -->
        <style>
          @media (max-width: 768px) {
            .diff-details-row, .diff-costs-row {
              grid-template-columns: 1fr !important;
              gap: 15px !important;
            }
            .differential-row {
              padding: 12px !important;
              margin-bottom: 15px !important;
            }
            .diff-details-row input, .diff-costs-row input {
              padding: 12px !important;
              font-size: 16px !important; /* Prevents zoom on iOS */
            }
          }
          
          @media (max-width: 480px) {
            .diff-details-row, .diff-costs-row {
              gap: 10px !important;
            }
            .differential-row {
              padding: 10px !important;
            }
          }
        </style>
      `;
      
      // SESSION 47: Add event listeners (simplified - no VAT calculations)
      const amountInput = div.querySelector('.diff-amount');
      const removeBtn = div.querySelector('.btn-remove');
      
      amountInput.addEventListener('input', function() {
        updateDifferentialsSummary();
        setTimeout(saveDifferentialsToHelper, 100);
      });
      
      // Add auto-save to text inputs with delay to ensure data is captured
      setTimeout(() => {
        const partField = div.querySelector('.diff-part');
        const natureDropdown = div.querySelector('.diff-nature-dropdown');
        const natureOtherField = div.querySelector('.diff-nature-other');
        const reasonField = div.querySelector('.diff-reason');
        
        console.log('🔗 SESSION 47: ATTACHING EVENT LISTENERS:', {
          partField: !!partField,
          natureDropdown: !!natureDropdown,
          natureOtherField: !!natureOtherField,
          reasonField: !!reasonField
        });
        
        if (partField) {
          partField.addEventListener('input', (e) => {
            console.log('🔥 PART INPUT EVENT:', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (natureDropdown) {
          natureDropdown.addEventListener('change', (e) => {
            console.log('🔥 NATURE DROPDOWN EVENT:', e.target.value);
            toggleNatureOtherField(e.target);
          });
        }
        
        if (natureOtherField) {
          natureOtherField.addEventListener('input', (e) => {
            console.log('🔥 NATURE OTHER INPUT EVENT:', e.target.value);
            const hiddenField = div.querySelector('.diff-nature');
            if (hiddenField) hiddenField.value = e.target.value;
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (reasonField) {
          reasonField.addEventListener('input', (e) => {
            console.log('🔥 REASON INPUT EVENT:', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
      }, 50);
      
      removeBtn.addEventListener('click', function() {
        div.remove();
        updateDifferentialsSummary();
        setTimeout(saveDifferentialsToHelper, 100);
      });
      
      // SESSION 88: Populate invoice lines dropdown after creating the row
      setTimeout(() => {
        populateInvoiceLinesDropdown(div);
      }, 100);
      
      return div;
    }

    // ============================================================================
    // SESSION 88: INVOICE LINES INTEGRATION FOR DIFFERENTIALS
    // ============================================================================

    /**
     * Populate invoice lines dropdown in a differential row
     */
    async function populateInvoiceLinesDropdown(rowElement) {
      try {
        const dropdown = rowElement.querySelector('.diff-invoice-line');
        if (!dropdown) return;

        console.log('📋 SESSION 88: Populating invoice lines dropdown...');

        // Get invoice lines from multiple sources
        const invoiceLines = await getInvoiceLinesForCase();
        
        if (!invoiceLines || invoiceLines.length === 0) {
          dropdown.innerHTML = '<option value="">אין חשבוניות זמינות</option>';
          console.log('ℹ️ SESSION 88: No invoice lines found');
          return;
        }

        // Build dropdown options
        let optionsHTML = '<option value="">בחר פריט מחשבונית...</option>';
        
        invoiceLines.forEach((line, index) => {
          const displayText = `${line.invoice_number || 'חשבונית'} - ${line.description || 'פריט'} (₪${(line.line_total || 0).toLocaleString()})`;
          optionsHTML += `<option value="${index}" data-line='${JSON.stringify(line)}'>${displayText}</option>`;
        });

        dropdown.innerHTML = optionsHTML;
        console.log(`✅ SESSION 88: Populated dropdown with ${invoiceLines.length} invoice lines`);

      } catch (error) {
        console.error('❌ SESSION 88: Error populating invoice lines dropdown:', error);
        const dropdown = rowElement.querySelector('.diff-invoice-line');
        if (dropdown) {
          dropdown.innerHTML = '<option value="">שגיאה בטעינת חשבוניות</option>';
        }
      }
    }

    /**
     * Get invoice lines for the current case from applied mappings
     */
    async function getInvoiceLinesForCase() {
      try {
        const helper = window.helper || {};
        
        // Use the correct case_id path as specified in CLAUDE.md
        const caseId = helper.case_info?.supabase_case_id;
        
        console.log('🔍 SESSION 88 DEBUG: getInvoiceLinesForCase called');
        console.log('  case_id:', caseId);
        console.log('  window.supabase available:', !!window.supabase);
        
        if (!caseId || !window.supabase) {
          console.log('ℹ️ SESSION 88: No case_id or Supabase, cannot get invoice lines');
          return [];
        }
        
        // Query invoice_damage_center_mappings to get applied mappings
        const { data: mappings, error } = await window.supabase
          .from('invoice_damage_center_mappings')
          .select(`
            *,
            invoice:invoices!inner(
              id,
              invoice_number,
              supplier_name
            ),
            invoice_line:invoice_lines!inner(*)
          `)
          .eq('case_id', caseId);
        
        if (error) {
          console.error('❌ SESSION 88: Error querying mappings:', error);
          return [];
        }
        
        console.log('🔍 SESSION 88 DEBUG: Raw mappings data:', mappings);
        console.log('  Number of mappings:', mappings?.length || 0);
        
        if (!mappings || mappings.length === 0) {
          console.log('ℹ️ SESSION 88: No invoice mappings found');
          return [];
        }
        
        // Debug each mapping structure
        mappings.forEach((mapping, index) => {
          console.log(`🔍 Mapping ${index}:`, {
            id: mapping.id,
            invoice: mapping.invoice,
            invoice_line: mapping.invoice_line,
            case_id: mapping.case_id
          });
        });
        
        // Convert mappings to invoice lines format
        const allLines = mappings.map(mapping => {
          // Check for missing invoice data
          if (!mapping.invoice) {
            console.warn('⚠️ SESSION 88: Missing invoice data in mapping:', mapping.id);
            return null;
          }
          
          return {
            ...mapping.invoice_line,
            invoice_id: mapping.invoice.id,
            invoice_number: mapping.invoice.invoice_number,
            supplier_name: mapping.invoice.supplier_name,
            damage_center_id: mapping.damage_center_id,
            field_type: mapping.field_type,
            mapping_id: mapping.id,
            source: 'applied_mappings'
          };
        }).filter(line => line !== null); // Remove null entries

        console.log(`📊 SESSION 88: Found ${allLines.length} invoice lines from applied mappings`);
        return allLines;

      } catch (error) {
        console.error('❌ SESSION 88: Error getting invoice lines:', error);
        return [];
      }
    }

    /**
     * Populate differential row fields from selected invoice line
     */
    function populateFromInvoiceLine(selectElement) {
      try {
        const selectedIndex = selectElement.value;
        if (!selectedIndex) return;

        const selectedOption = selectElement.options[selectElement.selectedIndex];
        const lineData = JSON.parse(selectedOption.getAttribute('data-line'));
        
        console.log('📝 SESSION 88: Populating row from invoice line:', lineData);

        const row = selectElement.closest('.differential-row');
        if (!row) return;

        // Populate fields
        const partField = row.querySelector('.diff-part');
        const natureDropdown = row.querySelector('.diff-nature-dropdown');
        const reasonField = row.querySelector('.diff-reason');
        const amountField = row.querySelector('.diff-amount');

        if (partField) {
          partField.value = lineData.description || lineData.part_name || '';
        }

        if (natureDropdown) {
          const category = lineData.metadata?.category || lineData.category;
          if (category === 'part') {
            natureDropdown.value = 'parts';
          } else if (category === 'work') {
            natureDropdown.value = 'works';
          } else if (category === 'repair') {
            natureDropdown.value = 'repairs';
          } else {
            natureDropdown.value = 'other';
          }
          
          // Trigger change event to handle "other" field
          toggleNatureOtherField(natureDropdown);
        }

        if (reasonField) {
          reasonField.value = `חשבונית ${lineData.invoice_number} - ${lineData.supplier_name || 'ספק'}`;
        }

        if (amountField) {
          amountField.value = lineData.line_total || lineData.total_cost || 0;
        }

        // Update calculations
        updateDifferentialsSummary();
        setTimeout(saveDifferentialsToHelper, 100);

        console.log('✅ SESSION 88: Row populated successfully from invoice line');

      } catch (error) {
        console.error('❌ SESSION 88: Error populating from invoice line:', error);
      }
    }

    // Make function available globally
    window.populateFromInvoiceLine = populateFromInvoiceLine;
    
    // SESSION 47: UPDATE ALL DIFFERENTIALS SUBTOTALS
    function updateAllDifferentialsSubtotals() {
      const breakdown = calculatePartsDifferentialsBreakdown();
      
      // SESSION 48: Calculate category differentials from ערך ההנחה (reduction amounts)
      const categoryRows = document.querySelectorAll('.category-differential-row');
      let categoryReductionTotal = 0;
      categoryRows.forEach(row => {
        const reductionValueField = row.querySelector('.category-diff-category-value');
        const reductionValueText = reductionValueField?.value || '₪0';
        const reductionValue = parseFloat(reductionValueText.replace(/[₪,]/g, '')) || 0;
        categoryReductionTotal += reductionValue;
      });
      
      const invoiceRows = document.querySelectorAll('.differential-row');
      let invoiceTotal = 0;
      invoiceRows.forEach(row => {
        const amountField = row.querySelector('.diff-amount');
        const amount = parseFloat(amountField?.value) || 0;
        invoiceTotal += amount;
      });
      
      // SESSION 48: Sum of all REDUCTION amounts (not totals after reduction)
      const totalComponentDifferentials = Math.round(breakdown.totalReduction + breakdown.totalWear + categoryReductionTotal);
      const totalInvoiceDiff = Math.round(invoiceTotal);
      const grandTotalWithoutVAT = Math.round(totalComponentDifferentials + totalInvoiceDiff);
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const vatRate = parseFloat(window.helper?.calculations?.vat_rate || helper.calculations?.vat_rate || 18);
      const grandTotalVAT = Math.round(grandTotalWithoutVAT * (vatRate / 100));
      const grandTotalWithVAT = Math.round(grandTotalWithoutVAT + grandTotalVAT);
      
      const componentWearEl = document.getElementById('totalComponentWear');
      const invoiceDiffEl = document.getElementById('totalInvoiceDifferentials');
      const grandTotalWithoutVATEl = document.getElementById('grandTotalDifferentialsWithoutVAT');
      const grandTotalVATEl = document.getElementById('grandTotalDifferentialsVAT');
      const grandTotalWithVATEl = document.getElementById('grandTotalDifferentialsWithVAT');
      
      if (componentWearEl) componentWearEl.textContent = `₪${totalComponentDifferentials.toLocaleString()}`;
      if (invoiceDiffEl) invoiceDiffEl.textContent = `₪${totalInvoiceDiff.toLocaleString()}`;
      if (grandTotalWithoutVATEl) grandTotalWithoutVATEl.textContent = `₪${grandTotalWithoutVAT.toLocaleString()}`;
      if (grandTotalVATEl) grandTotalVATEl.textContent = `₪${grandTotalVAT.toLocaleString()}`;
      if (grandTotalWithVATEl) grandTotalWithVATEl.textContent = `₪${grandTotalWithVAT.toLocaleString()}`;
      
      console.log('📊 SESSION 47: Updated subtotals - Component: ₪', totalComponentWear, ', Invoice: ₪', totalInvoiceDiff, ', Grand (no VAT): ₪', grandTotalWithoutVAT, ', VAT: ₪', grandTotalVAT, ', Grand (with VAT): ₪', grandTotalWithVAT);
    }
    
    function toggleDifferentialsTable() {
      console.log('🔄 SESSION 47: TOGGLE DIFFERENTIALS TABLE CALLED');
      const checkbox = document.getElementById('hasDifferentials');
      const mainContainer = document.getElementById('differentialsMainContainer');
      
      console.log('📋 Checkbox state:', checkbox?.checked);
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (!helper.final_report) helper.final_report = {};
      if (!helper.final_report.differential) helper.final_report.differential = {};
      
      helper.final_report.differential.has_differentials = checkbox?.checked || false;
      sessionStorage.setItem('helper', JSON.stringify(helper));
      console.log('💾 Updated helper.final_report.differential.has_differentials =', checkbox?.checked);
      
      if (checkbox?.checked) {
        if (mainContainer) mainContainer.style.display = 'block';
        
        renderPartsReductionsSection();
        renderPartsWearSection();
        updateAllDifferentialsSubtotals();
      } else {
        if (mainContainer) mainContainer.style.display = 'none';
        // Clear all differential rows when hiding
        const container = document.getElementById('differentialsRows');
        if (container) {
          container.innerHTML = '';
          updateDifferentialsSummary();
        }
        // CLEAR DIFFERENTIAL DATA when unchecked
        console.log('🗑️ CLEARING DIFFERENTIAL DATA - checkbox unchecked');
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (!helper.final_report) helper.final_report = {};
        helper.final_report.differential = {
          has_differentials: false,
          items: [],
          summary: {
            total_amount_without_vat: 0,
            total_vat: 0,
            total_amount_with_vat: 0,
            currency: '₪'
          },
          last_updated: new Date().toISOString()
        };
        sessionStorage.setItem('helper', JSON.stringify(helper));
        console.log('💾 Saved unchecked differential state');
      }
      
      // Refresh container layout after toggle
      setTimeout(refreshDamageCentersContainerLayout, 200);
    }
    
    // Alias for toggleDifferentialsTable to match HTML onclick
    function toggleDifferentials() {
      return toggleDifferentialsTable();
    }
    
    
    function addDifferentialRow() {
      const container = document.getElementById('differentialsRows');
      if (container) {
        const newRow = createDifferentialRow();
        container.appendChild(newRow);
        console.log('✅ Added new differential row');
        updateDifferentialsSummary();
        setTimeout(saveDifferentialsToHelper, 100);
        
        // Force reattach event listeners to all existing rows
        setTimeout(reattachDifferentialEventListeners, 100);
      }
    }
    
    // Force reattach event listeners to all differential rows
    function reattachDifferentialEventListeners() {
      console.log('🔗 REATTACHING ALL DIFFERENTIAL EVENT LISTENERS');
      const rows = document.querySelectorAll('#differentialsRows .differential-row');
      
      rows.forEach((row, index) => {
        const partField = row.querySelector('.diff-part');
        const damageCenterDropdown = row.querySelector('.diff-damage-center');
        const natureDropdown = row.querySelector('.diff-nature-dropdown');
        const natureOtherField = row.querySelector('.diff-nature-other');
        const reasonField = row.querySelector('.diff-reason');
        
        console.log(`🔗 Row ${index} - Reattaching to:`, {
          partField: !!partField,
          damageCenterDropdown: !!damageCenterDropdown,
          natureDropdown: !!natureDropdown,
          natureOtherField: !!natureOtherField,
          reasonField: !!reasonField
        });
        
        // Remove existing listeners and add new ones
        if (partField) {
          partField.replaceWith(partField.cloneNode(true));
          const newPartField = row.querySelector('.diff-part');
          newPartField.addEventListener('input', (e) => {
            console.log('🔥 PART INPUT (REATTACHED):', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (damageCenterDropdown) {
          damageCenterDropdown.replaceWith(damageCenterDropdown.cloneNode(true));
          const newDamageCenterDropdown = row.querySelector('.diff-damage-center');
          newDamageCenterDropdown.addEventListener('change', (e) => {
            console.log('🔥 DAMAGE CENTER DROPDOWN (REATTACHED):', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (natureDropdown) {
          natureDropdown.replaceWith(natureDropdown.cloneNode(true));
          const newNatureDropdown = row.querySelector('.diff-nature-dropdown');
          newNatureDropdown.addEventListener('change', (e) => {
            console.log('🔥 NATURE DROPDOWN (REATTACHED):', e.target.value);
            toggleNatureOtherField(e.target);
          });
        }
        
        if (natureOtherField) {
          natureOtherField.replaceWith(natureOtherField.cloneNode(true));
          const newNatureOtherField = row.querySelector('.diff-nature-other');
          newNatureOtherField.addEventListener('input', (e) => {
            console.log('🔥 NATURE OTHER INPUT (REATTACHED):', e.target.value);
            const hiddenField = row.querySelector('.diff-nature');
            if (hiddenField) hiddenField.value = e.target.value;
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (reasonField) {
          reasonField.replaceWith(reasonField.cloneNode(true));
          const newReasonField = row.querySelector('.diff-reason');
          newReasonField.addEventListener('input', (e) => {
            console.log('🔥 REASON INPUT (REATTACHED):', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
      });
    }
    
    // SESSION 47: Auto-save differential data to helper (ENHANCED)
    function saveDifferentialsToHelper() {
      console.log('🚀 SESSION 47: SAVE DIFFERENTIALS FUNCTION CALLED!');
      const rows = document.querySelectorAll('#differentialsRows .differential-row');
      const differentialsData = [];
      let totalAmount = 0;
      let totalVat = 0;
      let totalWithVat = 0;
      
      console.log('🔍 DEBUG: Found', rows.length, 'invoice differential rows to save');
      
      rows.forEach((row, index) => {
        const partField = row.querySelector('.diff-part');
        const natureField = row.querySelector('.diff-nature');
        const reasonField = row.querySelector('.diff-reason');
        const amountField = row.querySelector('.diff-amount');
        
        const part = partField?.value || '';
        const nature = natureField?.value || '';
        const reason = reasonField?.value || '';
        const amount = parseFloat(amountField?.value) || 0;
        
        differentialsData.push({
          id: index + 1,
          part: part,
          nature: nature,
          reason: reason,
          amount_without_vat: amount
        });
        
        totalAmount += amount;
      });
      
      // SESSION 48: Collect category differentials with DETAILED logging
      const categoryDiffRows = document.querySelectorAll('.category-differential-row');
      const categoryDifferentials = [];
      
      console.log('🔍 SESSION 48: Searching for category differential rows...');
      console.log('   Found', categoryDiffRows.length, 'rows with class .category-differential-row');
      
      categoryDiffRows.forEach((row, index) => {
        const typeEl = row.querySelector('.category-diff-type');
        const percentageEl = row.querySelector('.category-diff-percentage');
        const categoryValueEl = row.querySelector('.category-diff-category-value');
        const amountEl = row.querySelector('.category-diff-amount');
        
        const type = typeEl?.value || '';
        const percentage = percentageEl?.value || '0%';
        const categoryValue = categoryValueEl?.value || '₪0';
        const amountRaw = amountEl?.value;
        const amount = parseFloat(amountRaw) || 0;
        
        console.log(`   Row ${index}: RAW VALUES from DOM:`);
        console.log(`      type raw="${typeEl?.value}", final="${type}"`);
        console.log(`      amount raw="${amountRaw}", parsed=${amount}`);
        console.log(`      percentage raw="${percentageEl?.value}", final="${percentage}"`);
        console.log(`      categoryValue raw="${categoryValueEl?.value}", final="${categoryValue}"`);
        console.log(`   Elements exist: type=${!!typeEl}, percentage=${!!percentageEl}, categoryValue=${!!categoryValueEl}, amount=${!!amountEl}`);
        
        // SESSION 48: Save ALL rows, not just ones with amount > 0
        if (type) {
          categoryDifferentials.push({
            id: index + 1,
            type: type,
            percentage: percentage,
            category_value: categoryValue,
            amount: amount
          });
          console.log(`   ✅ Saved row ${index} to categoryDifferentials`);
        } else {
          console.log(`   ⚠️ Skipped row ${index} - no category type selected`);
        }
      });
      
      console.log('📊 SESSION 48: Total category differentials to save:', categoryDifferentials.length);
      console.log('📊 Category differentials data:', categoryDifferentials);
      
      // Save to helper.final_report.differential
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (!helper.final_report) helper.final_report = {};
      
      const breakdown = calculatePartsDifferentialsBreakdown();
      const vatRate = parseFloat(window.helper?.calculations?.vat_rate || helper.calculations?.vat_rate || 18);
      
      // SESSION 48: Sum category_value (ערך ההנחה) not amount (סכום)
      const categoryReductionTotal = categoryDifferentials.reduce((sum, item) => {
        const reductionValue = parseFloat(String(item.category_value).replace(/[₪,]/g, '')) || 0;
        return sum + reductionValue;
      }, 0);
      
      const grandTotalWithoutVAT = totalAmount + breakdown.totalReduction + breakdown.totalWear + categoryReductionTotal;
      const grandTotalVAT = Math.round(grandTotalWithoutVAT * (vatRate / 100));
      const grandTotalWithVAT = Math.round(grandTotalWithoutVAT + grandTotalVAT);
      
      console.log('📊 SESSION 47: VAT Rate used for differentials:', vatRate, '% (from window.helper.calculations.vat_rate:', window.helper?.calculations?.vat_rate, ', helper.calculations.vat_rate:', helper.calculations?.vat_rate, ')');
      
      // SESSION 48: REBUILD - Capture ALL sections with complete field data
      helper.final_report.differential = {
        has_differentials: document.getElementById('hasDifferentials')?.checked || false,
        
        // SECTION 1: הנחת רכיב (Parts Reductions) - Auto-imported
        parts_reductions: {
          items: breakdown.reductions.map(item => ({
            damage_center: item.centerName,
            part_name: item.partName,
            percentage: item.percentage,
            amount: item.amount
          })),
          total: breakdown.totalReduction
        },
        
        // SECTION 2: בלאי רכיב (Parts Wear) - Auto-imported
        parts_wear: {
          items: breakdown.wear.map(item => ({
            damage_center: item.centerName,
            part_name: item.partName,
            percentage: item.percentage,
            amount: item.amount
          })),
          total: breakdown.totalWear
        },
        
        // SECTION 3: הפרשי קטגוריה (Category Differentials) - Manual entry
        category_differentials: {
          items: categoryDifferentials.map(item => ({
            category_type: item.type,
            category_value: item.category_value,
            percentage: item.percentage,
            amount: item.amount
          })),
          total: categoryReductionTotal
        },
        
        // SECTION 4: הפרשי חשבוניות (Invoice Differentials) - Manual entry
        invoice_differentials: {
          items: differentialsData.map(item => ({
            part: item.part,
            nature: item.nature,
            reason: item.reason,
            amount_without_vat: item.amount_without_vat
          })),
          total: totalAmount
        },
        
        // SUBTOTALS & SUMMARY
        subtotals: {
          component_differentials_total: Math.round(breakdown.totalReduction + breakdown.totalWear + categoryReductionTotal),
          invoice_total: Math.round(totalAmount)
        },
        
        grand_total: {
          without_vat: Math.round(grandTotalWithoutVAT),
          vat_amount: grandTotalVAT,
          with_vat: grandTotalWithVAT,
          vat_rate: vatRate,
          currency: '₪'
        },
        
        last_updated: new Date().toISOString()
      };
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // CRITICAL FIX: Also update window.helper to prevent broadcastHelperUpdate from overwriting
      if (window.helper) {
        if (!window.helper.final_report) window.helper.final_report = {};
        window.helper.final_report.differential = helper.final_report.differential;
        console.log('🔄 Updated window.helper.final_report.differential to prevent broadcast overwrite');
      }
      
      console.log('💾 Auto-saved differentials to helper:', helper.final_report.differential);
      
      // Trigger Global report recalculation if Global report is active
      setTimeout(() => {
        const sumTotalGlobalField = document.getElementById('sumTotalGlobal');
        if (sumTotalGlobalField && sumTotalGlobalField.offsetParent !== null) { // Check if visible
          const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[₪,]/g, '')) || 0;
          calculateGlobalReport(helper, marketValue);
          console.log('🔄 Triggered Global report recalculation due to differentials change');
        }
      }, 100);
      
      // Refresh damage centers container layout after differential changes
      setTimeout(refreshDamageCentersContainerLayout, 300);
    }
    
    function updateDifferentialsSummary() {
      console.log('🔄 SESSION 47: updateDifferentialsSummary called');
      
      updateAllDifferentialsSubtotals();
      
      updateDifferentialCalculations();
    }
    
    // NEW: Update differential calculations per damage center
    function updateDifferentialCalculations() {
      try {
        const helper = window.helper || {};
        const originalTotals = helper.damage_assessment?.totals || {};
        const damageCenters = helper.centers || [];
        
        // Initialize totals_after_differentials with original values
        if (!helper.damage_assessment) helper.damage_assessment = {};
        helper.damage_assessment.totals_after_differentials = {
          'Total parts': parseInt(originalTotals['Total parts'] || 0),
          'Total works': parseInt(originalTotals['Total works'] || 0),
          'Total repairs': parseInt(originalTotals['Total repairs'] || 0),
          'Other': 0,
          'Total with VAT': parseInt(originalTotals['Total with VAT'] || 0)
        };
        
        // Process each differential row
        const rows = document.querySelectorAll('#differentialsRows .differential-row');
        rows.forEach(row => {
          const damageCenterSelect = row.querySelector('.diff-damage-center');
          const natureSelect = row.querySelector('.diff-nature-dropdown');
          const amountInput = row.querySelector('.diff-amount');
          
          if (damageCenterSelect && natureSelect && amountInput) {
            const selectedCenter = damageCenterSelect.value;
            const nature = natureSelect.value;
            const amount = parseFloat(amountInput.value) || 0;
            
            if (selectedCenter && nature && amount !== 0) {
              // Apply differential to specific category
              const vatRate = getVatRate();
              const amountWithVat = Math.round(amount * (1 + vatRate));
              
              switch(nature) {
                case 'parts':
                  helper.damage_assessment.totals_after_differentials['Total parts'] += amount;
                  break;
                case 'works':
                  helper.damage_assessment.totals_after_differentials['Total works'] += amount;
                  break;
                case 'repairs':
                  helper.damage_assessment.totals_after_differentials['Total repairs'] += amount;
                  break;
                case 'other':
                  helper.damage_assessment.totals_after_differentials['Other'] += amount;
                  break;
              }
              
              // Update total with VAT
              if (nature !== 'other') {
                helper.damage_assessment.totals_after_differentials['Total with VAT'] += amountWithVat;
              } else {
                helper.damage_assessment.totals_after_differentials['Total with VAT'] += amount;
              }
            }
          }
        });
        
        // Update session storage and window.helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        // Refresh damage centers container layout
        setTimeout(refreshDamageCentersContainerLayout, 100);
        
        console.log('🔄 Updated differential calculations:', helper.damage_assessment.totals_after_differentials);
        
      } catch (error) {
        console.error('Error updating differential calculations:', error);
      }
    }
    
    // Save differentials data with user feedback
    // SESSION 48: Redirect to comprehensive save function
    function saveDifferentials() {
      console.log('💾 SAVE DIFFERENTIALS BUTTON CLICKED - Calling saveDifferentialsToHelper()');
      const saveButton = document.querySelector('button[onclick="saveDifferentials()"]');
      
      // Show visual feedback
      if (saveButton) {
        saveButton.style.background = '#17a2b8';
        saveButton.innerHTML = '⏳ שומר הפרשים...';
        saveButton.disabled = true;
      }
      
      // Call the comprehensive save function
      saveDifferentialsToHelper();
      
      // Show success message
      setTimeout(() => {
        if (saveButton) {
          saveButton.style.background = '#28a745';
          saveButton.innerHTML = '✅ נשמר הפרשים!';
          setTimeout(() => {
            saveButton.innerHTML = 'שמור הפרשים';
            saveButton.style.background = '#28a745';
            saveButton.disabled = false;
          }, 1500);
        }
      }, 100);
    }
    
    // Update final report fields (agreement status and company report)
    function updateFinalReportField(fieldName, value) {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (!helper.final_report) helper.final_report = {};
        
        helper.final_report[fieldName] = value;
        
        // Save to both storage locations
        sessionStorage.setItem('helper', JSON.stringify(helper));
        localStorage.setItem('helper', JSON.stringify(helper));
        
        // Update global helper directly to avoid setNestedValue error
        if (window.helper) {
          if (!window.helper.final_report) window.helper.final_report = {};
          window.helper.final_report[fieldName] = value;
        }
        
        console.log(`✅ Final report field updated: ${fieldName} = ${value}`);
      } catch (error) {
        console.error('❌ Error updating final report field:', error);
      }
    }
    
    // Save final report configuration function
    function saveFinalReportConfiguration() {
      try {
        // Collect current form values
        const reportType = document.getElementById('reportType')?.value;
        const isCompanyClient = document.getElementById('isCompanyClient')?.value;
        const inAgreement = document.getElementById('inAgreement')?.value;
        
        // Update helper with current values - SIMPLIFIED TO AVOID setNestedValue ERROR
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (!helper.final_report) helper.final_report = {};
        
        if (reportType) helper.final_report.report_type = reportType;
        if (isCompanyClient !== undefined) helper.final_report.report_for_company = (isCompanyClient === 'yes');
        if (inAgreement !== undefined) helper.final_report.in_agreement = (inAgreement === 'yes');
        
        // Save to storage locations directly (avoid helper.js updateHelper to prevent error)
        sessionStorage.setItem('helper', JSON.stringify(helper));
        localStorage.setItem('helper', JSON.stringify(helper));
        
        // Update global helper if available (direct assignment, no updateHelper)
        if (window.helper) {
          window.helper.final_report = helper.final_report;
        }
        
        // Show success feedback
        const button = document.querySelector('button[onclick="saveFinalReportConfiguration()"]');
        const originalText = button.textContent;
        button.textContent = '✅ נשמר';
        button.style.background = '#28a745';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = '#28a745';
        }, 2000);
        
        console.log('✅ Final report configuration saved:', {
          report_type: helper.final_report.report_type,
          report_for_company: helper.final_report.report_for_company,
          in_agreement: helper.final_report.in_agreement
        });
      } catch (error) {
        console.error('❌ Error saving final report configuration:', error);
        alert('שגיאה בשמירת הגדרות הדו"ח');
      }
    }
    
    // Load differential data from helper on page load
    function loadDifferentialData() {
      // Prevent multiple loads
      if (window.differentialDataLoaded) {
        console.log('⚠️ Differential data already loaded, skipping...');
        return;
      }
      
      try {
        console.log('📖 LOADING DIFFERENTIAL DATA FROM HELPER...');
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        console.log('🔍 Checking for differential data in helper.final_report:', helper.final_report);
        const differentialData = helper.final_report?.differential;
        
        if (!differentialData) {
          console.log('📝 No differential data found in helper.final_report.differential');
          return;
        }
        
        if (!differentialData.has_differentials) {
          console.log('📝 Differential data exists but has_differentials is false:', differentialData);
          return;
        }
        
        console.log('📖 Loading differential data from helper:', differentialData);
        
        // Check the "has differentials" checkbox
        const hasDiffCheckbox = document.getElementById('hasDifferentials');
        if (hasDiffCheckbox) {
          hasDiffCheckbox.checked = differentialData.has_differentials;
          
          // SESSION 47: Use new main container
          const mainContainer = document.getElementById('differentialsMainContainer');
          
          if (differentialData.has_differentials && mainContainer) {
            mainContainer.style.display = 'block';
            
            // Render auto-imported sections
            renderPartsReductionsSection();
            renderPartsWearSection();
          }
          
          console.log('✅ Checkbox set to:', differentialData.has_differentials, 'without triggering toggle');
        }
        
        // SESSION 48: Load category differential items (NEW STRUCTURE)
        const categoryContainer = document.getElementById('categoryDifferentialsList');
        const categoryItems = differentialData.category_differentials?.items || [];
        if (categoryContainer && categoryItems.length > 0) {
          console.log('📋 SESSION 48: Loading', categoryItems.length, 'category differential items');
          
          categoryContainer.innerHTML = '';
          
          categoryItems.forEach((item) => {
            addCategoryDifferentialRow();
            const rows = document.querySelectorAll('.category-differential-row');
            const lastRow = rows[rows.length - 1];
            
            if (lastRow) {
              const typeSelect = lastRow.querySelector('.category-diff-type');
              const percentageInput = lastRow.querySelector('.category-diff-percentage');
              const categoryValueInput = lastRow.querySelector('.category-diff-category-value');
              const amountInput = lastRow.querySelector('.category-diff-amount');
              
              // SESSION 48: Load ALL saved values including calculated ones
              if (typeSelect) typeSelect.value = item.category_type || '';
              if (percentageInput) percentageInput.value = item.percentage || '0%';
              if (categoryValueInput) categoryValueInput.value = item.category_value || '₪0';
              if (amountInput) amountInput.value = item.amount || 0;
            }
          });
          
          // SESSION 48: Don't recalculate - use saved values
          updateAllDifferentialsSubtotals();
        }
        
        // SESSION 48: Load invoice differential items (NEW STRUCTURE)
        const invoiceContainer = document.getElementById('differentialsRows');
        const invoiceItems = differentialData.invoice_differentials?.items || [];
        if (invoiceContainer && invoiceItems.length > 0) {
          console.log('📋 SESSION 48: Loading', invoiceItems.length, 'invoice differential items');
          
          invoiceContainer.innerHTML = '';
          
          invoiceItems.forEach((item) => {
            const row = createDifferentialRow({
              part: item.part || '',
              nature: item.nature || '',
              reason: item.reason || '',
              amount: item.amount_without_vat || 0
            });
            invoiceContainer.appendChild(row);
          });
          
          // CRITICAL FIX: Reattach event listeners to loaded rows
          setTimeout(reattachDifferentialEventListeners, 200);
        }
        
        // Update all subtotals
        updateAllDifferentialsSubtotals();
        
        // Mark as loaded to prevent multiple loads
        window.differentialDataLoaded = true;
        console.log('✅ Differential data loaded successfully');
      } catch (error) {
        console.error('❌ Error loading differential data:', error);
      }
    }
    
    

    // Get VAT rate based on company selection
    function getVatRate() {
      const isCompanyClient = document.getElementById('isCompanyClient')?.value;
      return (isCompanyClient === 'yes') ? 0 : ((window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100); // 0% for companies, admin rate for private
    }

    // Toggle differentials display
    function toggleDifferentials() {
      const checkbox = document.getElementById('hasDifferentials');
      const table = document.getElementById('differentialsTable');
      const summary = document.getElementById('differentialsSummary');
      
      if (!checkbox) return;
      
      const show = checkbox.checked;
      console.log('Toggling differentials:', show);
      
      if (table) table.style.display = show ? 'block' : 'none';
      if (summary) summary.style.display = show ? 'block' : 'none';
      
      // Add initial row if showing for first time
      if (show && document.getElementById('differentialsRows') && document.getElementById('differentialsRows').children.length === 0) {
        addDifferentialRow();
      }
      
      // Update calculations
      if (show) {
        updateDifferentialsSummary();
      } else {
        // Clear all differentials when unchecked
        const rows = document.querySelectorAll('#differentialsRows .differential-row');
        rows.forEach(row => row.remove());
        updateDifferentialsSummary();
      }
    }

    // Save and refresh calculations
    function saveAndRefresh() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Collect differentials data
      const differentialsData = {
        has_differentials: document.getElementById('hasDifferentials')?.checked || false,
        differentials: collectDifferentials()
      };
      
      // Update helper
      if (!helper.expertise) helper.expertise = {};
      if (!helper.expertise.depreciation) helper.expertise.depreciation = {};
      
      helper.expertise.depreciation.has_differentials = differentialsData.has_differentials;
      helper.expertise.depreciation.differentials = differentialsData.differentials;
      
      // Save to storage
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Refresh calculations
      refreshSummary();
    }

    // Collect differentials data
    function collectDifferentials() {
      return Array.from(document.querySelectorAll('#differentialsRows .differential-row')).map(row => {
        const amount = parseFloat(row.querySelector('.diff-amount')?.value || '0') || 0;
        const vat = parseFloat(row.querySelector('.diff-vat')?.value || '0') || 0;
        const total = parseFloat(row.querySelector('.diff-total')?.value || '0') || 0;
        const part = row.querySelector('.diff-part')?.value?.trim() || '';
        const nature = row.querySelector('.diff-nature')?.value?.trim() || '';
        const reason = row.querySelector('.diff-reason')?.value?.trim() || '';
        
        return {
          part: part,
          nature: nature,
          reason: reason,
          amount: amount,
          vat: vat,
          total_with_vat: total
        };
      });
    }

    // Refresh summary calculations - COMPLETE DYNAMIC SYSTEM
    // DISABLED: Second refreshSummary function with wrong data sources
    // This function was overriding the correct refreshSummary and using wrong mappings:
    // - Used levi.final_price instead of calculations.full_market_value  
    // - Used calc.total_damage instead of claims_data.total_claim
    // - Used dep.global_amount instead of depreciation.globalDepValue
    /*
    function refreshSummary() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const calc = helper.expertise?.calculations || {};
      const dep = helper.expertise?.depreciation || {};
      const levi = helper.expertise?.levi_report || {};
      
      // Get base values
      const marketValue = parseFloat(levi.final_price) || 0;
      const totalClaim = parseFloat(calc.total_damage) || 0;
      const depCompensation = parseFloat(dep.global_amount) || 0;
      
      // Update all summary fields across all report types
      const summaryFields = [
        'sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 
        'sumMarketValueTotal', 'sumMarketValueLegal'
      ];
      summaryFields.forEach(id => {
        const field = document.getElementById(id);
        if (field) field.value = marketValue ? `₪${marketValue.toLocaleString()}` : '';
      });
      
      const claimFields = [
        'sumClaim', 'sumClaimGlobal'
      ];
      claimFields.forEach(id => {
        const field = document.getElementById(id);
        if (field) field.value = totalClaim ? `₪${totalClaim.toLocaleString()}` : '';
      });
      
      // Update main totalClaim field with formatting
      const totalClaimDiv = document.getElementById('totalClaim');
      if (totalClaimDiv) {
        totalClaimDiv.innerText = totalClaim ? `₪${totalClaim.toLocaleString()}` : '';
      }
      
      const depFields = [
        'depCompensation', 'depCompensationGlobal'
      ];
      depFields.forEach(id => {
        const field = document.getElementById(id);
        if (field) field.value = depCompensation ? `₪${depCompensation.toLocaleString()}` : '';
      });
      
      // Calculate subtotals including תוספות והורדות for each report type
      calculateSubtotals();
      
      // Specific fields for different report types
      const saleValueDamage = document.getElementById('saleValueDamage');
      if (saleValueDamage) saleValueDamage.value = calc.sale_value_damaged || '';
      
      const salvageValueTotal = document.getElementById('salvageValueTotal');
      if (salvageValueTotal) salvageValueTotal.value = calc.salvage_value || '';
      
      const salvageValueLegal = document.getElementById('salvageValueLegal');
      if (salvageValueLegal) salvageValueLegal.value = calc.salvage_value || '';
      
      const storageValueTotal = document.getElementById('storageValueTotal');
      if (storageValueTotal) storageValueTotal.value = calc.storage_value || '';
      
      // Populate תוספות והורדות from levi adjustments
      populateAdditionsFromLevi();
      
      // Update differentials summary
      updateDifferentialsSummary();
    }
    */

    // Calculate subtotals including תוספות והורדות for each report type
    function calculateSubtotals() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const calc = helper.expertise?.calculations || {};
      const dep = helper.expertise?.depreciation || {};
      const levi = helper.expertise?.levi_report || {};
      
      // Get base values
      const marketValue = parseFloat(levi.final_price) || 0;
      const totalClaim = parseFloat(calc.total_damage) || 0;
      const depCompensation = parseFloat(dep.global_amount) || 0;
      
      // Calculate additions/deductions for each report type
      const reportTypes = [
        { summaryType: 'summaryPrivate', totalField: 'sumTotal' },
        { summaryType: 'summaryGlobal', totalField: 'sumTotalGlobal' },
        { summaryType: 'summaryDamage', totalField: 'afterSaleDamage' },
        { summaryType: 'summaryTotalLoss', totalField: 'afterSaleTotal' },
        { summaryType: 'summaryLegalLoss', totalField: 'afterSaleLegal' }
      ];
      
      reportTypes.forEach(({ summaryType, totalField }) => {
        const additionsTotal = calculateAdditionsTotal(summaryType);
        let subtotal = 0;
        
        // Different calculation logic for different report types
        if (summaryType === 'summaryPrivate' || summaryType === 'summaryGlobal') {
          // For private/global: market value + total claim + depreciation compensation + additions
          subtotal = marketValue + totalClaim + depCompensation + additionsTotal;
        } else if (summaryType === 'summaryDamage') {
          // For damaged state: market value - sale value + additions
          const saleValue = parseFloat(document.getElementById('saleValueDamage')?.value?.replace(/[^\d.-]/g, '')) || 0;
          subtotal = marketValue - saleValue + additionsTotal;
        } else if (summaryType === 'summaryTotalLoss') {
          // For total loss: market value - salvage value + storage + additions
          const salvageValue = parseFloat(document.getElementById('salvageValueTotal')?.value?.replace(/[^\d.-]/g, '')) || 0;
          const storageValue = parseFloat(document.getElementById('storageValueTotal')?.value?.replace(/[^\d.-]/g, '')) || 0;
          subtotal = marketValue - salvageValue + storageValue + additionsTotal;
        } else if (summaryType === 'summaryLegalLoss') {
          // For legal loss: market value - salvage value + additions
          const salvageValue = parseFloat(document.getElementById('salvageValueLegal')?.value?.replace(/[^\d.-]/g, '')) || 0;
          subtotal = marketValue - salvageValue + additionsTotal;
        }
        
        // Update the total field
        const totalFieldElement = document.getElementById(totalField);
        if (totalFieldElement) {
          totalFieldElement.value = `₪${Math.max(0, subtotal).toLocaleString()}`;
        }
      });
    }

    // Calculate total of additions/deductions for a specific report type
    function calculateAdditionsTotal(summaryType) {
      let total = 0;
      
      // Calculate additions from custom fields using exact container mapping
      const gridMapping = {
        'summaryPrivate': 'sumAdditionsGrid',
        'summaryGlobal': 'sumAdditionsGridGlobal', 
        'summaryDamage': 'sumAdditionsGridDamage',
        'summaryTotalLoss': 'sumAdditionsGridTotalLoss',
        'summaryLegalLoss': 'sumAdditionsGridLegalLoss'
      };
      
      const gridId = gridMapping[summaryType];
      const customGrid = document.getElementById(gridId);
      if (customGrid) {
        const customRows = customGrid.querySelectorAll('.custom-summary-row');
        customRows.forEach(row => {
          const value = parseFloat(row.querySelector('.custom-field-value')?.value?.replace(/[^\d.-]/g, '')) || 0;
          total += value;
        });
      }
      
      // Calculate Levi adjustments
      total += calculateLeviAdjustmentsTotal(summaryType);
      
      return total;
    }

    // Calculate total of Levi adjustments for a specific report type
    function calculateLeviAdjustmentsTotal(summaryType) {
      let total = 0;
      
      // Map summary types to Levi adjustment container IDs
      const leviMapping = {
        'summaryPrivate': 'leviAdjustmentsRows-private',
        'summaryGlobal': 'leviAdjustmentsRows-global',
        'summaryDamage': 'leviAdjustmentsRows-damage',
        'summaryTotalLoss': 'leviAdjustmentsRows-totalLoss',
        'summaryLegalLoss': 'leviAdjustmentsRows-legalLoss'
      };
      
      const leviId = leviMapping[summaryType];
      const leviContainer = document.getElementById(leviId);
      if (leviContainer) {
        const leviRows = leviContainer.querySelectorAll('.levi-adjustment-row');
        leviRows.forEach(row => {
          const value = parseFloat(row.querySelector('.levi-adjustment-value')?.value?.replace(/[^\d.-]/g, '')) || 0;
          total += value;
        });
      }
      
      return total;
    }

    // Populate תוספות והורדות from levi adjustments
    function populateAdditionsFromLevi() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const levi = helper.expertise?.levi_report || {};
      
      if (!levi.adjustments || !Array.isArray(levi.adjustments)) return;
      
      // Map summary types to Levi adjustment container IDs
      const leviMapping = {
        'summaryPrivate': 'leviAdjustmentsRows-private',
        'summaryGlobal': 'leviAdjustmentsRows-global',
        'summaryDamage': 'leviAdjustmentsRows-damage',
        'summaryTotalLoss': 'leviAdjustmentsRows-totalLoss',
        'summaryLegalLoss': 'leviAdjustmentsRows-legalLoss'
      };
      
      // Populate for each summary type
      Object.keys(leviMapping).forEach(summaryType => {
        const containerId = leviMapping[summaryType];
        const container = document.getElementById(containerId);
        if (!container) return;
        
        // Clear existing rows
        container.innerHTML = '';
        
        // Add Levi adjustments
        levi.adjustments.forEach(adjustment => {
          if (adjustment.name && adjustment.value) {
            const row = createLeviAdjustmentRow(adjustment.name, adjustment.value);
            container.appendChild(row);
          }
        });
      });
      
      console.log('✅ Levi adjustments populated across all summary types');
    }

    // Render existing differentials from data
    function renderDifferentials(list) {
      const container = document.getElementById('differentialsRows');
      if (!container) return;
      
      container.innerHTML = '';
      console.log('🔍 Loading differentials data:', list);
      
      if (list && list.length > 0) {
        // FILTER OUT CORRUPTED DATA - only load properly structured differential data
        const validDifferentials = list.filter(item => {
          return item && typeof item === 'object' && (item.part || item.nature || item.reason || item.amount);
        });
        
        console.log('✅ Valid differentials after filter:', validDifferentials);
        
        validDifferentials.forEach(item => {
          const row = createDifferentialRow(item);
          container.appendChild(row);
        });
      }
      updateDifferentialsSummary();
    }

    // ========================================
    // SESSION 62: CASE REDUCTION FUNCTIONS (הנחת תיק)
    // ========================================
    
    // Toggle Case Reduction Section
    function toggleCaseReductionTable() {
      const checkbox = document.getElementById('hasCaseReduction');
      const container = document.getElementById('caseReductionContainer');
      
      if (!checkbox || !container) {
        console.warn('⚠️ SESSION 62: Case reduction elements not found');
        return;
      }
      
      if (checkbox.checked) {
        container.style.display = 'block';
        
        // Initialize helper structure if needed
        if (!window.helper.final_report) window.helper.final_report = {};
        if (!window.helper.final_report.total_case_reduction) {
          window.helper.final_report.total_case_reduction = {
            enabled: true,
            percentage: 0,
            original_sum: 0,
            discount_value: 0,
            total_after_discount: 0,
            total_claim: 0
          };
        } else {
          window.helper.final_report.total_case_reduction.enabled = true;
        }
        
        // Load existing values if present
        const savedPercentage = window.helper.final_report.total_case_reduction.percentage || 0;
        document.getElementById('caseReductionPercentage').value = savedPercentage;
        
        // Calculate initial values
        calculateCaseReduction();
        
        console.log('✅ SESSION 62: Case reduction enabled');
      } else {
        container.style.display = 'none';
        if (window.helper.final_report?.total_case_reduction) {
          window.helper.final_report.total_case_reduction.enabled = false;
        }
        
        // Auto-save to sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(window.helper));
        
        console.log('❌ SESSION 62: Case reduction disabled');
      }
    }
    
    // Calculate Case Reduction Values
    function calculateCaseReduction() {
      // Get percentage input
      const percentageInput = document.getElementById('caseReductionPercentage');
      if (!percentageInput) {
        console.warn('⚠️ SESSION 62: Percentage input not found');
        return;
      }
      
      const percentage = parseFloat(percentageInput.value) || 0;
      
      // Validate percentage (0-100)
      if (percentage < 0) {
        percentageInput.value = 0;
        return;
      }
      if (percentage > 100) {
        percentageInput.value = 100;
        return;
      }
      
      // Get original sum from damage_assessment.totals
      const originalSum = window.helper?.damage_assessment?.totals?.["Total without VAT"] || 0;
      
      // Get VAT rate (NEVER hardcode!)
      let vatRate = window.helper?.calculations?.vat_rate;
      
      // If vat_rate is stored as percentage (e.g., 17), convert to decimal (0.17)
      if (vatRate > 1) {
        vatRate = vatRate / 100;
      }
      
      // Fallback to 0.17 if not found
      if (!vatRate) {
        vatRate = 0.17;
      }
      
      console.log('🔍 VAT Rate:', vatRate, 'from helper:', window.helper?.calculations?.vat_rate);
      
      // Calculate values (SESSION 62: Round all to whole numbers)
      const discountValue = Math.round(originalSum * (percentage / 100));
      const totalAfterDiscount = Math.round(originalSum - discountValue);
      const vatAmount = Math.round(totalAfterDiscount * vatRate);
      const totalWithVAT = totalAfterDiscount + vatAmount;
      
      console.log('🔍 Calculations:', { originalSum, discountValue, totalAfterDiscount, vatAmount, totalWithVAT });
      
      // Update UI display fields
      const caseOriginalSum = document.getElementById('caseOriginalSum');
      const caseDiscountValue = document.getElementById('caseDiscountValue');
      const caseTotalAfter = document.getElementById('caseTotalAfter');
      const caseTotalWithVAT = document.getElementById('caseTotalWithVAT');
      
      if (caseOriginalSum) caseOriginalSum.textContent = formatCurrency(originalSum);
      if (caseDiscountValue) caseDiscountValue.textContent = formatCurrency(discountValue);
      if (caseTotalAfter) caseTotalAfter.textContent = formatCurrency(totalAfterDiscount);
      if (caseTotalWithVAT) caseTotalWithVAT.textContent = formatCurrency(totalWithVAT);
      
      // Update helper.final_report.total_case_reduction
      if (!window.helper.final_report) window.helper.final_report = {};
      window.helper.final_report.total_case_reduction = {
        enabled: document.getElementById('hasCaseReduction')?.checked || false,
        percentage: percentage,
        original_sum: originalSum,
        discount_value: discountValue,
        total_after_discount: totalAfterDiscount,
        total_claim: totalWithVAT
      };
      
      // ⭐ SESSION 62: Also update helper.claims_data.total_claim_after_case_reduction
      if (!window.helper.claims_data) window.helper.claims_data = {};
      window.helper.claims_data.total_claim_after_case_reduction = totalWithVAT;
      
      // Auto-save to sessionStorage
      sessionStorage.setItem('helper', JSON.stringify(window.helper));
      
      console.log('✅ SESSION 62: Case reduction calculated and saved:', {
        percentage: percentage + '%',
        original: originalSum,
        discount: discountValue,
        final: totalWithVAT,
        saved_to_final_report: window.helper.final_report.total_case_reduction.total_claim,
        saved_to_claims_data: window.helper.claims_data.total_claim_after_case_reduction
      });
    }
    
    // Helper function for currency formatting (using existing pattern)
    function formatCurrency(value) {
      if (typeof value !== 'number') value = parseFloat(value) || 0;
      return '₪' + Math.round(value).toLocaleString('he-IL', {
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
      });
    }
    
    // Load Case Reduction from Helper
    function loadCaseReductionFromHelper() {
      if (!window.helper?.final_report?.total_case_reduction) {
        console.log('ℹ️ SESSION 62: No saved case reduction data found');
        return;
      }
      
      const data = window.helper.final_report.total_case_reduction;
      const checkbox = document.getElementById('hasCaseReduction');
      const percentageInput = document.getElementById('caseReductionPercentage');
      
      if (checkbox && data.enabled) {
        checkbox.checked = true;
        toggleCaseReductionTable();
      }
      
      if (percentageInput && data.percentage) {
        percentageInput.value = data.percentage;
        calculateCaseReduction();
      }
      
      console.log('✅ SESSION 62: Loaded case reduction from helper:', data);
    }
    
    // ========================================
    // END SESSION 62 CASE REDUCTION FUNCTIONS
    // ========================================

    // Create Levi adjustment row
    function createLeviAdjustmentRow(name, value) {
      const row = document.createElement('div');
      row.className = 'levi-adjustment-row';
      row.style.display = 'grid';
      row.style.gridTemplateColumns = '1fr 120px 80px';
      row.style.gap = '10px';
      row.style.marginBottom = '8px';
      row.style.alignItems = 'center';
      
      row.innerHTML = `
        <div>
          <input type="text" class="levi-adjustment-name" value="${name}" readonly style="width:100%; padding:6px; border:1px solid #ccc; background:#f8f9fa; border-radius:4px;">
        </div>
        <div>
          <input type="number" class="levi-adjustment-value" value="${value}" style="width:100%; padding:6px; border:1px solid #ccc; border-radius:4px;">
        </div>
        <div>
          <button type="button" class="btn-remove" style="background:#dc3545; color:white; border:none; padding:6px 10px; border-radius:4px; cursor:pointer;">✕</button>
        </div>
      `;
      
      // Add event listeners
      const valueInput = row.querySelector('.levi-adjustment-value');
      const removeBtn = row.querySelector('.btn-remove');
      
      valueInput.addEventListener('input', function() {
        calculateSubtotals();
        saveAndRefresh();
      });
      
      removeBtn.addEventListener('click', function() {
        row.remove();
        calculateSubtotals();
        saveAndRefresh();
      });
      
      return row;
    }

    // Global depreciation calculation
    function calculateGlobalDepreciationValue() {
      const globalDep1 = document.getElementById('globalDep1');
      if (!globalDep1) return;
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Try multiple sources for market value
      let marketValue = 0;
      
      // First try the summary market value field (most reliable)
      const sumMarketValueField = document.getElementById('sumMarketValue');
      if (sumMarketValueField && sumMarketValueField.value) {
        const sumMarketStr = sumMarketValueField.value.replace(/[₪,]/g, '') || '0';
        marketValue = parseFloat(sumMarketStr) || 0;
      }
      
      // Fallback to helper data
      if (!marketValue) {
        marketValue = helper.calculations?.market_value || 
                     helper.expertise?.levi_report?.final_price || 
                     helper.calculations?.vehicle_value_gross || 0;
      }
      // Clean the percentage value properly to handle decimals like 2.5%
      const cleanedValue = globalDep1.value.replace('%', '').replace(/[^0-9.-]/g, '');
      const depPercent = parseFloat(cleanedValue) || 0;
      
      const globalAmount = Math.round(marketValue * (depPercent / 100));
      
      // Update helper data
      if (!helper.expertise) helper.expertise = {};
      if (!helper.expertise.depreciation) helper.expertise.depreciation = {};
      helper.expertise.depreciation.global_percent = depPercent;
      helper.expertise.depreciation.global_amount = globalAmount;
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Update display - target the correct field: globalDepValue
      const globalDepValueField = document.getElementById('globalDepValue');
      if (globalDepValueField) {
        globalDepValueField.value = `₪${globalAmount.toLocaleString()}`;
      }
      
    }

    // Trigger MathEngine calculation
    function triggerMathCalculation() {
      if (typeof MathEngine !== 'undefined' && MathEngine.calculateAll) {
        try {
          // Gather required data for calculation
          const helper = window.helper || {};
          const baseDamage = helper.damage_assessment?.totals?.base_damage || 0;
          const depreciation = helper.depreciation?.total_value || 0;
          const fees = helper.fees?.total || 0;
          const marketValue = helper.vehicle?.market_value || 0;
          const vehicleValueGross = helper.vehicle?.gross_value || marketValue;
          const shavehPercent = helper.calculations?.shaveh_percent || 0;
          const vatRate = helper.calculations?.vat_rate || 18;
          
          const calculationData = {
            baseDamage,
            depreciation,
            fees,
            marketValue,
            vehicleValueGross,
            shavehPercent,
            vatRate
          };
          
          MathEngine.calculateAll(calculationData);
          console.log('✅ MathEngine calculation triggered with data:', calculationData);
        } catch (error) {
          console.error('❌ Error triggering MathEngine calculation:', error);
        }
      }
    }

    // Enhanced saveAndRefresh with complete data collection
    function saveAndRefreshComplete() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Ensure structure exists
      if (!helper.expertise) helper.expertise = {};
      if (!helper.expertise.depreciation) helper.expertise.depreciation = {};
      
      // Collect all form data
      const reportType = document.getElementById('reportType')?.value;
      const isCompanyClient = document.getElementById('isCompanyClient')?.value;
      const globalDep1 = document.getElementById('globalDep1')?.value;
      const workDays = document.getElementById('workDays')?.value;
      const isAgreement = document.getElementById('isAgreement')?.checked;
      const hasDifferentials = document.getElementById('hasDifferentials')?.checked;
      
      // Update helper with form data
      if (reportType) helper.meta = { ...helper.meta, report_type_display: reportType };
      if (isCompanyClient) helper.client = { ...helper.client, is_company_client: isCompanyClient === 'yes' };
      if (globalDep1) helper.expertise.depreciation.global_percent = parseFloat(globalDep1);
      if (workDays) helper.expertise.depreciation.work_days = parseInt(workDays);
      helper.expertise.depreciation.is_agreement = !!isAgreement;
      helper.expertise.depreciation.has_differentials = !!hasDifferentials;
      
      // Collect differentials
      if (hasDifferentials) {
        helper.expertise.depreciation.differentials = collectDifferentials();
      }
      
      // Save to storage
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Trigger calculations
      calculateGlobalDepreciationValue();
      triggerMathCalculation();
      refreshSummary();
      
      console.log('💾 Complete data saved and calculations refreshed');
    }

    // Add custom summary field - EXACT COPY FROM WORKING DEPRECIATION MODULE
    function addCustomSummaryField(summaryType) {
      const gridMapping = {
        'summaryPrivate': 'sumAdditionsGrid',
        'summaryGlobal': 'sumAdditionsGridGlobal', 
        'summaryDamage': 'sumAdditionsGridDamage',
        'summaryTotalLoss': 'sumAdditionsGridTotalLoss',
        'summaryLegalLoss': 'sumAdditionsGridLegalLoss'
      };
      
      const gridId = gridMapping[summaryType];
      const grid = document.getElementById(gridId);
      
      if (!grid) {
        console.warn('Grid not found for summary type:', summaryType);
        return;
      }
      
      const row = document.createElement('div');
      row.className = 'custom-summary-row';
      row.style.display = 'grid';
      row.style.gridTemplateColumns = '1fr 1fr 80px';
      row.style.gap = '10px';
      row.style.marginBottom = '10px';
      
      row.innerHTML = `
        <div>
          <input type="text" class="custom-field-name" placeholder="שם השדה" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc;">
        </div>
        <div>
          <input type="text" class="custom-field-value" placeholder="ערך" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc;">
        </div>
        <div>
          <button type="button" class="btn remove" style="background:#dc3545; padding:8px 12px; margin-top:0; font-size: 14px;">✕</button>
        </div>
      `;
      
      // Add event listeners
      row.querySelector('.remove').addEventListener('click', () => {
        row.remove();
        calculateSubtotals();
        saveAndRefreshComplete();
      });
      
      row.querySelector('.custom-field-name').addEventListener('input', () => {
        calculateSubtotals();
        saveAndRefreshComplete();
      });
      
      row.querySelector('.custom-field-value').addEventListener('input', () => {
        calculateSubtotals();
        saveAndRefreshComplete();
      });
      
      grid.appendChild(row);
      console.log(`✅ Custom field added to ${summaryType}`);
    }

    // NEW: Handle final report date completely separate from everything else
    function updateFinalReportDate(element) {
      console.log('🚀 updateFinalReportDate called! Element:', element.id, 'Value:', element.value);
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const value = element.value;
      
      // Create final report section if it doesn't exist
      if (!helper.final_report) helper.final_report = {};
      
      // Store ONLY in final report - NO connection to Levi or car details
      helper.final_report.report_date = value;
      helper.final_report.generated_date = new Date().toISOString();
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      console.log('💾 Saved to helper.final_report.report_date:', value);
      
      // Sync both final report date fields
      const topField = document.getElementById('finalReportDate');
      const summaryField = document.getElementById('finalReportDateSummary');
      if (topField && element.id !== 'finalReportDate') topField.value = value;
      if (summaryField && element.id !== 'finalReportDateSummary') summaryField.value = value;
      
      console.log('✅ Final report date updated (separate from Levi):', value);
    }

    // Alias for the same function
    function updateFinalReportDateField(element) {
      console.log('🔍 updateFinalReportDateField called with element:', element.id, 'value:', element.value);
      updateFinalReportDate(element);
      
      // Additional verification log
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('🔍 After save - final_report.report_date:', helper.final_report?.report_date);
    }

    // New workflow functions
    // REMOVED - Duplicate function that was saving to wrong location
    
    function continueToValidation() {
      // Save all current data before proceeding
      saveDepreciationData();
      
      // Set workflow state
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (!helper.workflow) helper.workflow = {};
      helper.workflow.current_stage = 'fee_calculation';
      helper.workflow.from_builder = true;
      helper.workflow.report_type = document.getElementById('reportType')?.value || 'חוות דעת פרטית';
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Navigate to fee module
      window.location.href = 'fee-module.html';
    }

    // Function to ensure salvage sale calculation works properly
    function ensureSalvageSaleCalculation() {
      const reportType = document.getElementById('reportType')?.value;
      if (reportType === 'חוות דעת מכירה מצבו הניזוק') {
        console.log('🔄 Ensuring salvage sale calculation');
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        const marketValue = helper.calculations?.full_market_value || 0;
        
        // Update market value field
        const marketField = document.getElementById('sumMarketValueDamage');
        if (marketField && marketValue > 0) {
          marketField.value = `₪${marketValue.toLocaleString()}`;
        }
        
        // Perform calculation
        const salvageSaleField = document.getElementById('saleValueDamage');
        if (salvageSaleField) {
          const salvagePrice = parseFloat(salvageSaleField.value.replace(/[₪,]/g, '')) || 0;
          const result = marketValue - salvagePrice;
          
          const resultField = document.getElementById('afterSaleDamage');
          if (resultField) {
            resultField.value = `₪${result.toLocaleString()}`;
            console.log(`✅ Salvage sale calculation ensured: ${marketValue} - ${salvagePrice} = ${result}`);
          }
        }
      }
    }
    
    // Function to ensure total loss calculation works properly with retry mechanism
    function ensureTotalLossCalculation(retryCount = 0) {
      const reportType = document.getElementById('reportType')?.value;
      if (reportType === 'חוות דעת טוטלוסט') {
        console.log(`🔄 Ensuring total loss calculation (attempt ${retryCount + 1})`);
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        const marketValue = helper.calculations?.full_market_value || 0;
        
        // Update market value field
        const marketField = document.getElementById('sumMarketValueTotal');
        if (marketField && marketValue > 0) {
          marketField.value = `₪${marketValue.toLocaleString()}`;
        }
        
        // Get field elements
        const salvageField = document.getElementById('salvageValueTotal');
        const towingField = document.getElementById('storageValueTotal');
        const resultField = document.getElementById('afterSaleTotal');
        
        // Check if fields are populated
        const fieldsReady = salvageField && towingField && 
                           (salvageField.value || towingField.value || 
                            helper.final_report?.summary?.salvage_value_total || 
                            helper.final_report?.summary?.storage_towing_value_total);
        
        if (!fieldsReady && retryCount < 5) {
          // Fields not ready, retry after delay
          console.log(`⏳ Fields not ready, retrying in 500ms...`);
          setTimeout(() => {
            ensureTotalLossCalculation(retryCount + 1);
          }, 500);
          return;
        }
        
        // Load manual fields from helper if empty
        if (salvageField && !salvageField.value) {
          const savedSalvage = helper.final_report?.summary?.salvage_value_total || '';
          if (savedSalvage) {
            salvageField.value = savedSalvage;
            console.log(`📥 Loaded salvage value from helper: ${salvageField.value}`);
          }
        }
        
        if (towingField && !towingField.value) {
          const savedTowing = helper.final_report?.summary?.storage_towing_value_total || '';
          if (savedTowing) {
            towingField.value = savedTowing;
            console.log(`📥 Loaded towing value from helper: ${towingField.value}`);
          }
        }
        
        // Perform calculation with current values
        if (resultField && marketValue > 0) {
          const salvageValue = parseFloat(salvageField?.value?.replace(/[₪,]/g, '')) || 0;
          const towingValue = parseFloat(towingField?.value?.replace(/[₪,]/g, '')) || 0;
          const result = marketValue - salvageValue + towingValue;
          
          resultField.value = `₪${result.toLocaleString()}`;
          console.log(`✅ Total loss calculation: ${marketValue} - ${salvageValue} + ${towingValue} = ${result}`);
          
          // Double-check after delay to ensure it sticks
          setTimeout(() => {
            const currentValue = resultField.value;
            const expectedValue = `₪${result.toLocaleString()}`;
            if (currentValue !== expectedValue) {
              resultField.value = expectedValue;
              console.log(`🔧 Re-applied total loss result: ${expectedValue}`);
            }
          }, 1000);
        }
      }
    }
    
    // Debug function to check Total Loss field values
    function debugTotalLossFields() {
      console.log('🐛 DEBUG: Total Loss Fields Status');
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      console.log('Helper values:', {
        marketValue: helper.calculations?.full_market_value,
        salvageInHelper: helper.final_report?.summary?.salvage_value_total,
        towingInHelper: helper.final_report?.summary?.storage_towing_value_total
      });
      
      const salvageField = document.getElementById('salvageValueTotal');
      const towingField = document.getElementById('storageValueTotal');
      const resultField = document.getElementById('afterSaleTotal');
      
      console.log('DOM field values:', {
        salvageField: salvageField?.value,
        towingField: towingField?.value,
        resultField: resultField?.value
      });
      
      console.log('Field elements exist:', {
        salvageField: !!salvageField,
        towingField: !!towingField,
        resultField: !!resultField
      });
    }
    
    // Make functions globally available
    window.updateSummaryVisibility = updateSummaryVisibility;
    window.ensureSalvageSaleCalculation = ensureSalvageSaleCalculation;
    window.ensureTotalLossCalculation = ensureTotalLossCalculation;
    window.debugTotalLossFields = debugTotalLossFields;
    
    // Initialize summary after helper system is ready
    function initializeSummaryWhenReady() {
      // Check both window.helper and sessionStorage for helper data
      const helperFromWindow = window.helper;
      const helperFromSession = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const helper = helperFromWindow || helperFromSession;
      
      // Ensure window.helper is set
      if (!window.helper) {
        window.helper = helper;
      }
      
      // Wait for market value to be available
      const marketValue = helper?.calculations?.full_market_value || 0;
      console.log(`🔍 Checking helper readiness - Market value: ${marketValue}`);
      
      if (helper && marketValue > 0) {
        console.log('🔄 Helper data is ready with market value, initializing summary...');
        
        // Restore the saved report type from helper or sessionStorage
        const reportTypeSelect = document.getElementById('reportType');
        const savedVariant = sessionStorage.getItem('selectedReportVariant') || helper.final_report?.dropdown_type;
        if (reportTypeSelect && savedVariant) {
          reportTypeSelect.value = savedVariant;
          console.log('✅ Restored report type:', savedVariant);
          
          // Ensure helper is updated with the restored value
          if (!helper.final_report) helper.final_report = {};
          helper.final_report.dropdown_type = savedVariant;
          window.helper = helper;
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        
        // First load all summary fields from helper
        loadSummaryFieldsFromHelper(helper);
        console.log('✅ Loaded summary fields from helper');
        
        console.log('🔄 About to call updateSummaryVisibility()');
        updateSummaryVisibility();
        console.log('✅ updateSummaryVisibility() called');
        
        // Additional safety: refresh summary after a short delay to ensure DOM is ready
        setTimeout(() => {
          console.log('🔄 Safety refresh of summary after DOM stabilization');
          refreshSummary();
          ensureSalvageSaleCalculation();
          ensureTotalLossCalculation();
          ensureLegalLossCalculation();
        }, 500);
        
        // Extra safety for Total Loss variant - ensure fields are populated before calculation
        if (savedVariant === 'חוות דעת טוטלוסט') {
          setTimeout(() => {
            console.log('🔄 Extra safety refresh for Total Loss variant');
            ensureTotalLossCalculation();
          }, 1000);
        }
        
        // Extra safety for Legal Loss variant - ensure fields are populated before calculation
        if (savedVariant === 'חוות דעת אובדן להלכה') {
          setTimeout(() => {
            console.log('🔄 Extra safety refresh for Legal Loss variant');
            ensureLegalLossCalculation();
          }, 1000);
        }
      } else {
        console.log('⏳ Helper data not ready yet (market value missing), waiting 500ms...');
        setTimeout(initializeSummaryWhenReady, 500);
      }
    }
    
    // Add event listeners for Total Loss and Salvage Sale calculations
    function setupTotalLossCalculation() {
      // Total Loss fields
      const salvageFieldTotal = document.getElementById('salvageValueTotal');
      const towingFieldTotal = document.getElementById('storageValueTotal');
      
      // Salvage Sale field
      const salvageSaleField = document.getElementById('saleValueDamage');
      
      // Legal Loss field
      const salvageLegalField = document.getElementById('salvageValueLegal');
      
      if (salvageFieldTotal) {
        salvageFieldTotal.addEventListener('input', refreshSummary);
      }
      if (towingFieldTotal) {
        towingFieldTotal.addEventListener('input', refreshSummary);
      }
      if (salvageSaleField) {
        salvageSaleField.addEventListener('input', refreshSummary);
      }
      if (salvageLegalField) {
        salvageLegalField.addEventListener('input', refreshSummary);
      }
      
      // Add event delegation for dynamically created fields
      document.addEventListener('input', function(event) {
        const fieldId = event.target.id;
        if (fieldId === 'saleValueDamage' || fieldId === 'sumDamagedSaleValue' || 
            fieldId === 'salvageValueTotal' || fieldId === 'storageValueTotal' ||
            fieldId === 'salvageValueLegal') {
          console.log(`🎯 Field input detected via event delegation: ${fieldId}`);
          refreshSummary();
        }
      });
    }

    // ENSURE LEGAL LOSS CALCULATION - Retry mechanism for page refresh timing issues
    function ensureLegalLossCalculation(retryCount = 0) {
      const reportType = document.getElementById('reportType')?.value;
      if (reportType === 'חוות דעת אובדן להלכה') {
        console.log(`🔄 Ensuring legal loss calculation (attempt ${retryCount + 1})`);
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        const marketValue = helper.calculations?.full_market_value || 0;
        
        // Update market value field
        const marketField = document.getElementById('sumMarketValueLegal');
        if (marketField && marketValue > 0) {
          marketField.value = `₪${marketValue.toLocaleString()}`;
        }
        
        // Get field elements
        const salvageField = document.getElementById('salvageValueLegal');
        const resultField = document.getElementById('afterSaleLegal');
        
        // Check if fields are populated
        const fieldsReady = salvageField && 
                           (salvageField.value || 
                            helper.final_report?.summary?.salvage_value_legal);
        
        if (!fieldsReady && retryCount < 5) {
          // Fields not ready, retry after delay
          console.log(`⏳ Legal loss fields not ready, retrying in 500ms...`);
          setTimeout(() => {
            ensureLegalLossCalculation(retryCount + 1);
          }, 500);
          return;
        }
        
        // Load manual fields from helper if they're empty
        if (salvageField && !salvageField.value) {
          const savedSalvage = helper.final_report?.summary?.salvage_value_legal || '';
          if (savedSalvage) {
            salvageField.value = savedSalvage;
            console.log(`📥 Loaded legal loss salvage value: ${salvageField.value}`);
          }
        }
        
        // Perform calculation
        if (resultField && marketValue > 0) {
          const salvageValue = parseFloat(salvageField?.value.replace(/[₪,]/g, '')) || 0;
          const legalLossResult = marketValue - salvageValue;
          
          resultField.value = `₪${legalLossResult.toLocaleString()}`;
          console.log(`🧮 Legal Loss retry calculation: ₪${marketValue.toLocaleString()} - ₪${salvageValue.toLocaleString()} = ₪${legalLossResult.toLocaleString()}`);
          
          // Save to helper
          helper.final_report = helper.final_report || {};
          helper.final_report.summary = helper.final_report.summary || {};
          helper.final_report.summary.total_after_salvage_legal = resultField.value;
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
      }
    }
    
    // Setup Total Loss calculation and start checking for helper readiness
    setupTotalLossCalculation();
    initializeSummaryWhenReady();
    
    // Additional safeguard on window load
    window.addEventListener('load', function() {
      setTimeout(() => {
        console.log('🔄 Window load - ensuring variant calculations');
        ensureSalvageSaleCalculation();
        ensureTotalLossCalculation();
        ensureLegalLossCalculation();
      }, 1000);
    });
    window.addDepreciationRow = addDepreciationRow;
    window.addDifferentialRow = addDifferentialRow;
    window.updateDifferentialsSummary = updateDifferentialsSummary;
    window.refreshDamageCentersContainerLayout = refreshDamageCentersContainerLayout;
    window.toggleNatureOtherField = toggleNatureOtherField;
    window.toggleDifferentials = toggleDifferentials;
    window.toggleDifferentialsTable = toggleDifferentialsTable;
    window.updateFinalReportDate = updateFinalReportDate;
    
    // Test function accessibility
    console.log('🧪 updateFinalReportDate function available:', typeof window.updateFinalReportDate);
    
    // Add event listeners programmatically as backup
    document.addEventListener('DOMContentLoaded', function() {
      const topField = document.getElementById('finalReportDate');
      const summaryField = document.getElementById('finalReportDateSummary');
      
      if (topField) {
        console.log('🔧 Adding event listener to finalReportDate');
        topField.addEventListener('change', function() {
          console.log('📅 finalReportDate changed programmatically to:', this.value);
          updateFinalReportDate(this);
        });
      }
      
      if (summaryField) {
        console.log('🔧 Adding event listener to finalReportDateSummary');
        summaryField.addEventListener('change', function() {
          console.log('📅 finalReportDateSummary changed programmatically to:', this.value);
          updateFinalReportDate(this);
        });
      }
    });
    window.saveDepreciationData = saveDepreciationData;
    window.continueToValidation = continueToValidation;
    window.saveAndRefresh = saveAndRefresh;
    window.saveAndRefreshComplete = saveAndRefreshComplete;
    window.refreshSummary = refreshSummary;
    window.calculateSubtotals = calculateSubtotals;
    window.calculateSummaryTotals = calculateSummaryTotals;
    window.calculateAdditionsTotal = calculateAdditionsTotal;
    window.calculateLeviAdjustmentsTotal = calculateLeviAdjustmentsTotal;
    window.populateAdditionsFromLevi = populateAdditionsFromLevi;
    window.collectDifferentials = collectDifferentials;
    window.getVatRate = getVatRate;
    window.renderDifferentials = renderDifferentials;
    window.saveDifferentials = saveDifferentials;
    window.updateFinalReportField = updateFinalReportField;
    window.loadDifferentialData = loadDifferentialData;
    window.reattachDifferentialEventListeners = reattachDifferentialEventListeners;
    window.saveDifferentials = saveDifferentials;
    window.saveDifferentialsToHelper = saveDifferentialsToHelper;
    window.addDifferentialRow = addDifferentialRow;
    window.toggleDifferentialsTable = toggleDifferentialsTable;
    window.testDifferentialSave = () => {
      console.log('🧪 MANUAL TEST: Reattaching listeners and saving...');
      reattachDifferentialEventListeners();
      setTimeout(saveDifferentialsToHelper, 200);
    };
    
    window.debugDifferentialData = () => {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('🔍 CURRENT HELPER DIFFERENTIAL DATA:', {
        exists: !!helper.final_report?.differential,
        has_differentials: helper.final_report?.differential?.has_differentials,
        items_count: helper.final_report?.differential?.items?.length || 0,
        items: helper.final_report?.differential?.items,
        full_structure: helper.final_report?.differential
      });
    };
    
    window.forceLoadDifferentials = () => {
      window.differentialDataLoaded = false;
      loadDifferentialData();
    };
    window.createLeviAdjustmentRow = createLeviAdjustmentRow;
    window.calculateGlobalDepreciationValue = calculateGlobalDepreciationValue;
    window.triggerMathCalculation = triggerMathCalculation;
    window.addCustomSummaryField = addCustomSummaryField;

    // Document Operations Functions
    window.returnToSelection = function() {
      if (confirm('האם אתה בטוח שברצונך לחזור לדף הבחירה? השינויים שלא נשמרו יאבדו.')) {
        window.location.href = 'selection.html';
      }
    };

    window.saveData = function() {
      saveFinalReport();
    };

    // Preview final report with all filled data
    window.previewFinalReport = function() {
      try {
        console.log('🔍 Opening final report template preview in PiP...');
        
        // Save current data first
        saveDepreciationData();
        
        // Get all the data from helper
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Set a flag to indicate we're in preview mode
        helper.preview_mode = true;
        helper.preview_timestamp = new Date().toISOString();
        
        // Make sure all the latest data is in the helper
        helper.final_report = helper.final_report || {};
        helper.final_report.generated_date = new Date().toLocaleDateString('he-IL');
        helper.final_report.preview = true;
        
        // Save the helper with preview flag
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Create preview modal if it doesn't exist
        let previewModal = document.getElementById('reportPreviewModal');
        if (!previewModal) {
          previewModal = createPreviewModal();
          document.body.appendChild(previewModal);
        }
        
        // Show the modal
        previewModal.style.display = 'block';
        
        // Load the report template in the iframe and populate tables after load
        const iframe = document.getElementById('reportPreviewFrame');
        
        // Use the exact same approach that works in template-builder
        iframe.onload = function() {
          console.log('📄 Template iframe loaded, waiting for initialization...');
          
          // Wait for the template to fully initialize
          setTimeout(() => {
            try {
              const iframeWindow = iframe.contentWindow;
              const iframeDocument = iframe.contentDocument;
              
              // Ensure sessionStorage data is available in iframe
              const helperData = sessionStorage.getItem('helper');
              const metaData = sessionStorage.getItem('meta');
              if (helperData) iframeWindow.sessionStorage.setItem('helper', helperData);
              if (metaData) iframeWindow.sessionStorage.setItem('meta', metaData);
              
              // Multiple retry attempts to ensure functions are loaded and execute
              let attempts = 0;
              const populateTables = () => {
                attempts++;
                if (iframeWindow && iframeWindow.populateNewAdjustmentsTable) {
                  console.log('✅ Populating iframe tables...');
                  iframeWindow.populateNewAdjustmentsTable();
                  iframeWindow.populateGrossDamageTable();
                  iframeWindow.formatDamagePercent();
                  console.log('✅ Preview tables populated successfully');
                } else if (attempts < 15) {
                  console.log(`⏳ Waiting for iframe functions... attempt ${attempts}`);
                  setTimeout(populateTables, 500);
                } else {
                  console.log('❌ Failed to find iframe functions after 15 attempts');
                }
              };
              
              populateTables();
            } catch (e) {
              console.error('Error populating preview tables:', e);
            }
          }, 3000); // Longer initial wait
        };
        
        iframe.src = 'final-report-template-builder.html';
        
        // Remove preview flag after a short delay
        setTimeout(() => {
          const updatedHelper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          delete updatedHelper.preview_mode;
          delete updatedHelper.preview_timestamp;
          if (updatedHelper.final_report) {
            delete updatedHelper.final_report.preview;
          }
          sessionStorage.setItem('helper', JSON.stringify(updatedHelper));
        }, 2000);
        
        console.log('✅ Final report preview opened in PiP');
        
      } catch (error) {
        console.error('❌ Error opening preview:', error);
        alert('שגיאה בפתיחת תצוגה מקדימה');
      }
    };
    
    // Create the preview modal structure
    function createPreviewModal() {
      const modal = document.createElement('div');
      modal.id = 'reportPreviewModal';
      
      // Get viewport dimensions for responsive sizing
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const isMobile = viewportWidth <= 768;
      
      // Calculate responsive dimensions and center positioning
      const width = isMobile ? Math.min(viewportWidth - 20, 350) : Math.min(800, viewportWidth - 100);
      const height = isMobile ? Math.min(viewportHeight - 100, 500) : Math.min(viewportHeight * 0.8, 600);
      const top = Math.max(10, (viewportHeight - height) / 2);
      const left = Math.max(10, (viewportWidth - width) / 2);
      
      modal.style.cssText = `
        display: none;
        position: fixed;
        top: ${top}px;
        left: ${left}px;
        width: ${width}px;
        height: ${height}px;
        background: white;
        border: 2px solid #333;
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        z-index: 10000;
        resize: ${isMobile ? 'none' : 'both'};
        overflow: auto;
        min-width: ${isMobile ? '300px' : '400px'};
        min-height: ${isMobile ? '250px' : '300px'};
        max-width: 95vw;
        max-height: 95vh;
      `;
      
      // Create header
      const header = document.createElement('div');
      header.style.cssText = `
        background: #1e40af;
        color: white;
        padding: ${isMobile ? '8px 12px' : '12px 20px'};
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: move;
        user-select: none;
        border-radius: 10px 10px 0 0;
        min-height: ${isMobile ? '40px' : '48px'};
        box-sizing: border-box;
      `;
      header.innerHTML = `
        <h3 style="margin: 0; font-size: ${isMobile ? '14px' : '18px'}; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">תצוגה מקדימה - חוות דעת</h3>
        <div style="display: flex; gap: ${isMobile ? '5px' : '10px'}; flex-shrink: 0;">
          <button onclick="minimizePreview()" style="background: none; border: none; color: white; font-size: ${isMobile ? '16px' : '20px'}; cursor: pointer; width: ${isMobile ? '32px' : '24px'}; height: ${isMobile ? '32px' : '24px'}; touch-action: manipulation;" title="מזער">_</button>
          <button onclick="maximizePreview()" style="background: none; border: none; color: white; font-size: ${isMobile ? '16px' : '20px'}; cursor: pointer; width: ${isMobile ? '32px' : '24px'}; height: ${isMobile ? '32px' : '24px'}; touch-action: manipulation;" title="הגדל">□</button>
          <button onclick="closePreview()" style="background: none; border: none; color: white; font-size: ${isMobile ? '20px' : '24px'}; cursor: pointer; width: ${isMobile ? '32px' : '24px'}; height: ${isMobile ? '32px' : '24px'}; touch-action: manipulation;" title="סגור">×</button>
        </div>
      `;
      
      // Create iframe container
      const iframeContainer = document.createElement('div');
      iframeContainer.style.cssText = `
        width: 100%;
        height: calc(100% - 50px);
        overflow: hidden;
      `;
      
      // Create iframe
      const iframe = document.createElement('iframe');
      iframe.id = 'reportPreviewFrame';
      iframe.style.cssText = `
        width: 100%;
        height: 100%;
        border: none;
      `;
      
      iframeContainer.appendChild(iframe);
      modal.appendChild(header);
      modal.appendChild(iframeContainer);
      
      // Make the modal draggable
      makeDraggable(modal, header);
      
      return modal;
    }
    
    // Make element draggable
    function makeDraggable(element, handle) {
      let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
      handle.onmousedown = dragMouseDown;
      
      function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
      }
      
      function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
        element.style.right = "auto";
      }
      
      function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
      }
    }
    
    // Preview control functions
    window.closePreview = function() {
      const modal = document.getElementById('reportPreviewModal');
      if (modal) {
        modal.style.display = 'none';
        const iframe = document.getElementById('reportPreviewFrame');
        if (iframe) iframe.src = '';
      }
    };
    
    window.minimizePreview = function() {
      const modal = document.getElementById('reportPreviewModal');
      if (modal) {
        modal.style.width = '400px';
        modal.style.height = '300px';
      }
    };
    
    window.maximizePreview = function() {
      const modal = document.getElementById('reportPreviewModal');
      if (modal) {
        modal.style.width = '90vw';
        modal.style.height = '90vh';
        modal.style.top = '5vh';
        modal.style.left = '5vw';
      }
    };


    // Functions for renamed buttons (former final report functions)
    window.fetchFinalReportPDF = function() {
      // Redirect to preview final report functionality
      previewFinalReport();
    };

    window.requestFinalReport = function() {
      // Redirect to generate final report functionality  
      generateFinalReport();
    };

    // EXPERTISE FETCH FUNCTION - Uses input field for flexibility
    window.fetchExpertisePDF = async function() {
      // FETCH functions use input field for flexibility (can load any case)
      const plateInput = document.getElementById('builderPlateInput');
      const plateNumber = plateInput ? plateInput.value.trim() : '';
      
      if (!plateNumber) {
        alert('אנא הכנס מספר רכב בשדה "טען תיק קיים"');
        return;
      }
      
      const fetchBtn = document.getElementById('fetchExpertiseBtn');
      const originalText = fetchBtn.textContent;
      
      try {
        fetchBtn.disabled = true;
        fetchBtn.textContent = 'טוען PDF...';
        
        const helper = sessionStorage.getItem('helper');
        const caseData = helper ? JSON.parse(helper) : null;
        const payload = {
          plate: plateNumber,
          case_id: caseData?.meta?.case_id,
          document_type: 'expertise'
        };
        
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('FETCH_EXPERTISE_PDF', payload);
        
        if (response?.success && response?.pdf_url) {
          showFloatingPDF(response.pdf_url, 'אקספירטיזה PDF');
        } else {
          alert('אקספירטיזה לא נמצאה במערכת או לא הופקה עדיין');
        }
        
      } catch (error) {
        console.error('Error fetching expertise PDF:', error);
        alert('שגיאה בטעינת אקספירטיזה PDF');
      } finally {
        fetchBtn.disabled = false;
        fetchBtn.textContent = originalText;
      }
    };

    // ESTIMATE FUNCTIONS - NEW ADDITION
    window.fetchEstimatePDF = async function() {
      // FETCH functions use input field for flexibility (can load any case)
      const plateInput = document.getElementById('builderPlateInput');
      const plateNumber = plateInput ? plateInput.value.trim() : '';
      
      if (!plateNumber) {
        alert('אנא הכנס מספר רכב בשדה "טען תיק קיים"');
        return;
      }
      
      const fetchBtn = document.getElementById('fetchEstimateBtn');
      const originalText = fetchBtn.textContent;
      
      try {
        fetchBtn.disabled = true;
        fetchBtn.textContent = 'טוען PDF...';
        
        const payload = {
          plate: plateNumber,
          case_id: helperData?.meta?.case_id,
          document_type: 'estimate'
        };
        
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('FETCH_ESTIMATE_PDF', payload);
        
        if (response?.success && response?.pdf_url) {
          showFloatingPDF(response.pdf_url, 'אומדן ראשוני PDF');
        } else {
          alert('אומדן ראשוני לא נמצא במערכת או לא הופק עדיין');
        }
        
      } catch (error) {
        console.error('Error fetching estimate PDF:', error);
        alert('שגיאה בטעינת אומדן ראשוני PDF');
      } finally {
        fetchBtn.disabled = false;
        fetchBtn.textContent = originalText;
      }
    };



    window.exitSystem = function() {
      if (confirm('האם אתה בטוח שברצונך לצאת מהמערכת? השינויים שלא נשמרו יאבדו.')) {
        // Clear session data
        sessionStorage.clear();
        window.location.href = 'index.html';
      }
    };

    // 🏛️ VAT RATE MANAGEMENT FUNCTIONS
    
    // Initialize VAT rate display
    window.initVatDisplay = async function() {
      try {
        // Try to get actual VAT rate from admin hub via MathEngine
        let adminVatRate = null;
        let vatSource = 'default';
        
        if (typeof MathEngine !== 'undefined' && MathEngine.loadAdminHubVatRate) {
          try {
            adminVatRate = await MathEngine.loadAdminHubVatRate();
            if (adminVatRate !== null) {
              vatSource = 'admin_hub';
              console.log('✅ Loaded VAT rate from admin hub:', adminVatRate + '%');
            }
          } catch (e) {
            console.warn('⚠️ Could not load VAT rate from admin hub:', e);
          }
        }
        
        // Fallback to helper or default
        if (adminVatRate === null) {
          adminVatRate = window.getHelperVatRate ? window.getHelperVatRate() : 18;
          vatSource = window.helper?.calculations?.vat_rate ? 'helper' : 'default';
        }
        
        // Update MathEngine with admin rate
        if (typeof MathEngine !== 'undefined' && MathEngine.setVatRate && vatSource === 'admin_hub') {
          MathEngine.setVatRate(adminVatRate);
        }
        
        // Update display
        const vatInput = document.getElementById('vat-rate-input');
        const sourceDisplay = document.getElementById('vat-source-display');
        const updatedDisplay = document.getElementById('vat-updated-display');
        
        if (vatInput) vatInput.value = adminVatRate;
        if (sourceDisplay) {
          sourceDisplay.textContent = vatSource === 'admin_hub' ? 'מנהל מערכת' : 
                                      vatSource === 'helper' ? 'נתוני מערכת' : 'ברירת מחדל';
        }
        if (updatedDisplay) {
          updatedDisplay.textContent = vatSource === 'admin_hub' ? 
            new Date().toLocaleString('he-IL') : 'לא עודכן מאדמין';
        }
        
        console.log(`📊 VAT display initialized: ${adminVatRate}% (${vatSource})`);
        
      } catch (e) {
        console.warn('⚠️ Could not initialize VAT display:', e);
        // Fallback initialization
        const vatInput = document.getElementById('vat-rate-input');
        if (vatInput) vatInput.value = 18;
      }
    };
    
    // Update VAT rate manually (DIRECT UPDATE TO calculations.vat_rate)
    window.updateVatRate = function() {
      const input = document.getElementById('vat-rate-input');
      const newRate = parseFloat(input.value);
      
      if (isNaN(newRate) || newRate < 0 || newRate > 100) {
        alert('אנא הזן שיעור מע"מ חוקי (0-100)');
        return;
      }
      
      // DIRECT UPDATE: Write directly to calculations.vat_rate (where all calculations read from)
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (!helper.calculations) helper.calculations = {};
      
      const oldRate = helper.calculations.vat_rate;
      
      // Set protection flags to ignore admin hub updates for 10 seconds
      window.lastManualVatUpdate = Date.now();
      window.ignoreAdminVatUntil = Date.now() + 10000; // 10 seconds protection
      console.log('🛡️ Manual VAT override protection activated for 10 seconds (final-report)');
      
      // CRITICAL: Create SESSION-ONLY override (NEVER touch admin hub)
      // 1. Update helper.calculations.vat_rate (session override)
      helper.calculations.vat_rate = newRate;
      helper.calculations.vat_rate_source = 'manual_session_override';
      helper.calculations.vat_rate_updated = new Date().toISOString();
      
      // 2. Update MathEngine with session override (DO NOT update admin hub core rate)
      if (typeof MathEngine !== 'undefined' && MathEngine.setSessionVatRate) {
        MathEngine.setSessionVatRate(newRate);
        console.log('SESSION OVERRIDE: MathEngine now uses:', newRate + '% (admin hub core rate preserved)');
      } else if (typeof MathEngine !== 'undefined') {
        // Fallback: direct update without admin hub communication
        sessionStorage.setItem('globalVAT', newRate);
        console.log('SESSION OVERRIDE: VAT rate stored in session, admin hub core rate preserved');
      }
      
      // Update window.helper in memory AND sessionStorage
      window.helper = helper;
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      console.log(`✅ DUAL VAT UPDATE: helper.calculations.vat_rate AND MathEngine changed to ${newRate}%`);
      console.log('Current helper.calculations.vat_rate:', helper.calculations.vat_rate);
      
      alert(`שיעור המע"מ עודכן ל-${newRate}%`);
      window.initVatDisplay(); // Refresh display
      
      // Trigger calculations refresh
      if (typeof refreshAllCalculations === 'function') {
        refreshAllCalculations();
      }
    };
    
    // Reset VAT rate to admin hub value (DIRECT IMPLEMENTATION)
    window.resetVatRateFromAdmin = function() {
      if (confirm('האם לאפס את שיעור המע"מ לערך מנהל המערכת?')) {
        
        // DIRECT ADMIN RATE RETRIEVAL (same as working estimate builder)
        console.log('DEBUGGING VAT SOURCES FOR RESET (FINAL REPORT):');
        console.log('- sessionStorage globalVAT:', sessionStorage.getItem('globalVAT'));
        console.log('- localStorage globalVAT:', localStorage.getItem('globalVAT'));
        console.log('- MathEngine available:', typeof MathEngine !== 'undefined');
        if (typeof MathEngine !== 'undefined' && MathEngine.getVatRate) {
          console.log('- MathEngine.getVatRate():', MathEngine.getVatRate());
        }
        
        // Get TRUE admin rate (NEVER from MathEngine - it has session overrides)
        let adminRate = 18; // TRUE admin hub default
        
        // Try to get the ORIGINAL admin rate from storage (if available)
        const originalAdminVat = localStorage.getItem('originalAdminVAT') || sessionStorage.getItem('originalAdminVAT');
        if (originalAdminVat && !isNaN(originalAdminVat)) {
          adminRate = parseFloat(originalAdminVat);
          console.log('Got ORIGINAL admin VAT from storage:', adminRate + '%');
        } else {
          // Fallback to known admin rate (should be 18% based on your setup)
          console.log('Using KNOWN admin hub rate (18%) - MathEngine has session overrides');
          adminRate = 18; // TRUE admin hub rate
        }
        
        console.log('ADMIN RATE FOR RESET (FINAL REPORT):', adminRate + '%');
        
        // DIRECTLY UPDATE BOTH SYSTEMS
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (!helper.calculations) helper.calculations = {};
        
        const oldRate = helper.calculations.vat_rate;
        const oldSource = helper.calculations.vat_rate_source;
        
        // RESTORE BOTH SYSTEMS to true admin rate
        // 1. Clear session override in helper
        helper.calculations.vat_rate = adminRate;
        helper.calculations.vat_rate_source = 'admin_hub_restored';
        helper.calculations.vat_rate_updated = new Date().toISOString();
        
        // Update window.helper and save
        window.helper = helper;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // 2. RESTORE MathEngine to true admin rate (clear session override)
        if (typeof MathEngine !== 'undefined') {
          console.log('BEFORE RESET: MathEngine had session override:', MathEngine.getVatRate ? MathEngine.getVatRate() : 'unknown');
          
          if (MathEngine.setVatRate) {
            MathEngine.setVatRate(adminRate);
            console.log('RESTORED: MathEngine back to admin rate:', adminRate + '%');
          }
          
          // Verify the restore worked
          setTimeout(() => {
            console.log('AFTER RESET: MathEngine now uses admin rate:', MathEngine.getVatRate ? MathEngine.getVatRate() : 'unknown');
          }, 100);
        }
        
        console.log('FINAL REPORT RESET COMPLETE: ' + oldRate + '% (' + oldSource + ') -> ' + adminRate + '% (admin_hub)');
        
        // Update display
        document.getElementById('vat-rate-input').value = adminRate;
        window.initVatDisplay();
        alert(`שיעור המע"מ אופס לערך מנהל המערכת: ${adminRate}%`);
        
        // Trigger calculations refresh
        if (typeof refreshAllCalculations === 'function') {
          refreshAllCalculations();
        }
      }
    };
    
    // 🔧 DEBUG: Test admin hub connection
    window.testAdminHubConnection = function() {
      console.log('🔍 Testing admin hub connection...');
      
      if (window.parent && window.parent !== window) {
        console.log('✅ Parent frame detected - we are in an iframe');
        
        // Test VAT rate request
        const timeout = setTimeout(() => {
          console.log('❌ Timeout: Admin hub did not respond');
          alert('❌ לא התקבלה תשובה מאדמין בזמן - ייתכן שהחיבור לא פעיל');
        }, 3000);
        
        const messageHandler = (event) => {
          if (event.data && event.data.type === 'VAT_RATE_RESPONSE') {
            clearTimeout(timeout);
            window.removeEventListener('message', messageHandler);
            console.log('✅ Admin hub responded with VAT rate:', event.data.vatRate + '%');
            alert(`✅ חיבור לאדמין פעיל! שיעור מע"מ נוכחי: ${event.data.vatRate}%`);
          }
        };
        
        window.addEventListener('message', messageHandler);
        window.parent.postMessage({ type: 'GET_VAT_RATE' }, '*');
        
      } else {
        console.log('❌ No parent frame - not running in admin hub');
        alert('❌ לא רץ בתוך מנהל המערכת - פתח דרך הפורטל');
      }
    };
    
    // 🔍 VERIFY: Check if admin hub functions are loaded
    window.verifyAdminHubFunctions = function() {
      const functions = [
        'initVatDisplay',
        'updateVatRate', 
        'resetVatRateFromAdmin',
        'testAdminHubConnection',
        'getHelperVatRate',
        'refreshHelperVatRate'
      ];
      
      console.log('🔍 Checking admin hub function availability:');
      functions.forEach(funcName => {
        const available = typeof window[funcName] === 'function';
        console.log(`${available ? '✅' : '❌'} ${funcName}: ${available ? 'Available' : 'Not found'}`);
      });
      
      // Check MathEngine availability
      const mathEngineAvailable = typeof MathEngine !== 'undefined';
      console.log(`${mathEngineAvailable ? '✅' : '❌'} MathEngine: ${mathEngineAvailable ? 'Available' : 'Not found'}`);
      
      if (mathEngineAvailable) {
        console.log(`📊 Current VAT rate from MathEngine: ${MathEngine.getVatRate()}%`);
      }
      
      return {
        functions: functions.reduce((acc, func) => ({ ...acc, [func]: typeof window[func] === 'function' }), {}),
        mathEngine: mathEngineAvailable,
        currentVat: mathEngineAvailable ? MathEngine.getVatRate() : null
      };
    };
    
    // ENSURE DATA FLOW: Update dependent fields when source data changes
    function refreshAllCalculations() {
      try {
        console.log('🔄 Starting calculation refresh...');
        
        // 0. Ensure basic price is populated from helper if empty
        ensureBasicPriceFromHelper();
        
        // 1. Update total claim from damage centers
        const totalClaim = calculateTotalClaimFromDamageCenters();
        const totalClaimField = document.getElementById('totalClaim');
        if (totalClaimField) {
          totalClaimField.value = totalClaim ? `₪${totalClaim.toLocaleString()}` : '₪0';
          console.log(`💰 Updated totalClaim: ${totalClaim}`);
        }
        
        // 2. Update gross market value from basic price + adjustments
        // Only if helper data has been loaded (to avoid overriding helper data)
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        if (helper && Object.keys(helper).length > 0 && typeof updateGrossMarketValueCalculation === 'function') {
          updateGrossMarketValueCalculation();
          console.log('📊 Updated gross market value');
        }
        
        // 3. Update damage percentage: totalClaim / grossMarketValue * 100
        if (typeof updateGrossPercentageField === 'function') {
          updateGrossPercentageField();
          console.log('📈 Updated damage percentage');
        }
        
        // 4. Update full market value from basic price + all adjustments
        if (typeof calculateFullMarketValue === 'function') {
          calculateFullMarketValue();
          console.log('🏪 Updated full market value');
        }
        
        console.log('✅ All calculations refreshed');
      } catch (error) {
        console.error('❌ Error refreshing calculations:', error);
      }
    }
    
    // Ensure basic price field is populated from helper data
    function ensureBasicPriceFromHelper() {
      try {
        const basicPriceField = document.getElementById('basicPrice');
        if (!basicPriceField) return;
        
        // Only update if field is empty
        if (basicPriceField.value && basicPriceField.value.trim() !== '') return;
        
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        let basePrice = 0;
        
        // Try multiple helper paths for base price
        if (helper.valuation?.base_price) {
          basePrice = parseFloat(helper.valuation.base_price.toString().replace(/[₪,]/g, ''));
        } else if (helper.levi_report?.base_price) {
          basePrice = parseFloat(helper.levi_report.base_price);
        } else if (helper.expertise?.levi_report?.base_price) {
          basePrice = parseFloat(helper.expertise.levi_report.base_price);
        } else if (helper.car_details?.base_price) {
          basePrice = parseFloat(helper.car_details.base_price.toString().replace(/[₪,]/g, ''));
        }
        
        if (basePrice > 0) {
          basicPriceField.value = `₪${basePrice.toLocaleString()}`;
          console.log(`💵 Populated basicPrice from helper: ${basePrice}`);
        }
      } catch (error) {
        console.error('❌ Error ensuring basic price from helper:', error);
      }
    }
    
    // Expose refresh function globally
    window.refreshAllCalculations = refreshAllCalculations;
    
    // NUCLEAR FIX FOR ALL MANUAL INPUT FIELDS
    function forceManualFieldsEditable() {
      const fieldsToFix = [
        {
          id: 'saleValueDamage',
          placeholder: 'הזן ערך המכירה...',
          label: 'Sale Value Damage',
          callback: function() {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[₪,]/g, '')) || 0;
            calculateDamagedSaleReport(helper, marketValue).catch(console.error);
          }
        },
        {
          id: 'salvageValueTotal',
          placeholder: 'הזן ערך שרידים...',
          label: 'Salvage Value Total',
          callback: function() {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[₪,]/g, '')) || 0;
            calculateTotalLossReport(helper, marketValue);
          }
        },
        {
          id: 'storageValueTotal',
          placeholder: 'הזן עלות גרירה ואחסנה...',
          label: 'Storage Value Total',
          callback: function() {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[₪,]/g, '')) || 0;
            calculateTotalLossReport(helper, marketValue);
          }
        },
        {
          id: 'salvageValueLegal',
          placeholder: 'הזן ערך שרידים...',
          label: 'Salvage Value Legal',
          callback: function() {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[₪,]/g, '')) || 0;
            calculateLegalLossReport(helper, marketValue);
          }
        }
      ];

      fieldsToFix.forEach(fieldConfig => {
        const field = document.getElementById(fieldConfig.id);
        if (field) {
          console.log(`🚨 FORCING ${fieldConfig.id} to be editable...`);
          
          // Nuclear option - completely reset the field
          const parent = field.parentNode;
          const newField = document.createElement('input');
          newField.type = 'text';
          newField.id = fieldConfig.id;
          newField.placeholder = fieldConfig.placeholder;
          newField.style.cssText = 'width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; background: white; color: #333;';
          
          // LOAD SAVED VALUE FROM HELPER
          const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
          const helperKey = getHelperMappingKey(fieldConfig.id);
          if (helperKey && helper.final_report?.summary?.[helperKey]) {
            newField.value = helper.final_report.summary[helperKey];
            console.log(`📖 Restored ${fieldConfig.id} value: ${newField.value}`);
          }
          
          // Add event listener with specific callback AND persistence
          newField.addEventListener('input', function(e) {
            console.log(`💰 ${fieldConfig.label} changed:`, e.target.value);
            
            // Save to helper immediately
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            if (!helper.final_report) helper.final_report = {};
            if (!helper.final_report.summary) helper.final_report.summary = {};
            
            const helperKey = getHelperMappingKey(fieldConfig.id);
            if (helperKey) {
              helper.final_report.summary[helperKey] = e.target.value;
              sessionStorage.setItem('helper', JSON.stringify(helper));
              window.helper = helper;
              console.log(`💾 Saved ${fieldConfig.id} to helper.final_report.summary.${helperKey}`);
            }
            
            // Trigger calculation
            if (fieldConfig.callback) {
              fieldConfig.callback();
            }
          });
          
          // Replace the problematic field
          parent.replaceChild(newField, field);
          console.log(`✅ ${fieldConfig.id} field replaced with editable version`);
        }
      });
    }

    // Load differential data on page load
    document.addEventListener('DOMContentLoaded', function() {
      console.log('📖 Loading saved differential data...');
      setTimeout(loadDifferentialData, 1000); // Increased delay to ensure all other loading is complete
      
      // SESSION 62: Load case reduction data
      console.log('📖 Loading saved case reduction data...');
      setTimeout(loadCaseReductionFromHelper, 1000);
      
      // Initialize differential fields visibility based on checkbox state
      setTimeout(() => {
        toggleDifferentialsTable(); // This will properly show/hide the "לאחר הפרשים" fields
        console.log('✅ Initialized differential fields visibility');
      }, 1200);
      
      // Fix all manual input fields
      setTimeout(forceManualFieldsEditable, 1500);
    });
    
    // Also try loading after the main data loading is complete
    window.addEventListener('load', function() {
      console.log('📖 Loading differential data after full page load...');
      setTimeout(loadDifferentialData, 500);
      
      // SESSION 62: Also load case reduction after full page load
      console.log('📖 Loading case reduction data after full page load...');
      setTimeout(loadCaseReductionFromHelper, 500);
    });
    
    // Auto-trigger calculation refresh when key data changes
    document.addEventListener('DOMContentLoaded', function() {
      console.log('🚀 Setting up data flow observers...');
      
      // Refresh calculations when damage centers are updated
      const damageCentersElement = document.getElementById('damageCentersContent');
      if (damageCentersElement) {
        const observer = new MutationObserver(function(mutations) {
          console.log('👀 Damage centers changed, refreshing calculations...');
          setTimeout(refreshAllCalculations, 300);
        });
        observer.observe(damageCentersElement, { childList: true, subtree: true });
        console.log('👀 Damage centers observer set up');
      }
      
      // Refresh calculations when basicPrice field changes
      const basicPriceField = document.getElementById('basicPrice');
      if (basicPriceField) {
        basicPriceField.addEventListener('input', function() {
          console.log('💵 Basic price changed, refreshing calculations...');
          setTimeout(refreshAllCalculations, 100);
        });
        console.log('💵 BasicPrice observer set up');
      }
      
      // Initialize VAT display on page load
      setTimeout(function() {
        if (typeof window.initVatDisplay === 'function') {
          window.initVatDisplay();
          console.log('🏛️ VAT display initialized');
        }
      }, 1000);
      
      // Initial calculation refresh on page load (delayed to allow helper data to load first)
      // TEMPORARILY DISABLED to check if this is causing configuration issues
      // setTimeout(refreshAllCalculations, 2000);
    });
    
  </script>
  
  <script type="module">
    // Import and make MathEngine globally available
    import { MathEngine } from './math.js';
    import { caseOwnershipService } from './services/caseOwnershipService.js';
    
    // Make MathEngine available globally for other scripts
    window.MathEngine = MathEngine;
    
    // Log that MathEngine is now available
    console.log('✅ MathEngine loaded and available globally');
    
    // Dispatch event to notify other scripts MathEngine is ready
    window.dispatchEvent(new CustomEvent('mathEngineReady', { 
      detail: { MathEngine: MathEngine } 
    }));
    
    // Phase 6: Case ownership check
    (async () => {
      const plateNumber = window.helper?.plate || sessionStorage.getItem('currentPlate');
      
      if (plateNumber) {
        const ownershipCheck = await caseOwnershipService.canEditCase(plateNumber);
        
        if (!ownershipCheck.canEdit) {
          alert(ownershipCheck.reason || 'אין לך הרשאה לערוך תיק זה.\n\nרק הבעלים, מנהל או מפתח יכולים לערוך.');
          window.location.href = 'selection.html';
          return;
        }
        
        console.log('✅ Case ownership verified - user can edit final report');
      }
    })();
  </script>
  
  <script>
    // 🔧 IMMEDIATE FUNCTIONS - Available right away for testing
    window.quickVatTest = function() {
      console.log('🔍 Quick VAT Test:');
      console.log('MathEngine available:', typeof MathEngine !== 'undefined');
      console.log('Helper VAT function:', typeof window.getHelperVatRate === 'function');
      console.log('Current VAT:', window.getHelperVatRate ? window.getHelperVatRate() : 'Not available');
      console.log('Parent frame detected:', window.parent !== window);
      
      // Test admin hub connection immediately
      if (window.parent && window.parent !== window) {
        console.log('📡 Sending test message to admin hub...');
        window.parent.postMessage({ type: 'GET_VAT_RATE' }, '*');
        
        // Listen for response
        const responseListener = (event) => {
          if (event.data && event.data.type === 'VAT_RATE_RESPONSE') {
            window.removeEventListener('message', responseListener);
            console.log('✅ Admin hub responded with VAT:', event.data.vatRate + '%');
          }
        };
        window.addEventListener('message', responseListener);
        
        // Timeout if no response
        setTimeout(() => {
          window.removeEventListener('message', responseListener);
          console.log('⏰ No response from admin hub after 2 seconds');
        }, 2000);
      }
    };
    
    // Make it available immediately
    console.log('🚀 Quick test available: quickVatTest()');
    
    
    // PICTURE-IN-PICTURE OVERLAY FUNCTION
    function openInPiP(url, title) {
      console.log('🖼️ Creating PiP overlay for:', url);
      
      // Remove any existing PiP windows
      const existingPiP = document.getElementById('pipOverlay');
      if (existingPiP) {
        existingPiP.remove();
      }
      
      // Create overlay container
      const overlay = document.createElement('div');
      overlay.id = 'pipOverlay';
      
      // Get viewport dimensions for responsive sizing
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const isMobile = viewportWidth <= 768;
      
      // Calculate responsive dimensions and center positioning
      const width = isMobile ? Math.min(viewportWidth - 20, 350) : Math.min(800, viewportWidth - 100);
      const height = isMobile ? Math.min(viewportHeight - 100, 500) : Math.min(600, viewportHeight - 100);
      const top = Math.max(10, (viewportHeight - height) / 2);
      const left = Math.max(10, (viewportWidth - width) / 2);
      
      overlay.style.cssText = `
        position: fixed;
        top: ${top}px;
        left: ${left}px;
        width: ${width}px;
        height: ${height}px;
        background: white;
        border: 2px solid #1e3a8a;
        border-radius: 12px;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        z-index: 10000;
        display: flex;
        flex-direction: column;
        resize: ${isMobile ? 'none' : 'both'};
        overflow: hidden;
        font-family: inherit;
        max-width: 95vw;
        max-height: 95vh;
      `;
      
      // Create header with title and controls
      const header = document.createElement('div');
      header.style.cssText = `
        background: #1e3a8a;
        color: white;
        padding: ${isMobile ? '8px 12px' : '12px 16px'};
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: move;
        border-radius: 10px 10px 0 0;
        font-size: ${isMobile ? '12px' : '14px'};
        font-weight: bold;
        min-height: ${isMobile ? '40px' : '48px'};
        box-sizing: border-box;
      `;
      header.innerHTML = `
        <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${title}</span>
        <button onclick="document.getElementById('pipOverlay').remove()" style="
          background: none;
          border: none;
          color: white;
          font-size: ${isMobile ? '20px' : '18px'};
          cursor: pointer;
          padding: 0;
          width: ${isMobile ? '32px' : '24px'};
          height: ${isMobile ? '32px' : '24px'};
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          flex-shrink: 0;
          touch-action: manipulation;
        " onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='none'" ontouchstart="this.style.background='rgba(255,255,255,0.2)'" ontouchend="this.style.background='none'">×</button>
      `;
      
      // Create iframe container
      const iframeContainer = document.createElement('div');
      iframeContainer.style.cssText = `
        flex: 1;
        overflow: hidden;
        position: relative;
      `;
      
      // Create iframe
      const iframe = document.createElement('iframe');
      iframe.src = url;
      iframe.style.cssText = `
        width: 100%;
        height: 100%;
        border: none;
        background: white;
      `;
      iframe.onload = function() {
        console.log('✅ PiP iframe loaded successfully');
      };
      iframe.onerror = function() {
        console.error('❌ PiP iframe failed to load');
        iframeContainer.innerHTML = `
          <div style="padding: 20px; text-align: center; color: #666;">
            <p>שגיאה בטעינת התוכן</p>
            <button onclick="window.open('${url}', '_blank')" style="
              background: #1e3a8a;
              color: white;
              border: none;
              padding: 10px 20px;
              border-radius: 6px;
              cursor: pointer;
              margin-top: 10px;
            ">פתח בחלון חדש</button>
          </div>
        `;
      };
      
      // Assemble the PiP window
      iframeContainer.appendChild(iframe);
      overlay.appendChild(header);
      overlay.appendChild(iframeContainer);
      document.body.appendChild(overlay);
      
      // Make draggable
      let isDragging = false;
      let startX, startY, initialX, initialY;
      
      header.addEventListener('mousedown', function(e) {
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        initialX = overlay.offsetLeft;
        initialY = overlay.offsetTop;
        overlay.style.cursor = 'grabbing';
      });
      
      document.addEventListener('mousemove', function(e) {
        if (isDragging) {
          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;
          overlay.style.left = (initialX + deltaX) + 'px';
          overlay.style.top = (initialY + deltaY) + 'px';
        }
      });
      
      document.addEventListener('mouseup', function() {
        isDragging = false;
        overlay.style.cursor = 'default';
      });
      
      console.log('✅ PiP overlay created successfully');
      
      // Add window resize listener to maintain responsiveness
      window.addEventListener('resize', function() {
        const currentOverlay = document.getElementById('pipOverlay');
        if (currentOverlay) {
          const newViewportWidth = window.innerWidth;
          const newViewportHeight = window.innerHeight;
          const newIsMobile = newViewportWidth <= 768;
          
          // Update dimensions and center on resize
          const newWidth = newIsMobile ? Math.min(newViewportWidth - 20, 350) : Math.min(800, newViewportWidth - 100);
          const newHeight = newIsMobile ? Math.min(newViewportHeight - 100, 500) : Math.min(600, newViewportHeight - 100);
          const newTop = Math.max(10, (newViewportHeight - newHeight) / 2);
          const newLeft = Math.max(10, (newViewportWidth - newWidth) / 2);
          
          currentOverlay.style.width = newWidth + 'px';
          currentOverlay.style.height = newHeight + 'px';
          currentOverlay.style.top = newTop + 'px';
          currentOverlay.style.left = newLeft + 'px';
          currentOverlay.style.right = 'auto';
          currentOverlay.style.resize = newIsMobile ? 'none' : 'both';
          currentOverlay.style.maxWidth = '95vw';
          currentOverlay.style.maxHeight = '95vh';
        }
      });
    }

    // LOCAL GENERATION FUNCTIONS - No webhooks needed, skip validation
    window.generateEstimateReport = function() {
      console.log('🔧 Generating estimate report locally...');
      console.log('✅ GenerateEstimateReport function called successfully!');
      
      // Get current helper data or plate from input
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const plateInput = document.getElementById('builderPlateInput');
      const currentPlate = helper.plate || helper.מספר_רכב || helper['מס רכב'] || (plateInput ? plateInput.value.trim() : '');
      
      console.log('📋 Current plate for estimate:', currentPlate);
      console.log('📊 Current helper data:', helper);
      
      // If no plate in helper but there's one in input, create minimal helper structure
      if (!currentPlate && plateInput && plateInput.value.trim()) {
        const plateValue = plateInput.value.trim();
        console.log('📝 Creating minimal helper structure with plate:', plateValue);
        
        // Create basic helper structure with plate
        const minimalHelper = {
          plate: plateValue,
          מספר_רכב: plateValue,
          meta: {
            case_id: `case_${plateValue}_${Date.now()}`,
            created_at: new Date().toISOString()
          }
        };
        
        // Merge with existing helper if any
        const updatedHelper = { ...helper, ...minimalHelper };
        sessionStorage.setItem('helper', JSON.stringify(updatedHelper));
        window.helper = updatedHelper;
      }
      
      // Skip saving final report data for direct report generation (avoids validation)
      console.log('⏭️ Skipping final report save for direct report generation...');
      
      // Set multiple flags to ensure estimate builder skips validation
      const reportConfig = {
        selectedReportType: 'estimate',
        skipValidation: true,
        autoSelectReportType: 'estimate',
        skipReportTypeDialog: true,
        directGeneration: true,
        fromFinalReportBuilder: 'true',
        reportTypeSelected: true,
        timestamp: new Date().toISOString()
      };
      
      // Set individual items including the bypass flag
      Object.keys(reportConfig).forEach(key => {
        sessionStorage.setItem(key, String(reportConfig[key]));
      });
      
      // Also set as complete config object
      sessionStorage.setItem('reportConfig', JSON.stringify(reportConfig));
      
      console.log('🚀 Navigating directly to estimate builder...');
      console.log('📋 Report configuration set:', reportConfig);
      
      // Navigate directly to estimate builder, bypassing fee-module and report selection
      setTimeout(() => {
        const finalPlate = helper.plate || helper.מספר_רכב || helper['מס רכב'] || (plateInput ? plateInput.value.trim() : '');
        const urlWithParams = `estimate-report-builder.html?plate=${encodeURIComponent(finalPlate)}&skipValidation=true&fromFinalReportBuilder=true`;
        console.log('🎯 Direct navigation to estimate report builder:', urlWithParams);
        
        try {
          // Create a proper PiP window using iframe approach
          openInPiP(urlWithParams, 'Estimate Report Builder');
        } catch (error) {
          console.warn('⚠️ PiP opening failed, trying fallback navigation:', error);
          window.location.href = 'estimate-report-builder.html?skipValidation=true&fromFinalReportBuilder=true';
        }
      }, 100);
    };
    
    window.generateExpertiseReport = function() {
      console.log('🔧 Generating expertise report locally...');
      console.log('✅ GenerateExpertiseReport function called successfully!');
      
      // Get current helper data or plate from input  
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const plateInput = document.getElementById('builderPlateInput');
      const currentPlate = helper.plate || helper.מספר_רכב || helper['מס רכב'] || (plateInput ? plateInput.value.trim() : '');
      
      console.log('📋 Current plate for expertise:', currentPlate);
      console.log('📊 Current helper data:', helper);
      
      // If no plate in helper but there's one in input, create minimal helper structure
      if (!currentPlate && plateInput && plateInput.value.trim()) {
        const plateValue = plateInput.value.trim();
        console.log('📝 Creating minimal helper structure with plate:', plateValue);
        
        // Create basic helper structure with plate
        const minimalHelper = {
          plate: plateValue,
          מספר_רכב: plateValue,
          meta: {
            case_id: `case_${plateValue}_${Date.now()}`,
            created_at: new Date().toISOString()
          }
        };
        
        // Merge with existing helper if any
        const updatedHelper = { ...helper, ...minimalHelper };
        sessionStorage.setItem('helper', JSON.stringify(updatedHelper));
        window.helper = updatedHelper;
      }
      
      // Skip saving final report data for direct report generation (avoids validation)
      console.log('⏭️ Skipping final report save for direct report generation...');
      
      // Set multiple flags to ensure fee module gets the message
      const reportConfig = {
        selectedReportType: 'expertise',
        skipValidation: true,
        autoSelectReportType: 'expertise',
        skipReportTypeDialog: true,
        directGeneration: true,
        fromFinalReportBuilder: true,
        reportTypeSelected: true,
        timestamp: new Date().toISOString()
      };
      
      // Set individual items
      Object.keys(reportConfig).forEach(key => {
        sessionStorage.setItem(key, String(reportConfig[key]));
      });
      
      // Also set as complete config object
      sessionStorage.setItem('reportConfig', JSON.stringify(reportConfig));
      
      console.log('🚀 Navigating directly to expertise builder...');
      console.log('📋 Report configuration set:', reportConfig);
      
      // Navigate directly to expertise builder, bypassing fee-module and report selection
      setTimeout(() => {
        const finalPlate = helper.plate || helper.מספר_רכב || helper['מס רכב'] || (plateInput ? plateInput.value.trim() : '');
        const urlWithParams = `expertise builder.html?plate=${encodeURIComponent(finalPlate)}&skipValidation=true&fromFinalReportBuilder=true`;
        console.log('🎯 Direct navigation to expertise builder:', urlWithParams);
        
        try {
          // Create a proper PiP window using iframe approach
          openInPiP(urlWithParams, 'Expertise Builder');
        } catch (error) {
          console.warn('⚠️ PiP opening failed, trying fallback navigation:', error);
          window.location.href = 'expertise builder.html?skipValidation=true&fromFinalReportBuilder=true';
        }
      }, 100);
    };
    
    console.log('✅ Local generation functions defined:', {
      generateEstimateReport: typeof window.generateEstimateReport,
      generateExpertiseReport: typeof window.generateExpertiseReport
    });
    
    // FORCE PLATE INPUT TO BE PLAIN TEXT - Keep password type for autofill but prevent dots
    window.forcePlateInputAsText = function() {
      const plateInput = document.getElementById('builderPlateInput');
      if (plateInput) {
        // Keep type as password for autofill, but override the visual display
        plateInput.style.webkitTextSecurity = 'none';
        plateInput.style.textSecurity = 'none';
        plateInput.style.fontFamily = 'inherit';
        plateInput.style.letterSpacing = 'normal';
        plateInput.style.fontSize = '16px';
        
        // Additional CSS to prevent password styling
        plateInput.style.setProperty('-webkit-text-security', 'none', 'important');
        plateInput.style.setProperty('text-security', 'none', 'important');
        
        console.log('🔢 Plate input configured for autofill with plain text display');
      }
    };
    
    // Apply the fix immediately and on DOM ready
    setTimeout(window.forcePlateInputAsText, 100);
    document.addEventListener('DOMContentLoaded', window.forcePlateInputAsText);
    
    // Enhanced event listeners to maintain plain text display
    document.addEventListener('DOMContentLoaded', function() {
      const plateInput = document.getElementById('builderPlateInput');
      if (plateInput) {
        // Apply fixes on various events
        plateInput.addEventListener('focus', window.forcePlateInputAsText);
        plateInput.addEventListener('input', window.forcePlateInputAsText);
        plateInput.addEventListener('change', window.forcePlateInputAsText);
        plateInput.addEventListener('keyup', window.forcePlateInputAsText);
        plateInput.addEventListener('blur', window.forcePlateInputAsText);
        
        // SESSION 52 FIX: Monitor for autofill but stop after 20 checks (10 seconds)
        let autofillCheckCount = 0;
        const autofillInterval = setInterval(function() {
          autofillCheckCount++;
          
          if (plateInput.value && plateInput.style.webkitTextSecurity !== 'none') {
            window.forcePlateInputAsText();
          }
          
          // Stop checking after 20 attempts (10 seconds) or if field is properly configured
          if (autofillCheckCount >= 20 || (plateInput.style.webkitTextSecurity === 'none' && plateInput.type === 'text')) {
            clearInterval(autofillInterval);
            console.log('✅ Plate input autofill monitoring stopped after', autofillCheckCount, 'checks');
          }
        }, 500);
        
        console.log('✅ Enhanced plate input event listeners configured');
      }
    });
    
    // Test MathEngine loading
    window.testMathEngineLoading = function() {
      console.log('🧪 Testing MathEngine loading status...');
      console.log('MathEngine available:', typeof MathEngine !== 'undefined');
      console.log('MathEngine.getVatRate available:', typeof MathEngine?.getVatRate === 'function');
      
      if (typeof MathEngine !== 'undefined' && MathEngine.getVatRate) {
        console.log('✅ MathEngine VAT rate:', MathEngine.getVatRate() + '%');
      } else {
        console.log('⚠️ MathEngine not fully loaded yet');
      }
      
      // Test helper fallback
      if (typeof window.getHelperVatRate === 'function') {
        console.log('✅ Helper VAT rate:', window.getHelperVatRate() + '%');
      }
    };
    
    // Test admin VAT change simulation
    window.simulateAdminVatChange = function(newVatRate = 19) {
      console.log(`🧪 Simulating admin VAT change to ${newVatRate}%...`);
      console.log('📊 BEFORE - helper.calculations.vat_rate:', window.helper?.calculations?.vat_rate);
      
      // Simulate the message that admin hub would send
      const simulatedMessage = {
        data: {
          type: 'VAT_RATE_UPDATED',
          vatRate: newVatRate,
          timestamp: Date.now()
        },
        origin: '*',
        source: window
      };
      
      // Trigger the message handler manually
      window.dispatchEvent(new MessageEvent('message', simulatedMessage));
      
      // Check result after a short delay
      setTimeout(() => {
        console.log('📊 AFTER - helper.calculations.vat_rate:', window.helper?.calculations?.vat_rate);
        console.log('📊 AFTER - getHelperVatRate():', window.getHelperVatRate ? window.getHelperVatRate() : 'function not available');
      }, 200);
    };
  </script>
  <script type="module" src="./helper-events.js"></script>
  <!-- TEMPORARILY DISABLED - conflicts with differential structure -->
  <!-- <script type="module" src="./depreciation_module.js"></script> -->
  
  <!-- Floating PDF Display Component -->
  <div id="floatingPdfOverlay" class="floating-pdf-overlay" style="display: none;">
    <div class="floating-pdf-container">
      <div class="floating-pdf-header">
        <h3 id="floatingPdfTitle">מציג PDF</h3>
        <div class="floating-pdf-controls">
          <button id="togglePdfBtn" class="toggle-btn">_</button>
          <button id="closePdfBtn" class="close-btn">×</button>
        </div>
      </div>
      <div id="floatingPdfContent" class="floating-pdf-content">
        <iframe id="pdfViewer" src="" width="100%" height="100%" frameborder="0"></iframe>
      </div>
    </div>
  </div>
  
  <script type="module" src="auth.js"></script>
  <script src="helper.js" type="module"></script>
  
  <script>
    // 🏛️ INITIALIZE ADMIN HUB COMMUNICATION AFTER ALL MODULES LOADED
    window.addEventListener('load', function() {
      // Wait a bit more for modules to finish loading
      setTimeout(() => {
        console.log('🔌 Now initializing admin hub communication after all modules loaded...');
        
        // Check if helper VAT function is available
        if (typeof window.setHelperVatRateFromAdmin === 'function') {
          console.log('✅ setHelperVatRateFromAdmin function is available');
        } else {
          console.log('❌ setHelperVatRateFromAdmin function NOT available');
        }
        
        // Initialize admin hub communication
        if (typeof initAdminHubCommunication === 'function') {
          initAdminHubCommunication();
        }
        
        // Initialize VAT display
        if (typeof window.initVatDisplay === 'function') {
          window.initVatDisplay();
        }
        
        console.log('🎯 Admin hub communication initialized. Testing functions available:');
        console.log('- simulateAdminVatChange(19) - Test admin VAT change');
        console.log('- testMathEngineLoading() - Test MathEngine status');
        console.log('- testCompleteVatFlow() - Test entire VAT flow');
        
        // Create comprehensive VAT flow test
        window.testCompleteVatFlow = function() {
          console.log('🧪 Testing complete VAT flow: Admin → Helper → All UI');
          console.log('═══════════════════════════════════════════════');
          
          // Step 1: Check current state
          console.log('📊 STEP 1: Current VAT State');
          console.log('helper.calculations.vat_rate:', window.helper?.calculations?.vat_rate);
          console.log('getHelperVatRate():', window.getHelperVatRate ? window.getHelperVatRate() : 'N/A');
          console.log('MathEngine.getVatRate():', typeof MathEngine !== 'undefined' ? MathEngine.getVatRate() : 'N/A');
          
          // Step 2: Test helper function availability
          console.log('📊 STEP 2: Function Availability');
          console.log('setHelperVatRateFromAdmin:', typeof window.setHelperVatRateFromAdmin === 'function');
          console.log('getHelperVatRate:', typeof window.getHelperVatRate === 'function');
          console.log('initVatDisplay:', typeof window.initVatDisplay === 'function');
          
          // Step 3: Test admin → helper flow
          console.log('📊 STEP 3: Testing Admin → Helper Flow');
          if (typeof window.setHelperVatRateFromAdmin === 'function') {
            const testRate = 19;
            console.log(`Setting helper VAT to ${testRate}% directly...`);
            const success = window.setHelperVatRateFromAdmin(testRate, 'test_admin');
            console.log('Helper update success:', success);
            
            setTimeout(() => {
              console.log('📊 STEP 4: Verification');
              console.log('helper.calculations.vat_rate after update:', window.helper?.calculations?.vat_rate);
              console.log('getHelperVatRate() after update:', window.getHelperVatRate());
              
              // Step 5: Test if UI updates
              console.log('📊 STEP 5: UI Update Test');
              const vatInput = document.getElementById('vat-rate-input');
              if (vatInput) {
                console.log('VAT input field value:', vatInput.value);
                console.log('Expected:', testRate, 'Actual:', parseFloat(vatInput.value));
                console.log('UI updated correctly:', parseFloat(vatInput.value) === testRate);
              } else {
                console.log('VAT input field not found');
              }
              
              console.log('═══════════════════════════════════════════════');
              console.log('✅ VAT flow test completed');
            }, 200);
          } else {
            console.log('❌ Cannot test - setHelperVatRateFromAdmin not available');
          }
        };
        
      }, 500);
    });
  </script>

  <!-- GENERATION BUTTONS - Static at bottom -->
  <div style="margin: 30px auto; max-width: 800px; padding: 20px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
    <div style="text-align: center; font-weight: bold; color: #1e3a8a; margin-bottom: 15px; font-size: 16px;">
      🚀 הפקת מסמכים על בסיס התיק הנוכחי
    </div>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; max-width: 500px; margin: 0 auto;">
      <button class="nav-btn" id="generateEstimateBtn" onclick="generateEstimateReport()" style="background: #ea580c; color: white; font-size: 14px; padding: 12px; border-radius: 6px;">
        צור אומדן ראשוני
      </button>
      <button class="nav-btn" id="generateExpertiseBtn" onclick="generateExpertiseReport()" style="background: #059669; color: white; font-size: 14px; padding: 12px; border-radius: 6px;">
        צור אקספירטיזה
      </button>
    </div>
    <div style="font-size: 12px; color: #6b7280; text-align: center; margin-top: 10px;">
      לא נדרש הכנסת מספר רכב נוסף - עובד על בסיס הנתונים הקיימים
    </div>
  </div>

  <!-- SESSION 74: Invoice Mapping Modal -->
  <div id="invoice-mapping-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.5); z-index: 10000; justify-content: center; align-items: center;">
    <div style="background: white; border-radius: 12px; padding: 24px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; direction: rtl;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h3 style="margin: 0; color: #1e3a8a; font-size: 20px;">מיפוי פריטים מהחשבונית</h3>
        <button onclick="closeInvoiceMappingModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">×</button>
      </div>
      <div id="invoice-mapping-field-info" style="background: #f3f4f6; padding: 12px; border-radius: 8px; margin-bottom: 16px; font-size: 14px;">
        <div style="font-weight: 600; margin-bottom: 4px;">שדה נבחר:</div>
        <div id="field-info-text" style="color: #666;">...</div>
      </div>
      <div id="invoice-items-dropdown-container"></div>
      <div style="margin-top: 16px; display: flex; gap: 8px; justify-content: flex-end;">
        <button onclick="closeInvoiceMappingModal()" style="padding: 8px 16px; background: #e5e7eb; border: none; border-radius: 6px; cursor: pointer;">ביטול</button>
      </div>
    </div>
  </div>

  <script src="internal-browser.js"></script>
  <script src="levi-floating.js"></script>
  <script src="car-details-floating.js"></script>
  <script src="invoice-details-floating.js"></script>
  <script src="parts-search-results-floating.js"></script>
  <script src="password-prefill.js"></script>
  <script src="services/damage-center-mapper.js"></script>
  <script src="components/invoice-parts-dropdown.js"></script>
  <script src="final_report.js" type="module"></script>

  <!-- SESSION 74: Invoice Mapping Integration -->
  <script>
    // Invoice mapping state
    let invoiceMappingState = {
      damageCenterId: null,
      fieldType: null,
      fieldIndex: null,
      caseId: null,
      invoiceId: null,
      dropdown: null
    };

    // Initialize invoice mapping on page load
    document.addEventListener('DOMContentLoaded', async () => {
      // Get case ID from sessionStorage
      const caseId = sessionStorage.getItem('currentCaseId');
      if (caseId) {
        invoiceMappingState.caseId = caseId;
        console.log('🗺️ Invoice mapping initialized for case:', caseId);
        
        // Initialize mapper
        if (window.damageCenterMapper) {
          await window.damageCenterMapper.initialize(caseId);
        }
      }

      // Listen for messages from damage center iframes or floating screens
      window.addEventListener('message', handleDamageCenterMessage);
    });

    // Handle messages from damage center iframes
    function handleDamageCenterMessage(event) {
      // Check if message is about field click
      if (event.data && event.data.type === 'DAMAGE_CENTER_FIELD_CLICKED') {
        const { centerId, fieldType, fieldIndex, currentValue } = event.data;
        console.log('📍 Field clicked:', { centerId, fieldType, fieldIndex });
        
        // Show invoice mapping modal
        showInvoiceMappingModal(centerId, fieldType, fieldIndex, currentValue);
      }
    }

    // Show invoice mapping modal
    async function showInvoiceMappingModal(centerId, fieldType, fieldIndex, currentValue = null) {
      try {
        // Get invoice ID from helper (most recent invoice)
        let invoiceId = null;
        if (window.helper && window.helper.financials && window.helper.financials.invoices && window.helper.financials.invoices.length > 0) {
          invoiceId = window.helper.financials.invoices[0].id;
        }

        if (!invoiceId) {
          alert('לא נמצאה חשבונית לתיק זה. אנא העלה חשבונית תחילה.');
          return;
        }

        // Store state
        invoiceMappingState.damageCenterId = centerId;
        invoiceMappingState.fieldType = fieldType;
        invoiceMappingState.fieldIndex = fieldIndex;
        invoiceMappingState.invoiceId = invoiceId;

        // Update field info display
        const fieldTypeLabels = {
          'work': 'עבודה',
          'part': 'חלק',
          'repair': 'תיקון'
        };
        const fieldLabel = fieldTypeLabels[fieldType] || fieldType;
        document.getElementById('field-info-text').textContent = 
          `${fieldLabel} #${fieldIndex + 1} במרכז נזקים ${centerId}${currentValue ? ' - ערך נוכחי: ' + currentValue : ''}`;

        // Show modal
        const modal = document.getElementById('invoice-mapping-modal');
        modal.style.display = 'flex';

        // Initialize dropdown
        if (!invoiceMappingState.dropdown) {
          invoiceMappingState.dropdown = new InvoicePartsDropdown();
        }

        // Load dropdown items
        const success = await invoiceMappingState.dropdown.init({
          fieldType: fieldType,
          caseId: invoiceMappingState.caseId,
          invoiceId: invoiceId,
          containerId: 'invoice-items-dropdown-container',
          onSelect: handleInvoiceItemSelected
        });

        if (!success) {
          alert('שגיאה בטעינת פריטים מהחשבונית');
          closeInvoiceMappingModal();
        }
      } catch (error) {
        console.error('❌ Error showing mapping modal:', error);
        alert('שגיאה בטעינת מיפוי חשבונית: ' + error.message);
      }
    }

    // Handle invoice item selection
    async function handleInvoiceItemSelected(item) {
      try {
        console.log('✅ Item selected for mapping:', item);

        const mappingData = {
          invoiceId: invoiceMappingState.invoiceId,
          invoiceLineId: item.invoice_line_id || null,
          caseId: invoiceMappingState.caseId,
          damageCenterId: invoiceMappingState.damageCenterId,
          fieldType: invoiceMappingState.fieldType,
          fieldIndex: invoiceMappingState.fieldIndex,
          itemData: item
        };

        // Create mapping using damage-center-mapper
        if (window.damageCenterMapper) {
          const mappingId = await window.damageCenterMapper.mapItemToField(mappingData);
          console.log('✅ Mapping created:', mappingId);

          // Notify user
          alert('הפריט מופה בהצלחה לשדה!');

          // Notify iframe if present
          window.damageCenterMapper.notifyIframeOfMappingChange(
            invoiceMappingState.damageCenterId,
            invoiceMappingState.fieldType,
            invoiceMappingState.fieldIndex,
            {
              name: item.name,
              costWithoutVat: item.price || item.total || 0
            }
          );

          // Close modal
          closeInvoiceMappingModal();
        } else {
          throw new Error('Damage center mapper not initialized');
        }
      } catch (error) {
        console.error('❌ Error creating mapping:', error);
        alert('שגיאה ביצירת מיפוי: ' + error.message);
      }
    }

    // Close invoice mapping modal
    function closeInvoiceMappingModal() {
      const modal = document.getElementById('invoice-mapping-modal');
      modal.style.display = 'none';

      // Cleanup dropdown
      if (invoiceMappingState.dropdown) {
        invoiceMappingState.dropdown.destroy();
        invoiceMappingState.dropdown = null;
      }

      // Clear state
      invoiceMappingState.damageCenterId = null;
      invoiceMappingState.fieldType = null;
      invoiceMappingState.fieldIndex = null;
    }

    // Global function for testing
    window.testInvoiceMapping = function() {
      showInvoiceMappingModal('center_1', 'work', 0, 'Test Work');
    };

    console.log('✅ Invoice mapping integration loaded');
  </script>
</body>
</html>