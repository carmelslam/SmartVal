<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <title>אשף חוות הדעת - ירון כיוף</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp" type="image/webp">
  <style>
    body {
      font-family: sans-serif;
      background: #f3f6fb;
      margin: 0;
      min-height: 100vh;
      padding: 0;
      padding-top: 90px;
      overflow-x: hidden;
    }
    .container {
      width: 100%;
      max-width: 820px;
      min-width: 320px;
      background: #fff;
      padding: 32px 24px 24px 24px;
      border-radius: 16px;
      box-shadow: 0 0 20px rgba(0,0,0,0.08);
      margin: 32px auto 32px auto;
      box-sizing: border-box;
    }
    .logo {
      display: flex;
      justify-content: center;
      margin-bottom: 8px;
    }
    .logo img {
      width: 112px;
      height: auto;
      display: block;
    }
    .title { font-size: 27px; font-weight: bold; text-align: center; margin-bottom: 2px; font-weight: 900;}
    .subtitle { font-size: 23px; color: #666; text-align: center; margin-bottom: 10px;}
    h1, h2 { color: #1e3a8a; font-size: 25px; text-align: center; margin: 15px 0 8px 0; font-weight: 600;}
    h3 { color: #1e3a8a; font-size: 24px; margin: 22px 0 12px 0; text-align: right; font-weight: 900;}
    .form-section {
      width: 100%;
      max-width: 100%;
      margin-bottom: 20px;
      background: #fafbfe;
      border-radius: 12px;
      padding: 17px 15px 12px 15px;
      box-sizing: border-box;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      overflow: hidden;
    }
    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px 18px;
      width: 100%;
    }
    @media (max-width: 600px) {
      .form-grid { grid-template-columns: 1fr; }
      .container {
        width: 98vw;
        max-width: 98vw;
        min-width: 0;
        padding: 14px 2vw 20px 2vw;
      }
    }
    
    /* Mobile viewport fixes */
    @media (max-width: 768px) {
      body {
        width: 100vw;
        overflow-x: hidden !important;
        position: relative;
      }
      
      html {
        width: 100vw;
        overflow-x: hidden !important;
      }
      
      .container {
        width: 95vw;
        max-width: 95vw;
        margin: 32px 2.5vw 32px 2.5vw;
      }
    }
    
    /* Desktop constraint fix */
    @media (min-width: 769px) {
      .container {
        width: 100%;
        max-width: 820px !important;
        margin: 32px auto !important;
      }
    }
    
    /* Summary container constraint fix */
    .summary-container {
      max-width: 820px;
      margin: 0 auto;
      width: 100%;
      box-sizing: border-box;
    }
    
    @media (min-width: 769px) {
      .summary-container {
        max-width: 820px;
        width: 820px;
      }
    }
    
    /* Summary block styling within container */
    .summary-block {
      width: 100% !important;
      box-sizing: border-box !important;
      margin-bottom: 20px;
    }
    label {
      font-size: 18px;
      margin-bottom: 4px;
      display: block;
      text-align: right;
    }
    input, select, textarea {
      width: 100%;
      font-size: 16px;
      border-radius: 8px;
      border: 1px solid #ccc;
      margin-bottom: 0px;
      padding: 8px 9px;
      box-sizing: border-box;
      text-align: right !important;
      background: #f9f9f9;
      transition: border .15s;
      outline: none;
    }
    input:focus, select:focus, textarea:focus {
      border-color: #3b82f6;
    }
    .readonly-box {
      background: #f4f6fa;
      border-radius: 6px;
      border: 1px solid #eee;
      padding: 7px 8px;
      min-height: 20px;
      font-size: 16px;
      color: #333;
      text-align: right !important;
    }
    .btn {
      background: #007bff;
      color: white;
      border: none;
      padding: 12px 15px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      display: block;
    }
    
    /* FLOATING SCREENS STYLING - COPIED FROM DEPRECIATION */
    .floating-toggles-top {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.95);
      padding: 8px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .toggle-square {
      width: 80px;
      height: 70px;
      background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      color: white;
      text-align: center;
      border: 2px solid transparent;
    }

    .toggle-square:hover {
      background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
    }

    .toggle-square.active {
      border-color: #fbbf24;
      box-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
    }

    .toggle-icon {
      font-size: 18px;
      margin-bottom: 2px;
    }

    .toggle-text {
      font-size: 10px;
      font-weight: 600;
      line-height: 1.1;
    }
    
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .section-header h3 {
      margin: 0;
    }
    @media (max-width: 768px) {
      .floating-toggles-top {
        top: 5px;
        gap: 4px;
        padding: 6px;
      }
      .toggle-square {
        width: 65px;
        height: 60px;
      }
      .toggle-icon {
        font-size: 16px;
      }
      .toggle-text {
        font-size: 9px;
      }
      
      /* Mobile fixes for depreciation table */
      #depreciationBulkTable .dep-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #depreciationBulkTable .dep-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #depreciationBulkTable .dep-row > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(1)::before {
        content: "מס' מוקד:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(2)::before {
        content: "החלק הניזוק:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(3)::before {
        content: "מהות התיקון:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(4)::before {
        content: "% ירידת ערך:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(5)::before {
        content: "ערך ב-₪:";
      }
      
      #depreciationBulkTable .dep-row > div:nth-child(6)::before {
        content: "פעולות:";
      }
      
      /* Hide table headers on mobile */
      #depreciationSection > div:first-child {
        display: none !important;
      }
      
      /* Mobile fixes for Full Market Adjustments table */
      #allAdjustmentsList .adjustment-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #allAdjustmentsList .adjustment-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #allAdjustmentsList .adjustment-row > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
        display: block;
        margin-bottom: 4px;
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(1)::before {
        content: "תיאור:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(2)::before {
        content: "סוג:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(3)::before {
        content: "אחוז:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(4)::before {
        content: "ערך:";
      }
      
      #allAdjustmentsList .adjustment-row > div:nth-child(5)::before {
        content: "פעולות:";
      }
      
      /* Hide Full Market Adjustments table headers on mobile */
      #allAdjustments > div:first-child {
        display: none !important;
      }
      
      /* Mobile fixes for damage center part rows */
      .part-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa !important;
        padding: 12px !important;
        border-radius: 8px !important;
        margin-bottom: 12px !important;
        border: 1px solid #e9ecef !important;
      }
      
      .part-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .part-row > div:nth-child(1) label::after {
        content: " (שם החלק)";
      }
      
      .part-row > div:nth-child(2) label::after {
        content: " (תיאור)";
      }
      
      .part-row > div:nth-child(3) label::after {
        content: " (עלות)";
      }
      
      /* Mobile fixes for damage center work rows */
      .work-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa !important;
        padding: 12px !important;
        border-radius: 8px !important;
        margin-bottom: 12px !important;
        border: 1px solid #e9ecef !important;
      }
      
      .work-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .work-row > div:nth-child(1) label::after {
        content: " (סוג עבודה)";
      }
      
      .work-row > div:nth-child(2) label::after {
        content: " (הערות)";
      }
      
      .work-row > div:nth-child(3) label::after {
        content: " (עלות)";
      }
      
      /* Mobile fixes for damage center repair rows */
      .repair-row {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa !important;
        padding: 12px !important;
        border-radius: 8px !important;
        margin-bottom: 12px !important;
        border: 1px solid #e9ecef !important;
      }
      
      .repair-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .repair-row > div:nth-child(1) label::after {
        content: " (תיאור תיקון)";
      }
      
      .repair-row > div:nth-child(2) label::after {
        content: " (הערות)";
      }
      
      .repair-row > div:nth-child(3) label::after {
        content: " (עלות)";
      }
      
      /* Mobile fixes for Features Adjustments section */
      #featuresAdjustments > div:first-child {
        display: none !important;
      }
      
      #featuresAdjustmentsList > div {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #featuresAdjustmentsList > div > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #featuresAdjustmentsList > div > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
        display: block;
        margin-bottom: 4px;
      }
      
      #featuresAdjustmentsList > div > div:nth-child(1)::before {
        content: "תיאור:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(2)::before {
        content: "סוג:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(3)::before {
        content: "אחוז:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(4)::before {
        content: "ערך:";
      }
      
      #featuresAdjustmentsList > div > div:nth-child(5)::before {
        content: "פעולות:";
      }
      
      /* Mobile fixes for Registration Adjustments section */
      #registrationAdjustments > div:first-child {
        display: none !important;
      }
      
      #registrationAdjustmentsList > div {
        display: grid !important;
        grid-template-columns: 1fr !important;
        gap: 8px !important;
        background: #f8f9fa;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 12px;
        border: 1px solid #e9ecef;
      }
      
      #registrationAdjustmentsList > div > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      #registrationAdjustmentsList > div > div::before {
        font-weight: bold;
        font-size: 12px;
        color: #495057;
        display: block;
        margin-bottom: 4px;
      }
      
      #registrationAdjustmentsList > div > div:nth-child(1)::before {
        content: "תיאור:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(2)::before {
        content: "סוג:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(3)::before {
        content: "אחוז:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(4)::before {
        content: "ערך:";
      }
      
      #registrationAdjustmentsList > div > div:nth-child(5)::before {
        content: "פעולות:";
      }
      
      
      /* Fix button spacing on mobile */
      .btn.add {
        width: 100% !important;
        margin-top: 8px !important;
      }
      
      /* Navigation buttons mobile responsive */
      .nav-btn {
        font-size: 14px !important;
        padding: 10px 8px !important;
        min-height: 44px !important;
      }
      
      /* Damage centers mobile responsive */
      #damageCentersContent > div > div > div:nth-child(n+1) {
        grid-template-columns: 1fr 1fr !important;
        gap: 4px !important;
      }
      
      /* Levi adjustments mobile responsive */
      .levi-adjustments-grid {
        grid-template-columns: 1fr !important;
        gap: 4px !important;
      }
      
      .levi-adjustment-row {
        grid-template-columns: 1fr !important;
        gap: 4px !important;
        padding: 8px !important;
      }
      
      .levi-adjustment-row > div {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 4px 0;
      }
      
      .levi-adjustment-row > div:nth-child(1)::after {
        content: "";
      }
      
      .levi-adjustment-row > div:nth-child(2)::before {
        content: "אחוז: ";
        font-weight: bold;
        color: #495057;
      }
      
      .levi-adjustment-row > div:nth-child(3)::before {
        content: "ערך: ";
        font-weight: bold;
        color: #495057;
      }
      
      /* Custom summary rows mobile responsive */
      .custom-summary-row {
        grid-template-columns: 1fr !important;
        gap: 8px !important;
      }
      
      .custom-summary-row > input {
        margin-bottom: 4px;
      }
    }
    
    .collapsible-btn {
      background: #e0e7f1;
      font-family: sans-serif;
      color: #1e3a8a;
      border: none;
      padding: 7px 18px;
      border-radius: 7px;
      margin-bottom: 8px;
      margin-top: 2px;
      cursor: pointer;
      font-weight: 600;
      font-size: 16px;
      text-align: right;
      width: auto;
      display: inline-block;
    }

    .collapsible-btn:hover {
      background: #d1d9e6;
    }

    .btn.add {
      background: #28a745;
      margin-top: 7px;
      margin-bottom: 0;
      width: auto;
      padding: 8px 18px;
      font-size: 16px;
      display: block;
    }

    /* Navigation Buttons Styling */
    .nav-btn {
      padding: 12px 16px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      min-height: 48px;
    }

    .save-btn {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
    }
    .save-btn:hover {
      background: linear-gradient(135deg, #218838 0%, #1ea085 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
    }

    .preview-btn {
      background: linear-gradient(135deg, #17a2b8 0%, #20c997 100%);
    }
    .preview-btn:hover {
      background: linear-gradient(135deg, #138496 0%, #1ea085 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(23, 162, 184, 0.3);
    }

    .generate-btn {
      background: linear-gradient(135deg, #007bff 0%, #6610f2 100%);
    }
    .generate-btn:hover {
      background: linear-gradient(135deg, #0056b3 0%, #520dc2 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
    }

    .back-btn {
      background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
    }
    .back-btn:hover {
      background: linear-gradient(135deg, #545b62 0%, #3d4142 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
    }
    
    .footer {
      margin-top: 40px;
      font-size: 12px;
      color: #aaa;
      text-align: center;
    }
    
    /* Floating PDF Display Styles */
    .floating-pdf-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 0;
      margin: 0;
      box-sizing: border-box;
    }
    
    .floating-pdf-container {
      background: white;
      border-radius: 12px;
      width: 90%;
      max-width: 900px;
      height: 90%;
      max-height: 700px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }
    
    /* Mobile optimization for floating PDF - Complete rewrite */
    @media (max-width: 768px) {
      .floating-pdf-overlay {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100% !important;
        height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        background: rgba(0, 0, 0, 0.8) !important;
        z-index: 999999 !important;
        overflow: hidden !important;
      }
      
      .floating-pdf-container {
        position: fixed !important;
        top: 20px !important;
        left: 10px !important;
        right: 10px !important;
        bottom: 20px !important;
        width: auto !important;
        height: auto !important;
        max-width: none !important;
        max-height: none !important;
        margin: 0 !important;
        border-radius: 10px !important;
        background: white !important;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5) !important;
        overflow: hidden !important;
      }
      
      .floating-pdf-header {
        position: relative !important;
        background: #1e3a8a !important;
        color: white !important;
        padding: 15px !important;
        border-radius: 10px 10px 0 0 !important;
        display: flex !important;
        justify-content: space-between !important;
        align-items: center !important;
        min-height: 60px !important;
        box-sizing: border-box !important;
      }
      
      .floating-pdf-header h3 {
        font-size: 18px !important;
        margin: 0 !important;
        flex: 1 !important;
        text-align: right !important;
      }
      
      .floating-pdf-controls {
        display: flex !important;
        gap: 10px !important;
        flex-shrink: 0 !important;
      }
      
      .toggle-btn, .close-btn {
        width: 44px !important;
        height: 44px !important;
        font-size: 22px !important;
        background: rgba(255,255,255,0.2) !important;
        border: none !important;
        color: white !important;
        border-radius: 8px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        cursor: pointer !important;
        touch-action: manipulation !important;
        -webkit-tap-highlight-color: transparent !important;
      }
      
      .floating-pdf-content {
        position: absolute !important;
        top: 60px !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        overflow: hidden !important;
      }
      
      .floating-pdf-content iframe {
        width: 100% !important;
        height: 100% !important;
        border: none !important;
      }
    }
    
    /* Extra small mobile devices */
    @media (max-width: 480px) {
      .floating-pdf-container {
        top: 10px !important;
        left: 5px !important;
        right: 5px !important;
        bottom: 10px !important;
      }
      
      .floating-pdf-header {
        padding: 12px !important;
        min-height: 50px !important;
      }
      
      .floating-pdf-header h3 {
        font-size: 16px !important;
      }
      
      .toggle-btn, .close-btn {
        width: 40px !important;
        height: 40px !important;
        font-size: 20px !important;
      }
    }
    
    .floating-pdf-header {
      background: #1e3a8a;
      color: white;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 12px 12px 0 0;
    }
    
    .floating-pdf-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    
    .floating-pdf-controls {
      display: flex;
      gap: 10px;
    }
    
    .toggle-btn, .close-btn {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 35px;
      height: 35px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.3s ease;
    }
    
    .toggle-btn:hover, .close-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }
    
    .floating-pdf-content {
      flex: 1;
      padding: 0;
      overflow: hidden;
    }
    
    .floating-pdf-content.minimized {
      display: none;
    }
    
    .floating-pdf-container.minimized {
      height: auto;
      max-height: none;
    }
    
    /* Plate and document actions section styles */
    .plate-actions-section {
      background: #f8fafc;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 25px;
    }
    
    .plate-actions-section label {
      font-size: 16px;
      font-weight: 600;
      color: #1e3a8a;
      margin-bottom: 10px;
      text-align: right;
    }
    
    .plate-actions-section input {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #cbd5e1;
      border-radius: 6px;
      text-align: center;
      box-sizing: border-box;
    }
    
    .load-case-btn {
      padding: 10px 20px;
      background: #1e3a8a;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
    }
    
    .load-case-btn:hover {
      background: #3b82f6;
    }
    
    .document-actions-section {
      margin-top: 20px;
      padding: 15px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
    }
    
    .document-actions-section .nav-btn {
      flex: 1;
      padding: 12px;
      font-size: 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      color: white;
    }
    
    /* Summary block styling to work with inline gradients */
    .summary-block {
      position: relative;
      max-width: 100% !important;
      width: 100% !important;
      box-sizing: border-box !important;
      /* Enhanced with inline gradient backgrounds */
    }
    
    .summary-block h3 {
      color: white !important;
      font-size: 26px !important;
      text-align: center !important;
      margin-bottom: 20px !important;
      font-weight: 900 !important;
    }
    
    /* Ensure all form sections stay within container bounds - merged with existing definition */
    
    /* Force container children to stay within bounds */
    .container > * {
      max-width: 100% !important;
      box-sizing: border-box !important;
    }
    
    /* Mobile fixes for summary date field */
    @media (max-width: 768px) {
      /* Reduce the overall summary block padding on mobile */
      .summary-block {
        padding: 15px 6px !important;
      }
      
      .summary-block > div {
        margin-left: 0 !important;
        margin-right: 0 !important;
        padding-left: 0 !important;
        padding-right: 0 !important;
      }
      
      /* Fix date input container specifically */
      .summary-block input[type="date"] {
        width: calc(100% - 4px) !important;
        box-sizing: border-box !important;
        max-width: calc(100% - 4px) !important;
        margin: 2px !important;
        padding: 6px 4px !important;
        font-size: 13px !important;
      }
      
      /* More specific targeting for the summary date field */
      #finalReportDateSummary {
        width: calc(100% - 10px) !important;
        box-sizing: border-box !important;
        max-width: calc(100% - 10px) !important;
        margin: 5px !important;
        padding: 4px 2px !important;
        font-size: 12px !important;
      }
      
      /* Ensure date container doesn't overflow */
      .summary-block > div[style*="text-align: center"] {
        padding: 2px !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
        box-sizing: border-box !important;
      }
    }
    
    /* Override for parts search modal width */
    #partsSearchResultsModal {
      max-width: 750px !important;
      width: 80vw !important;
    }
  </style>
</head>
<body>
  <!-- FLOATING SCREEN TOGGLES - TOP OF PAGE -->
  <div class="floating-toggles-top">
    <div class="toggle-square" onclick="toggleFloatingScreen('leviReport')">
      <div class="toggle-icon">📊</div>
      <div class="toggle-text">דו"ח לוי יצחק</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('carDetails')">
      <div class="toggle-icon">🚗</div>
      <div class="toggle-text">פרטי רכב</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('invoiceDetails')">
      <div class="toggle-icon">🧾</div>
      <div class="toggle-text">פרטי חשבוניות</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('internalBrowser')">
      <div class="toggle-icon">🌐</div>
      <div class="toggle-text">דפדפן פנימי</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('partsSearchResults')">
      <div class="toggle-icon">🔧</div>
      <div class="toggle-text">תוצאות חלקים</div>
    </div>
  </div>

  <div class="container">
    <div class="logo"><img src="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp" alt="Logo"></div>
    <div class="title">ירון כיוף שמאות - פורטל</div>
    <div class="subtitle">שמאות והערכת נזקי רכב ורכוש</div>
    
    <!-- Plate Input and Document Actions Section -->
    <div class="plate-actions-section">
      <!-- Separate the plate input from password to prevent browser interference -->
      <div style="margin-bottom: 15px;">
        <div style="display: inline-block; margin-left: 15px;">
          <label for="builderPlateInput" style="display: block; margin-bottom: 5px;">מספר רכב:</label>
          <input type="text" id="builderPlateInput" placeholder="הכנס מספר רכב" required autocomplete="off" autocapitalize="none" spellcheck="false" inputmode="numeric" data-plate-field="true">
        </div>
      </div>
      
      <form id="builderLoadCaseForm" onsubmit="event.preventDefault(); const plateInput = document.getElementById('builderPlateInput'); if (plateInput && typeof loadExistingCaseForBuilder === 'function') { loadExistingCaseForBuilder(); }" autocomplete="off">
        
        <div style="display:grid; grid-template-columns:1fr; gap:15px; margin-bottom:15px; max-width: 300px;">
          <div>
            <label>סיסמת גישה (מתמלאת אוטומטית):</label>
            <input type="text" id="builderPasswordInput" placeholder="סיסמת אימות לעמוד" autocomplete="off" readonly onfocus="this.removeAttribute('readonly')">
          </div>
        </div>
        
        <div style="text-align:center; margin-bottom:15px;">
          <button type="submit" id="builderLoadCaseBtn" class="load-case-btn">
            טען תיק קיים
          </button>
        </div>
      </form>
      
      <div style="margin-top:10px; font-size:12px; color:#6b7280; text-align:center;">
        💡 הזן מספר רכב - סיסמת העמוד מתמלאת אוטומטית מהכניסה למערכת
      </div>
      
      <div id="builderPlateStatus" style="margin-top:10px; font-size:14px; color:#059669; display:none; text-align:right;">
        ✓ נתוני הרכב נטענו בהצלחה
      </div>
      
      <!-- Document Actions Section -->
    <div id="documentActionsSection" style="margin-top: 20px; padding: 15px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
      <div style="font-size: 16px; font-weight: 600; color: #1e3a8a; margin-bottom: 15px; text-align: center;">
        פעולות מסמכים
      </div>
      <!-- FETCH BUTTONS - View existing documents (require plate input) -->
      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 10px;">
        <button class="nav-btn" id="fetchEstimateBtn" onclick="fetchEstimatePDF()" style="background: #dc2626; color: white;">
          הצג אומדן ראשוני PDF
        </button>
        <button class="nav-btn" id="fetchExpertiseBtn" onclick="fetchExpertisePDF()" style="background: #8b5cf6; color: white;">
          הצג אקספירטיזה PDF
        </button>
        <button class="nav-btn" id="fetchFinalReportBtn" onclick="fetchFinalReportPDF()" style="background: #06b6d4; color: white;">
          הצג חוות דעת PDF
        </button>
      </div>
      <div style="margin-top: 10px; padding: 10px; background: #e0f2fe; border-radius: 6px; font-size: 14px; text-align: center; color: #0277bd;">
        📁 הכנס מספר רכב וטען תיק כדי לצפות במסמכים קיימים<br>
        כפתורי הפקה של מסמכים חדשים נמצאים בתחתית העמוד 🚀
      </div>
    </div>
    
    <h1>אשף חוות הדעת - מודול ירידת ערך מתקדם</h1> 
    <h2 id="pageTitle">רכב מס. ...</h2>

    <!-- DEPRECIATION REPORT TYPE SELECTION -->
    <div class="form-section">
      <h3>בניית חוות דעת</h3>
      <div class="form-grid">
        <div>
          <label for="reportType">בחר סוג חוות דעת:</label>
          <select id="reportType" onchange="updateSummaryVisibility(); loadLegalText(); saveLegalTextAfterChange();">
            <option>חוות דעת פרטית</option>
            <option>חוות דעת גלובלית</option>
            <option>חוות דעת מכירה מצבו הניזוק</option>
            <option>חוות דעת טוטלוסט</option>
            <option>חוות דעת אובדן להלכה</option>
          </select>
        </div>
        <div>
          <label for="isCompanyClient">דו"ח לחברה:</label>
          <select id="isCompanyClient" onchange="updateFinalReportField('report_for_company', this.value === 'yes')">
            <option value="no">לא</option>
            <option value="yes">כן</option>
          </select>
        </div>
        <div>
          <label for="inAgreement">סטטוס הסדר:</label>
          <select id="inAgreement" onchange="updateFinalReportField('in_agreement', this.value === 'yes')">
            <option value="yes">בהסדר</option>
            <option value="no">לא בהסדר</option>
          </select>
        </div>
        
        <div style="text-align: center; margin-top: 15px;">
          <button type="button" onclick="saveFinalReportConfiguration()" class="nav-btn" style="background: #28a745; color: white; font-size: 14px;">
            💾 שמור הגדרות
          </button>
        </div>
      </div>
    </div>

    <!-- VEHICLE DATA - EDITABLE FROM HELPER -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('vehicleData')">נתוני רכב (הצג/הסתר)</button>
      <div id="vehicleData" style="display:none;">
        <div class="form-grid">
          <div><label>מספר רכב:</label><input type="text" id="carPlate" onchange="updateHelperFromField(event);" /></div>
          <div><label>תוצרת:</label><input type="text" id="carManufacturer" onchange="updateHelperFromField(event);" /></div>
          <div><label>דגם:</label><input type="text" id="carModel" onchange="updateHelperFromField(event);" /></div>
          <div><label>שנת ייצור:</label><input type="text" id="carYear" onchange="updateHelperFromField(event);" /></div>
          <div><label>קוד דגם:</label><input type="text" id="carModelCode" onchange="updateHelperFromField(event);" /></div>
          <div><label>מחיר בסיס:</label><input type="text" id="carBasePrice" onchange="updateHelperFromVehicleField(this);" /></div>
          <div><label>ערך השוק של הרכב:</label><input type="text" id="carMarketValue" onchange="updateHelperFromVehicleField(this);" /></div>
          <div><label>תאריך חוות הדעת (דוח סופי):</label><input type="date" id="finalReportDate" onchange="updateHelperFromField(event);" /></div>
        </div>
      </div>
    </div>


    <!-- COLLAPSIBLE CONTACT DATA -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('contactData')">נתוני התקשרות (הצג/הסתר)</button>
      <div id="contactData" style="display:none;">
        <div class="form-grid">
          <div><label>שם בעל הרכב:</label><input type="text" id="ownerName" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>כתובת בעל הרכב:</label><input type="text" id="ownerAddress" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>טלפון בעל הרכב:</label><input type="text" id="ownerPhone" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>חברת ביטוח:</label><input type="text" id="insuranceCompany" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>אימייל חברת ביטוח:</label><input type="text" id="insuranceEmail" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>סוכן ביטוח:</label><input type="text" id="insuranceAgent" onchange="updateHelperFromContactField(this); triggerFloatingScreenRefresh();" /></div>
          <div><label>טלפון סוכן ביטוח:</label><input type="text" id="agentPhone" onchange="updateHelperFromContactField(this); triggerFloatingScreenRefresh();" /></div>
          <div><label>אימייל סוכן ביטוח:</label><input type="text" id="agentEmail" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>שם מוסך:</label><input type="text" id="garageName" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>טלפון מוסך:</label><input type="text" id="garagePhone" onchange="updateHelperFromContactField(this);" /></div>
          <div><label>אימייל מוסך:</label><input type="text" id="garageEmail" onchange="updateHelperFromContactField(this);" /></div>
        </div>
      </div>
    </div>

    <!-- DAMAGE CENTERS SUMMARY SECTION - EDITABLE -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('damageCentersSummary')">סיכום מוקדי נזק (הצג/הסתר)</button>
      <div id="damageCentersSummary" style="display:none;">
        <h3>סיכום מוקדי נזק (ניתן לעריכה) </h3>
        <div style="background: #f8f9fa; border-radius: 6px; padding: 15px; min-height: 50px;" id="damageCentersContent">
          <div style="color: #666; text-align: center;">טוען נתוני מוקדי נזק...</div>
        </div>
        <button type="button" class="btn add" onclick="addNewDamageCenter()" style="margin-top: 10px;">הוסף מוקד נזק חדש</button>
      </div>
    </div>

    <!-- GROSS DAMAGE PERCENTAGE CALCULATION -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('grossCalc')">  ערך הרכב לנזק גולמי - מאפיינים ועליה לכביש בלבד (הצג/הסתר)</button>
      <div id="grossCalc" style="display:none;">
        <div class="form-grid">
          <div><label>ערך הרכב ע"פ מחירון כולל מע"מ:</label><input type="text" id="basicPrice" placeholder="₪" onchange="updateHelperFromField(event); updateGrossMarketValueCalculation(); updateHelperFromAdjustments();" /></div>
          <div></div>
        </div>
        <div style="margin-top: 10px; text-align: right;">
          <button type="button" onclick="reloadGrossAdjustments()" style="background: #ff9500; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600;">טען התאמות לוי יצחק</button>
        </div>
        
        <!-- Features Adjustments -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">תוספות מאפיינים (תכונות הרכב):</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            🏗️ תוספות הקשורות לתכונות פיזיות של הרכב עצמו
          </div>
          <div id="featuresAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="featuresAdjustmentsList"></div>
            <div id="grossFeaturesCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ערך לאחר תוספות מאפיינים: <span style="color: #28a745;">₪0</span>
            </div>
            <button class="btn add" type="button" onclick="addFeatureAdjustment()">הוסף תוספת מאפיין</button>
          </div>
        </div>
        
        <!-- Registration Adjustments -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">עליה לכביש (תאריך רישום):</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            📅 התאמות בגין תאריך רישום הרכב (מאפיין קבוע של הרכב)
          </div>
          <div id="registrationAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="registrationAdjustmentsList"></div>
            <div id="grossRegistrationCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ערך לאחר עליה לכביש: <span style="color: #28a745;">₪0</span>
            </div>
            <button class="btn add" type="button" onclick="addRegistrationAdjustment()">הוסף תוספת עליה לכביש</button>
          </div>
        </div>
        
        <!-- Gross Market Value Result -->
        <div style="margin-top: 20px; padding: 15px; background: #f0f8ff; border-radius: 8px; border: 2px solid #4a90e2;">
          <div class="form-grid">
            <div><label><strong>ערך הרכב לנזק גולמי כולל מע"מ:</strong></label><input type="text" id="grossMarketValueResult" style="background: #f8f9fa; font-weight: bold;" readonly /></div>
            <div></div>
          </div>
        </div>
      </div>
    </div>

    <!-- FINAL REPORT ADJUSTMENTS SECTION -->

    <!-- GROSS DAMAGE PERCENTAGE RESULT -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('grossPercentageResult')">אחוז הנזק הגולמי - בסיס הרכב בלבד (הצג/הסתר)</button>
      <div id="grossPercentageResult" style="display:none;">
        <div class="form-grid">
          <div><label>סה״כ עלות נזקים: <span style="color: #dc3545; font-size: 11px;">(לפי חשבונית/הערכה)</span></label><input type="text" id="totalClaimGross" style="background: #f8f9fa;" readonly /></div>
          <div><label>ערך הרכב לנזק גולמי:</label><input type="text" id="leviPriceList" style="background: #f8f9fa;" readonly /></div>
        </div>
        
        <!-- Additional Claims Data -->
        <div style="margin-top: 20px;">
          <div class="form-grid">
            <div><label>סה"כ תביעה (מאושר):</label><input type="text" id="authorizedClaim" onchange="updateAuthorizedClaim(this); updateGrossPercentageField();" style="direction: ltr; text-align: right;" /></div>
            <div></div>
          </div>
        </div>
        
        <!-- Gross Percentage Result -->
        <div style="margin-top: 15px; padding: 15px; background: #f0f8ff; border-radius: 8px; border: 2px solid #e74c3c;">
          <div class="form-grid">
            <div><label><strong>אחוז הנזק הגולמי:</strong></label><input type="text" id="grossPercent" style="background: #f8f9fa; font-weight: bold; color: #e74c3c;" readonly /></div>
            <div></div>
          </div>
          <div style="margin-top: 10px; font-size: 14px; color: #666;">
            <strong>חישוב:</strong> סה״כ תביעה (מאושר) ÷ ערך הרכב לנזק גולמי × 100
          </div>
        </div>
      </div>
    </div>

    <!-- FULL MARKET VALUE CALCULATION -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('fullMarketValue')">ערך השוק המלא - כולל גורמי שימוש (הצג/הסתר)</button>
      <div id="fullMarketValue" style="display:none;">
        <div class="form-grid">
          <div><label>ערך הרכב ע"פ מחירון כולל מע"מ:</label><input type="text" id="fullBasicPrice" placeholder="₪" readonly style="background: #f8f9fa;" /></div>
          <div></div>
        </div>
        <div style="margin-top: 10px; text-align: right;">
          <button type="button" onclick="reloadFullMarketAdjustments()" style="background: #ff9500; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600;">טען התאמות לוי יצחק</button>
        </div>
        
        <!-- Features Adjustments (תוספות מאפיינים) -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">תוספות מאפיינים (תכונות הרכב):</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            🏗️ תוספות הקשורות לתכונות פיזיות של הרכב עצמו
          </div>
          <div id="fullFeaturesAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="fullFeaturesAdjustmentsList"></div>
            <div id="featuresCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ערך לאחר תוספות מאפיינים: <span style="color: #28a745;">₪118,000</span>
            </div>
            <button class="btn add" type="button" onclick="addFullMarketFeatureAdjustment()">הוסף תוספת מאפיין</button>
          </div>
        </div>
        
        <!-- Registration Adjustments (עליה לכביש) -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">עליה לכביש (תאריך רישום):</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            📅 התאמות בגין תאריך רישום הרכב (מאפיין קבוע של הרכב)
          </div>
          <div id="fullRegistrationAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="fullRegistrationAdjustmentsList"></div>
            <div id="registrationCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ערך לאחר עליה לכביש: <span style="color: #28a745;">₪118,000</span>
            </div>
            <button class="btn add" type="button" onclick="addFullMarketRegistrationAdjustment()">הוסף תוספת עליה לכביש</button>
          </div>
        </div>
        
        <!-- Mileage Adjustments (מס ק"מ) -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">מס ק"מ:</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            🚗 התאמות בגין ק"מ של הרכב
          </div>
          <div id="mileageAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="mileageAdjustmentsList"></div>
            <div id="mileageCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ערך לאחר מס ק"מ: <span style="color: #dc3545;">₪86,312</span>
            </div>
            <button class="btn add" type="button" onclick="addMileageAdjustment()">הוסף התאמת מס ק"מ</button>
          </div>
        </div>
        
        <!-- Ownership Type Adjustments (סוג בעלות) -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">סוג בעלות:</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            🏢 התאמות בגין סוג בעלות (פרטי, חברה, ליסינג)
          </div>
          <div id="ownershipAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="ownershipAdjustmentsList"></div>
            <div id="ownershipCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ערך לאחר סוג בעלות: <span style="color: #dc3545;">₪84,586</span>
            </div>
            <button class="btn add" type="button" onclick="addOwnershipAdjustment()">הוסף התאמת סוג בעלות</button>
          </div>
        </div>
        
        <!-- Number of Owners Adjustments (מספר בעלים) -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">מספר בעלים:</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            👥 התאמות בגין מספר בעלים קודמים
          </div>
          <div id="ownersAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="ownersAdjustmentsList"></div>
            <div id="ownersCumulative" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-weight: bold; text-align: center;">
              ערך לאחר מספר בעלים: <span style="color: #dc3545;">₪70,206</span>
            </div>
            <button class="btn add" type="button" onclick="addOwnersAdjustment()">הוסף התאמת מספר בעלים</button>
          </div>
        </div>
        
        <!-- Additional Market Adjustments -->
        <div style="margin-top: 20px;">
          <h4 style="color: #1e3a8a; margin-bottom: 10px;">התאמות שוק נוספות:</h4>
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            💡 התאמות נוספות בגין שווי שוק
          </div>
          <div id="allAdjustments">
            <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
              <div><label>תיאור:</label></div>
              <div><label>סוג:</label></div>
              <div><label>אחוז:</label></div>
              <div><label>ערך:</label></div>
              <div><label>פעולות:</label></div>
            </div>
            <div id="allAdjustmentsList">
              <!-- This will be populated from helper data -->
            </div>
            <button class="btn add" type="button" onclick="addFullMarketAdjustment()">הוסף התאמה נוספת</button>
          </div>
        </div>
        
        <!-- Full Market Value Result -->
        <div style="margin-top: 20px; padding: 15px; background: #f0f8ff; border-radius: 8px; border: 2px solid #28a745;">
          <div class="form-grid">
            <div><label><strong>ערך השוק המלא של הרכב כולל מע"מ:</strong></label><input type="text" id="fullMarketValueResult" style="background: #f8f9fa; font-weight: bold; color: #28a745;" readonly /></div>
            <div></div>
          </div>
          <div style="margin-top: 10px; font-size: 14px; color: #666;">
            <strong>חישוב:</strong> (מחיר בסיס + התאמות רכב) + התאמות שימוש
          </div>
        </div>
      </div>
    </div>


    <!-- DEPRECIATION CALCULATION SECTION -->
    <div class="form-section" id="depreciationSection">
      <button class="collapsible-btn" type="button" onclick="toggleSection('depreciationContent')">חישוב ירידת ערך לפי מוקדי נזק (הצג/הסתר)</button>
      <div id="depreciationContent" style="display: none;">
        <h3>חישוב ירידת ערך לפי מוקדי נזק</h3>
        <div style="display:grid; grid-template-columns:70px 2fr 2fr 80px 90px 80px; gap:14px; margin-bottom:10px;">
        <div><label>מס' מוקד:</label></div>
        <div><label>החלק הניזוק:</label></div>
        <div><label>מהות התיקון:</label></div>
        <div><label>% ירידת ערך:</label></div>
        <div><label>ערך ב-₪:</label></div>
        <div><label>פעולות:</label></div>
      </div>
      <div id="depreciationBulkTable"></div>
      <button class="btn add" type="button" onclick="addDepField()">הוסף שדה</button>
      <div style="margin-top:14px;">
        <label>ירידת ערך גלובלי:</label>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:14px;">
          <input type="text" id="globalDep1" placeholder="ירידת ערך" style="direction: ltr; text-align: right;" />
          <input type="text" id="globalDepValue" placeholder="ערך ב-₪" readonly style="background:#f4f6fa;" />
        </div>
      </div>
      <div style="margin-top:14px;">
        <label>ימי מוסך משוערים:</label>
        <input type="number" id="garageDays" placeholder="מספר ימי עבודה" style="width: 200px;" onchange="updateHelperDepreciationField(this, 'work_days_impact');" />
      </div>
      <br><br>
  </div>
    </div>
    </div> <!-- Close depreciationContent -->
    <br><br>

    <!-- COLLAPSIBLE PRICE DATA -->
    <div class="form-section">
      <button class="collapsible-btn" type="button" onclick="toggleSection('priceData')">נתוני תביעה (הצג/הסתר)</button>
      <div id="priceData" style="display:none;">
        <div class="form-grid">
          <div>
            <label>סה״כ תביעה (סכום מוקדי נזק):</label>
            <div class="readonly-box" id="totalClaim">0</div>
          </div>
          <div>
            <label>חישוב הערך לנזק גולמי:</label>
            <div class="readonly-box" id="grossDamageValue">יחושב אוטומטית מהתאמות לוי</div>
          </div>
          <div>
            <label>חישוב האחוז הגולמי:</label>
            <div class="readonly-box" id="grossPercentage">יחושב אוטומטית</div>
          </div>
          <div>
            <label>מחיר שוק (בסיס + התאמות):</label>
            <div class="readonly-box" id="marketPriceCalculated">יחושב אוטומטית</div>
          </div>
          <div>
            <label>ערך השוק של הרכב (לפי דו״ח לוי יצחק): </label>
            <div class="readonly-box" id="finalMarketValue">יחושב מהתאמות לוי</div>
          </div>
          <div>
            <label>אישור חברת ביטוח (אופציונלי):</label>
            <input type="text" id="insuranceAuthorization" placeholder="₪" onchange="updateClaimsDataFromField(this, 'authorized_claim');" style="direction: ltr; text-align: right;" />
          </div>
        </div>
      </div>
    </div>

    <!-- SUMMARY SECTIONS CONTAINER -->
    <div style="text-align: center; margin: 20px 0;">
      <button onclick="location.reload()" style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 14px; cursor: pointer; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">🔄 רענן דף</button>
    </div>
    <div class="summary-container">
    
    <!-- SUMMARY SECTION - PROPER FINAL REPORT VERSION -->
    <div class="form-section summary-block" id="summaryPrivate" style="background: linear-gradient(135deg, #0346a4 0%, #042676 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">סיכום - חוות דעת פרטית</h3>
      
      <!-- Final Report Date Section -->
      <div style="background: rgba(255,255,255,0.9); color: #333; border-radius: 8px; padding: 12px; margin-bottom: 15px; text-align: center;">
        <div style="margin-bottom: 8px;">
          <label style="color: #1e3a8a; font-weight: bold; font-size: 14px;">תאריך חוות הדעת:</label>
        </div>
        <div>
          <input type="date" id="finalReportDateSummary" onchange="updateHelperFromField(event);" style="background: white; color: #333; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px;" />
        </div>
      </div>
      <div style="background: rgba(255,255,255,0.95); color: #333; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
        <div class="form-grid">
        <div>
          <label style="color: #333;">ערך השוק של הרכב:</label>
          <input type="text" id="sumMarketValue" style="background: white; color: #333;" />
        </div>
        <div>
          <label style="color: #333;">סה״כ תביעה:</label>
          <input type="text" id="sumClaim" style="background: white; color: #333;" />
        </div>
        <div>
          <label style="color: #333;">פיצוי בגין ירידת ערך:</label>
          <input type="text" id="depCompensation" style="background: white; color: #333;" />
        </div>
        <div>
          <label style="color: #333;">תוספות והורדות (מידע בלבד):</label>
          <input type="text" id="adjustmentsInfo" style="background: #f0f0f0; color: #666;" readonly />
        </div>
        </div>
      </div>
      <div style="background: rgba(255,255,255,0.95); color: #333; border-radius: 8px; padding: 15px;">
        <div class="form-grid">
          <div>
            <label style="color: #333;">סה״כ נכלל בחוות הדעת:</label>
            <input type="text" id="sumTotalBeforeDifferentials" style="background: white; color: #333;" />
          </div>
        </div>
      </div>
    </div>

    <div class="form-section summary-block" id="summaryGlobal" style="display:none; background: linear-gradient(135deg, #0346a4 0%, #042676 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">סיכום - חוות דעת גלובלית</h3>
      <div class="form-grid">
        <div>
          <label>ערך השוק של הרכב:</label>
          <input type="text" id="sumMarketValueGlobal" />
        </div>
        <div>
          <label>סה״כ תביעה:</label>
          <input type="text" id="sumClaimGlobal" />
        </div>
        <div>
          <label>פיצוי בגין ירידת ערך:</label>
          <input type="text" id="depCompensationGlobal" />
        </div>
      </div>
      <div class="form-grid" style="margin-top:16px;">
        <div>
          <label>סה״כ נכלל בחוות הדעת:</label>
          <input type="text" id="sumTotalGlobal" />
        </div>
      </div>
    </div>

    <div class="form-section summary-block" id="summaryDamage" style="display:none; background: linear-gradient(135deg, #0346a4 0%, #042676 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">סיכום - מצבו הניזוק</h3>
      <div class="form-grid">
        <div>
          <label>ערך השוק של הרכב:</label>
          <input type="text" id="sumMarketValueDamage" />
        </div>
        <div>
          <label>ערך המכירה במצבו הניזוק:</label>
          <input type="text" id="saleValueDamage" />
        </div>
        <div>
          <label>שיטת תשלום:</label>
          <input type="text" id="paymentMethod" placeholder="מזומן, צ'ק, העברה בנקאית..." />
        </div>
      </div>
      <div class="form-grid" style="margin-top:16px;">
        <div>
          <label>סה״כ לאחר מכירה:</label>
          <input type="text" id="afterSaleDamage" />
        </div>
      </div>
    </div>

    <div class="form-section summary-block" id="summaryTotalLoss" style="display:none; background: linear-gradient(135deg, #0346a4 0%, #042676 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">סיכום - טוטלוסט</h3>
      <div class="form-grid">
        <div>
          <label>ערך השוק של הרכב:</label>
          <input type="text" id="sumMarketValueTotal" />
        </div>
        <div>
          <label>ערך שרידי הרכב:</label>
          <input type="text" id="salvageValueTotal" />
        </div>
        <div>
          <label>תוספת גרירה ואחסנה:</label>
          <input type="text" id="storageValueTotal" />
        </div>
      </div>
      <div class="form-grid" style="margin-top:16px;">
        <div>
          <label>סה״כ לאחר מכירת שרידים:</label>
          <input type="text" id="afterSaleTotal" style="background: white; color: #333;" />
        </div>
      </div>
    </div>

    <div class="form-section summary-block" id="summaryLegalLoss" style="display:none; background: linear-gradient(135deg, #0346a4 0%, #042676 100%); color: white; border-radius: 12px; padding: 20px;">
      <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 26px;">סיכום - אובדן להלכה</h3>
      <div class="form-grid">
        <div>
          <label>ערך השוק של הרכב:</label>
          <input type="text" id="sumMarketValueLegal" />
        </div>
        <div>
          <label>ערך שרידי הרכב:</label>
          <input type="text" id="salvageValueLegal" />
        </div>
      </div>
      <div class="form-grid" style="margin-top:16px;">
        <div>
          <label>סה״כ לאחר מכירת שרידים:</label>
          <input type="text" id="afterSaleLegal" style="background: white; color: #333;" />
        </div>
      </div>
    </div>

    <!-- ADDITIONAL NOTES -->
    <div class="form-section">
      <h3>הערות נוספות לחוות דעת</h3>
      <textarea id="additional-notes" placeholder="הוסף הערות, המלצות או מידע נוסף לחוות דעת..." style="min-height: 80px; font-family: sans-serif; font-size: 16px;" onchange="updateHelperFromField(event);"></textarea>
    </div>

    <!-- LEGAL TEXT SECTION - EDITABLE (MOVED BEFORE NAVIGATION) -->
    <div class="form-section" id="legal-text">
      <h3>טקסט משפטי לחוות דעת</h3>
      <div style="margin-bottom: 10px;">
        <button type="button" onclick="loadLegalTextFromVault()" style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-left: 10px;">טען מהכספת</button>
        <button type="button" onclick="resetLegalText()" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">איפוס טקסט</button>
      </div>
      <textarea id="legal-text-content" style="width: 100%; min-height: 200px; padding: 15px; border: 1px solid #e2e8f0; border-radius: 6px; background: #f8f9fa; line-height: 1.6; font-family: inherit; resize: vertical; box-sizing: border-box;" placeholder="הטקסט המשפטי יטען כאן עם הנתונים המעודכנים..." onchange="updateHelperFromField(event);"></textarea>
      <div style="margin-top: 8px; font-size: 14px; color: #666;">
        💡 הטקסט ניתן לעריכה לצורך התאמה לדוח הספציפי. השינויים לא ישפיעו על הכספת המקורית.
      </div>
    </div>

    <!-- VAT RATE SETTINGS -->
    <div class="form-section" id="vat-settings" style="background: #fff3cd; border-left: 4px solid #ffc107;">
      <h3 style="color: #856404;">🏛️ הגדרות מע"מ</h3>
      <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px;">
        <div style="font-size: 14px; color: #495057; margin-bottom: 10px;">
          <strong>מקור שיעור מע"מ נוכחי:</strong> <span id="vat-source-display">טוען...</span><br>
          <strong>עדכון אחרון:</strong> <span id="vat-updated-display">טוען...</span>
        </div>
        <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
          <label style="font-weight: bold; color: #495057;">שיעור מע"מ (%):</label>
          <input type="number" id="vat-rate-input" min="0" max="100" step="0.1" 
                 style="width: 80px; padding: 6px; border: 1px solid #ced4da; border-radius: 4px;" 
                 value="" placeholder="18">
          <button type="button" onclick="updateVatRate()" 
                  style="background: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">
            עדכן מע"מ
          </button>
          <button type="button" onclick="resetVatRateFromAdmin()" 
                  style="background: #6c757d; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">
            אפס לערך מנהל
          </button>
        </div>
        <div style="font-size: 12px; color: #6c757d; margin-top: 8px;">
          💡 שינוי שיעור המע"מ ישפיע על כל החישובים בדו"ח זה. השינוי לא ישפיע על המקרים האחרים.
        </div>
      </div>
    </div>

    <!-- ATTACHMENTS SECTION - EDITABLE -->
    <div class="form-section" id="attachments-section">
      <h3>רשימת נספחים</h3>
      <div style="margin-bottom: 10px;">
        <button type="button" onclick="loadAttachmentsFromVault()" style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-left: 10px;">טען מהכספת</button>
        <button type="button" onclick="resetAttachments()" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">איפוס רשימה</button>
      </div>
      <textarea id="attachments-content" style="width: 100%; min-height: 120px; padding: 15px; border: 1px solid #e2e8f0; border-radius: 6px; background: #f8f9fa; line-height: 1.6; font-family: inherit; resize: vertical; box-sizing: border-box;" placeholder="רשימת הנספחים תטען כאן..."><strong>לוטה</strong>
תצלומי הרכב הניזוק
חשבוניות תיקון
ערך רכב ממוחשב
צילום רישיון הרכב
חשכ"ט</textarea>
      <div style="margin-top: 8px; font-size: 14px; color: #666;">
        💡 הרשימה ניתנת לעריכה לצורך התאמה לדוח הספציפי. השינויים לא ישפיעו על הכספת המקורית.
      </div>
    </div>

    <!-- Navigation Buttons -->
    <div class="form-section">
      <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px;">
        <button type="button" class="nav-btn save-btn" onclick="saveDepreciationData()">שמור נתונים</button>
        <button type="button" class="nav-btn" style="background: #1e40af;" onclick="previewFinalReport()">
          <span style="margin-left: 5px;">👁️</span>
          תצוגה מקדימה לחוו״ד
        </button>
        <button type="button" class="nav-btn" style="background: #059669;" onclick="continueToValidation()">
          <span style="margin-left: 5px;">✅</span>
          המשך לשכר טרחה
        </button>
        <button type="button" class="nav-btn back-btn" onclick="window.location.href='selection.html'">חזור לדף הבחירה</button>
      </div>
    </div>

    </div> <!-- Close summary-container -->

    <div class="footer"> Carmel Cayouf 2025 © All rights reserved. SmartVal Pro System by Evalix. </div>
  </div>
</div>

  
  <!-- Load Legal Text Engine -->
  <script src="legal-text-engine.js"></script>
  
  <script>

    // IMMEDIATE FUNCTION DEFINITIONS - MUST BE AVAILABLE BEFORE DOM LOADS
    
    // Helper function to safely parse amounts and prevent NaN
    function safeParseAmount(value) {
      if (!value || value === '') return 0;
      
      // Convert to string if not already
      const strValue = String(value);
      
      // Remove currency symbols (₪ and ש), commas, and spaces
      const cleanedValue = strValue.replace(/[₪ש,\s]/g, '');
      
      // Parse the cleaned value
      const parsed = parseFloat(cleanedValue);
      
      // Return 0 if parsing resulted in NaN, otherwise round to whole number
      return isNaN(parsed) ? 0 : Math.round(parsed);
    }
    
    // Helper function to check if a type is a reduction/minus type
    function isReductionType(type) {
      return type === 'minus' || type === 'הפחתה' || type === 'הפחתה (-)' || type === 'הורדה';
    }
    window.toggleFloatingScreen = function(screenType) {
      
      const screens = {
        leviReport: () => {
          if (window.toggleLeviReport) {
            window.toggleLeviReport();
          } else {
          }
        },
        carDetails: () => {
          if (window.toggleCarDetails) {
            window.toggleCarDetails();
          } else {
          }
        },
        internalBrowser: () => {
          if (window.showBrowserMenu) {
            showBrowserMenuUnderToggle();
          } else {
          }
        },
        invoiceDetails: () => {
          if (window.toggleInvoiceDetails) {
            window.toggleInvoiceDetails();
          } else {
            alert('מסך פרטי חשבוניות יהיה זמין בקרוב\nInvoice details screen coming soon');
          }
        },
        partsSearchResults: () => {
          if (window.togglePartsSearchResults) {
            window.togglePartsSearchResults();
          } else {
            console.log('Parts search results floating screen not available');
          }
        }
      };
      
      if (screens[screenType]) {
        screens[screenType]();
      } else {
      }
    };
    
    window.toggleSection = function(sectionId) {
      
      const section = document.getElementById(sectionId);
      if (section) {
        const isVisible = section.style.display !== 'none';
        section.style.display = isVisible ? 'none' : 'block';
      } else {
      }
    };
    // Authentication check
    const auth = sessionStorage.getItem("auth");
    if (!auth) {
      alert("הגישה חסומה - אנא התחבר דרך דף הבית");
      window.location.href = "index.html";
    }

    // FLOATING SCREENS TOGGLE FUNCTION - COPIED FROM DEPRECIATION MODULE

    // CUSTOM BROWSER MENU - COPIED FROM DEPRECIATION MODULE
    function showBrowserMenuUnderToggle() {
      const menu = document.createElement('div');
      menu.style.cssText = `
        position: fixed;
        top: 90px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 20px;
        z-index: 99999;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        font-family: sans-serif;
        direction: rtl;
        min-width: 280px;
      `;
      
      menu.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 15px; color: #2c3e50; font-size: 16px;">בחר אתר לפתיחה:</div>
        <button onclick="window.openInternalBrowser('car-part.co.il'); this.parentElement.remove();" style="width: 100%; padding: 12px; margin-bottom: 8px; border: none; background: #28a745; color: white; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: 500;">
          🔧 Car Part - חלקי רכב
        </button>
        <button onclick="window.openInternalBrowser('portal.levi-itzhak.co.il'); this.parentElement.remove();" style="width: 100%; padding: 12px; margin-bottom: 8px; border: none; background: #007bff; color: white; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: 500;">
          📊 פורטל לוי יצחק
        </button>
        <button onclick="this.parentElement.remove();" style="width: 100%; padding: 10px; border: 1px solid #ccc; background: white; color: #666; border-radius: 6px; cursor: pointer; font-size: 14px;">
          ביטול
        </button>
      `;
      
      document.body.appendChild(menu);
      
      // Remove menu when clicking outside
      setTimeout(() => {
        document.addEventListener('click', function removeMenu(e) {
          if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', removeMenu);
          }
        });
      }, 100);
    }

    // COLLAPSIBLE SECTION TOGGLE
    function toggleSection(sectionId) {
      const section = document.getElementById(sectionId);
      if (section) {
        section.style.display = section.style.display === 'none' ? 'block' : 'none';
        
        // Save state to sessionStorage
        const isVisible = section.style.display !== 'none';
        sessionStorage.setItem(`section-${sectionId}`, isVisible ? 'expanded' : 'collapsed');
      } else {
      }
    }

    // DAMAGE CENTERS SECTION TOGGLE
    function toggleDamageCentersSection() {
      const section = document.getElementById('damageCentersSummary');
      const toggleBtn = document.getElementById('damageCentersToggleBtn');
      
      if (section && toggleBtn) {
        const isVisible = section.style.display !== 'none';
        
        if (isVisible) {
          // Hide section
          section.style.display = 'none';
          toggleBtn.innerHTML = '🔼 פתח';
          toggleBtn.style.background = '#28a745';
        } else {
          // Show section
          section.style.display = 'block';
          toggleBtn.innerHTML = '🔽 סגור';
          toggleBtn.style.background = '#6c757d';
        }
        
        // Save state to sessionStorage
        sessionStorage.setItem('damageCentersSection', isVisible ? 'collapsed' : 'expanded');
      }
    }

    
    // ADD DEPRECIATION FIELD FUNCTION
    function addDepField(data = {}) {
      const container = document.getElementById('depreciationBulkTable');
      if (!container) {
        return;
      }
      
      const rowId = 'depRow_' + Date.now();
      const newRow = `
        <div id="${rowId}" class="dep-row" style="display:grid; grid-template-columns:70px 2fr 2fr 80px 90px 80px; gap:10px; margin-bottom:8px;">
          <div><input type="text" placeholder="מס' מוקד" value="${data.center_number || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" style="text-align: center;" title="${data.center_number || ''}" /></div>
          <div><input type="text" placeholder="החלק הניזוק" value="${data.damaged_part || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="${data.damaged_part || ''}" /></div>
          <div><input type="text" placeholder="מהות התיקון" value="${data.repair_type || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="${data.repair_type || ''}" /></div>
          <div><input type="text" placeholder="ירידת ערך (מספר)" value="${data.percent || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="${data.percent || ''}" style="direction: ltr; text-align: right;" /></div>
          <div><input type="text" placeholder="ערך ב-₪" value="${data.value || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="₪${data.value || ''}" /></div>
          <div><button class="btn remove" onclick="removeDepField('${rowId}')">מחק</button></div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      
      // Add auto-calculation functionality to the percentage field
      const row = document.getElementById(rowId);
      
      // Add tooltip update listeners to all input fields
      const inputs = row.querySelectorAll('input');
      inputs.forEach(input => {
        input.addEventListener('input', function() {
          this.title = this.value;
        });
      });
      const percentInput = row.querySelector('input[placeholder="ירידת ערך (מספר)"]');
      const valueInput = row.querySelector('input[placeholder="ערך ב-₪"]');
      
      percentInput.addEventListener('input', function() {
        // Clean the value to extract the numeric part for calculation only
        const cleanValue = this.value.replace('%', '').replace(/[^0-9.-]/g, '');
        let percent = parseFloat(cleanValue) || 0;
        
        // Don't modify the input value - keep it as the user entered it
        
        // Calculate value from market price automatically
        const marketValueField = document.getElementById('carMarketValue') || document.getElementById('sumMarketValue');
        const marketValueStr = marketValueField?.value.replace(/[₪,]/g, '') || '0';
        const marketValue = parseFloat(marketValueStr) || 0;
        
        const calculatedValue = (marketValue * percent) / 100;
        valueInput.value = calculatedValue ? `₪${Math.round(calculatedValue).toLocaleString()}` : '';
        
        // Save data after calculation
        saveDepreciationData();
      });
    }

    // ✅ REAL-TIME 2-WAY DATA FLOW: Update helper.depreciation immediately when UI fields change
    function updateHelperDepreciationField(element, fieldName) {
      try {
        const helper = window.helper || {};
        if (!helper.depreciation) helper.depreciation = {};
        
        let value = element.value;
        
        // Handle different field types
        switch(fieldName) {
          case 'global_percentage':
            // Clean the value: remove % sign and handle decimal values correctly
            const cleanValue = value.replace('%', '').replace(/[^0-9.-]/g, '');
            helper.depreciation.global_percentage = parseFloat(cleanValue) || 0;
            // Also trigger the calculation
            calculateGlobalDepreciationValue();
            break;
          case 'work_days_impact':
            helper.depreciation.work_days_impact = parseInt(value) || 0;
            break;
          default:
            helper.depreciation[fieldName] = value;
        }
        
        helper.depreciation.last_updated = new Date().toISOString();
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        
        // Trigger helper update broadcast
        if (typeof broadcastHelperUpdate === 'function') {
          broadcastHelperUpdate(['depreciation'], 'depreciation_field_update');
        }
      } catch (error) {
      }
    }
    
    // REMOVE DEPRECIATION FIELD FUNCTION
    function removeDepField(rowId) {
      const row = document.getElementById(rowId);
      if (row) {
        row.remove();
        // Save after removal
        saveDepreciationData();
      }
    }

    // SAVE DEPRECIATION DATA TO HELPER
    function saveDepreciationData() {
      console.log('💾 SAVE DATA BUTTON CLICKED!');
      const button = document.querySelector('.save-btn');
      
      // Show visual feedback
      if (button) {
        button.style.background = '#059669';
        button.innerHTML = '⏳ שומר...';
        button.disabled = true;
      }
      
      try {
        // Get helper data from sessionStorage (single source of truth) to ensure consistency
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Get global depreciation values
        const globalPercent = document.getElementById('globalDep1')?.value || '';
        const globalValue = document.getElementById('globalDepValue')?.value || '';
        
        
        // Collect depreciation data
        const depreciationData = {
          global_percent: globalPercent,
          global_value: globalValue,
          bulk_items: []
        };
        
        // Collect data from all depreciation rows
        const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
        console.log('💾 Collecting data from', depRows.length, 'depreciation rows');
        
        depRows.forEach((row, index) => {
          const inputs = row.querySelectorAll('input');
          if (inputs.length >= 5) {
            const item = {
              center_number: inputs[0].value,
              damaged_part: inputs[1].value,
              repair_type: inputs[2].value,
              // Keep percent value as entered by user
              percent: inputs[3].value,
              value: inputs[4].value
            };
            console.log(`  Row ${index + 1}:`, item);
            depreciationData.bulk_items.push(item);
          }
        });
        
        // ✅ CORRECT 2-WAY DATA FLOW: Save to main helper.depreciation structure
        if (!helper.depreciation) helper.depreciation = {};
        
        
        // Save to main depreciation section (single source of truth) with COMPLETE structure
        try {
          
          helper.depreciation = {
            // Form field names (for direct loading) - keep the value as entered by user
            globalDep1: globalPercent,
            globalDepValue: globalValue,
            garageDays: document.getElementById('garageDays')?.value || '',
            
            // Processed values (for calculations)  
            global_percentage: parseFloat(String(globalPercent).replace('%', '').replace(/[^0-9.-]/g, '')) || 0,
            global_amount: parseFloat(String(globalValue).replace(/[₪,]/g, '')) || 0,
            work_days_impact: parseInt(document.getElementById('garageDays')?.value) || 0,
            
            // Array data (single array, no duplication)
            bulk_items: depreciationData.bulk_items,
            
            // Metadata
            last_updated: new Date().toISOString(),
            lastSaved: new Date().toISOString(),
            source: 'final_report_builder',
            isManualSave: true
          };
          
        } catch (error) {
        }
        
        // Also maintain final_report reference for compatibility
        if (!helper.final_report) helper.final_report = {};
        helper.final_report.depreciation = helper.depreciation;
        
        // Initialize adjustments structure mirroring estimate.adjustments
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // ✅ REMOVED: No longer saving to manual_depreciation - everything is in helper.depreciation
        
        // ✅ CRITICAL FIX: Update BOTH sessionStorage AND in-memory window.helper to prevent populateAllForms overwrite
        sessionStorage.setItem('helper', JSON.stringify(helper));
        if (window.helper) {
          window.helper.depreciation = helper.depreciation;
          window.helper.final_report = helper.final_report;
        }
        
        console.log('✅ Depreciation data saved successfully:', helper.depreciation);
        console.log('✅ Updated window.helper:', window.helper);
        
        // Trigger helper update broadcast for real-time sync
        if (typeof broadcastHelperUpdate === 'function') {
          broadcastHelperUpdate(['depreciation'], 'depreciation_update');
        }
        
        console.log('✅ DATA SAVED SUCCESSFULLY!');
        
        // Show success message using the standard message system
        showSectionMessage('depreciation', '✅ נתוני ירידת ערך נשמרו בהצלחה', 'success');
        
        // Show success feedback on button
        if (button) {
          button.style.background = '#16a34a';
          button.innerHTML = '✅ נשמר!';
          setTimeout(() => {
            button.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
            button.innerHTML = 'שמור נתונים';
            button.disabled = false;
          }, 2000);
        }
        
      } catch (error) {
        console.error('❌ SAVE ERROR:', error);
        
        // Show error feedback
        if (button) {
          button.style.background = '#dc2626';
          button.innerHTML = '❌ שגיאה';
          setTimeout(() => {
            button.style.background = '#ef4444';
            button.innerHTML = 'שמור נתונים';
            button.disabled = false;
          }, 2000);
        }
      }
    }

    // ADD AUTO-CALCULATION TO EXISTING ROWS
    function addAutoCalculationToExistingRows() {
      const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
      depRows.forEach(row => {
        const percentInput = row.querySelector('input[placeholder="ירידת ערך (מספר)"]');
        const valueInput = row.querySelector('input[placeholder="ערך ב-₪"]');
        
        if (percentInput && valueInput) {
          // Remove any existing event listeners first
          percentInput.removeEventListener('input', percentInput.autoCalcHandler);
          
          // Create the auto-calculation handler
          const autoCalcHandler = function() {
            // Clean the value to extract the numeric part
            const cleanValue = this.value.replace('%', '').replace(/[^0-9.-]/g, '');
            let percent = parseFloat(cleanValue) || 0;
            
            // Keep value as clean decimal number without % sign
            this.value = cleanValue;
            
            // Calculate value from market price automatically
            const marketValueField = document.getElementById('carMarketValue') || document.getElementById('sumMarketValue');
            const marketValueStr = marketValueField?.value.replace(/[₪,]/g, '') || '0';
            const marketValue = parseFloat(marketValueStr) || 0;
            
            const calculatedValue = (marketValue * percent) / 100;
            valueInput.value = calculatedValue ? `₪${Math.round(calculatedValue).toLocaleString()}` : '';
            
            // Save data after calculation
            saveDepreciationData();
          };
          
          // Store the handler reference for potential removal
          percentInput.autoCalcHandler = autoCalcHandler;
          
          // Add the event listener
          percentInput.addEventListener('input', autoCalcHandler);
          
          // Trigger calculation for existing values
          if (percentInput.value) {
            autoCalcHandler.call(percentInput);
          }
        }
      });
    }

    // MAKE FUNCTIONS GLOBALLY ACCESSIBLE
    window.toggleSection = toggleSection;
    window.toggleDamageCentersSection = toggleDamageCentersSection;
    window.addDepField = addDepField;
    window.removeDepField = removeDepField;
    window.saveDepreciationData = saveDepreciationData;

    // BUTTON FUNCTIONS - NO DEBUG ALERTS
    window.saveFinalReport = function() {
      const selectedTypeElement = document.querySelector('input[name="final-report-type"]:checked');
      if (!selectedTypeElement) {
        alert('אנא בחר סוג חוות דעת');
        return;
      }
      
      const selectedType = selectedTypeElement.value;
      const additionalNotes = document.getElementById('additional-notes')?.value || '';
      const garageDays = document.getElementById('garageDays')?.value || '';
      
      // Get summary data
      const summaryData = {
        market_value: document.getElementById('sumMarketValue')?.value || '',
        total_claim: document.getElementById('sumClaim')?.value || '',
        vat: document.getElementById('sumVAT')?.value || '',
        total_with_vat: document.getElementById('sumTotalClaim')?.value || '',
        dep_compensation: document.getElementById('depCompensation')?.value || '',
        salvage_value: document.getElementById('salvageValue')?.value || ''
      };
      
      // Get depreciation data
      const depreciationData = {
        global_percent: document.getElementById('globalDep1')?.value || '',
        global_value: document.getElementById('globalDepValue')?.value || '',
        bulk_items: []
      };
      
      // Collect depreciation bulk items
      const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
      depRows.forEach(row => {
        const inputs = row.querySelectorAll('input');
        if (inputs.length >= 5) {
          depreciationData.bulk_items.push({
            center_number: inputs[0].value,
            damaged_part: inputs[1].value,
            repair_type: inputs[2].value,
            // Clean percent value to remove % and handle decimals properly
            percent: inputs[3].value.replace('%', '').replace(/[^0-9.-]/g, ''),
            value: inputs[4].value
          });
        }
      });
      
      // Collect adjustment data and save to helper.final_report.adjustments
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Initialize final_report.adjustments if not exists
      if (!helper.final_report) helper.final_report = {};
      if (!helper.final_report.adjustments) {
        helper.final_report.adjustments = {
          features: [],
          registration: [],
          mileage: [],
          ownership_type: [],
          ownership_history: [],
          usage: [],
          additional: []
        };
      }

      // Define adjustment mapping for all categories
      const adjustmentMappings = [
        { category: 'features', containerId: 'featuresAdjustmentsList' },
        { category: 'registration', containerId: 'registrationAdjustmentsList' },
        { category: 'features', containerId: 'fullFeaturesAdjustmentsList' }, // Full market features
        { category: 'registration', containerId: 'fullRegistrationAdjustmentsList' }, // Full market registration
        { category: 'mileage', containerId: 'mileageAdjustmentsList' },
        { category: 'ownership_type', containerId: 'ownershipAdjustmentsList' },
        { category: 'ownership_history', containerId: 'ownersAdjustmentsList' },
        { category: 'usage', containerId: 'usageAdjustmentsList' },
        { category: 'additional', containerId: 'allAdjustmentsList' }
      ];

      // Clear all categories in final_report.adjustments
      Object.keys(helper.final_report.adjustments).forEach(key => {
        helper.final_report.adjustments[key] = [];
      });

      // Collect adjustments from all containers
      adjustmentMappings.forEach(({ category, containerId }) => {
        const container = document.getElementById(containerId);
        if (container) {
          // Try different row selectors based on container structure
          let rows = container.querySelectorAll('div.adjustment-row');
          if (rows.length === 0) {
            // Fallback for containers that use direct child divs
            rows = container.children;
          }
          
          Array.from(rows).forEach(row => {
            const inputs = row.querySelectorAll('input, select');
            
            if (inputs.length >= 4) {
              const adjustmentItem = {
                value: inputs[0].value || '', // Field mapping: תיאור → value
                type: inputs[1].value || 'plus', // Field mapping: סוג → type
                percent: parseFloat(inputs[2].value) || 0, // Field mapping: אחוז → percent
                percentage: parseFloat(inputs[2].value) || 0, // Backward compatibility
                amount: safeParseAmount(inputs[3].value),
                amount_display: inputs[3].value || '',
                source: 'final_report',
                timestamp: new Date().toISOString()
              };

              // Apply proper sign based on type
              if (adjustmentItem.type === 'minus') {
                adjustmentItem.percent = -Math.abs(adjustmentItem.percent);
                adjustmentItem.percentage = -Math.abs(adjustmentItem.percentage);
                adjustmentItem.amount = -Math.abs(adjustmentItem.amount);
              }

              helper.final_report.adjustments[category].push(adjustmentItem);
            }
          });
        }
      });

      // Update valuation.adjustments with original items only (first item of each category)
      if (!helper.valuation) helper.valuation = {};
      if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
      
      Object.keys(helper.final_report.adjustments).forEach(category => {
        const items = helper.final_report.adjustments[category];
        if (items.length > 0 && items[0].source !== 'final_report') {
          // Only update valuation if the first item is from original estimate data
          helper.valuation.adjustments[category] = items[0];
        }
      });

      // Legacy format for compatibility
      const adjustmentsData = {
        features: helper.final_report.adjustments.features,
        registration: helper.final_report.adjustments.registration,
        full_market: helper.final_report.adjustments.additional
      };
      
      // Collect legal text
      const legalText = document.getElementById('legal-text-content')?.value || '';
      
      // Save to helper using proper function
      const finalReportData = {
        type: selectedType,
        notes: additionalNotes,
        work_days: garageDays,
        summary: summaryData,
        depreciation: depreciationData,
        adjustments: adjustmentsData,
        legal_text: legalText
      };
      
      // Save the helper object with updated adjustments
      sessionStorage.setItem('helper', JSON.stringify(helper));
      if (window.helper) {
        window.helper = helper;
      }

      if (typeof updateHelper === 'function') {
        updateHelper('final_report', finalReportData, 'final_report_builder_save');
      } else {
        // Fallback for compatibility - already updated helper above
        Object.assign(helper.final_report, finalReportData);
        sessionStorage.setItem('helper', JSON.stringify(helper));
      }
      
      // ✅ BIDIRECTIONAL INTEGRATION: Update builder current state with all final report data
      updateBuilderCurrentState('final_report.type', selectedType);
      updateBuilderCurrentState('final_report.notes', additionalNotes);
      updateBuilderCurrentState('final_report.work_days', garageDays);
      updateBuilderCurrentState('final_report.summary', summaryData);
      updateBuilderCurrentState('final_report.depreciation', depreciationData);
      // Removed: updateBuilderCurrentState('final_report.adjustments', adjustmentsData); - using valuation.adjustments instead
      updateBuilderCurrentState('final_report.legal_text', legalText);
      
      alert('חוות דעת סופית נשמרה בהצלחה');
    };

    window.previewFinalReport = function() {
      // First save all data
      window.saveFinalReport();
      
      // Set report type and navigate
      sessionStorage.setItem('selectedReportType', 'final-report');
      window.location.href = 'final-report-validation.html';
    };

    window.generateFinalReport = function() {
      // First save all data
      window.saveFinalReport();
      
      // Set report type and navigate to fee module
      sessionStorage.setItem('selectedReportType', 'final-report');
      window.location.href = 'fee-module.html';
    };

    // Convert various date formats to YYYY-MM-DD for date input
    function convertToDateInputFormat(dateString) {
      if (!dateString) return '';
      
      try {
        // Handle various date formats
        let date;
        
        // If already in YYYY-MM-DD format, return as is
        if (/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
          return dateString;
        }
        
        // Handle DD/MM/YYYY format
        if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateString)) {
          const parts = dateString.split('/');
          const day = parts[0].padStart(2, '0');
          const month = parts[1].padStart(2, '0');
          const year = parts[2];
          return `${year}-${month}-${day}`;
        }
        
        // Handle DD-MM-YYYY format
        if (/^\d{1,2}-\d{1,2}-\d{4}$/.test(dateString)) {
          const parts = dateString.split('-');
          const day = parts[0].padStart(2, '0');
          const month = parts[1].padStart(2, '0');
          const year = parts[2];
          return `${year}-${month}-${day}`;
        }
        
        // Handle DD.MM.YYYY format
        if (/^\d{1,2}\.\d{1,2}\.\d{4}$/.test(dateString)) {
          const parts = dateString.split('.');
          const day = parts[0].padStart(2, '0');
          const month = parts[1].padStart(2, '0');
          const year = parts[2];
          return `${year}-${month}-${day}`;
        }
        
        // Try to parse as a general date
        date = new Date(dateString);
        if (!isNaN(date.getTime())) {
          return date.toISOString().split('T')[0];
        }
        
        return '';
      } catch (error) {
        return '';
      }
    }

    // LOAD DATA FROM HELPER
    function loadDataFromHelper() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Clean up redundant duplicate damage_assessment.centers section on page load
        if (helper.damage_assessment?.centers) {
          delete helper.damage_assessment.centers;
          if (Object.keys(helper.damage_assessment).length === 0) {
            delete helper.damage_assessment;
          }
          // Save cleaned helper
          sessionStorage.setItem('helper', JSON.stringify(helper));
          window.helper = helper;
        }
        
        // Helper function to get nested values
        const getNestedValue = (obj, path, defaultValue = '') => {
          const keys = path.split('.');
          let current = obj;
          for (const key of keys) {
            if (current && typeof current === 'object' && key in current) {
              current = current[key];
            } else {
              return defaultValue;
            }
          }
          return current || defaultValue;
        };
        
        // Load car details (now editable) and sync vehicle structure
        if (helper.car_details || helper.meta) {
          document.getElementById('carPlate').value = helper.meta?.plate || helper.car_details?.plate || '';
          document.getElementById('carManufacturer').value = helper.car_details?.manufacturer || '';
          document.getElementById('carModel').value = helper.car_details?.model || '';
          document.getElementById('carYear').value = helper.car_details?.year || '';
          document.getElementById('carModelCode').value = helper.car_details?.model_code || helper.vehicle?.model_code || '';
          // Base price from standardized valuation structure (with legacy fallback)
          const rawBasePrice = helper.valuation?.base_price || helper.car_details?.base_price || helper.levi_report?.base_price;
          // Clean any existing currency symbols and parse as number
          const basePrice = rawBasePrice ? parseFloat(String(rawBasePrice).replace(/[₪,]/g, '')) : null;
          document.getElementById('carBasePrice').value = basePrice ? `₪${basePrice.toLocaleString()}` : '';
          
          // Also populate the basicPrice field (marked price field) with levi base price
          const basicPriceField = document.getElementById('basicPrice');
          if (basicPriceField && basePrice) {
            basicPriceField.value = `₪${basePrice.toLocaleString()}`;
          }
          // Market value from standardized vehicle structure (with legacy fallback) 
          const rawMarketValue = helper.calculations?.full_market_value || helper.vehicle?.market_value || helper.valuation?.market_value;
          
          // DEBUG: Track where 80487 comes from
          if (helper.vehicle?.market_value) {
          }
          if (helper.calculations?.full_market_value) {
          }
          if (helper.valuation?.market_value) {
          }
          
          // Clean any existing currency symbols and parse as number
          const marketValue = rawMarketValue ? parseFloat(String(rawMarketValue).replace(/[₪,]/g, '')) : null;
          
          // Debug market value loading
          if (marketValue && marketValue > 0) {
          } else {
          }
          
          document.getElementById('carMarketValue').value = marketValue ? `₪${marketValue.toLocaleString()}` : '';
          // Load finalReportDate from car_details like other fields
          const finalReportDateValue = helper.car_details?.final_report_date || new Date().toISOString().split('T')[0];
          const topDateField = document.getElementById('finalReportDate');
          const summaryDateField = document.getElementById('finalReportDateSummary');
          
          if (topDateField) topDateField.value = convertToDateInputFormat(finalReportDateValue);
          if (summaryDateField) summaryDateField.value = convertToDateInputFormat(finalReportDateValue);
          
          // Load saved full market value from helper if it exists
          const savedFullMarketValue = helper.calculations?.full_market_value;
          if (savedFullMarketValue) {
            const fullMarketValueField = document.getElementById('fullMarketValueResult');
            if (fullMarketValueField) {
              fullMarketValueField.value = `₪${savedFullMarketValue.toLocaleString()}`;
            }
          }
          
          // Ensure vehicle structure is populated on load
          helper.vehicle = helper.vehicle || {};
          helper.vehicle.manufacturer = helper.car_details?.manufacturer || helper.vehicle.manufacturer || '';
          helper.vehicle.model = helper.car_details?.model || helper.vehicle.model || '';
          helper.vehicle.year = helper.car_details?.year || helper.vehicle.year || '';
          helper.vehicle.model_code = helper.car_details?.model_code || helper.vehicle.model_code || '';
          helper.vehicle.plate_number = helper.meta?.plate || helper.car_details?.plate || helper.vehicle.plate_number || '';
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
        
        // Load claims data section fields - מיפוי נתוני תביעה
        const calc = helper.expertise?.calculations || {};
        const claimsData = helper.claims_data || {};
        const leviData = helper.levi_report || helper.levisummary || {};
        
        // 1. סה״כ תביעה (סכום מוקדי נזק) - Total Claim from damage centers
        const totalClaimDiv = document.getElementById('totalClaim');
        const formattedClaim = claimsData.total_claim || 
          (calc.total_damage ? `₪${calc.total_damage.toLocaleString()}` : '') ||
          (helper.damage_centers_summary?.total_cost ? `₪${helper.damage_centers_summary.total_cost.toLocaleString()}` : '');
        if (totalClaimDiv) {
          totalClaimDiv.innerText = formattedClaim;
        }
        
        // Load totalClaimGross field from original damage_assessment.totals["Total with VAT"] 
        const totalClaimGrossField = document.getElementById('totalClaimGross');
        if (totalClaimGrossField) {
          let totalWithVAT = helper.damage_assessment?.totals?.["Total with VAT"] || 0;
          let source = 'totals["Total with VAT"]';
          
          // Fallback to damage_assessment.summary.total_with_vat if totals doesn't exist
          if (!totalWithVAT && helper.damage_assessment?.summary?.total_with_vat) {
            totalWithVAT = helper.damage_assessment.summary.total_with_vat;
            source = 'summary.total_with_vat';
          }
          
          totalClaimGrossField.value = totalWithVAT ? `₪${totalWithVAT.toLocaleString()}` : '';
        }
        
        // Load authorizedClaim field - prioritize totals_after_differentials, then check saved data
        const authorizedClaimField = document.getElementById('authorizedClaim');
        if (authorizedClaimField) {
          let useValue = '';
          let numericValue = 0;
          
          // Priority 1: Check for totals_after_differentials first (most current data)
          if (helper.damage_assessment?.totals_after_differentials?.["Total with VAT"]) {
            numericValue = helper.damage_assessment.totals_after_differentials["Total with VAT"];
            useValue = `₪${numericValue.toLocaleString()}`;
            console.log('✅ Using totals_after_differentials for authorizedClaim:', numericValue);
          }
          // Priority 2: Fallback to original totals
          else if (helper.damage_assessment?.totals?.["Total with VAT"]) {
            numericValue = helper.damage_assessment.totals["Total with VAT"];
            useValue = `₪${numericValue.toLocaleString()}`;
            console.log('✅ Using original totals for authorizedClaim:', numericValue);
          }
          // Priority 3: Check for manually saved values
          else {
            const savedClaimValue = helper.claims_data?.total_claim;
            const savedCalculationValue = helper.calculations?.total_damage;
            
            if (savedClaimValue && savedClaimValue !== '' && savedClaimValue !== '0' && savedClaimValue !== '00') {
              useValue = savedClaimValue;
              numericValue = parseFloat(savedClaimValue.replace(/[₪,]/g, '')) || 0;
            } else if (savedCalculationValue && savedCalculationValue > 0) {
              numericValue = savedCalculationValue;
              useValue = `₪${numericValue.toLocaleString()}`;
            } else {
              // Final fallback to damage_centers_summary
              let totalWithVAT = helper.damage_centers_summary?.total_cost || 0;
              numericValue = totalWithVAT;
              useValue = totalWithVAT ? `₪${totalWithVAT.toLocaleString()}` : '';
            }
          }
          
          authorizedClaimField.value = useValue;
          
          // Ensure both storage locations are updated
          if (!helper.claims_data) helper.claims_data = {};
          if (!helper.calculations) helper.calculations = {};
          helper.claims_data.total_claim = useValue;
          helper.calculations.total_damage = numericValue;
        }
        
        
        // 2. חישוב הערך לנזק גולמי - Gross damage value (from Levi adjustments)
        const grossDamageValueDiv = document.getElementById('grossDamageValue');
        const grossValue = helper.calculations?.vehicle_value_gross || 
          leviData.final_price || 
          (helper.valuation?.calculations?.gross_price?.total) || 0;
        if (grossDamageValueDiv && grossValue > 0) {
          grossDamageValueDiv.innerText = `₪${grossValue.toLocaleString()}`;
        }
        
        // 3. חישוב האחוז הגולמי - Gross percentage calculation
        const grossPercentageDiv = document.getElementById('grossPercentage');
        const grossPercent = claimsData.gross_percent || 
          (helper.calculations?.damage_percent ? `${helper.calculations.damage_percent}%` : '') ||
          (calc.damage_percent ? `${calc.damage_percent}%` : '');
        if (grossPercentageDiv) {
          grossPercentageDiv.innerText = grossPercent;
        }
        
        // 4. מחיר שוק (בסיס + התאמות) - Market price CORRECTED MAPPING
        const marketPriceDiv = document.getElementById('marketPriceCalculated');
        let marketPrice = helper.calculations?.full_market_value || 
                         helper.expertise?.calculations?.market_value || 
                         helper.vehicle?.market_value || 
                         helper.valuation?.market_value || 0;
        
        // DEBUG: Check what's in helper for market value
        console.log('🔍 Market value debug:', {
          'helper.calculations': helper.calculations,
          'helper.calculations.full_market_value': helper.calculations?.full_market_value,
          'helper.expertise?.calculations?.market_value': helper.expertise?.calculations?.market_value,
          'helper.vehicle?.market_value': helper.vehicle?.market_value,
          'marketPrice': marketPrice
        });
        
        // Handle string values that need parsing
        if (typeof marketPrice === 'string') {
          marketPrice = parseFloat(marketPrice.replace(/[₪,]/g, '')) || 0;
        }
        
        if (marketPriceDiv && marketPrice > 0) {
          marketPriceDiv.innerText = `₪${marketPrice.toLocaleString()}`;
        } else if (marketPriceDiv) {
          marketPriceDiv.innerText = 'לא זמין';
        }
        
        // 5. ערך השוק של הרכב (לפי דו״ח לוי יצחק) - Final market value from Levi report
        const finalMarketValueDiv = document.getElementById('finalMarketValue');
        let finalMarketVal = helper.levisummary?.final_price || 
                            helper.levi_report?.final_price || 
                            helper.expertise?.levi_report?.final_price || 0;
        
        // DEBUG: Check what's in helper for Levi data
        
        // Handle string values that need parsing
        if (typeof finalMarketVal === 'string') {
          finalMarketVal = parseFloat(finalMarketVal.replace(/[₪,]/g, '')) || 0;
        }
        
        if (finalMarketValueDiv && finalMarketVal > 0) {
          finalMarketValueDiv.innerText = `₪${finalMarketVal.toLocaleString()}`;
        } else if (finalMarketValueDiv) {
          finalMarketValueDiv.innerText = 'לא זמין';
        }
        
        // Legacy field mappings for backward compatibility
        const leviPriceListField = document.getElementById('leviPriceList');
        if (leviPriceListField) {
          leviPriceListField.value = grossValue > 0 ? `₪${grossValue.toLocaleString()}` : '';
        }
        
        const grossPercentField = document.getElementById('grossPercent');
        if (grossPercentField) {
          grossPercentField.value = grossPercent;
        }
        
          
        console.log('💰 נתוני תביעה mapped successfully:', { 
          totalClaim: formattedClaim,
          grossDamageValue: grossValue,
          grossPercentage: grossPercent,
          marketPrice: marketPrice,
          finalMarketValue: finalMarketVal
        });
        
        // Update gross market value field with calculated value
        updateGrossMarketValueField();
        
        // Force refresh of all cost displays and calculations
        setTimeout(() => {
          updateAllCostDisplays();
          updateSummaryTotalsFromDamageCenters();
          // loadGrossCalculationData(); // DISABLED - causes duplicate Levi data, loadGrossAdjustments() already handles this
        }, 200);
        
        // Load contact data using standardized helper structure - Populate ALL fields from standardized helper structure paths (with legacy fallback)
        document.getElementById('ownerName').value = getNestedValue(helper, 'stakeholders.owner.name') || helper.client?.name || '';
        document.getElementById('ownerAddress').value = getNestedValue(helper, 'stakeholders.owner.address') || helper.client?.address || '';  
        document.getElementById('ownerPhone').value = getNestedValue(helper, 'stakeholders.owner.phone') || helper.client?.phone || '';
        document.getElementById('insuranceCompany').value = getNestedValue(helper, 'stakeholders.insurance.company') || helper.client?.insurance_company || '';
        document.getElementById('insuranceEmail').value = getNestedValue(helper, 'stakeholders.insurance.email') || helper.client?.insurance_email || '';
        document.getElementById('insuranceAgent').value = getNestedValue(helper, 'stakeholders.insurance.agent.name') || helper.client?.insurance_agent || '';
        document.getElementById('agentPhone').value = getNestedValue(helper, 'stakeholders.insurance.agent.phone') || helper.client?.insurance_agent_phone || '';
        document.getElementById('agentEmail').value = getNestedValue(helper, 'stakeholders.insurance.agent.email') || helper.client?.insurance_agent_email || '';
        
        // Load garage data from stakeholders helper
        document.getElementById('garageName').value = getNestedValue(helper, 'stakeholders.garage.name') || helper.garage?.name || '';
        document.getElementById('garagePhone').value = getNestedValue(helper, 'stakeholders.garage.phone') || helper.garage?.phone || '';
        document.getElementById('garageEmail').value = getNestedValue(helper, 'stakeholders.garage.email') || helper.garage?.email || '';
        
          
        // Sync data to both standardized and legacy structures for compatibility
        helper.car_details = helper.car_details || {};
        helper.car_details.owner = getNestedValue(helper, 'stakeholders.owner.name') || helper.client?.name || '';
        helper.car_details.ownerAddress = getNestedValue(helper, 'stakeholders.owner.address') || helper.client?.address || '';
        helper.car_details.ownerPhone = getNestedValue(helper, 'stakeholders.owner.phone') || helper.client?.phone || '';
        helper.car_details.insuranceCompany = getNestedValue(helper, 'stakeholders.insurance.company') || helper.client?.insurance_company || '';
        helper.car_details.agentName = getNestedValue(helper, 'stakeholders.insurance.agent.name') || helper.client?.insurance_agent || '';
        helper.car_details.insurance_agent_phone = getNestedValue(helper, 'stakeholders.insurance.agent.phone') || helper.client?.insurance_agent_phone || '';
        helper.car_details.insurance_agent_email = getNestedValue(helper, 'stakeholders.insurance.agent.email') || helper.client?.insurance_agent_email || '';
          
          // Note: garageName and garagePhone are not in the builder, so they'll remain empty
          helper.car_details.garageName = helper.car_details.garageName || '';
          helper.car_details.garagePhone = helper.car_details.garagePhone || '';
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Update page title with plate
        // Standardize plate format
        const rawPlate = helper.meta?.plate || helper.car_details?.plate || '...';
        const standardizedPlate = rawPlate !== '...' ? String(rawPlate).replace(/[-\s]/g, '') : rawPlate;
        document.getElementById('pageTitle').textContent = `רכב מס. ${standardizedPlate}`;
        
        // Load summary data
        loadSummaryData(helper);
        
        // Load depreciation data
        loadDepreciationData(helper);
        
        // Load garage days data
        if (helper.final_report?.work_days || helper.expertise?.depreciation?.work_days) {
          document.getElementById('garageDays').value = helper.final_report?.work_days || helper.expertise?.depreciation?.work_days || '';
        }
        
        // Load damage centers summary
        loadDamageCentersSummary(helper);
        
        // Load features and registration adjustments for gross calculation
        loadGrossAdjustments(helper);
        
        // DISABLED: loadAllAdjustments - causes override of final_report data
        // loadAllAdjustments(helper);
        
        // Load Total Value Section adjustments from final_report.adjustments
        loadTotalValueSectionAdjustments(helper);
        
        // Set flag to prevent sync during page load before calculations
        window.pageLoadInProgress = true;
        
        // Trigger calculations after data is loaded
        setTimeout(() => {
          updateGrossMarketValueCalculation();
          updateFullMarketValueCalculation();
          
          // CRITICAL: Save all adjustment data including added rows after calculations
          updateFullMarketValueToFinalReportAndValuation(helper);
          
          // CRITICAL: Trigger all change events to ensure formatAdjustmentDisplay runs
          triggerAllAdjustmentChangeEvents();
          
          // Save formatted state back to sessionStorage so refresh loads correct data  
          setTimeout(() => {
            // REMOVED: updateHelperFromAdjustments() to prevent overwriting calculated amounts on page load
            const updatedHelper = window.helper || {};
            sessionStorage.setItem('helper', JSON.stringify(updatedHelper));
            console.log('💾 Saved formatted helper state to sessionStorage after load with change events');
          }, 100);
        }, 150);
        
        
        // Note: addFieldChangeListeners() is called in DOMContentLoaded event
        
      } catch (error) {
        console.error('Error loading data from helper:', error);
      }
    }

    // POPULATE MARKET VALUE FOR CURRENT VARIANT - TARGETED APPROACH
    function populateMarketValueForCurrentVariant(helper, reportType) {
      try {
        // Handle different value formats (string, number, formatted)
        let marketValue = helper.calculations?.full_market_value || 0;
        
        if (typeof marketValue === 'string') {
          marketValue = parseFloat(marketValue.replace(/[₪,\s]/g, '')) || 0;
        } else if (typeof marketValue === 'number') {
          marketValue = marketValue || 0;
        }
        
        console.log('🔍 Market value population - Type:', reportType, 'Value:', marketValue);
        
        if (marketValue <= 0) {
          console.log('❌ No valid market value found');
          return;
        }
        
        // Target the correct field ID based on report type
        let targetFieldId = '';
        switch(reportType) {
          case 'חוות דעת פרטית':
            targetFieldId = 'sumMarketValuePrivate';
            break;
          case 'חוות דעת גלובלית':
            targetFieldId = 'sumMarketValueGlobal';
            break;
          case 'חוות דעת טוטלוסט':
            targetFieldId = 'sumMarketValueTotal';
            break;
          case 'חוות דעת מכירה מצבו הניזוק':
            targetFieldId = 'sumMarketValueDamage';
            break;
          case 'חוות דעת אובדן להלכה':
            targetFieldId = 'sumMarketValueLegal';
            break;
          default:
            targetFieldId = 'sumMarketValueDefault';
        }
        
        // Populate the target field
        const targetField = document.getElementById(targetFieldId);
        if (targetField) {
          const formattedValue = `₪${marketValue.toLocaleString()}`;
          targetField.value = formattedValue;
          console.log(`✅ Set ${targetFieldId} = ${formattedValue}`);
        } else {
          console.log(`❌ Field ${targetFieldId} not found`);
        }
        
      } catch (error) {
        console.error('Error populating market value:', error);
      }
    }

    // LOAD SUMMARY FIELDS FROM HELPER - ENHANCED FOR ALL 5 REPORT VARIANTS
    function loadSummaryFieldsFromHelper(helper) {
      try {
        
        // ENSURE HELPER STRUCTURE EXISTS FOR ALL VARIANTS
        helper.final_report = helper.final_report || {};
        helper.final_report.summary = helper.final_report.summary || {};
        
        // AUTO-POPULATED FIELDS (COMMON ACROSS VARIANTS)
        
        // SIMPLE DIRECT MAPPING - NO COMPLICATIONS
        
        // 1. Market Value - ONLY from calculations.full_market_value
        const marketValue = helper.calculations?.full_market_value || 0;
        
        // Set market value for ALL variant fields immediately
        ['sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 'sumMarketValueTotal', 'sumMarketValueLegal', 'sumMarketValuePrivate'].forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.value = marketValue > 0 ? `₪${marketValue.toLocaleString()}` : '';
          }
        });
        
        // 2. Total Claim - from helper.claims_data.total_claim
        let totalClaim = 0;
        
        // Parse from claims_data.total_claim (may be formatted string)
        if (helper.claims_data?.total_claim) {
          const claimValue = helper.claims_data.total_claim;
          if (typeof claimValue === 'string') {
            totalClaim = parseFloat(claimValue.replace(/[₪,]/g, '')) || 0;
          } else {
            totalClaim = parseFloat(claimValue) || 0;
          }
        } 
        // Fallback to damage_centers_summary.total_cost
        else if (helper.damage_centers_summary?.total_cost) {
          totalClaim = parseFloat(helper.damage_centers_summary.total_cost) || 0;
        }
        
        // Populate all total claim fields across ALL variants
        const allClaimFields = ['sumClaim', 'sumClaimGlobal', 'sumClaimPrivate', 'sumClaimDefault'];
        allClaimFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            const formattedClaim = totalClaim > 0 ? `₪${totalClaim.toLocaleString()}` : '';
            field.value = formattedClaim;
            helper.final_report.summary.total_claim = formattedClaim;
          }
        });
        
        // 3. Depreciation Compensation - from helper.depreciation.globalDepValue
        let depCompensation = 0;
        
        // Parse from globalDepValue (preferred)
        if (helper.depreciation?.globalDepValue) {
          const depValue = helper.depreciation.globalDepValue;
          if (typeof depValue === 'string') {
            depCompensation = parseFloat(depValue.replace(/[₪,]/g, '')) || 0;
          } else {
            depCompensation = parseFloat(depValue) || 0;
          }
        }
        // Fallback to globalDep1 (may contain formatted string like "1,972₪")
        else if (helper.depreciation?.globalDep1) {
          const dep1Value = helper.depreciation.globalDep1;
          if (typeof dep1Value === 'string') {
            depCompensation = parseFloat(dep1Value.replace(/[₪,%]/g, '')) || 0;
          } else {
            depCompensation = parseFloat(dep1Value) || 0;
          }
        }
        // Final fallback to total_compensation
        else if (helper.depreciation?.total_compensation) {
          depCompensation = parseFloat(helper.depreciation.total_compensation) || 0;
        }
        
        // Populate all depreciation compensation fields across ALL variants
        const allDepFields = ['depCompensation', 'depCompensationGlobal', 'depCompensationPrivate', 'sumDepreciation', 'sumDepreciationDefault'];
        allDepFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            const formattedDepValue = depCompensation > 0 ? `₪${depCompensation.toLocaleString()}` : '';
            field.value = formattedDepValue;
            helper.final_report.summary.dep_compensation = formattedDepValue;
          }
        });
        
        // 4. Adjustments Info - informative field only (not for calculations)
        const adjustmentsValue = helper.calculations?.final_adjustments_value || 0;
        const adjustmentsInfoField = document.getElementById('adjustmentsInfo');
        const adjustmentsInfoPrivateField = document.getElementById('adjustmentsInfoPrivate');
        
        const formattedAdjValue = adjustmentsValue !== 0 ? `₪${adjustmentsValue.toLocaleString()}` : '₪0';
        
        // Populate both static and dynamic private fields
        if (adjustmentsInfoField) {
          adjustmentsInfoField.value = formattedAdjValue;
        }
        
        if (adjustmentsInfoPrivateField) {
          adjustmentsInfoPrivateField.value = formattedAdjValue;
        }
        
        if (!adjustmentsInfoField && !adjustmentsInfoPrivateField) {
        }
        helper.final_report.summary.adjustments_value = adjustmentsValue;
        
        // MANUAL INPUT FIELDS (VARIANT-SPECIFIC)
        
        // Load existing manual input values from helper structure
        const manualFields = [
          // Damaged Sale variant
          { fieldId: 'saleValueDamage', helperKey: 'sale_value_damaged' },
          { fieldId: 'paymentMethod', helperKey: 'paymentMethod' },
          { fieldId: 'afterSaleDamage', helperKey: 'total_after_sale_damage' },
          
          // Total Loss variant  
          { fieldId: 'salvageValueTotal', helperKey: 'salvage_value_total' },
          { fieldId: 'storageValueTotal', helperKey: 'storage_towing_value_total' },
          { fieldId: 'afterSaleTotal', helperKey: 'total_after_salvage_total' },
          
          // Legal Loss variant
          { fieldId: 'salvageValueLegal', helperKey: 'salvage_value_legal' },
          { fieldId: 'afterSaleLegal', helperKey: 'total_after_salvage_legal' },
          
          // Legacy fields
          { fieldId: 'salvageValue', helperKey: 'salvage_value' }
        ];
        
        // Load manual input fields and ensure they exist in helper structure
        manualFields.forEach(({ fieldId, helperKey }) => {
          const field = document.getElementById(fieldId);
          const savedValue = helper.final_report.summary[helperKey];
          
          if (field) {
            // ENHANCED PROTECTION: Don't overwrite calculated fields if they have calculated values
            const isCalculatedField = ['afterSaleDamage', 'afterSaleTotal', 'afterSaleLegal'].includes(fieldId);
            const hasValue = field.value && field.value.trim() !== '';
            const marketValue = helper.calculations?.full_market_value || 0;
            const isNotMarketValue = field.value !== `₪${marketValue.toLocaleString()}`;
            
            if (isCalculatedField && hasValue && isNotMarketValue) {
              console.log(`🔒 ENHANCED PROTECTION: Preserving calculated field ${fieldId} = ${field.value} (blocked override with ${savedValue})`);
              // Also ensure the helper has the correct calculated value
              if (savedValue !== field.value) {
                helper.final_report.summary[helperKey] = field.value;
                sessionStorage.setItem('helper', JSON.stringify(helper));
                console.log(`🔄 Updated helper with preserved calculation: ${helperKey} = ${field.value}`);
              }
              return; // Skip this field to preserve calculation
            }
            // Load saved value if exists
            field.value = savedValue || '';
          }
          
          // Ensure field exists in helper structure (initialize if missing)
          if (!helper.final_report.summary.hasOwnProperty(helperKey)) {
            helper.final_report.summary[helperKey] = '';
          }
        });
        
        // Save updated helper structure
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Calculate totals based on loaded fields
        setTimeout(() => {
          calculateSummaryTotals();
        }, 100);
        
        
      } catch (error) {
        console.error('❌ Error loading enhanced summary fields:', error);
      }
    }
    
    // CONSOLIDATED FIELD MAPPING - ELIMINATES DUPLICATES
    function getHelperMappingKey(fieldId) {
      const consolidatedMapping = {
        // UNIVERSAL FIELDS - ALL VARIANTS USE SAME KEY
        // Market Value - all variants write to same key
        'sumMarketValue': 'market_value',
        'sumMarketValueGlobal': 'market_value',
        'sumMarketValueDamage': 'market_value', 
        'sumMarketValueTotal': 'market_value',
        'sumMarketValueLegal': 'market_value',
        'sumMarketValuePrivate': 'market_value',
        
        // Total Claim - all variants write to same key
        'sumClaim': 'total_claim',
        'sumClaimPrivate': 'total_claim',
        'sumClaimGlobal': 'total_claim',
        
        // Depreciation Compensation - all variants write to same key
        'depCompensation': 'depreciation_compensation',
        'depCompensationPrivate': 'depreciation_compensation',
        'depCompensationGlobal': 'depreciation_compensation',
        'sumDepreciation': 'depreciation_compensation',
        
        // VARIANT-SPECIFIC FIELDS - UNIQUE VALUES
        // Private Report
        'sumTotalBeforeDifferentials': 'private_before_differentials',
        'sumTotalFinal': 'private_after_differentials',
        
        // Global Report  
        'sumTotalGlobal': 'global_before_differentials',
        // Damaged Sale Report
        'saleValueDamage': 'sale_value_damaged',
        'afterSaleDamage': 'damage_total_before_differentials',
        
        // Total Loss Report
        'salvageValueTotal': 'salvage_value_total_loss',
        'storageValueTotal': 'storage_towing_costs',
        'afterSaleTotal': 'total_loss_before_differentials',
        
        // Legal Loss Report
        'salvageValueLegal': 'salvage_value_legal_loss',
        'afterSaleLegal': 'legal_loss_before_differentials',
        
        // General fields
        'finalReportDateSummary': 'report_date'
      };
      return consolidatedMapping[fieldId] || null;
    }

    // LOAD ADDITIONAL NOTES FIELD
    function loadAdditionalNotesField() {
      try {
        const helper = window.helper || {};
        const additionalNotesField = document.getElementById('additional-notes');
        
        if (additionalNotesField) {
          // Check both 'notes' (from save) and 'comments' (from real-time save)
          const savedNotes = helper.final_report?.notes || helper.final_report?.comments || '';
          
          console.log('🔍 Loading additional notes field:', {
            fieldExists: true,
            notes: helper.final_report?.notes,
            comments: helper.final_report?.comments,
            savedNotes: savedNotes,
            currentValue: additionalNotesField.value
          });
          
          if (savedNotes) {
            additionalNotesField.value = savedNotes;
            console.log('✅ Additional notes loaded successfully:', savedNotes.substring(0, 50) + '...');
          } else {
            console.log('⚠️ No saved notes found in helper');
          }
        } else {
          console.log('❌ Additional notes field not found in DOM');
        }
      } catch (error) {
        console.error('❌ Error loading additional notes:', error);
      }
    }

    // LOAD SUMMARY DATA AND CALCULATIONS - ENHANCED FOR AUTO-POPULATION
    function loadSummaryData(helper) {
      try {
        console.log('📊 Loading summary data with enhanced auto-population');
        
        // FIXED: Set correct final report type (not estimate type) based on selection
        const selectedType = document.querySelector('input[name="final-report-type"]:checked')?.value || 'אובדן_להלכה';
        const reportTypeText = selectedType === 'אובדן_להלכה' ? 'חוות דעת אובדן להלכה' : 'חוות דעת טוטלוסט';
        document.getElementById('reportType').value = reportTypeText;
        
        // ENHANCED AUTO-POPULATION SYSTEM
        
        // 1. Market Value Auto-Population (from mapping analysis)
        const marketValue = helper.calculations?.full_market_value || 0;
        if (marketValue > 0) {
          console.log(`💰 Auto-populating market value: ₪${marketValue.toLocaleString()}`);
          
          // Auto-populate all market value fields using comprehensive mapping
          const marketValueFields = ['sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 'sumMarketValueTotal', 'sumMarketValueLegal'];
          marketValueFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
              field.value = `₪${marketValue.toLocaleString()}`;
              // Update helper using comprehensive mapping
              const mappingKey = getHelperMappingKey(fieldId);
              if (mappingKey) {
                helper.final_report.summary[mappingKey] = field.value;
              }
            }
          });
        }
        
        // 2. Total Claim Auto-Population (from mapping analysis)  
        const totalClaim = helper.claims_data?.total_claim || 0;
        if (totalClaim > 0) {
          console.log(`💰 Auto-populating total claim: ₪${totalClaim.toLocaleString()}`);
          const sumClaimField = document.getElementById('sumClaim');
          if (sumClaimField) {
            sumClaimField.value = `₪${totalClaim.toLocaleString()}`;
            helper.final_report.summary.total_claim = sumClaimField.value;
          }
        }
        
        // 3. Depreciation Compensation Auto-Population (from mapping analysis)
        const depCompensation = helper.depreciation?.globalDepValue || 0;
        if (depCompensation > 0) {
          console.log(`💰 Auto-populating depreciation compensation: ₪${depCompensation.toLocaleString()}`);
          const depCompensationField = document.getElementById('depCompensation');
          if (depCompensationField) {
            depCompensationField.value = `₪${depCompensation.toLocaleString()}`;
            helper.final_report.summary.dep_compensation = depCompensationField.value;
          }
        }
        
        // 4. Adjustments Value Auto-Population (from mapping analysis)
        const adjustmentsValue = helper.calculations?.final_adjustments_value || 0;
        if (adjustmentsValue !== 0) {
          console.log(`💰 Auto-populating adjustments value: ₪${adjustmentsValue.toLocaleString()}`);
          helper.final_report.summary.adjustments_value = adjustmentsValue;
        }
        
        // Load all summary fields using enhanced loader IMMEDIATELY
        loadSummaryFieldsFromHelper(helper);
        
        // Calculate VAT and totals if we have claim data
        if (totalClaim > 0) {
          const vatRate = getVatRate();
          const vat = totalClaim * vatRate;
          
          const vatField = document.getElementById('sumVAT');
          if (vatField) {
            vatField.value = `₪${Math.round(vat).toLocaleString()}`;
          }
          
          const totalWithVAT = totalClaim + vat;
          const totalClaimField = document.getElementById('sumTotalClaim');
          if (totalClaimField) {
            totalClaimField.value = `₪${Math.round(totalWithVAT).toLocaleString()}`;
          }
        }
        
        // Load saved final report notes if available
        // Check both 'notes' (from save) and 'comments' (from real-time save)
        const additionalNotesField = document.getElementById('additional-notes');
        if (additionalNotesField) {
          const savedNotes = helper.final_report?.notes || helper.final_report?.comments || '';
          console.log('🔍 Checking for additional notes:', {
            notes: helper.final_report?.notes,
            comments: helper.final_report?.comments,
            savedNotes: savedNotes
          });
          
          if (savedNotes) {
            additionalNotesField.value = savedNotes;
            console.log('✅ Loaded additional notes from helper:', savedNotes.substring(0, 50) + '...');
          } else {
            console.log('⚠️ No saved notes found in helper');
          }
        } else {
          console.log('❌ Additional notes field not found in DOM');
        }
        
        // Add event listeners for real-time calculations
        addSummaryCalculationListeners();
        
        // TRIGGER INITIAL AUTO-FILL FOR SUMMARY FIELDS
        setTimeout(() => {
          if (window.addSummaryCalculationListeners) {
            const calculateEvent = new Event('input', { bubbles: true });
            
            // Trigger auto-fill from totalClaim to sumClaim
            const totalClaimField = document.getElementById('totalClaim');
            if (totalClaimField && totalClaimField.value) {
              totalClaimField.dispatchEvent(calculateEvent);
            }
            
            // Trigger auto-fill from globalDepValue to depCompensation
            const globalDepField = document.getElementById('globalDepValue');
            if (globalDepField && globalDepField.value) {
              globalDepField.dispatchEvent(calculateEvent);
            }
          }
        }, 200);
        
      } catch (error) {
        console.error('Error loading summary data:', error);
      }
    }

    // ADD CALCULATION LISTENERS FOR SUMMARY WITH MATH.JS - CORRECTED LOGIC
    function addSummaryCalculationListeners() {
      const sumMarketValueInput = document.getElementById('sumMarketValue');
      const sumClaimInput = document.getElementById('sumClaim');
      const depCompensationInput = document.getElementById('depCompensation');
      const sumVATInput = document.getElementById('sumVAT');
      const sumTotalInput = document.getElementById('sumTotalClaim');

      function calculateSummaryTotals() {
        try {
          // Skip auto-fill for private summary - handled by refreshSummary() 
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          const helperMarketValue = helper.calculations?.full_market_value || 0;
          // Don't auto-fill private summary field - let refreshSummary() handle it
          
          // Also auto-fill global variant market value field if it exists
          const sumMarketValueGlobal = document.getElementById('sumMarketValueGlobal');
          if (helperMarketValue && helperMarketValue > 0 && sumMarketValueGlobal) {
            sumMarketValueGlobal.value = `₪${helperMarketValue.toLocaleString()}`;
          }
          
          // AUTO-FILL SUMMARY CLAIM FROM CLAIMS SECTION
          const totalClaimValue = document.getElementById('totalClaim')?.value;
          if (totalClaimValue && sumClaimInput) {
            sumClaimInput.value = totalClaimValue;
          }
          
          // AUTO-FILL DEPRECIATION COMPENSATION FROM GLOBAL DEPRECIATION VALUE
          const globalDepValue = document.getElementById('globalDepValue')?.value;
          if (globalDepValue && depCompensationInput) {
            depCompensationInput.value = globalDepValue;
          }
          
          // Ensure all variant fields are populated
          const updatedHelper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
          loadSummaryFieldsFromHelper(updatedHelper);
          
          // Get values - market price + claim + compensation - salvage = total
          const marketValue = parseFloat(sumMarketValueInput?.value.replace(/[₪,]/g, '') || '0') || 0;
          const claimValue = parseFloat(sumClaimInput?.value.replace(/[₪,]/g, '') || '0') || 0;
          const depValue = parseFloat(depCompensationInput?.value.replace(/[₪,]/g, '') || '0') || 0;
          const salvageValue = parseFloat(document.getElementById('salvageValue')?.value.replace(/[₪,]/g, '') || '0') || 0;
          
          // Calculate subtotal: claim + compensation - salvage value = subtotal (market price is separate)
          const subtotal = claimValue + depValue - salvageValue;
          
          // Automatic calculation with math.js - Calculate VAT (admin rate on subtotal)
          const vatRate = (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100;
          const vat = Math.round(subtotal * vatRate);
          
          // Calculate final total (subtotal + VAT) - automatic calculation with math.js
          const total = subtotal + vat;
          
          // Update readonly fields with formatted values - auto-filled from relevant fields
          if (sumVATInput) {
            sumVATInput.value = vat ? `₪${vat.toLocaleString()}` : '';
            sumVATInput.readOnly = true;
            sumVATInput.style.background = '#f4f6fa';
          }
          
          if (sumTotalInput) {
            sumTotalInput.value = total ? `₪${total.toLocaleString()}` : '';
            sumTotalInput.readOnly = true;
            sumTotalInput.style.background = '#e8f5e8';
          }
          
        } catch (error) {
          console.error('Error in summary calculations:', error);
        }
      }

      // Add listeners to trigger calculations for all relevant fields
      // Disabled - private summary handled by refreshSummary()
      // if (sumMarketValueInput) {
      //   sumMarketValueInput.addEventListener('input', calculateSummaryTotals);
      // }
      if (sumClaimInput) {
        sumClaimInput.addEventListener('input', calculateSummaryTotals);
      }
      if (depCompensationInput) {
        depCompensationInput.addEventListener('input', calculateSummaryTotals);
      }
      
      // Auto-update when car market value changes
      const carMarketValueInput = document.getElementById('carMarketValue');
      if (carMarketValueInput) {
        carMarketValueInput.addEventListener('input', () => {
          calculateSummaryTotals();
          triggerGlobalDepreciationCalc(); // Recalculate global depreciation when market value changes
        });
      }
      
      // Disabled - private summary handled by refreshSummary()
      // Auto-update when summary market value changes
      // if (sumMarketValueInput) {
      //   sumMarketValueInput.addEventListener('input', () => {
      //     calculateSummaryTotals();
      //     triggerGlobalDepreciationCalc(); // Recalculate global depreciation when market value changes
      //   });
      // }
      
      // ADD EVENT LISTENERS FOR SOURCE FIELDS TO AUTO-UPDATE SUMMARY
      const totalClaimInput = document.getElementById('totalClaim');
      if (totalClaimInput) {
        totalClaimInput.addEventListener('input', calculateSummaryTotals);
      }
      
      const globalDepValueInput = document.getElementById('globalDepValue');
      if (globalDepValueInput) {
        globalDepValueInput.addEventListener('input', calculateSummaryTotals);
      }
      
      // ADD EVENT LISTENER FOR SALVAGE VALUE TO TRIGGER RECALCULATION
      const salvageValueInput = document.getElementById('salvageValue');
      if (salvageValueInput) {
        salvageValueInput.addEventListener('input', calculateSummaryTotals);
      }
      
      // ENHANCED MANUAL INPUT FIELD LISTENERS - For All 5 Report Variants
      addManualInputFieldListeners();
      
      // Add listeners for custom additions if they exist
      function addCustomFieldListeners() {
        const customFields = document.querySelectorAll('#sumAdditionsGridFinalReport input');
        customFields.forEach(field => {
          field.addEventListener('input', calculateSummaryTotals);
        });
      }
      
      // Initial calculation and setup
      calculateSummaryTotals();
      addCustomFieldListeners();
      
      // Re-add listeners when custom fields are added
      const originalAddField = window.addCustomSummaryField;
      window.addCustomSummaryField = function(summaryType) {
        originalAddField(summaryType);
        setTimeout(addCustomFieldListeners, 100);
      };
    }

    // LOAD DEPRECIATION DATA
    function loadDepreciationData(helper) {
      try {
        console.log('🔄 Loading depreciation data, helper:', helper);
        console.log('🔍 helper.centers:', helper.centers);
        console.log('🔍 helper.depreciation:', helper.depreciation);
        console.log('🔍 helper.final_report?.depreciation:', helper.final_report?.depreciation);
        
        // ✅ 2-WAY DATA FLOW: Check both locations for depreciation data
        // The save function writes to both helper.depreciation AND helper.final_report.depreciation
        const depreciationData = helper.final_report?.depreciation || helper.depreciation || null;
        
        console.log('📊 Depreciation data found:', depreciationData);
        console.log('📊 Bulk items:', depreciationData?.bulk_items);
        
        if (depreciationData) {
          
          // Load global depreciation fields from helper.depreciation (single source)
          // Format global depreciation with % symbol if numeric
          const globalPercent = depreciationData.globalDep1 || depreciationData.global_percent || '';
          // Keep the value as is - don't add % if it's already there
          document.getElementById('globalDep1').value = globalPercent;
          document.getElementById('globalDepValue').value = depreciationData.globalDepValue || 
                                                           depreciationData.global_value || '';
          document.getElementById('garageDays').value = depreciationData.garageDays || 
                                                       depreciationData.work_days_impact || '';
          
          // Load bulk depreciation table
          if (depreciationData.bulk_items && Array.isArray(depreciationData.bulk_items)) {
            // Check if we need to update the mapping
            let needsUpdate = false;
            
            // If we have damage centers, check if the saved data needs updating
            if (helper.centers && helper.centers.length > 0) {
              // Check if any saved item has old format (center_number is not just a number)
              needsUpdate = depreciationData.bulk_items.some(item => 
                item.center_number && (item.center_number.includes('מוקד') || isNaN(item.center_number))
              );
            }
            
            if (needsUpdate) {
              // Don't regenerate - just load the existing data even if format is old
              console.log('⚠️ Old format detected but preserving existing manual data');
            }
            
            // Always load existing saved data
            if (depreciationData.bulk_items.length > 0) {
              // Load existing data
              const depreciationContainer = document.getElementById('depreciationBulkTable');
              if (depreciationContainer) {
                depreciationContainer.innerHTML = '';
              }
              
              console.log('📋 Loading bulk items:', depreciationData.bulk_items);
              depreciationData.bulk_items.forEach((item, index) => {
                console.log(`  Item ${index + 1}:`, item);
                addDepField(item);
              });
              
              // Add auto-calculation to all existing rows after loading
              setTimeout(() => {
                addAutoCalculationToExistingRows();
              }, 100);
            }
          }
          
        }
        
        // ALWAYS check and auto-populate from damage centers if table is empty
        // BUT ONLY if there's no saved depreciation data
        if (helper.centers && helper.centers.length > 0) {
          const existingRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
          const hasDepreciationData = depreciationData && depreciationData.bulk_items && depreciationData.bulk_items.length > 0;
          
          if (existingRows.length === 0 && !hasDepreciationData) {
            console.log('🔄 Auto-populating depreciation from damage centers (no saved data found)...');
            updateDepreciationFromDamageCenters([]);
          }
        }
      } catch (error) {
        console.error('Error loading depreciation data:', error);
      }
    }

    // LOAD DAMAGE CENTERS SUMMARY - EDITABLE CARDS
    function loadDamageCentersSummary(helper) {
      try {
        const damageCentersContent = document.getElementById('damageCentersContent');
        
        // Load from damage centers helper (primary source) with fallbacks
        // NOTE: Removed damage_assessment.centers - using only helper.centers as source of truth
        const damageCenters = helper.centers || 
                             helper.damage_centers || 
                             helper.expertise?.damage_blocks || [];
        
        if (damageCenters && damageCenters.length > 0) {
          let summaryHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters">';
          
          damageCenters.forEach((center, index) => {
            // Adapt centers data structure to damage block structure for compatibility
            const adaptedCenter = adaptCenterToBlock(center, index);
            summaryHTML += createEditableDamageCenterCard(adaptedCenter, index);
          });
          
          summaryHTML += '</div>';
          damageCentersContent.innerHTML = summaryHTML;
          
          // Add event listeners after HTML is created
          setTimeout(addDamageCenterEventListeners, 100);
          
          // Reposition save button if subtotal exists
          setTimeout(repositionDamageCentersSaveButton, 150);
          
        } else {
          damageCentersContent.innerHTML = '<div style="color: #666; text-align: center;">לא נמצאו נתוני מוקדי נזק - לחץ "הוסף מוקד נזק חדש" כדי להתחיל</div>';
        }
      } catch (error) {
        console.error('Error loading damage centers summary:', error);
        document.getElementById('damageCentersContent').innerHTML = '<div style="color: #dc3545; text-align: center;">שגיאה בטעינת נתוני מוקדי נזק</div>';
      }
    }

    // Adapt centers data structure to damage block structure for compatibility
    function adaptCenterToBlock(center, index) {
      
      // Centers structure (from wizard) vs damage_blocks structure (from expertise)
      const adaptedBlock = {
        damage_center_name: center.Location || center.damage_center_name || `מוקד נזק ${index + 1}`,
        // Extract just the number if it contains the full text
        damage_center_number: (() => {
          const num = center["Damage center Number"] || center.damage_center_number || (index + 1);
          // If it's a string that contains "מוקד נזק מס'", extract just the number
          if (typeof num === 'string' && num.includes('מוקד')) {
            const match = num.match(/\d+$/);
            return match ? match[0] : String(index + 1);
          }
          return num;
        })(),
        description: center.Description || center.description || '',
        // CORRECT MAPPING: RepairNature data from helper.centers
        RepairNature: center.RepairNature || center.repair_nature || '',
        // CORRECT MAPPING: Works data structure from helper.centers
        works: center.Works?.works || center.works || [],
        // CORRECT MAPPING: Parts data is in center.Parts.parts_required for helper.centers
        parts: center.Parts?.parts_required || center.Parts?.parts || center.parts_required || center.parts || center.Parts || [],
        // CORRECT MAPPING: Repairs data structure from helper.centers
        repairs: center.Repairs?.repairs || center.repairs || [],
        works_meta: center.Works?.works_meta || center.works_meta || { total_cost: 0 },
        parts_meta: center.Parts?.parts_meta || center.parts_meta || { total_cost: 0 },
        repairs_meta: center.Repairs?.repairs_meta || center.repairs_meta || { total_cost: 0 },
        total_cost: center.Summary?.["Total with VAT"] || center.total_cost || 0
      };
      
      // Additional normalization for different data structures
      if (Array.isArray(center.Works) && adaptedBlock.works.length === 0) {
        adaptedBlock.works = center.Works;
      }
      if (Array.isArray(center.Parts) && adaptedBlock.parts.length === 0) {
        adaptedBlock.parts = center.Parts;
      }
      if (Array.isArray(center.Repairs) && adaptedBlock.repairs.length === 0) {
        adaptedBlock.repairs = center.Repairs;
      }
      
      console.log(`✅ Adapted block ${index}:`, adaptedBlock);
      console.log(`📋 Parts found: ${adaptedBlock.parts.length}, Works found: ${adaptedBlock.works.length}`);
      
      return adaptedBlock;
    }

    // CREATE EDITABLE DAMAGE CENTER CARD
    function createEditableDamageCenterCard(block, index) {
      
      const centerNum = block.damage_center_number || (index + 1);
      const centerLocation = block.damage_center_name || block.Location || `מוקד נזק ${centerNum}`;
      const workCosts = block.work_cost || 0;
      const partsCosts = block.parts_cost || 0;
      const repairsCosts = workCosts + partsCosts;
      const totalWithVAT = repairsCosts * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100);
      
      // Get existing parts, works, repairs from block
      const parts = block.parts || [];
      const works = block.works || [];
      const repairs = block.repairs || [];
      
      console.log(`🔧 Card ${index} data - Parts: ${parts.length}, Works: ${works.length}, Repairs: ${repairs.length}`);
      console.log(`📋 Parts content:`, parts);
      console.log(`🔨 Works content:`, works);
      
      return `
        <div class="editable-damage-card" data-center-index="${index}" style="background: white; border-radius: 8px; padding: 15px; border: 1px solid #e2e8f0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <!-- Card Header -->
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="font-weight: bold; color: #1e3a8a; font-size: 16px;">מוקד נזק מס'</span>
              <input type="text" value="${centerNum}" class="damage-center-number" style="font-weight: bold; color: #1e3a8a; font-size: 16px; border: 1px solid #ddd; padding: 8px; border-radius: 4px; width: 50px; text-align: center;" />
            </div>
            <button onclick="removeDamageCenter(${index})" style="background: #dc3545; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">מחק</button>
          </div>
          
          <!-- Damage Center Location Field -->
          <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #1e3a8a;">שם מוקד הנזק:</label>
            <input type="text" class="damage-center-location" style="width: 100%; border: 1px solid #ddd; padding: 8px; border-radius: 4px; font-size: 14px;" placeholder="הזן שם/איזור מוקד הנזק (לדוגמה: פגוש קדמי, דלת נהג, וכו')" value="${centerLocation}" />
          </div>
          
          <!-- Damage Description Field -->
          <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #1e3a8a;">תיאור הנזק:</label>
            <textarea class="damage-center-description" style="width: 100%; min-height: 60px; border: 1px solid #ddd; padding: 8px; border-radius: 4px; font-size: 14px; font-family: inherit; resize: vertical;" placeholder="הזן תיאור מפורט של הנזק במוקד זה...">${block.description || ''}</textarea>
          </div>

          <!-- RepairNature Field -->
          <div style="margin-bottom: 15px;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #1e3a8a;">מהות התיקון:</label>
            <input class="damage-center-repair-nature" style="width: 100%; border: 1px solid #ddd; padding: 8px; border-radius: 4px; font-size: 14px;" placeholder="הזן את מהות התיקון..." value="${block.RepairNature || block.repair_nature || ''}" />
          </div>

          <!-- Parts Section (Full Width Row) -->
          <div style="border: 1px solid #e2e8f0; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
            <h4 style="margin: 0 0 10px 0; color: #1e3a8a;">חלקים נדרשים:</h4>
            <div class="parts-list" data-center="${index}">
              ${parts.map((part, partIndex) => createEditablePartRow(part, index, partIndex)).join('')}
            </div>
            <button onclick="addPartRow(${index})" class="btn" style="background: #28a745; color: white; padding: 6px 12px; margin-top: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">הוסף חלק</button>
          </div>

          <!-- Works Section (Full Width Row) -->
          <div style="border: 1px solid #e2e8f0; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
            <h4 style="margin: 0 0 10px 0; color: #1e3a8a;">עבודות נדרשות:</h4>
            <div class="works-list" data-center="${index}">
              ${works.map((work, workIndex) => createEditableWorkRow(work, index, workIndex)).join('')}
            </div>
            <button onclick="addWorkRow(${index})" class="btn" style="background: #17a2b8; color: white; padding: 6px 12px; margin-top: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">הוסף עבודה</button>
          </div>

          <!-- Repairs Section (Full Width Row) -->
          <div style="border: 1px solid #e2e8f0; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
            <h4 style="margin: 0 0 10px 0; color: #1e3a8a;">תיקונים נדרשים:</h4>
            <div class="repairs-list" data-center="${index}">
              ${repairs.map((repair, repairIndex) => createEditableRepairRow(repair, index, repairIndex)).join('')}
            </div>
            <button onclick="addRepairRow(${index})" class="btn" style="background: #ffc107; color: #212529; padding: 6px 12px; margin-top: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">הוסף תיקון</button>
          </div>

          <!-- Cost Summary (Auto-calculated) -->
          <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; border: 1px solid #e2e8f0;">
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; font-size: 14px;">
              <div><strong>עבודות:</strong> <span class="work-costs-display">₪${workCosts.toLocaleString()}</span></div>
              <div><strong>חלפים:</strong> <span class="parts-costs-display">₪${partsCosts.toLocaleString()}</span></div>
              <div><strong>תיקונים:</strong> <span class="repairs-costs-display">₪${repairsCosts.toLocaleString()}</span></div>
              <div><strong>כולל מע"מ:</strong> <span class="total-with-vat-display">₪${Math.round(totalWithVAT).toLocaleString()}</span></div>
            </div>
          </div>
        </div>
      `;
    }

    // CREATE EDITABLE PART ROW WITH SEARCH DROPDOWN
    function createEditablePartRow(part, centerIndex, partIndex) {
      const partName = part?.name || '';
      const partDesc = part?.desc || part?.description || part?.תיאור || '';
      const partPrice = part?.price || 0;
      const partSource = part?.source || part?.מקור || '';
      
      return `
        <div class="part-row" data-center="${centerIndex}" data-part="${partIndex}" style="display: grid; grid-template-columns: 2fr 2fr 1fr auto; gap: 8px; margin-bottom: 8px; padding: 8px; background: #f9f9f9; border-radius: 4px;">
          <div style="position: relative;">
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">שם החלק:</label>
            <input type="text" value="${partName}" placeholder="שם החלק" class="part-name" 
                   style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"
                   onkeyup="showPartSuggestions(this, ${centerIndex}, ${partIndex})" />
            <div class="part-suggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ddd; border-top: none; border-radius: 0 0 4px 4px; display: none; z-index: 1000; max-height: 200px; overflow-y: auto;"></div>
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">תיאור:</label>
            <input type="text" value="${partDesc}" placeholder="תיאור החלק" class="part-desc" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">עלות (₪):</label>
            <input type="number" value="${partPrice}" placeholder="0" class="part-price" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" min="0" step="0.01" />
          </div>
          <button onclick="removePartRow(${centerIndex}, ${partIndex})" style="background: #dc3545; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; align-self: end;">מחק</button>
          <input type="hidden" value="${partSource}" class="part-source" />
        </div>
      `;
    }

    // CREATE EDITABLE WORK ROW WITH DROPDOWN
    function createEditableWorkRow(work, centerIndex, workIndex) {
      const workTypes = [
        'כל עבודות הפחחות כולל פירוקים והרכבות','עבודות צבע', 'עבודות חשמל', 'עבודות מכונאות', 
        'עבודות מזגן', 'עבודות ריפוד', 'עבודות זגגות',
        'איטום וזיפות', 'בדיקת מתלה', 'הנזק מחייב תקנה 309',
        'כיול רדאר', 'העברת חיישנים', 'אחר'
      ];
      
      const workType = typeof work === 'object' ? (work.category || work.type) : work;
      const workNote = typeof work === 'object' ? (work.comments || work.note || '') : '';
      const workCost = typeof work === 'object' ? work.cost : 0;
      
      return `
        <div class="work-row" data-center="${centerIndex}" data-work="${workIndex}" style="display: grid; grid-template-columns: 2fr 2fr 1fr auto; gap: 8px; margin-bottom: 8px; padding: 8px; background: #f9f9f9; border-radius: 4px;">
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">סוג עבודה:</label>
            <select class="work-type" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" onchange="handleWorkTypeChange(this, ${centerIndex}, ${workIndex})">
              ${workTypes.map(type => `<option value="${type}" ${type === workType ? 'selected' : ''}>${type}</option>`).join('')}
            </select>
            <input type="text" class="work-type-other" placeholder="הכנס סוג עבודה אחר" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; margin-top: 4px; display: ${workType === 'אחר' ? 'block' : 'none'};" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">הערות:</label>
            <input type="text" value="${workNote}" placeholder="הערות נוספות" class="work-note" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">עלות (₪):</label>
            <input type="number" value="${workCost}" placeholder="0" class="work-cost" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" min="0" step="0.01" />
          </div>
          <button onclick="removeWorkRow(${centerIndex}, ${workIndex})" style="background: #dc3545; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; align-self: end;">מחק</button>
        </div>
      `;
    }

    // CREATE EDITABLE REPAIR ROW
    function createEditableRepairRow(repair, centerIndex, repairIndex) {
      const repairText = typeof repair === 'object' ? repair.description : repair;
      const repairCost = typeof repair === 'object' ? repair.cost : 0;
      const repairName = typeof repair === 'object' ? repair.name || '' : '';
      const repairHours = typeof repair === 'object' ? repair.hours || 0 : 0;
      
      return `
        <div class="repair-row" data-center="${centerIndex}" data-repair="${repairIndex}" style="display: grid; grid-template-columns: 1.5fr 2fr 0.8fr 1fr auto; gap: 8px; margin-bottom: 8px; padding: 8px; background: #f9f9f9; border-radius: 4px;">
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">שם התיקון:</label>
            <input type="text" value="${repairName}" placeholder="שם התיקון" class="repair-name" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">תיאור התיקון:</label>
            <textarea placeholder="תיאור התיקון" class="repair-text" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; font-family: inherit; min-height: 60px; resize: vertical;">${repairText}</textarea>
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">שעות:</label>
            <input type="number" value="${repairHours}" placeholder="0" class="repair-hours" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" min="0" step="0.1" />
          </div>
          <div>
            <label style="font-size: 12px; color: #666; margin-bottom: 2px; display: block;">עלות (₪):</label>
            <input type="number" value="${repairCost}" placeholder="0" class="repair-cost" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;" min="0" step="0.01" />
          </div>
          <button onclick="removeRepairRow(${centerIndex}, ${repairIndex})" style="background: #dc3545; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; height: 32px; margin-top: 14px;">מחק</button>
        </div>
      `;
    }

    // LOAD LEVI ADJUSTMENTS
    // UNIFIED ADJUSTMENTS SYSTEM - Combines Levi adjustments and custom additions
    // Debounce mechanism to prevent duplicate loading
    let loadAdjustmentsTimeout;
    
    // CRITICAL FIX: Function to clean up duplicate data in helper
    function cleanupHelperDuplicates(helper) {
      try {
        // Clean up levi_report adjustments
        if (helper.levi_report?.adjustments) {
          const seenAdjustments = new Set();
          const cleanedAdjustments = [];
          
          helper.levi_report.adjustments.forEach(adj => {
            const key = `${adj.description}-${adj.value}-${adj.percent}`;
            if (!seenAdjustments.has(key)) {
              seenAdjustments.add(key);
              cleanedAdjustments.push(adj);
            }
          });
          
          const removedCount = helper.levi_report.adjustments.length - cleanedAdjustments.length;
          if (removedCount > 0) {
            console.log(`🧹 Removed ${removedCount} duplicate levi_report adjustments`);
          }
          
          helper.levi_report.adjustments = cleanedAdjustments;
        }
        
        // Clean up custom adjustments
        if (helper.levi?.custom_adjustments) {
          const seenCustom = new Set();
          const cleanedCustom = [];
          
          helper.levi.custom_adjustments.forEach(adj => {
            const key = `${adj.description}-${adj.value}-${adj.percentage}`;
            if (!seenCustom.has(key)) {
              seenCustom.add(key);
              cleanedCustom.push(adj);
            }
          });
          
          const removedCustomCount = helper.levi.custom_adjustments.length - cleanedCustom.length;
          if (removedCustomCount > 0) {
            console.log(`🧹 Removed ${removedCustomCount} duplicate custom adjustments`);
          }
          
          helper.levi.custom_adjustments = cleanedCustom;
        }
        
        return helper;
      } catch (error) {
        console.error('Error cleaning helper duplicates:', error);
        return helper;
      }
    }
    
    function loadAllAdjustments(helper) {
      try {
        // Get caller information for debugging
        const caller = new Error().stack.split('\n')[2].trim();
        console.log('🔄 loadAllAdjustments called (will be debounced) from:', caller);
        
        // Clear any existing timeout to prevent duplicate calls
        if (loadAdjustmentsTimeout) {
          clearTimeout(loadAdjustmentsTimeout);
          console.log('⚠️ Cleared previous loadAllAdjustments timeout');
        }
        
        // Debounce the loading to prevent rapid multiple calls
        // loadAdjustmentsTimeout = setTimeout(() => {
        //   loadAllAdjustmentsImmediate(helper);
        // }, 100);
        console.log('⚠️ loadAllAdjustmentsImmediate disabled - adjustments container was removed');
        
      } catch (error) {
        console.error('Error in loadAllAdjustments debounce:', error);
      }
    }
    
    function loadAllAdjustmentsImmediate(helper) {
      try {
        console.log('🔄 Loading all adjustments (immediate)');
        // Note: Final report adjustments section was removed - skipping that part
        
        // CRITICAL FIX: Clean up duplicate data in helper before loading
        helper = cleanupHelperDuplicates(helper);
        
        // Save the cleaned helper back to sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        console.log('🧹 Helper cleaned up and saved, proceeding with load...');
        
        // AGGRESSIVE FIX: Clear the container completely and verify it's empty
        adjustmentsContainer.innerHTML = '';
        
        // Force a DOM update to ensure the container is truly empty
        adjustmentsContainer.offsetHeight; // Force reflow
        
        console.log('🧹 Container cleared, current children count:', adjustmentsContainer.children.length);
        
        let adjustmentsHTML = '';
        
        // 1. Load Levi adjustments (read-only from Levi report)
        if (helper.levi_report?.adjustments && helper.levi_report.adjustments.length > 0) {
          console.log('📄 Loading Levi adjustments:', helper.levi_report.adjustments);
          console.log('📄 Levi adjustments count:', helper.levi_report.adjustments.length);
          helper.levi_report.adjustments.forEach((adjustment, index) => {
            console.log(`📄 Processing Levi adjustment ${index}:`, adjustment);
            adjustmentsHTML += createAdjustmentRow({
              description: adjustment.description || 'התאמה מלוי יצחק',
              percentage: adjustment.percentage || adjustment.percent || 0,
              value: adjustment.value || 0,
              source: 'levi',
              index: index,
              readonly: false
            });
          });
        } else {
          console.log('📄 No Levi adjustments found in helper.levi_report.adjustments');
        }
        
        // 2. Load custom adjustments (editable, stored in helper.levi.custom_adjustments)
        if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments.length > 0) {
          console.log('📄 Loading custom adjustments:', helper.levi.custom_adjustments);
          console.log('📄 Custom adjustments count:', helper.levi.custom_adjustments.length);
          helper.levi.custom_adjustments.forEach((adjustment, index) => {
            console.log(`📄 Processing custom adjustment ${index}:`, adjustment);
            adjustmentsHTML += createAdjustmentRow({
              description: adjustment.description || 'התאמה מותאמת אישית',
              percentage: adjustment.percentage || 0,
              value: adjustment.value || 0,
              source: 'custom',
              index: index,
              readonly: false,
              adjustmentType: adjustment.adjustmentType || 'addition'
            });
          });
        } else {
          console.log('📄 No custom adjustments found in helper.levi.custom_adjustments');
        }
        
        if (!adjustmentsHTML) {
          adjustmentsHTML = '<div style="color: #666; text-align: center; padding: 10px; font-size: 13px;">לא נמצאו התאמות - השתמש בכפתור "הוסף התאמה נוספת"</div>';
        }
        
        adjustmentsContainer.innerHTML = adjustmentsHTML;
        
        // Add event listeners for all adjustments
        setTimeout(() => {
          addAdjustmentEventListeners();
          
          // Trigger initial auto-calculation for existing custom adjustments
          if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments.length > 0) {
            console.log('🔄 Triggering initial calculation for existing adjustments');
            helper.levi.custom_adjustments.forEach((adjustment, index) => {
              if (adjustment.percentage && adjustment.percentage !== 0) {
                console.log(`🚀 Initial calculation for adjustment ${index}: ${adjustment.percentage}%`);
                calculateAdjustmentValue('custom', index, adjustment.percentage);
              }
            });
          }
        }, 300);
        
      } catch (error) {
        console.error('Error loading all adjustments:', error);
        // Note: allAdjustmentsRows-final-report container was removed
      }
      
      // Removed: Loading adjustments from helper.final_report.adjustments
      // Now using valuation.adjustments for all adjustment data flow
      if (false) { // Disabled - keeping code for reference
        console.log('📋 Loading saved adjustments from Helper:', helper.final_report.adjustments);
        
        // Clear existing rows to prevent duplication
        // REMOVED: Wrong loading from final_report.adjustments
        // The correct loading is done by loadGrossAdjustments(helper) which reads from estimate.adjustments
        
      }
      
      // Load saved legal text from final_report
      if (helper.final_report?.legal_text) {
        const legalTextElement = document.getElementById('legal-text-content');
        if (legalTextElement) {
          legalTextElement.value = helper.final_report.legal_text;
        }
      }
      
      // Attachments are now loaded by dedicated loadAttachmentsData() function
    }
    
    // Create unified adjustment row HTML
    function createAdjustmentRow(params) {
      const { description, percentage, value, source, index, readonly, adjustmentType } = params;
      const rowId = `adjustment-${source}-${index}`;
      
      // Determine type and colors
      let typeLabel, typeColor;
      if (source === 'levi') {
        typeLabel = 'לוי יצחק';
        typeColor = '#007bff';
      } else {
        // For custom adjustments, use the explicit type or infer from values
        const currentType = adjustmentType || (percentage < 0 || value < 0 ? 'subtraction' : 'addition');
        typeLabel = currentType === 'addition' ? 'תוספת' : 'הפחתה';
        typeColor = currentType === 'addition' ? '#28a745' : '#dc3545';
      }
      
      if (readonly) {
        // Read-only Levi adjustments (5-column layout)
        return `
          <div class="adjustment-row" id="${rowId}" style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr auto; gap: 8px; padding: 8px; border-bottom: 1px solid #e9ecef; background: #f8f9fa;">
            <div style="font-size: 13px;">
              <span style="background: ${typeColor}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 8px;">${typeLabel}</span>
              ${description}
            </div>
            <div style="font-size: 13px; text-align: center; color: ${typeColor}; font-weight: bold;">${typeLabel}</div>
            <div style="font-size: 13px; text-align: center;">${percentage}%</div>
            <div style="font-size: 13px; text-align: center;">₪${value.toLocaleString()}</div>
            <div style="font-size: 11px; color: #666;">קריאה בלבד</div>
          </div>
        `;
      } else {
        // Editable custom adjustments with type dropdown (5-column layout)
        const currentAdjustmentType = adjustmentType || 'addition';
        return `
          <div class="adjustment-row" id="${rowId}" style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr auto; gap: 8px; padding: 8px; border-bottom: 1px solid #e9ecef;" data-source="${source}" data-loaded-from-helper="true">
            <input type="text" value="${description}" data-field="description" data-source="${source}" data-index="${index}" 
                   style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px;" 
                   placeholder="תיאור ההתאמה" />
            <select data-field="adjustmentType" data-source="${source}" data-index="${index}"
                    style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px; background: white;">
              <option value="addition" ${currentAdjustmentType === 'addition' ? 'selected' : ''} style="color: #28a745;">תוספת</option>
              <option value="subtraction" ${currentAdjustmentType === 'subtraction' ? 'selected' : ''} style="color: #dc3545;">הפחתה</option>
            </select>
            <input type="number" value="${Math.abs(percentage)}" data-field="percentage" data-source="${source}" data-index="${index}"
                   style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px; text-align: center;" 
                   placeholder="0" step="0.1" min="0" />
            <input type="number" value="${Math.abs(value)}" data-field="value" data-source="${source}" data-index="${index}"
                   style="font-size: 13px; border: 1px solid #ddd; padding: 4px; border-radius: 3px; text-align: center; background: #f8f9fa;" 
                   placeholder="אוטומטי" step="100" min="0" readonly title="מחושב אוטומטית: אחוז × מחיר בסיס" />
            <button type="button" onclick="removeCustomAdjustment('${source}', ${index})" 
                    style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">מחק</button>
          </div>
        `;
      }
    }

    // ADD CUSTOM ADJUSTMENT FIELD - Unified system
    function addCustomAdjustmentField() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Initialize custom adjustments array if it doesn't exist
      if (!helper.levi) helper.levi = {};
      if (!helper.levi.custom_adjustments) helper.levi.custom_adjustments = [];
      
      // Add new empty adjustment with default type
      const newAdjustment = {
        description: '',
        percentage: 0,
        value: 0,
        adjustmentType: 'addition'
      };
      
      helper.levi.custom_adjustments.push(newAdjustment);
      
      // Save to sessionStorage
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Reload all adjustments to show the new one
      loadAllAdjustments(helper);
      
      console.log('Added new custom adjustment, total custom adjustments:', helper.levi.custom_adjustments.length);
      
      // Ensure event listeners are attached to the new row
      const newIndex = helper.levi.custom_adjustments.length - 1;
      setTimeout(() => {
        console.log('🆕 Setting up new adjustment row with event listeners');
        addAdjustmentEventListeners();
        
        // Focus on the new row's description field
        const newDescriptionInput = document.querySelector(`input[data-field="description"][data-source="custom"][data-index="${newIndex}"]`);
        if (newDescriptionInput) {
          newDescriptionInput.focus();
        }
        
        // Trigger initial calculation if it has a percentage
        const newAdjustment = helper.levi.custom_adjustments[newIndex];
        if (newAdjustment && newAdjustment.percentage !== 0) {
          calculateAdjustmentValue('custom', newIndex, newAdjustment.percentage);
        }
      }, 150);
    }
    
    // REMOVE CUSTOM ADJUSTMENT
    function removeCustomAdjustment(source, index) {
      if (source !== 'custom') return; // Only allow removing custom adjustments
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments[index]) {
        helper.levi.custom_adjustments.splice(index, 1);
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Reload all adjustments
        loadAllAdjustments(helper);
        
        // Re-attach event listeners after removal
        setTimeout(() => {
          addAdjustmentEventListeners();
        }, 100);
        
        console.log('Removed custom adjustment at index:', index);
      }
    }
    
    // ADD EVENT LISTENERS FOR ADJUSTMENT FIELDS
    function addAdjustmentEventListeners() {
      // Remove existing event listeners to prevent duplicates
      // Final report container removed - will return empty NodeList
      const existingInputs = document.querySelectorAll('#allAdjustmentsRows-final-report input[data-source], #allAdjustmentsRows-final-report select[data-source]');
      existingInputs.forEach(element => {
        // Clone element to remove all event listeners
        const newElement = element.cloneNode(true);
        element.parentNode.replaceChild(newElement, element);
      });
      
      // Add fresh event listeners to all adjustment inputs (both custom and levi)
      // Final report container removed - will return empty NodeList  
      const adjustmentInputs = document.querySelectorAll('#allAdjustmentsRows-final-report input[data-source], #allAdjustmentsRows-final-report select[data-source]');
      
      console.log(`🔗 Adding event listeners to ${adjustmentInputs.length} adjustment inputs`);
      
      adjustmentInputs.forEach(element => {
        // Input event for real-time updates
        element.addEventListener('input', function() {
          const source = this.dataset.source;
          const index = parseInt(this.dataset.index);
          const field = this.dataset.field;
          
          console.log(`📝 Input changed: ${field} for ${source}[${index}] = ${this.value}`);
          
          let value;
          if (field === 'description') {
            value = this.value;
          } else if (field === 'adjustmentType') {
            value = this.value;
          } else {
            value = parseFloat(this.value) || 0;
          }
          
          // Update helper based on source type
          if (source === 'custom') {
            updateCustomAdjustmentInHelper(source, index, field, value);
          } else if (source === 'levi') {
            updateLeviAdjustmentInHelper(source, index, field, value);
          }
          
          // Auto-calculate value when percentage changes
          if (field === 'percentage') {
            console.log(`🔢 Triggering auto-calculation for percentage: ${value}%`);
            calculateAdjustmentValue(source, index, value);
          }
          
          // Debug: Check if helper is updated
          const currentHelper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          console.log(`🔍 DEBUG: Helper after adjustment update:`, currentHelper.levi?.custom_adjustments);
          console.log(`🔍 DEBUG: Helper expertise.levi_report:`, currentHelper.expertise?.levi_report);
          
          // Trigger floating screen refresh when adjustments change
          triggerFloatingScreenRefresh();
        });
        
        // Change event for final updates
        element.addEventListener('change', function() {
          // Trigger calculation update on change
          calculateSummaryTotals();
          
          // Trigger floating screen refresh when adjustments change
          triggerFloatingScreenRefresh();
          
          // If adjustment type changed, reload to update display
          if (this.dataset.field === 'adjustmentType') {
            // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
            setTimeout(() => loadAllAdjustments(helper), 50);
          }
        });
        
        // For percentage fields, trigger auto-calculation on focus out
        if (element.dataset.field === 'percentage') {
          element.addEventListener('blur', function() {
            const value = parseFloat(this.value) || 0;
            if (value !== 0) {
              console.log(`🎯 Blur event: Recalculating for percentage ${value}%`);
              calculateAdjustmentValue(this.dataset.source, parseInt(this.dataset.index), value);
            }
          });
        }
      });
    }
    
    // AUTO-CALCULATE ADJUSTMENT VALUE FROM PERCENTAGE
    function calculateAdjustmentValue(source, index, percentage) {
      // Get base price from car details
      const basePrice = getBasePriceForCalculation();
      
      if (basePrice > 0 && percentage !== 0) {
        const calculatedValue = Math.round((basePrice * Math.abs(percentage)) / 100);
        
        console.log(`Auto-calculating adjustment value: ${percentage}% × ₪${basePrice.toLocaleString()} = ₪${calculatedValue.toLocaleString()}`);
        
        // Update the value field in DOM
        const valueInput = document.querySelector(`input[data-field="value"][data-source="${source}"][data-index="${index}"]`);
        if (valueInput) {
          valueInput.value = calculatedValue;
        }
        
        // Update helper with calculated value (works for both custom and levi)
        if (source === 'custom') {
          updateCustomAdjustmentInHelper(source, index, 'value', calculatedValue);
        } else if (source === 'levi') {
          updateLeviAdjustmentInHelper(source, index, 'value', calculatedValue);
        }
      }
    }
    
    // UPDATE LEVI ADJUSTMENT IN HELPER
    function updateLeviAdjustmentInHelper(source, index, field, value) {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Ensure Levi report structure exists
        if (!helper.levi_report) helper.levi_report = {};
        if (!helper.levi_report.adjustments) helper.levi_report.adjustments = [];
        
        // Update the specific adjustment
        if (helper.levi_report.adjustments[index]) {
          helper.levi_report.adjustments[index][field] = value;
          
          // Save back to helper
          sessionStorage.setItem('helper', JSON.stringify(helper));
          console.log(`✅ Updated Levi adjustment ${index}.${field} = ${value}`);
        }
      } catch (error) {
        console.error('Error updating Levi adjustment in helper:', error);
      }
    }
    
    // GET BASE PRICE FOR CALCULATION
    function getBasePriceForCalculation() {
      // Try multiple sources for base price
      let basePrice = 0;
      
      // Priority 1: Car base price field
      const carBasePriceField = document.getElementById('carBasePrice');
      if (carBasePriceField && carBasePriceField.value) {
        const carBasePriceStr = carBasePriceField.value.replace(/[₪,]/g, '') || '0';
        basePrice = parseFloat(carBasePriceStr) || 0;
      }
      
      // Priority 2: Helper data
      if (basePrice === 0) {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        basePrice = helper?.vehicle_value_base || 
                   helper?.car_details?.base_price || 
                   helper?.levi?.base_price || 
                   helper?.levi_report?.base_price || 0;
      }
      
      return basePrice;
    }
    
    // RECALCULATE ALL ADJUSTMENT VALUES (when base price changes)
    function recalculateAllAdjustmentValues() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments.length > 0) {
        console.log('🔄 Recalculating all adjustment values due to base price change');
        
        helper.levi.custom_adjustments.forEach((adjustment, index) => {
          if (adjustment.percentage && adjustment.percentage !== 0) {
            calculateAdjustmentValue('custom', index, adjustment.percentage);
          }
        });
      }
    }
    
    // UPDATE CUSTOM ADJUSTMENT IN HELPER
    function updateCustomAdjustmentInHelper(source, index, field, value) {
      if (source !== 'custom') return;
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments[index]) {
        const adjustment = helper.levi.custom_adjustments[index];
        
        // Update the field
        adjustment[field] = value;
        
        // Apply proper signs based on adjustment type when updating numeric fields
        if (field === 'percentage' || field === 'value') {
          const adjustmentType = adjustment.adjustmentType || 'addition';
          const absoluteValue = Math.abs(value);
          
          if (adjustmentType === 'subtraction') {
            adjustment[field] = -absoluteValue;
          } else {
            adjustment[field] = absoluteValue;
          }
        }
        
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log(`Updated custom adjustment ${index}.${field} to:`, adjustment[field]);
        console.log('Full adjustment object:', adjustment);
        
        // Update the structured Levi data for floating screen compatibility
        updateLeviDataStructure(helper);
        
        // Helper is already updated above with sessionStorage.setItem
        console.log('✅ Helper updated with adjustment data');
      }
    }
    
    // UPDATE LEVI DATA STRUCTURE FOR FLOATING SCREEN COMPATIBILITY
    function updateLeviDataStructure(helper) {
      try {
        // Ensure expertise.levi_report exists
        if (!helper.expertise) helper.expertise = {};
        if (!helper.expertise.levi_report) helper.expertise.levi_report = {};
        
        // Map basic vehicle info from other helper sections
        if (helper.car_details) {
          helper.expertise.levi_report.manufacturer = helper.car_details.manufacturer || helper.vehicle?.manufacturer;
          helper.expertise.levi_report.year = helper.car_details.year || helper.vehicle?.year;
          helper.expertise.levi_report.base_price = helper.car_details.base_price;
          helper.expertise.levi_report.final_price = helper.car_details.market_value;
          helper.expertise.levi_report.vehicle_type = helper.vehicle?.vehicle_type || '';
          helper.expertise.levi_report.model_code = helper.vehicle?.model_code || '';
          helper.expertise.levi_report.category = helper.vehicle?.category || '';
          helper.expertise.levi_report.full_model = helper.vehicle?.model || helper.car_details.model;
        }
        
        // Process custom adjustments into the structure expected by Levi floating screen
        if (helper.levi?.custom_adjustments) {
          // Initialize all adjustment fields to ensure they exist
          helper.expertise.levi_report.registration = '';
          helper.expertise.levi_report.registration_percent = '';
          helper.expertise.levi_report.registration_value = '';
          helper.expertise.levi_report.registration_total = '';
          helper.expertise.levi_report.ownership = '';
          helper.expertise.levi_report.ownership_percent = '';
          helper.expertise.levi_report.ownership_value = '';
          helper.expertise.levi_report.ownership_total = '';
          helper.expertise.levi_report.km = '';
          helper.expertise.levi_report.km_percent = '';
          helper.expertise.levi_report.km_value = '';
          helper.expertise.levi_report.km_total = '';
          helper.expertise.levi_report.owners = '';
          helper.expertise.levi_report.owners_percent = '';
          helper.expertise.levi_report.owners_value = '';
          helper.expertise.levi_report.owners_total = '';
          helper.expertise.levi_report.features = '';
          helper.expertise.levi_report.features_percent = '';
          helper.expertise.levi_report.features_value = '';
          helper.expertise.levi_report.features_total = '';
          
          helper.levi.custom_adjustments.forEach((adjustment, index) => {
            const desc = adjustment.description ? adjustment.description.toLowerCase() : '';
            
            console.log(`🔍 Mapping adjustment ${index}: "${adjustment.description}" (${adjustment.percentage}%, ₪${adjustment.value})`);
            
            // Map based on description keywords ONLY (check specific terms first to avoid conflicts)
            if (desc.includes('עליה לכביש') || desc.includes('registration') || desc.includes('רישוי')) {
              helper.expertise.levi_report.registration = adjustment.description || 'עליה לכביש';
              helper.expertise.levi_report.registration_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.registration_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.registration_total = Math.abs(adjustment.value || 0);
              console.log(`✅ Mapped to registration: ${adjustment.description}`);
            } else if (desc.includes('מספר בעלים') || desc.includes('owners')) {
              helper.expertise.levi_report.owners = adjustment.description || 'מספר בעלים';
              helper.expertise.levi_report.owners_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.owners_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.owners_total = Math.abs(adjustment.value || 0);
              console.log(`✅ Mapped to owners: ${adjustment.description}`);
            } else if (desc.includes('בעלות') || desc.includes('ownership')) {
              helper.expertise.levi_report.ownership = adjustment.description || 'בעלות';
              helper.expertise.levi_report.ownership_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.ownership_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.ownership_total = Math.abs(adjustment.value || 0);
              console.log(`✅ Mapped to ownership: ${adjustment.description}`);
            } else if (desc.includes('ק״מ') || desc.includes('km') || desc.includes('קילומטרים')) {
              helper.expertise.levi_report.km = adjustment.description || 'מס ק״מ';
              helper.expertise.levi_report.km_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.km_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.km_total = Math.abs(adjustment.value || 0);
              console.log(`✅ Mapped to km: ${adjustment.description}`);
            } else if (desc.includes('מאפיינים') || desc.includes('features')) {
              helper.expertise.levi_report.features = adjustment.description || 'מאפיינים';
              helper.expertise.levi_report.features_percent = Math.abs(adjustment.percentage || 0);
              helper.expertise.levi_report.features_value = Math.abs(adjustment.value || 0);
              helper.expertise.levi_report.features_total = Math.abs(adjustment.value || 0);
              console.log(`✅ Mapped to features: ${adjustment.description}`);
            } else {
              console.log(`⚠️ No mapping found for: "${adjustment.description}" - will be stored in helper for validation/report`);
            }
          });
        }
        
        // Update helper in sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('📊 Updated Levi data structure for floating screen compatibility');
        
      } catch (error) {
        console.error('Error updating Levi data structure:', error);
      }
    }
    
    // CALCULATE SUMMARY TOTALS - Updates helper with calculated totals
    function calculateSummaryTotals() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Calculate Levi adjustment totals
        let leviTotal = 0;
        if (helper.levi?.adjustments) {
          leviTotal = helper.levi.adjustments.reduce((sum, adj) => sum + (parseFloat(adj.value) || 0), 0);
        }
        if (helper.levi?.custom_adjustments) {
          leviTotal += helper.levi.custom_adjustments.reduce((sum, adj) => sum + (parseFloat(adj.value) || 0), 0);
        }
        
        // Calculate damage center totals
        let damageTotal = 0;
        if (helper.expertise?.damage_blocks) {
          helper.expertise.damage_blocks.forEach(block => {
            damageTotal += (parseFloat(block.parts_cost) || 0) + (parseFloat(block.work_cost) || 0) + (parseFloat(block.repairs_cost) || 0);
          });
        }
        
        // Update helper with calculated totals
        helper.summary_totals = {
          levi_total: leviTotal,
          damage_total: damageTotal,
          total_before_vat: leviTotal + damageTotal,
          total_with_vat: Math.round((leviTotal + damageTotal) * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100)),
          calculated_at: new Date().toISOString()
        };
        
        sessionStorage.setItem('helper', JSON.stringify(helper));
        console.log('✅ Summary totals calculated and updated in helper:', helper.summary_totals);
        
        // Trigger floating screen updates when helper changes
        triggerFloatingScreenRefresh();
        
      } catch (error) {
        console.error('Error calculating summary totals:', error);
      }
    }

    // TRIGGER FLOATING SCREEN REFRESH - Updates all helper-dependent floating screens
    function triggerFloatingScreenRefresh() {
      try {
        console.log('🔄 Triggering floating screen refresh after helper update');
        
        // Update helper with current 3-bulk calculations
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Ensure calculations structure exists
        helper.calculations = helper.calculations || {};
        helper.expertise = helper.expertise || {};
        helper.expertise.calculations = helper.expertise.calculations || {};
        
        // Update with current bulk calculations - with safety checks
        let grossMarketValue = 0;
        let fullMarketValue = 0;
        let totalClaim = 0;
        let grossPercentage = 0;
        
        if (window.FinalReportCalculations && typeof window.FinalReportCalculations === 'object') {
          grossMarketValue = window.FinalReportCalculations.getGrossMarketValue();
          fullMarketValue = window.FinalReportCalculations.getFullMarketValue();
          totalClaim = window.FinalReportCalculations.getTotalClaim();
          grossPercentage = window.FinalReportCalculations.getGrossPercentage();
        } else {
          console.warn('FinalReportCalculations not yet initialized, using fallback values');
          // Try to get values from DOM or helper as fallback
          grossMarketValue = parseFloat(document.getElementById('grossMarketValueResult')?.value.replace(/[₪,]/g, '') || '0') || 0;
          fullMarketValue = parseFloat(document.getElementById('fullMarketValueResult')?.value.replace(/[₪,]/g, '') || '0') || 0;
          totalClaim = parseFloat(document.getElementById('totalClaim')?.value.replace(/[₪,]/g, '') || '0') || 0;
          grossPercentage = parseFloat(document.getElementById('grossPercent')?.value.replace(/[%]/g, '') || '0') || 0;
        }
        
        // ✅ FIX: Check for manual authorizedClaim value and use that instead of calculated totalClaim
        const authorizedClaimField = document.getElementById('authorizedClaim');
        if (authorizedClaimField && authorizedClaimField.value && authorizedClaimField.value !== '') {
          const manualTotalClaim = parseFloat(authorizedClaimField.value.replace(/[₪,]/g, '')) || 0;
          if (manualTotalClaim > 0) {
            totalClaim = manualTotalClaim;
            console.log(`🔧 Using manual authorizedClaim value: ${totalClaim} instead of calculated value`);
          }
        }
        
        // Get original base price from valuation (preserve webhook data)
        const rawBasePrice = helper.valuation?.base_price || 
                             helper.car_details?.base_price || 
                             helper.levi_report?.base_price || 0;
        const originalBasePrice = parseFloat(String(rawBasePrice).replace(/[₪,]/g, '')) || 0;
        
        helper.calculations.vehicle_value_gross = grossMarketValue;
        helper.calculations.market_value = fullMarketValue;
        helper.calculations.full_market_value = fullMarketValue;
        helper.calculations.total_damage = totalClaim;
        helper.calculations.damage_percent = grossPercentage;
        
        // Add new bridge fields between webhook and user modifications
        helper.calculations.base_price = originalBasePrice;
        helper.calculations.final_adjustments_value = Math.round(fullMarketValue - originalBasePrice);
        
        // Debug logging to verify correct calculation
        console.log(`🔍 Bridge Field Debug: fullMarketValue=${fullMarketValue}, originalBasePrice=${originalBasePrice}, final_adjustments_value=${Math.round(fullMarketValue - originalBasePrice)}`);
        
        // Update expertise calculations for compatibility
        helper.expertise.calculations.vehicle_value_gross = grossMarketValue;
        helper.expertise.calculations.market_value = fullMarketValue;
        helper.expertise.calculations.total_damage = totalClaim;
        helper.expertise.calculations.damage_percent = grossPercentage;
        
        // Update claims_data for UI consistency
        helper.claims_data = helper.claims_data || {};
        
        helper.claims_data.gross_percent = `${grossPercentage.toFixed(2)}%`;
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Debug: Check which refresh functions are available
        console.log('Debug: Available refresh functions:', {
          refreshLeviData: typeof window.refreshLeviData,
          refreshCarData: typeof window.refreshCarData, 
          refreshInvoiceData: typeof window.refreshInvoiceData,
          refreshPartsResults: typeof window.refreshPartsResults
        });
        
        // Refresh Levi floating screen if open
        if (window.refreshLeviData && typeof window.refreshLeviData === 'function') {
          console.log('🔄 Refreshing Levi floating screen');
          window.refreshLeviData();
        }
        
        // Refresh Car Details floating screen if open
        if (window.refreshCarData && typeof window.refreshCarData === 'function') {
          console.log('🔄 Refreshing Car Details floating screen');
          window.refreshCarData();
        }
        
        // Refresh Invoice floating screen if open
        if (window.refreshInvoiceData && typeof window.refreshInvoiceData === 'function') {
          console.log('🔄 Refreshing Invoice floating screen');
          window.refreshInvoiceData();
        }
        
        // Refresh Parts Search floating screen
        if (window.refreshPartsResults && typeof window.refreshPartsResults === 'function') {
          console.log('🔄 Refreshing Parts Search floating screen');
          window.refreshPartsResults();
        }
        
        // Alternative: Try to reload data directly from iframe/floating screens
        setTimeout(() => {
          // Try to refresh via postMessage to floating screens
          const floatingScreens = document.querySelectorAll('.floating-screen[style*="block"]');
          floatingScreens.forEach(screen => {
            console.log('🔄 Found open floating screen:', screen.id);
            const iframe = screen.querySelector('iframe');
            if (iframe && iframe.contentWindow) {
              try {
                iframe.contentWindow.postMessage({
                  type: 'refreshData',
                  source: 'final-report-builder',
                  calculations: helper.calculations,
                  timestamp: new Date().toISOString()
                }, '*');
              } catch (e) {
                console.log('Could not post message to iframe:', e);
              }
            }
          });
        }, 100);
        
        // Dispatch custom event for any other modules listening
        window.dispatchEvent(new CustomEvent('helperDataUpdated', {
          detail: { 
            timestamp: new Date().toISOString(),
            source: 'final-report-builder',
            calculations: helper.calculations
          }
        }));
        
        
        console.log('✅ Helper updated with 3-bulk calculations:', {
          grossMarketValue,
          fullMarketValue,
          totalClaim,
          grossPercentage
        });
        
      } catch (error) {
        console.error('Error triggering floating screen refresh:', error);
      }
    }

    // LEGACY FUNCTION - Keep for compatibility but redirect to unified system
    function addCustomSummaryField(summaryType) {
      // Redirect to new unified system
      addCustomAdjustmentField();
    }
    
    // DEBUG FUNCTION - Test the complete data flow chain
    window.testDataFlow = function() {
      console.log('🧪 TESTING DATA FLOW CHAIN');
      
      // 1. Check if helper exists
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('1️⃣ Helper exists:', !!helper);
      console.log('   Helper keys:', Object.keys(helper));
      
      // 2. Test manual helper update
      console.log('2️⃣ Testing manual helper update...');
      helper.test_field = 'test_value_' + Date.now();
      helper.car_details = helper.car_details || {};
      helper.car_details.manufacturer = 'TEST_MANUFACTURER';
      sessionStorage.setItem('helper', JSON.stringify(helper));
      console.log('   Helper updated with test data');
      
      // 3. Test floating screen refresh
      console.log('3️⃣ Testing floating screen refresh...');
      triggerFloatingScreenRefresh();
      
      // 4. Check if refresh functions are available
      console.log('4️⃣ Checking refresh function availability:');
      console.log('   refreshLeviData:', typeof window.refreshLeviData);
      console.log('   refreshCarData:', typeof window.refreshCarData);
      console.log('   refreshInvoiceData:', typeof window.refreshInvoiceData);
      console.log('   refreshPartsResults:', typeof window.refreshPartsResults);
      
      // 5. Test manual adjustment input
      console.log('5️⃣ Testing manual adjustment input...');
      // Final report container removed - will return empty NodeList
      const adjustmentInputs = document.querySelectorAll('#allAdjustmentsRows-final-report input[data-source="custom"]');
      console.log('   Found adjustment inputs:', adjustmentInputs.length);
      
      if (adjustmentInputs.length > 0) {
        const firstInput = adjustmentInputs[0];
        console.log('   First input element:', firstInput);
        console.log('   First input data attributes:', {
          source: firstInput.dataset.source,
          index: firstInput.dataset.index,
          field: firstInput.dataset.field
        });
        
        // Simulate input change
        firstInput.value = 'TEST_ADJUSTMENT_' + Date.now();
        firstInput.dispatchEvent(new Event('input', { bubbles: true }));
        console.log('   Simulated input change');
      }
      
      console.log('🧪 DATA FLOW TEST COMPLETE');
    };

    // REMOVED DUPLICATE FUNCTION - Using the enhanced version above

    // UPDATE HELPER FROM FIELD
    function updateHelperFromField(event) {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        const fieldId = event.target.id;
        const value = event.target.value;
        
        console.log(`📝 Field change detected: ${fieldId} = "${value}"`);
        
        // Update the appropriate helper section based on field
        if (['carPlate', 'carManufacturer', 'carModel', 'carYear', 'carModelCode', 'carBasePrice', 'carMarketValue', 'carReportDate', 'basicPrice', 'finalReportDate', 'finalReportDateSummary'].includes(fieldId)) {
          helper.car_details = helper.car_details || {};
          helper.vehicle = helper.vehicle || {};
          
          const mapping = {
            'carPlate': 'plate',
            'carManufacturer': 'manufacturer',
            'carModel': 'model',
            'carYear': 'year',
            'carModelCode': 'model_code',
            'carBasePrice': 'base_price',
            'carMarketValue': 'market_value',
            'carReportDate': 'report_date',
            'basicPrice': 'basic_price',
            'finalReportDate': 'final_report_date',
            'finalReportDateSummary': 'final_report_date'
          };
          
          // Update car_details (builder format)
          helper.car_details[mapping[fieldId]] = value;
          
          // Special handling for final report date - also save to final_report.report_date
          if (fieldId === 'finalReportDate' || fieldId === 'finalReportDateSummary') {
            helper.final_report = helper.final_report || {};
            helper.final_report.report_date = value;
            console.log('📅 Also saved to final_report.report_date:', value);
          }
          
          // Also update vehicle structure (floating screen format)
          if (fieldId === 'carManufacturer') {
            helper.vehicle.manufacturer = value;
            console.log('🚗 Updated vehicle manufacturer:', value);
          } else if (fieldId === 'carModel') {
            helper.vehicle.model = value;
            console.log('🚗 Updated vehicle model:', value);
          } else if (fieldId === 'carYear') {
            helper.vehicle.year = value;
            console.log('🚗 Updated vehicle year:', value);
          } else if (fieldId === 'carModelCode') {
            helper.vehicle.model_code = value;
            console.log('🚗 Updated vehicle model code:', value);
          } else if (fieldId === 'carPlate') {
            // CRITICAL FIX: Use centralized plate standardization function
            if (window.setPlateNumber) {
              window.setPlateNumber(value, 'final-report-builder');
            } else {
              // Fallback: standardize manually
              const standardizedPlate = value ? String(value).replace(/[-\s]/g, '') : '';
              helper.vehicle.plate_number = standardizedPlate;
              helper.meta = helper.meta || {};
              helper.meta.plate = standardizedPlate;
            }
            console.log('🚗 Updated vehicle plate:', value);
          } else if (fieldId === 'basicPrice') {
            // Update levi_report structure for basic price
            helper.levi_report = helper.levi_report || {};
            helper.levi_report.base_price = value.replace(/[₪,]/g, '');
            helper.expertise = helper.expertise || {};
            helper.expertise.levi_report = helper.expertise.levi_report || {};
            helper.expertise.levi_report.base_price = value.replace(/[₪,]/g, '');
            console.log('🚗 Updated basic price:', value);
          }
          
          // Plate update is now handled above with centralized function
        } else if (['ownerName', 'ownerAddress', 'ownerPhone', 'insuranceCompany', 'insuranceEmail', 'insuranceAgent', 'agentPhone', 'agentEmail'].includes(fieldId)) {
          helper.client = helper.client || {};
          helper.car_details = helper.car_details || {};
          
          const mapping = {
            'ownerName': 'name',
            'ownerAddress': 'address',
            'ownerPhone': 'phone',
            'insuranceCompany': 'insurance_company',
            'insuranceEmail': 'insurance_email',
            'insuranceAgent': 'insurance_agent',
            'agentPhone': 'insurance_agent_phone',
            'agentEmail': 'insurance_agent_email'
          };
          
          // Update client structure (main format)
          helper.client[mapping[fieldId]] = value;
          
          // Also update car_details structure (floating screen format)
          if (fieldId === 'ownerName') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.name = value;
            helper.car_details.owner = value;
          } else if (fieldId === 'ownerAddress') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.address = value;
            helper.car_details.ownerAddress = value;
          } else if (fieldId === 'ownerPhone') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.phone_number = value;
            helper.car_details.ownerPhone = value;
          } else if (fieldId === 'insuranceCompany') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_company = value;
            helper.car_details.insuranceCompany = value;
          } else if (fieldId === 'insuranceAgent') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_agent = value;
            helper.car_details.agentName = value;
          } else if (fieldId === 'agentPhone') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_agent_phone = value;
            helper.car_details.insurance_agent_phone = value;
          } else if (fieldId === 'agentEmail') {
            // CORRECTED: Update helper.client as source of truth, then sync to car_details
            helper.client.insurance_agent_email = value;
            helper.car_details.insurance_agent_email = value;
          }
        } else if (fieldId === 'totalClaim') {
          // Claims data mapping
          helper.claims_data = helper.claims_data || {};
          helper.claims_data.total_claim = value;
          console.log(`💰 Updated claims_data.total_claim from ${fieldId}: ${value}`);
          
          // ✅ ENSURE: Update window.helper immediately
          window.helper = helper;
          
          // Also update expertise.calculations for compatibility
          helper.expertise = helper.expertise || {};
          helper.expertise.calculations = helper.expertise.calculations || {};
          if (fieldId === 'totalClaim') {
            // Remove currency formatting and parse number
            const numericValue = parseFloat(value.replace(/[₪,]/g, '')) || 0;
            helper.expertise.calculations.total_damage = numericValue;
          }
          
          console.log(`💰 Updated claims data: ${fieldId} = "${value}"`);
        } else if (['sumMarketValue', 'sumClaim', 'sumVAT', 'sumTotalClaim', 'depCompensation', 'salvageValue', 'garageDays', 
                   'sumMarketValueGlobal', 'sumMarketValueDamage', 'sumMarketValueTotal', 'sumMarketValueLegal',
                   'saleValueDamage', 'afterSaleDamage', 'salvageValueTotal', 'storageValueTotal', 'afterSaleTotal',
                   'salvageValueLegal', 'afterSaleLegal'].includes(fieldId)) {
          
          // COMPREHENSIVE SUMMARY FIELD MAPPING FOR ALL 5 REPORT VARIANTS
          
          // Handle garage days separately
          if (fieldId === 'garageDays') {
            helper.final_report.work_days = value;
          } else {
            helper.final_report.summary = helper.final_report.summary || {};
            
            // COMPREHENSIVE FIELD MAPPING DICTIONARY FOR ALL VARIANTS
            const comprehensiveMapping = {
              // COMMON FIELDS (used across multiple variants)
              'sumMarketValue': 'market_value',           // Private report market value
              'sumMarketValueGlobal': 'market_value_global',     // Global report market value  
              'sumMarketValueDamage': 'market_value_damage',     // Damage sale report market value
              'sumMarketValueTotal': 'market_value_total',       // Total loss report market value
              'sumMarketValueLegal': 'market_value_legal',       // Legal loss report market value
              
              // PRIVATE REPORT SPECIFIC FIELDS  
              'sumClaim': 'total_claim',
              'sumVAT': 'vat',
              'sumTotalClaim': 'total_with_vat',
              'depCompensation': 'dep_compensation',
              
              // DAMAGED SALE VARIANT SPECIFIC FIELDS
              'saleValueDamage': 'sale_value_damaged',           // Manual input: sale value in damaged state
              'paymentMethod': 'paymentMethod',                  // Manual input: payment method for damaged sale
              'afterSaleDamage': 'total_after_sale_damage',      // Calculated: market value - sale value
              
              // TOTAL LOSS VARIANT SPECIFIC FIELDS  
              'salvageValueTotal': 'salvage_value_total',        // Manual input: salvage value for total loss
              'storageValueTotal': 'storage_towing_value_total', // Manual input: storage/towing costs
              'afterSaleTotal': 'total_after_salvage_total',     // Calculated: market value - salvage + storage
              
              // LEGAL LOSS VARIANT SPECIFIC FIELDS
              'salvageValueLegal': 'salvage_value_legal',        // Manual input: salvage value for legal loss
              'afterSaleLegal': 'total_after_salvage_legal',     // Calculated: market value - salvage
              
              // LEGACY FIELDS (maintain compatibility)
              'salvageValue': 'salvage_value'                    // General salvage value field
            };
            
            // Map field to helper structure
            const mappedKey = comprehensiveMapping[fieldId];
            if (mappedKey) {
              helper.final_report.summary[mappedKey] = value;
              console.log(`📊 Updated summary field: ${fieldId} -> ${mappedKey} = "${value}"`);
            } else {
              console.warn(`⚠️ No mapping found for field: ${fieldId}`);
            }
          }
        }
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Trigger floating screen updates when helper changes
        triggerFloatingScreenRefresh();
        
        // Update page title if plate changed
        if (fieldId === 'carPlate') {
          // Standardize plate format
          const standardizedValue = value && value !== '...' ? String(value).replace(/[-\s]/g, '') : (value || '...');
          document.getElementById('pageTitle').textContent = `רכב מס. ${standardizedValue}`;
        }
        
        // Update legal text with new data
        loadLegalText().catch(console.error);
        
        // Special handling for salvage value changes
        if (fieldId === 'salvageValue') {
          console.log('Salvage value updated:', value);
        }
        
        // Trigger calculations if field affects calculations
        const calculationFields = ['basicPrice', 'carBasePrice', 'carMarketValue', 'totalClaim'];
        if (calculationFields.includes(fieldId)) {
          setTimeout(() => {
            if (window.FinalReportCalculations && typeof window.FinalReportCalculations.refresh3BulkCalculations === 'function') {
              window.FinalReportCalculations.refresh3BulkCalculations();
            }
          }, 100);
        }
        
      } catch (error) {
        console.error('Error updating helper from field:', error);
      }
    }

    // ✅ STANDARDIZED CLAIMS DATA MAPPING FUNCTION
    function updateClaimsDataFromField(element, claimsKey) {
      try {
        const helper = window.helper || {};
        if (!helper.claims_data) helper.claims_data = {};
        
        let value = element.value;
        const fieldId = element.id;
        
        console.log(`💰 Claims data field change: ${fieldId} -> claims_data.${claimsKey} = "${value}"`);
        
        // Format currency fields
        if (claimsKey === 'authorized_claim' && value) {
          // Remove existing currency symbols and format properly
          value = value.replace(/[₪,]/g, '').trim();
          if (value && !isNaN(value)) {
            const numericValue = parseInt(value);
            value = `₪${numericValue.toLocaleString()}`;
          }
        }
        
        // Update claims_data
        helper.claims_data[claimsKey] = value;
        
        // Also update calculations.authorized_claim when authorized_claim is updated
        if (claimsKey === 'authorized_claim') {
          if (!helper.calculations) helper.calculations = {};
          helper.calculations.authorized_claim = value;
        }
        
        // Save to helper
        window.helper = helper;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log(`✅ Updated claims_data.${claimsKey} = "${value}"`);
        
        // Trigger floating screen refresh
        if (typeof triggerFloatingScreenRefresh === 'function') {
          triggerFloatingScreenRefresh();
        }
        
      } catch (error) {
        console.error('Error updating claims data:', error);
      }
    }

    // Update helper from contact field - delegates to updateHelperFromField
    function updateHelperFromContactField(element) {
      const event = { target: element };
      updateHelperFromField(event);
    }

    // Copied from estimator-builder.html - dynamic sign handling
    function getDropdownTypeFromValues(percentValue, amountValue, currentType) {
      // Priority: Check percent first, then amount
      let numericValue = null;
      
      if (percentValue !== null && percentValue !== undefined && percentValue !== '' && !isNaN(percentValue)) {
        numericValue = parseFloat(percentValue);
      } else if (amountValue !== null && amountValue !== undefined && amountValue !== '' && !isNaN(amountValue)) {
        numericValue = parseFloat(amountValue);
      }
      
      // If we have a numeric value, determine type based on sign
      if (numericValue !== null && numericValue !== 0) {
        return numericValue < 0 ? 'minus' : 'plus';
      }
      
      // Fall back to current type or default to 'plus'
      return currentType || 'plus';
    }

    // ✅ STANDARDIZED CLAIMS DATA MAPPING - Load from helper to UI
    function loadClaimsDataToUI() {
      try {
        const helper = window.helper || {};
        const claimsData = helper.claims_data || {};
        
        // Insurance authorization field
        const insuranceField = document.getElementById('insuranceAuthorization');
        if (insuranceField && claimsData.authorized_claim) {
          insuranceField.value = claimsData.authorized_claim;
        }
        
        console.log('✅ Claims data loaded to UI fields');
        
      } catch (error) {
        console.error('Error loading claims data to UI:', error);
      }
    }

    // UPDATE REPORT TYPE
    function updateReportType() {
      const reportTypeSelect = document.getElementById('reportType');
      const selectedType = reportTypeSelect?.value || 'חוות דעת פרטית';
      
      console.log('🔄 Updating report type to:', selectedType);
      
      // Hide all summary sections first
      const summaryBlocks = document.querySelectorAll('.summary-block');
      summaryBlocks.forEach(block => block.style.display = 'none');
      
      // Show the correct summary section based on selected type
      let summaryId = '';
      switch(selectedType) {
        case 'חוות דעת פרטית':
          summaryId = 'summaryPrivate';
          break;
        case 'חוות דעת גלובלית':
          summaryId = 'summaryGlobal';
          break;
        case 'חוות דעת מכירה מצבו הניזוק':
          summaryId = 'summaryDamage';
          break;
        case 'חוות דעת טוטלוסט':
          summaryId = 'summaryTotalLoss';
          break;
        case 'חוות דעת אובדן להלכה':
          summaryId = 'summaryLegalLoss';
          break;
        default:
          summaryId = 'summaryPrivate';
      }
      
      // Show the selected summary section
      const selectedSummary = document.getElementById(summaryId);
      if (selectedSummary) {
        selectedSummary.style.display = 'block';
        console.log('✅ Showing summary section:', summaryId);
        
        // 🔧 FIX: Refresh summary content after changing report type
        refreshSummary();
        console.log('🔄 Summary content refreshed for report type:', selectedType);
      } else {
        console.warn('⚠️ Summary section not found:', summaryId);
      }
    }


    // LOAD LEGAL TEXT USING CENTRALIZED ENGINE
    async function loadLegalText() {
      const reportTypeSelect = document.getElementById('reportType');
      const reportType = reportTypeSelect?.value || 'חוות דעת פרטית';
      
      console.log('🔄 Loading legal text for report type:', reportType);
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Collect values for placeholder replacement
      const placeholderValues = {
        plate: document.getElementById('carPlate')?.value || helper.meta?.plate,
        manufacturer: document.getElementById('carManufacturer')?.value || helper.car_details?.manufacturer,
        model: document.getElementById('carModel')?.value || helper.car_details?.model,
        year: document.getElementById('carYear')?.value || helper.car_details?.year,
        ownerName: document.getElementById('ownerName')?.value || helper.client?.name,
        modelCode: document.getElementById('carModelCode')?.value || helper.car_details?.model_code || helper.levi_report?.model_code,
        damagePercent: document.getElementById('grossPercent')?.value || helper.claims_data?.gross_percent || calculateDamagePercentage() || helper.expertise?.calculations?.damage_percent,
        depreciation: document.getElementById('globalDep1')?.value || helper.final_report?.depreciation?.global_percent,
        damageCenters: (() => {
          // Primary source: damage_assessment.total_centers
          if (helper.damage_assessment?.total_centers) {
            return helper.damage_assessment.total_centers.toString();
          }
          
          // Fallback: Try multiple sources for damage centers count
          if (helper.damage_centers_summary && typeof helper.damage_centers_summary === 'object') {
            return Object.keys(helper.damage_centers_summary).filter(key => key.startsWith('Damage center')).length || 
                   Object.keys(helper.damage_centers_summary).length;
          }
          if (helper.damage_assessment?.comprehensive?.centers && typeof helper.damage_assessment.comprehensive.centers === 'object') {
            return Object.keys(helper.damage_assessment.comprehensive.centers).length;
          }
          if (helper.expertise?.damage_blocks?.length) {
            return helper.expertise.damage_blocks.length;
          }
          return '1'; // Default fallback
        })(),
        garageDays: document.getElementById('garageDays')?.value || helper.final_report?.work_days || helper.expertise?.depreciation?.work_days,
        carValue: document.getElementById('carMarketValue')?.value || document.getElementById('sumMarketValue')?.value || (helper.calculations?.full_market_value ? `₪${helper.calculations.full_market_value.toLocaleString()}` : undefined),
        salvageValue: (() => {
          // Check report type to determine correct salvage field
          const reportType = reportTypeSelect?.value || 'חוות דעת פרטית';
          let salvageInput;
          
          if (reportType === 'חוות דעת טוטלוסט') {
            // Total Loss variant uses salvageValueTotal
            salvageInput = document.getElementById('salvageValueTotal')?.value;
          } else if (reportType === 'חוות דעת אובדן להלכה') {
            // Legal Loss variant uses salvageValueLegal  
            salvageInput = document.getElementById('salvageValueLegal')?.value;
          } else {
            // Other variants use general salvageValue
            salvageInput = document.getElementById('salvageValue')?.value;
          }
          
          // Enhanced helper data fallback for variant-specific salvage values
          let helperSalvage = '';
          if (reportType === 'חוות דעת טוטלוסט') {
            helperSalvage = helper.final_report?.summary?.salvage_value_total ||
                           helper.final_report?.summary?.salvageValueTotal ||
                           helper.salvage_value_total_loss ||
                           helper.salvageValueTotal;
          } else if (reportType === 'חוות דעת אובדן להלכה') {
            helperSalvage = helper.final_report?.summary?.salvage_value_legal ||
                           helper.final_report?.summary?.salvageValueLegal ||
                           helper.salvage_value_legal_loss ||
                           helper.salvageValueLegal;
          } else {
            helperSalvage = helper.final_report?.summary?.salvage_value || 
                           helper.final_report?.salvage_value ||
                           helper.salvage_value;
          }
          
          let rawValue = '';
          if (salvageInput && salvageInput.trim() !== '' && salvageInput !== '₪0') {
            rawValue = salvageInput;
          } else if (helperSalvage && helperSalvage !== '₪0') {
            rawValue = helperSalvage;
          }
          
          // Remove existing currency symbols to prevent doubling
          if (rawValue) {
            rawValue = rawValue.replace(/₪|ש\"ח|ש״ח/g, '').trim();
            // Add clean currency formatting
            const numericValue = rawValue.replace(/[^\d.-]/g, '');
            if (numericValue) {
              return `₪${Number(numericValue).toLocaleString()}`;
            }
          }
          return undefined;
        })(),
        compensation: (() => {
          // For Global variant - prioritize final_report.summary.global_before_differentials
          const globalSummary = helper.final_report?.summary?.global_before_differentials;
          const depCompField = document.getElementById('depCompensation')?.value;
          const helperComp = helper.final_report?.summary?.dep_compensation;
          const globalDepValue = helper.depreciation?.globalDepValue;
          
          let rawValue = '';
          if (globalSummary && globalSummary !== '₪0') {
            rawValue = globalSummary;
          } else if (depCompField && depCompField.trim() !== '' && depCompField !== '₪0') {
            rawValue = depCompField;
          } else if (helperComp && helperComp !== '₪0') {
            rawValue = helperComp;
          } else if (globalDepValue) {
            rawValue = `₪${globalDepValue.toLocaleString()}`;
          }
          
          // Remove existing currency symbols to prevent doubling
          if (rawValue) {
            rawValue = rawValue.replace(/₪|ש\"ח|ש״ח/g, '').trim();
            // Add clean currency formatting
            const numericValue = rawValue.replace(/[^\d.-]/g, '');
            if (numericValue) {
              return `₪${Number(numericValue).toLocaleString()}`;
            }
          }
          return undefined;
        })(),
        salePrice: (() => {
          // For Damaged Sale variant - use saleValueDamage field
          const saleField = document.getElementById('saleValueDamage')?.value;
          const helperSale = helper.final_report?.summary?.sale_value_damaged;
          
          let rawValue = '';
          if (saleField && saleField.trim() !== '' && saleField !== '₪0') {
            rawValue = saleField;
          } else if (helperSale && helperSale !== '₪0') {
            rawValue = helperSale;
          }
          
          // Remove existing currency symbols to prevent doubling
          if (rawValue) {
            rawValue = rawValue.replace(/₪|ש\"ח|ש״ח/g, '').trim();
            // Add clean currency formatting
            const numericValue = rawValue.replace(/[^\d.-]/g, '');
            if (numericValue) {
              return `₪${Number(numericValue).toLocaleString()}`;
            }
          }
          return undefined;
        })(),
        paymentMethod: (() => {
          // For Damaged Sale variant - payment method from UI field
          const paymentField = document.getElementById('paymentMethod')?.value;
          const helperPayment = helper.final_report?.summary?.paymentMethod;
          
          if (paymentField && paymentField.trim() !== '') {
            return paymentField.trim();
          } else if (helperPayment && helperPayment.trim() !== '') {
            return helperPayment;
          }
          return undefined;
        })()
      };
      
      try {
        // Use the centralized legal text engine
        const legalText = await window.LegalTextEngine.getProcessedText(
          reportType, 
          placeholderValues, 
          'final_report'
        );
        
        const legalTextElement = document.getElementById('legal-text-content');
        if (legalTextElement) {
          legalTextElement.value = legalText;
          console.log('✅ Legal text loaded successfully from vault for:', reportType);
        } else {
          console.error('❌ Legal text element not found: legal-text-content');
        }
        
      } catch (error) {
        console.error('❌ Error loading legal text:', error);
        const legalTextElement = document.getElementById('legal-text-content');
        if (legalTextElement) {
          legalTextElement.value = 'שגיאה בטעינת טקסט משפטי מהכספת - אנא בדוק את החיבור';
        }
      }
    }

    // LOAD LEGAL TEXT FROM VAULT - SEPARATE FUNCTION FOR BUTTON
    function loadLegalTextFromVault() {
      try {
        loadLegalText().then(() => {
          // Save the legal text to helper after it's been loaded
          setTimeout(() => {
            try {
              const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
              
              // Initialize final_report object if it doesn't exist
              if (!helper.final_report) {
                helper.final_report = {};
              }
              
              const legalTextElement = document.getElementById('legal-text-content');
              if (legalTextElement && legalTextElement.value) {
                helper.final_report.legal_text = legalTextElement.value;
                sessionStorage.setItem('helper', JSON.stringify(helper));
                console.log('✅ Legal text loaded from vault and saved to final report');
              } else {
                console.error('❌ Legal text element not found or empty');
              }
            } catch (error) {
              console.error('❌ Error saving legal text to helper:', error);
            }
          }, 100);
        }).catch(error => {
          console.error('❌ Error loading legal text from vault:', error);
        });
      } catch (error) {
        console.error('❌ Error in loadLegalTextFromVault:', error);
      }
    }

    // Save legal text after report type or other changes
    function saveLegalTextAfterChange() {
      // Wait for legal text to be loaded, then save to helper
      setTimeout(() => {
        const legalTextArea = document.getElementById('legal-text-content');
        if (legalTextArea && legalTextArea.value && legalTextArea.value.trim() !== '') {
          const helper = window.helper || {};
          
          // Initialize final_report object if it doesn't exist
          if (!helper.final_report) {
            helper.final_report = {};
          }
          helper.final_report.legal_text = legalTextArea.value;
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
          updateBuilderCurrentState('final_report.legal_text', legalTextArea.value);
          
          console.log('✅ Legal text updated and saved to helper after report type change');
        }
      }, 1500); // Wait longer for legal text engine to load new content
    }

    // RESET LEGAL TEXT
    function resetLegalText() {
      const reportTypeSelect = document.getElementById('reportType');
      const reportType = reportTypeSelect?.value || 'חוות דעת פרטית';
      // Map report type to display text
      let typeText = 'פרטית';
      switch(reportType) {
        case 'חוות דעת פרטית':
          typeText = 'פרטית';
          break;
        case 'חוות דעת גלובלית':
          typeText = 'גלובלית';
          break;
        case 'חוות דעת מכירה מצבו הניזוק':
          typeText = 'מכירה מצבו הניזוק';
          break;
        case 'חוות דעת טוטלוסט':
          typeText = 'טוטלוסת';
          break;
        case 'חוות דעת אובדן להלכה':
          typeText = 'אובדן להלכה';
          break;
      }
      
      document.getElementById('legal-text-content').value = `טקסט משפטי לחוות דעת סופית ${typeText} - מוכן לעריכה`;
      
      // Clear saved legal text from helper
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (helper.final_report) {
        delete helper.final_report.legal_text;
      }
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      console.log('Legal text reset');
    }

    // LOAD ATTACHMENTS FROM VAULT
    async function loadAttachmentsFromVault() {
      console.log('🔵 loadAttachmentsFromVault function called');
      
      try {
        // Get selected type from dropdown
        const reportTypeSelect = document.getElementById('reportType');
        console.log('🔵 reportTypeSelect element:', reportTypeSelect);
        
        const reportType = reportTypeSelect?.value || 'חוות דעת פרטית';
        console.log('📎 Loading attachments from vault for type:', reportType);
        
        // Use the legal text engine to get attachments from the actual vault
        if (window.LegalTextEngine) {
          console.log('🔵 LegalTextEngine is available');
          const attachmentsText = await window.LegalTextEngine.getAttachments(reportType);
          
          const attachmentsElement = document.getElementById('attachments-content');
          console.log('🔵 attachments-content element:', attachmentsElement);
          
          if (attachmentsElement) {
            attachmentsElement.value = attachmentsText;
            console.log('🔵 Attachments text set to textarea');
          } else {
            console.error('❌ attachments-content element not found');
          }
          
          // Save to helper and LOCK the selection
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          if (!helper.final_report) helper.final_report = {};
          helper.final_report.attachments = attachmentsText;
          helper.final_report.attachments_locked = true; // Lock the selection
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          console.log('✅ Attachments loaded from vault using LegalTextEngine and LOCKED');
        } else {
          console.error('❌ LegalTextEngine not available');
          // Fallback to hardcoded with חשכ"ט
          const fallbackText = '**לוטה**\nתצלומי הרכב הניזוק\nחשבוניות תיקון\nערך רכב ממוחשב\nצילום רישיון הרכב\nחשכ"ט';
          document.getElementById('attachments-content').value = fallbackText;
        }
      } catch (error) {
        console.error('❌ Error loading attachments from vault:', error);
        // Fallback to default with חשכ"ט
        const fallbackText = '**לוטה**\nתצלומי הרכב הניזוק\nחשבוניות תיקון\nערך רכב ממוחשב\nצילום רישיון הרכב\nחשכ"ט';
        document.getElementById('attachments-content').value = fallbackText;
      }
    }

    // RESET ATTACHMENTS
    function resetAttachments() {
      try {
        // Reset to default attachments
        const defaultAttachments = '**לוטה**\nתצלומי הרכב הניזוק\nחשבוניות תיקון\nערך רכב ממוחשב\nצילום רישיון הרכב\nחשכ"ט';
        document.getElementById('attachments-content').value = defaultAttachments;
        
        // Clear from helper safely
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (!helper.final_report) helper.final_report = {};
        delete helper.final_report.attachments;
        delete helper.final_report.attachments_locked;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('✅ Attachments reset to default list');
      } catch (error) {
        console.error('❌ Error resetting attachments:', error);
      }
    }

    // LOAD ATTACHMENTS DATA FROM HELPER
    function loadAttachmentsData() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Load saved attachments if they exist and are locked
      if (helper.final_report?.attachments && helper.final_report?.attachments_locked) {
        const attachmentsElement = document.getElementById('attachments-content');
        if (attachmentsElement) {
          attachmentsElement.value = helper.final_report.attachments;
          console.log('📎 Loaded LOCKED attachments from helper - will not revert to default');
        }
      } else if (helper.final_report?.attachments) {
        const attachmentsElement = document.getElementById('attachments-content');
        if (attachmentsElement) {
          attachmentsElement.value = helper.final_report.attachments;
          console.log('📎 Loaded saved attachments from helper (not locked)');
        }
      } else {
        console.log('📎 No saved attachments found, keeping default');
      }
    }

    // ADD GLOBAL DEPRECIATION CALCULATION
    function updateGlobalDepreciationCalculation() {
      const globalDepInput = document.getElementById('globalDep1');
      const globalDepValueInput = document.getElementById('globalDepValue');
      
      if (globalDepInput && globalDepValueInput) {
        globalDepInput.addEventListener('input', function() {
          // Clean the value to extract the numeric part
          const cleanValue = this.value.replace('%', '').replace(/[^0-9.-]/g, '');
          let percent = parseFloat(cleanValue) || 0;
          
          // Keep value as clean decimal number without % sign
          this.value = cleanValue;
          
          // Calculate value from market price automatically - try multiple sources
          let marketValue = 0;
          
          // First try summary market value (priority)
          const sumMarketValueField = document.getElementById('sumMarketValue');
          if (sumMarketValueField && sumMarketValueField.value) {
            const sumMarketStr = sumMarketValueField.value.replace(/[₪,]/g, '') || '0';
            marketValue = parseFloat(sumMarketStr) || 0;
          }
          
          // If no summary value, try car details market value
          if (marketValue === 0) {
            const carMarketValueField = document.getElementById('carMarketValue');
            if (carMarketValueField && carMarketValueField.value) {
              const carMarketStr = carMarketValueField.value.replace(/[₪,]/g, '') || '0';
              marketValue = parseFloat(carMarketStr) || 0;
            }
          }
          
          console.log('Global depreciation calculation:', {
            percent,
            marketValue,
            calculation: (marketValue * percent) / 100
          });
          
          const calculatedValue = (marketValue * percent) / 100;
          globalDepValueInput.value = calculatedValue ? `₪${Math.round(calculatedValue).toLocaleString()}` : '';
          
          // TRIGGER SUMMARY UPDATE when global depreciation value changes
          if (window.addSummaryCalculationListeners) {
            const sumCalculate = document.querySelector('[data-summary-calculate]');
            if (sumCalculate) {
              sumCalculate.click();
            }
          }
          
          // Direct trigger for summary calculations
          setTimeout(() => {
            const event = new Event('input', { bubbles: true });
            globalDepValueInput.dispatchEvent(event);
          }, 100);
        });
      }
    }
    
    // CALCULATE DAMAGE PERCENTAGE
    function calculateDamagePercentage() {
      try {
        const totalClaim = parseFloat(document.getElementById('sumClaim')?.value.replace(/[₪,]/g, '') || '0') || 0;
        
        // Try to get vehicle_value_gross from helper first (gross market value for damage calculation)
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        const vehicleValueGross = helper.calculations?.vehicle_value_gross || 0;
        
        // Fallback to market value if vehicle_value_gross not available
        const marketValue = parseFloat(document.getElementById('sumMarketValue')?.value.replace(/[₪,]/g, '') || '0') || 0;
        const calculationBase = vehicleValueGross > 0 ? vehicleValueGross : marketValue;
        
        if (calculationBase > 0 && totalClaim > 0) {
          const percentage = (totalClaim / calculationBase) * 100;
          console.log(`📊 Damage percentage calculation: ${totalClaim.toLocaleString()} ÷ ${calculationBase.toLocaleString()} = ${Math.round(percentage)}%`);
          return Math.round(percentage) + '%';
        }
        return '[אחוז נזק]';
      } catch (error) {
        return '[אחוז נזק]';
      }
    }

    // UPDATE GROSS MARKET VALUE FIELD
    function updateGrossMarketValueField() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        let vehicleValueGross = helper.calculations?.vehicle_value_gross;
        
        console.log('🔍 Checking vehicle_value_gross:', {
          helper_calculations: helper.calculations,
          vehicle_value_gross: vehicleValueGross,
          levi_report_final_price: helper.levi_report?.final_price,
          expertise_calculations: helper.expertise?.calculations
        });
        
        // If vehicle_value_gross is missing, try to calculate it from Levi data
        if (!vehicleValueGross && helper.levi_report) {
          const leviReport = helper.levi_report;
          const basePrice = parseFloat(leviReport.base_price || 0);
          const featuresValue = parseFloat(leviReport.features_value || 0);
          const registrationValue = parseFloat(leviReport.registration_value || 0);
          
          if (basePrice > 0) {
            vehicleValueGross = basePrice + featuresValue + registrationValue;
            console.log(`🔧 Calculated vehicle_value_gross from Levi data: ${basePrice} + ${featuresValue} + ${registrationValue} = ${vehicleValueGross}`);
            
            // Update helper with calculated value
            helper.calculations = helper.calculations || {};
            helper.calculations.vehicle_value_gross = vehicleValueGross;
            sessionStorage.setItem('helper', JSON.stringify(helper));
          }
        }
        
        // If still no value, try other fallbacks
        if (!vehicleValueGross) {
          const fallbackSources = [
            helper.levi_report?.final_price,
            helper.expertise?.calculations?.market_value,
            helper.expertise?.calculations?.vehicle_value_gross,
            helper.levisummary?.final_price
          ];
          
          for (const fallback of fallbackSources) {
            if (fallback && fallback > 0) {
              vehicleValueGross = fallback;
              console.log(`🔧 Using fallback for vehicle_value_gross: ${vehicleValueGross}`);
              break;
            }
          }
        }
        
        // Update the field if we have a value
        if (vehicleValueGross && vehicleValueGross > 0) {
          const leviPriceListField = document.getElementById('leviPriceList');
          if (leviPriceListField) {
            leviPriceListField.value = `₪${vehicleValueGross.toLocaleString()}`;
            
            // Update helper claims data to maintain consistency
            helper.claims_data = helper.claims_data || {};
            helper.claims_data.gross_value = `₪${vehicleValueGross.toLocaleString()}`;
            sessionStorage.setItem('helper', JSON.stringify(helper));
            
            console.log(`💰 Updated gross market value field: ₪${vehicleValueGross.toLocaleString()}`);
          }
        } else {
          console.log('ℹ️ vehicle_value_gross not found - will be calculated when needed');
        }
        
        // Do NOT call updateGrossPercentageField here to avoid infinite loop
      } catch (error) {
        console.error('Error updating gross market value field:', error);
      }
    }

    // LOAD GROSS ADJUSTMENTS FROM helper.estimate.adjustments
    function loadGrossAdjustments(helper) {
      try {
        const featuresContainer = document.getElementById('featuresAdjustmentsList');
        const registrationContainer = document.getElementById('registrationAdjustmentsList');

        if (featuresContainer) featuresContainer.innerHTML = '';
        if (registrationContainer) registrationContainer.innerHTML = '';

        // Use SINGLE CLEAN SOURCE like reloadGrossAdjustments: estimate.adjustments || valuation.adjustments
        const adjustments = helper.estimate?.adjustments || helper.valuation?.adjustments || {};
        
        console.log('📍 Loading from: estimate.adjustments → valuation.adjustments (clean single source)');
        console.log('🔍 Available adjustments data:', adjustments);
        
        // Load features and registration only (matching reloadGrossAdjustments)
        const categories = [
          { key: 'features', addFunction: addFeatureAdjustment, container: featuresContainer },
          { key: 'registration', addFunction: addRegistrationAdjustment, container: registrationContainer }
        ];
        
        categories.forEach(({ key, addFunction, container }) => {
          // FIXED: First check final_report.adjustments for manually added rows
          const finalReportData = helper.final_report?.adjustments?.[key] || [];
          const estimateData = adjustments[key];
          
          // Use final_report data if it has manually added rows (length > 1)
          let categoryData;
          if (Array.isArray(finalReportData) && finalReportData.length > 1) {
            console.log(`📝 Loading ${key} from final_report (has ${finalReportData.length} items including manual additions)`);
            categoryData = finalReportData;
          } else {
            console.log(`📝 Loading ${key} from estimate.adjustments`);
            categoryData = estimateData;
          }
          
          if (categoryData && container) {
            console.log(`📝 Loading ${key} adjustments:`, categoryData);
            
            // Handle both array and single object data
            const items = Array.isArray(categoryData) ? categoryData : (categoryData && (categoryData.percent || categoryData.percentage || categoryData.amount) ? [categoryData] : []);
            
            items.forEach((item, index) => {
              if (item && (item.percent || item.percentage || item.amount || item.value)) {
                // Add new row
                addFunction();
                
                // Fill the data
                const rows = container.querySelectorAll('div[id*="Adj_"]');
                const lastRow = rows[rows.length - 1];
                
                if (lastRow) {
                  const inputs = lastRow.querySelectorAll('input, select');
                  if (inputs.length >= 4) {
                    // Field mapping: value → תיאור (description) - PRESERVE FULL TEXT
                    inputs[0].value = item.value || '';
                    
                    // Type dropdown - use stored type directly
                    const itemPercent = item.percentage || item.percent;
                    const itemAmount = item.amount;
                    const storedType = item.type || 'plus';
                    if (storedType === 'minus' || storedType === 'הפחתה' || storedType === 'הפחתה (-)') {
                      inputs[1].value = 'minus';
                    } else if (storedType === 'plus' || storedType === 'תוספת' || storedType === 'תוספת (+)') {
                      inputs[1].value = 'plus';
                    } else {
                      inputs[1].value = storedType; // For % or ₪ types
                    }
                    
                    // Percent and amount - preserve sign based on type
                    inputs[2].value = itemPercent ? Math.abs(itemPercent) : '';
                    
                    // FIXED: Preserve amount display properly
                    if (item.amount_display) {
                      inputs[3].value = item.amount_display;
                    } else if (item.amount !== undefined && item.amount !== 0) {
                      const absAmount = Math.abs(item.amount);
                      inputs[3].value = `₪${absAmount.toLocaleString()}`;
                    } else {
                      inputs[3].value = '';
                    }
                    
                    // Trigger change events
                    inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
                    if (inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
                    if (inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
                    
                    // Call formatAdjustmentDisplay to ensure proper sign display
                    formatAdjustmentDisplay(lastRow, inputs[1].value, itemPercent, itemAmount);
                    
                    // Mark source as original for page refresh loads
                    lastRow.setAttribute('data-source', 'original');
                    
                    console.log(`✅ Loaded ${key} item ${index}:`, {
                      description: inputs[0].value,
                      type: inputs[1].value,
                      percent: itemPercent,
                      amount: itemAmount
                    });
                  }
                }
              }
            });
          }
        });
        
        // Trigger calculations after loading
        setTimeout(() => {
          updateGrossMarketValueCalculation();
          console.log('✅ Gross adjustments loaded from clean single source');
        }, 100);
        
      } catch (error) {
        console.error('❌ Error loading gross adjustments:', error);
      }
    }
    
    // LOAD TOTAL VALUE SECTION ADJUSTMENTS FROM final_report.adjustments
    function loadTotalValueSectionAdjustments(helper) {
      try {
        console.log('🔄 Auto-loading Total Value Section with mixed data sources');
        
        // Mixed data sources (EXACT same as reload button):
        // - Features & Registration: from final_report.adjustments (sync with Gross section)  
        // - Others (KM, Ownership, Owners, Additional): from estimate.adjustments with valuation fallback
        const estimateAdjustments = helper.estimate?.adjustments || helper.valuation?.adjustments || {};
        const finalReportAdjustments = helper.final_report?.adjustments || {};
        
        console.log('📦 estimate.adjustments:', estimateAdjustments);
        console.log('📦 final_report.adjustments:', finalReportAdjustments);
        console.log('📦 helper.valuation.adjustments:', helper.valuation?.adjustments);
        console.log('📦 helper.valuation.adjustments keys:', Object.keys(helper.valuation?.adjustments || {}));
        
        // Helper function to create adjustment row
        function createTotalValueRow(adj, category, source) {
          const rowId = category === 'additional' ? `fullAdj_${Date.now()}` : `totalValue_${category}_${Date.now()}_${Math.random()}`;
          
          // DEBUG: Log the actual adjustment data being processed
          console.log(`🔍 DEBUG createTotalValueRow for ${category} from ${source}:`, {
            fullAdjustment: adj,
            type: adj.type,
            percent: adj.percent,
            percentage: adj.percentage,
            amount: adj.amount,
            value: adj.value
          });
          
          // Determine the type based on adjustment data
          let selectedType = '%'; // default
          
          // Get values for analysis
          const percentValue = adj.percent || adj.percentage || 0;
          const amountValue = adj.amount || 0;
          
          // First, determine if it's plus or minus based on values
          const isNegative = percentValue < 0 || amountValue < 0;
          
          // FIX: Use stored type directly, don't detect from values
          const itemPercent = adj.percentage || adj.percent;
          const itemAmount = adj.amount;
          const storedType = adj.type || 'plus';
          
          // Map stored type to dropdown value
          if (storedType === 'minus' || storedType === 'הפחתה' || storedType === 'הפחתה (-)') {
            selectedType = 'הפחתה (-)';
          } else if (storedType === 'plus' || storedType === 'תוספת' || storedType === 'תוספת (+)') {
            selectedType = 'תוספת (+)';
          } else {
            // Determine if it's percentage or amount based
            if (itemPercent !== undefined && itemPercent !== null && itemPercent !== '') {
              selectedType = '%';
            } else if (itemAmount !== undefined && itemAmount !== null && itemAmount !== '') {
              selectedType = '₪';
            } else {
              selectedType = '%'; // default
            }
          }
          
          
          const description = adj.value || adj.description || '';
          // Escape HTML entities to preserve special characters
          const escapedDescription = description
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
          // Populate percentage and amount from adjustment data (handle negative values properly)
          let percentage = '';
          let amount = '';
          
          // CRITICAL FIX: Percentage should always show positive in UI, type dropdown controls sign
          if (itemPercent !== undefined && itemPercent !== null && itemPercent !== '') {
            let cleanPercent = itemPercent;
            if (typeof itemPercent === 'string') {
              cleanPercent = itemPercent.replace('%', '');
            }
            const parsedPercent = parseFloat(cleanPercent);
            // ALWAYS show positive percentage - type dropdown controls the actual sign
            percentage = !isNaN(parsedPercent) ? Math.abs(parsedPercent) : '';
            console.log(`🔧 PERCENTAGE FIX: original=${parsedPercent}, displayed=${percentage}, type=${selectedType}`);
          } else {
            percentage = '';
          }
          
          // PRESERVE SIGN - don't use Math.abs() 
          if (adj.amount_display) {
            amount = adj.amount_display;
          } else if (adj.amount) {
            const amountValue = parseFloat(adj.amount);
            if (amountValue < 0) {
              amount = `-₪${Math.abs(amountValue).toLocaleString()}`;
            } else {
              amount = `₪${amountValue.toLocaleString()}`;
            }
          } else {
            amount = '';
          }
          const isPercent = selectedType === '%';
          const isAmount = selectedType === '₪';
          
          // Make features and registration read-only in Total Market Value section
          const isReadOnlyCategory = (category === 'features' || category === 'registration');
          const readOnlyAttr = isReadOnlyCategory ? 'readonly' : '';
          const readOnlyStyle = isReadOnlyCategory ? ' background: #f8f9fa; color: #6c757d;' : '';
          const disabledAttr = isReadOnlyCategory ? 'disabled' : '';
          
          console.log(`🔒 Making ${category} read-only in Total Market Value: ${isReadOnlyCategory}`);
          
          const html = `
            <div id="${rowId}" class="adjustment-row" data-source="${source}">
              <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
                <div><input type="text" placeholder="תיאור התאמה" value="${escapedDescription}" ${readOnlyAttr} style="${readOnlyStyle}" ${isReadOnlyCategory ? '' : `onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, '${category}');"`} /></div>
                <div>
                  ${category === 'additional' ? 
                    `<select ${disabledAttr} style="${readOnlyStyle}" ${isReadOnlyCategory ? '' : `onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, '${category}');"`}>
                      <option value="plus" ${adj.type === 'plus' || selectedType === 'תוספת (+)' ? 'selected' : ''}>תוספת (+)</option>
                      <option value="minus" ${adj.type === 'minus' || selectedType === 'הפחתה (-)' ? 'selected' : ''}>הפחתה (-)</option>
                    </select>` :
                    `<select ${disabledAttr} style="${readOnlyStyle}" ${isReadOnlyCategory ? '' : `onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, '${category}');"`}>
                      <option value="%" ${selectedType === '%' ? 'selected' : ''}>%</option>
                      <option value="₪" ${selectedType === '₪' ? 'selected' : ''}>₪</option>
                      <option value="plus" ${selectedType === 'תוספת (+)' || adj.type === 'plus' ? 'selected' : ''}>תוספת (+)</option>
                      <option value="minus" ${selectedType === 'הפחתה (-)' || adj.type === 'minus' ? 'selected' : ''}>הפחתה (-)</option>
                    </select>`
                  }
                </div>
                <div><input type="text" placeholder="אחוז" value="${percentage}" ${readOnlyAttr || (!isPercent ? 'readonly' : '')} style="direction: ltr; text-align: right;${readOnlyStyle}${!isPercent ? ' background: #f0f0f0;' : ''}" ${isReadOnlyCategory ? '' : `onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, '${category}');"`} /></div>
                <div><input type="text" placeholder="ערך" value="${amount}" ${readOnlyAttr || (isPercent ? 'readonly' : '')} style="direction: ltr; text-align: right;${readOnlyStyle}${isPercent ? ' background: #f0f0f0;' : ''}" ${isReadOnlyCategory ? '' : `onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, '${category}');"`} /></div>
                <div>
                  ${isReadOnlyCategory ? 
                    '<span style="color: #6c757d; font-size: 12px;">קריאה בלבד</span>' : 
                    `<button class="btn remove" type="button" onclick="removeAdjustmentRow('${rowId}')">הסר</button>`
                  }
                </div>
              </div>
              <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
                ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">${adj.cumulative ? `₪${adj.cumulative.toLocaleString()}` : '₪0'}</span>
              </div>
            </div>
          `;
          
          // Apply formatting after row is created AND trigger change events for consistency
          setTimeout(() => {
            const row = document.getElementById(rowId);
            if (row) {
              const inputs = row.querySelectorAll('input, select');
              if (inputs.length >= 4) {
                // Trigger change events (CRITICAL FOR MINUS SIGN DETECTION)
                inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
                if (inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
                if (inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
                
                // Also call formatAdjustmentDisplay directly as backup
                const itemPercent = adj.percentage || adj.percent;
                const itemAmount = adj.amount;
                formatAdjustmentDisplay(row, selectedType, itemPercent, itemAmount);
              }
            }
          }, 150);
          
          return html;
        }
        
        // 1. Load features from final_report.adjustments into fullFeaturesAdjustmentsList
        const featuresContainer = document.getElementById('fullFeaturesAdjustmentsList');
        if (featuresContainer) {
          featuresContainer.innerHTML = '';
          const features = finalReportAdjustments.features || [];
          console.log('📦 Loading features from final_report.adjustments:', features);
          if (Array.isArray(features)) {
            features.forEach((adj, index) => {
              console.log(`🔍 Processing features[${index}]:`, adj);
              // Load all non-empty items (check for any content)
              if (adj && (adj.value || adj.description || adj.percentage || adj.percent || adj.amount)) {
                const rowHtml = createTotalValueRow(adj, 'features', 'final_report');
                featuresContainer.insertAdjacentHTML('beforeend', rowHtml);
                
                // Update row cumulative if available from helper
                if (adj.cumulative !== undefined) {
                  setTimeout(() => {
                    const rows = featuresContainer.querySelectorAll('.adjustment-row');
                    const lastRow = rows[rows.length - 1];
                    const cumulativeSpan = lastRow?.querySelector('.row-cumulative');
                    if (cumulativeSpan) {
                      cumulativeSpan.textContent = `₪${Math.round(adj.cumulative).toLocaleString()}`;
                    }
                  }, 10);
                }
                console.log(`✅ Added features[${index}] to Total Value Section`);
              } else {
                console.log(`⚠️ Skipped features[${index}] - no content`);
              }
            });
          }
          console.log(`✅ Loaded ${features.length} total features, filtered and added to Total Value Section`);
        }
        
        // 2. Load registration from final_report.adjustments into fullRegistrationAdjustmentsList
        const registrationContainer = document.getElementById('fullRegistrationAdjustmentsList');
        if (registrationContainer) {
          registrationContainer.innerHTML = '';
          const registration = finalReportAdjustments.registration || [];
          console.log('📦 Loading registration from final_report.adjustments:', registration);
          if (Array.isArray(registration)) {
            registration.forEach((adj, index) => {
              console.log(`🔍 Processing registration[${index}]:`, adj);
              // Load all non-empty items (check for any content)
              if (adj && (adj.value || adj.description || adj.percentage || adj.percent || adj.amount)) {
                const rowHtml = createTotalValueRow(adj, 'registration', 'final_report');
                registrationContainer.insertAdjacentHTML('beforeend', rowHtml);
                
                // Update row cumulative if available from helper
                if (adj.cumulative !== undefined) {
                  setTimeout(() => {
                    const rows = registrationContainer.querySelectorAll('.adjustment-row');
                    const lastRow = rows[rows.length - 1];
                    const cumulativeSpan = lastRow?.querySelector('.row-cumulative');
                    if (cumulativeSpan) {
                      cumulativeSpan.textContent = `₪${Math.round(adj.cumulative).toLocaleString()}`;
                    }
                  }, 10);
                }
                console.log(`✅ Added registration[${index}] to Total Value Section`);
              } else {
                console.log(`⚠️ Skipped registration[${index}] - no content`);
              }
            });
          }
          console.log(`✅ Loaded ${registration.length} total registration, filtered and added to Total Value Section`);
        }
        
        // 3. Load KM from final_report.adjustments (priority) with fallback to estimate/valuation
        const mileageContainer = document.getElementById('mileageAdjustmentsList');
        if (mileageContainer) {
          mileageContainer.innerHTML = '';
          
          // FIXED: Load from final_report.adjustments FIRST (preserves manual additions)
          let mileage = finalReportAdjustments.mileage || [];
          let source = 'final_report';
          
          // Only fall back to estimate/valuation if final_report is empty
          if (!Array.isArray(mileage) || mileage.length === 0) {
            // Fallback to estimate.adjustments.mileage
            mileage = estimateAdjustments.mileage || [];
            source = 'estimate';
            
            if (!Array.isArray(mileage) || mileage.length === 0) {
              // Final fallback to valuation.adjustments.mileage
              console.log(`🔍 DEBUG: Checking valuation fallback for mileage`, helper.valuation?.adjustments);
              const valuationMileage = helper.valuation?.adjustments?.mileage;
              if (valuationMileage) {
                mileage = Array.isArray(valuationMileage) ? valuationMileage : [valuationMileage];
                source = 'original';
                console.log(`📦 Fallback: Loading mileage from valuation.adjustments:`, {
                  originalData: valuationMileage,
                  processedArray: mileage
                });
              } else {
                console.log(`📦 No mileage data in any source`);
              }
            } else {
              console.log(`📦 Loading mileage from estimate.adjustments:`, mileage);
            }
          } else {
            console.log(`📦 Loading mileage from final_report.adjustments (preserving manual additions):`, mileage);
          }
          
          if (Array.isArray(mileage)) {
            mileage.forEach((adj, index) => {
              if (adj && (adj.value || adj.percentage || adj.percent || adj.amount)) {
                const rowHtml = createTotalValueRow(adj, 'mileage', source);
                mileageContainer.insertAdjacentHTML('beforeend', rowHtml);
                
                // Update row cumulative if available from helper
                if (adj.cumulative !== undefined) {
                  setTimeout(() => {
                    const rows = mileageContainer.querySelectorAll('.adjustment-row');
                    const lastRow = rows[rows.length - 1];
                    const cumulativeSpan = lastRow?.querySelector('.row-cumulative');
                    if (cumulativeSpan) {
                      cumulativeSpan.textContent = `₪${Math.round(adj.cumulative).toLocaleString()}`;
                    }
                  }, 10);
                }
                console.log(`✅ Added mileage adjustment from ${source}:`, adj.value || 'no description');
              }
            });
          }
          console.log(`✅ Loaded ${mileage.length} mileage adjustments to Total Value Section from ${source}`);
        }
        
        // 4. Load ownership_type from final_report.adjustments (priority) with fallback to estimate/valuation
        const ownershipContainer = document.getElementById('ownershipAdjustmentsList');
        if (ownershipContainer) {
          ownershipContainer.innerHTML = '';
          
          // FIXED: Load from final_report.adjustments FIRST (preserves manual additions)
          let ownership = finalReportAdjustments.ownership_type || [];
          let source = 'final_report';
          
          // Only fall back to estimate/valuation if final_report is empty
          if (!Array.isArray(ownership) || ownership.length === 0) {
            // Fallback to estimate.adjustments.ownership_type
            ownership = estimateAdjustments.ownership_type || estimateAdjustments.ownership || [];
            source = 'estimate';
            
            if (!Array.isArray(ownership) || ownership.length === 0) {
              // Final fallback to valuation.adjustments.ownership_type
              console.log(`🔍 DEBUG: Checking valuation fallback for ownership_type`, helper.valuation?.adjustments);
              const valuationOwnership = helper.valuation?.adjustments?.ownership_type;
              if (valuationOwnership) {
                ownership = Array.isArray(valuationOwnership) ? valuationOwnership : [valuationOwnership];
                source = 'original';
                console.log(`📦 Fallback: Loading ownership from valuation.adjustments:`, {
                  originalData: valuationOwnership,
                  processedArray: ownership
                });
              } else {
                console.log(`📦 No ownership data in any source`);
              }
            } else {
              console.log(`📦 Loading ownership from estimate.adjustments:`, ownership);
            }
          } else {
            console.log(`📦 Loading ownership from final_report.adjustments (preserving manual additions):`, ownership);
          }
          
          if (Array.isArray(ownership)) {
            ownership.forEach((adj, index) => {
              if (adj && (adj.value || adj.percentage || adj.percent || adj.amount)) {
                const rowHtml = createTotalValueRow(adj, 'ownership_type', source);
                ownershipContainer.insertAdjacentHTML('beforeend', rowHtml);
                
                // Update row cumulative if available from helper
                if (adj.cumulative !== undefined) {
                  setTimeout(() => {
                    const rows = ownershipContainer.querySelectorAll('.adjustment-row');
                    const lastRow = rows[rows.length - 1];
                    const cumulativeSpan = lastRow?.querySelector('.row-cumulative');
                    if (cumulativeSpan) {
                      cumulativeSpan.textContent = `₪${Math.round(adj.cumulative).toLocaleString()}`;
                    }
                  }, 10);
                }
                console.log(`✅ Added ownership adjustment from ${source}:`, adj.value || 'no description');
              }
            });
          }
          console.log(`✅ Loaded ${ownership.length} ownership adjustments to Total Value Section from ${source}`);
        }
        
        // 5. Load ownership_history from final_report.adjustments (priority) with fallback to estimate/valuation
        const ownersContainer = document.getElementById('ownersAdjustmentsList');
        if (ownersContainer) {
          ownersContainer.innerHTML = '';
          
          // FIXED: Load from final_report.adjustments FIRST (preserves manual additions)
          let owners = finalReportAdjustments.ownership_history || [];
          let source = 'final_report';
          
          // Only fall back to estimate/valuation if final_report is empty
          if (!Array.isArray(owners) || owners.length === 0) {
            // Fallback to estimate.adjustments.ownership_history
            owners = estimateAdjustments.ownership_history || estimateAdjustments.owners || [];
            source = 'estimate';
            
            if (!Array.isArray(owners) || owners.length === 0) {
              // Final fallback to valuation.adjustments.ownership_history
              console.log(`🔍 DEBUG: Checking valuation fallback for ownership_history`, helper.valuation?.adjustments);
              const valuationOwners = helper.valuation?.adjustments?.ownership_history;
              if (valuationOwners) {
                owners = Array.isArray(valuationOwners) ? valuationOwners : [valuationOwners];
                source = 'original';
                console.log(`📦 Fallback: Loading owners from valuation.adjustments:`, {
                  originalData: valuationOwners,
                  processedArray: owners
                });
              } else {
                console.log(`📦 No owners data in any source`);
              }
            } else {
              console.log(`📦 Loading owners from estimate.adjustments:`, owners);
            }
          } else {
            console.log(`📦 Loading owners from final_report.adjustments (preserving manual additions):`, owners);
          }
          
          if (Array.isArray(owners)) {
            owners.forEach((adj, index) => {
              if (adj && (adj.value || adj.percentage || adj.percent || adj.amount)) {
                const rowHtml = createTotalValueRow(adj, 'ownership_history', source);
                ownersContainer.insertAdjacentHTML('beforeend', rowHtml);
                
                // Update row cumulative if available from helper
                if (adj.cumulative !== undefined) {
                  setTimeout(() => {
                    const rows = ownersContainer.querySelectorAll('.adjustment-row');
                    const lastRow = rows[rows.length - 1];
                    const cumulativeSpan = lastRow?.querySelector('.row-cumulative');
                    if (cumulativeSpan) {
                      cumulativeSpan.textContent = `₪${Math.round(adj.cumulative).toLocaleString()}`;
                    }
                  }, 10);
                }
                console.log(`✅ Added owners adjustment from ${source}:`, adj.value || 'no description');
              }
            });
          }
          console.log(`✅ Loaded ${owners.length} owners adjustments to Total Value Section from ${source}`);
        }
        
        // 6. Load additional from final_report.adjustments (priority) with fallback to estimate/valuation
        const additionalContainer = document.getElementById('allAdjustmentsList');
        if (additionalContainer) {
          additionalContainer.innerHTML = '';
          
          // FIXED: Load from final_report.adjustments FIRST (preserves manual additions)
          let additional = finalReportAdjustments.additional || [];
          let source = 'final_report';
          
          // Only fall back to estimate/valuation if final_report is empty
          if (!Array.isArray(additional) || additional.length === 0) {
            // Fallback to estimate.adjustments.additional
            additional = estimateAdjustments.additional || [];
            source = 'estimate';
            
            if (!Array.isArray(additional) || additional.length === 0) {
              // Final fallback to valuation.adjustments.additional
              const valuationAdditional = helper.valuation?.adjustments?.additional;
              if (valuationAdditional) {
                additional = Array.isArray(valuationAdditional) ? valuationAdditional : [valuationAdditional];
                source = 'original';
                console.log(`📦 Fallback: Loading additional from valuation.adjustments:`, additional);
              } else {
                console.log(`📦 No additional data in any source`);
              }
            } else {
              console.log(`📦 Loading additional from estimate.adjustments:`, additional);
            }
          } else {
            console.log(`📦 Loading additional from final_report.adjustments (preserving manual additions):`, additional);
          }
          
          if (Array.isArray(additional)) {
            additional.forEach((adj, index) => {
              if (adj && (adj.value || adj.percentage || adj.percent || adj.amount)) {
                // Create row with proper handlers for additional adjustments
                const rowId = 'fullAdj_' + Date.now() + '_' + Math.random();
                const newRow = `
                  <div id="${rowId}" class="adjustment-row" data-source="${source}">
                    <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
                      <div><input type="text" placeholder="תיאור התאמה נוספת" value="${adj.value || ''}" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional');" /></div>
                      <div><select onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));">
                        <option value="plus" ${adj.type === 'plus' ? 'selected' : ''}>תוספת (+)</option>
                        <option value="minus" ${adj.type === 'minus' ? 'selected' : ''}>הפחתה (-)</option>
                      </select></div>
                      <div><input type="text" placeholder="אחוז" value="${adj.percentage || adj.percent || ''}" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(this.value) || 0), safeParseAmount(inputs[3].value));" /></div>
                      <div><input type="text" placeholder="₪" value="${adj.amount_display || (adj.amount ? (adj.amount < 0 ? '-₪' + Math.abs(adj.amount).toLocaleString() : '₪' + Math.abs(adj.amount).toLocaleString()) : '')}" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(this.value));" /></div>
                      <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
                    </div>
                    <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
                      ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
                    </div>
                  </div>
                `;
                additionalContainer.insertAdjacentHTML('beforeend', newRow);
                
                // Trigger formatAdjustmentDisplay for proper minus sign display and update cumulative
                setTimeout(() => {
                  const row = document.getElementById(rowId);
                  if (row) {
                    formatAdjustmentDisplay(row, adj.type, adj.percentage || adj.percent, adj.amount);
                    
                    // Update row cumulative if available from helper
                    if (adj.cumulative !== undefined) {
                      const cumulativeSpan = row.querySelector('.row-cumulative');
                      if (cumulativeSpan) {
                        cumulativeSpan.textContent = `₪${Math.round(adj.cumulative).toLocaleString()}`;
                      }
                    }
                  }
                }, 10);
                
                console.log(`✅ Added additional adjustment from ${source}:`, adj.value || 'no description');
              }
            });
          }
          
          console.log(`✅ Loaded ${additional.length} additional adjustments to Total Value Section from ${source}`);
        }
        
        console.log('✅ Completed loading Total Value Section adjustments');
        
      } catch (error) {
        console.error('Error loading Total Value Section adjustments:', error);
      }
    }
    
    // RELOAD GROSS ADJUSTMENTS - triggered by reload button
    function reloadGrossAdjustments() {
      try {
        console.log('🔄 Reloading gross adjustments from estimate.adjustments with fallback to valuation.adjustments');
        
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // FIXED: Only clear Gross section data (features and registration), preserve Total section data
        if (helper.final_report && helper.final_report.adjustments) {
          // Preserve Total section data before clearing
          const preservedData = {
            mileage: helper.final_report.adjustments.mileage || [],
            ownership_type: helper.final_report.adjustments.ownership_type || [],
            ownership_history: helper.final_report.adjustments.ownership_history || [],
            usage: helper.final_report.adjustments.usage || [],
            additional: helper.final_report.adjustments.additional || []
          };
          
          // Clear only features and registration (Gross section data)
          helper.final_report.adjustments.features = [];
          helper.final_report.adjustments.registration = [];
          
          // Restore preserved Total section data
          Object.assign(helper.final_report.adjustments, preservedData);
          
          console.log('🧹 Cleared only Gross section data (features & registration), preserved Total section data');
          console.log('📦 Preserved Total section data:', preservedData);
        }
        
        // Clear existing rows
        const featuresContainer = document.getElementById('featuresAdjustmentsList');
        const registrationContainer = document.getElementById('registrationAdjustmentsList');
        
        if (featuresContainer) featuresContainer.innerHTML = '';
        if (registrationContainer) registrationContainer.innerHTML = '';
        
        // FORCE reload from estimate.adjustments (button overrides user changes)
        const adjustments = helper.estimate?.adjustments || helper.valuation?.adjustments || {};
        
        console.log('📍 Force loading from: estimate.adjustments → valuation.adjustments (button override)');
        console.log('🔍 Available adjustments data:', adjustments);
        
        // Load features and registration only (for gross section)
        const categories = [
          { key: 'features', addFunction: addFeatureAdjustment, container: featuresContainer },
          { key: 'registration', addFunction: addRegistrationAdjustment, container: registrationContainer }
        ];
        
        categories.forEach(({ key, addFunction, container }) => {
          const categoryData = adjustments[key];
          if (categoryData && container) {
            console.log(`📝 Loading ${key} adjustments:`, categoryData);
            
            // Handle both array and single object data
            const items = Array.isArray(categoryData) ? categoryData : (categoryData && (categoryData.percent || categoryData.percentage || categoryData.amount) ? [categoryData] : []);
            
            items.forEach((item, index) => {
              if (item && (item.percent || item.percentage || item.amount)) {
                // Add new row
                addFunction();
                
                // Fill the data
                const rows = container.querySelectorAll('div[id*="Adj_"]');
                const lastRow = rows[rows.length - 1];
                
                if (lastRow) {
                  const inputs = lastRow.querySelectorAll('input, select');
                  if (inputs.length >= 4) {
                    // Field mapping: value → תיאור (description)
                    inputs[0].value = item.value || '';
                    
                    // Type dropdown - use stored type directly
                    const itemPercent = item.percentage || item.percent;
                    const itemAmount = item.amount;
                    // FIX: Trust the stored type instead of detecting from values
                    const storedType = item.type || 'plus';
                    // Handle Hebrew type values
                    if (storedType === 'הפחתה' || storedType === 'הפחתה (-)' || storedType === 'הורדה' || storedType === 'minus') {
                      inputs[1].value = 'minus';
                    } else if (storedType === 'תוספת' || storedType === 'תוספת (+)' || storedType === 'plus') {
                      inputs[1].value = 'plus';
                    } else if (storedType === '%' || storedType === '₪') {
                      inputs[1].value = storedType;
                    } else {
                      // Default to plus if type is unclear
                      inputs[1].value = 'plus';
                    }
                    
                    // Percent and amount - preserve sign based on type
                    inputs[2].value = itemPercent ? Math.abs(itemPercent) : '';
                    
                    // FIXED: Preserve amount display properly
                    if (item.amount_display) {
                      inputs[3].value = item.amount_display;
                    } else if (item.amount !== undefined && item.amount !== 0) {
                      const absAmount = Math.abs(item.amount);
                      inputs[3].value = `₪${absAmount.toLocaleString()}`;
                    } else {
                      inputs[3].value = '';
                    }
                    
                    // Trigger change events
                    inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
                    if (inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
                    if (inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
                    
                    // Mark source based on data origin
                    const dataSource = item.source || 'estimate'; // Use original source if available
                    lastRow.setAttribute('data-source', dataSource);
                    
                    if (dataSource === 'manual') {
                      lastRow.style.background = '#fff8e1';
                      lastRow.style.border = '1px solid #ff9800';
                    } else {
                      lastRow.style.background = '#e8f5e8';
                      lastRow.style.border = '1px solid #28a745';
                    }
                    
                    console.log(`✅ Reloaded ${key} item ${index}:`, {
                      description: inputs[0].value,
                      type: inputs[1].value,
                      percent: inputs[2].value,
                      amount: inputs[3].value
                    });
                  }
                }
              }
            });
          }
        });
        
        // No need to load manual entries separately - final_report.adjustments already contains all data
        
        // Trigger calculation after reloading
        updateGrossMarketValueCalculation();
        
        // DELAY before updating helper to ensure UI is fully loaded
        setTimeout(() => {
          // REMOVED: updateHelperFromAdjustments() to prevent overwriting calculated amounts on page load
          
          // CRITICAL: Save current state to sessionStorage so refresh loads correct data
          const updatedHelper = window.helper || {};
          sessionStorage.setItem('helper', JSON.stringify(updatedHelper));
          console.log('💾 Saved updated helper to sessionStorage after reload with delay');
        }, 300);
        
        console.log('✅ Gross adjustments reload completed');
        
      } catch (error) {
        console.error('❌ Error reloading gross adjustments:', error);
      }
    }
    
    // GROSS DAMAGE PERCENTAGE CALCULATION FUNCTIONS
    
    // Add feature adjustment row
    function addFeatureAdjustment() {
      const container = document.getElementById('featuresAdjustmentsList');
      const rowId = 'featureAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור המאפיין" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'features');" /></div>
            <div><select onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));">
              <option value="plus">תוספת (+)</option>
              <option value="minus">הפחתה (-)</option>
            </select></div>
            <div><input type="text" placeholder="אחוז" oninput="calculateAdjustmentValueSimple(this);" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(this.value) || 0), safeParseAmount(inputs[3].value));" /></div>
            <div><input type="text" placeholder="₪" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(this.value));" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      updateGrossMarketValueCalculation();
    }
    
    // Add registration adjustment row
    function addRegistrationAdjustment() {
      const container = document.getElementById('registrationAdjustmentsList');
      const rowId = 'regAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור עליה לכביש" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');" /></div>
            <div><select onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));">
              <option value="plus">תוספת (+)</option>
              <option value="minus">הפחתה (-)</option>
            </select></div>
            <div><input type="text" placeholder="אחוז" oninput="calculateAdjustmentValueSimple(this);" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(this.value) || 0), safeParseAmount(inputs[3].value));" /></div>
            <div><input type="text" placeholder="₪" onchange="updateGrossMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('div[data-source]'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(this.value));" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      updateGrossMarketValueCalculation();
    }
    
    // ============================================================================
    // AUTO-POPULATION FROM LEVI SUMMARY
    // ============================================================================
    
    // Flag to prevent multiple executions
    let autoPopulationInProgress = false;
    let autoPopulationCompleted = sessionStorage.getItem('autoPopulationCompleted') === 'true';
    
    /**
     * Auto-populate features and registration adjustments from Levi summary data
     */
    function autoPopulateFromLeviSummary() {
      if (autoPopulationInProgress) {
        console.log('⚠️ Auto-population already in progress, skipping...');
        return;
      }
      
      if (autoPopulationCompleted) {
        console.log('⚠️ Auto-population already completed, skipping...');
        return;
      }
      
      // NEW: Don't auto-populate if final_report.adjustments already has user data
      const helper = window.helper || {};
      if (helper.final_report?.adjustments?.features?.length > 0 || helper.final_report?.adjustments?.registration?.length > 0) {
        console.log('⚠️ User data exists in final_report.adjustments, skipping auto-population');
        autoPopulationCompleted = true;
        sessionStorage.setItem('autoPopulationCompleted', 'true');
        return;
      }
      
      autoPopulationInProgress = true;
      console.log('🚀 Starting auto-population from Levi summary...');
      
      // ENHANCED: Ensure FinalReportCalculations is ready before proceeding
      if (!window.FinalReportCalculations) {
        console.log('⏳ FinalReportCalculations not ready, waiting...');
        setTimeout(() => {
          autoPopulationInProgress = false;
          autoPopulateFromLeviSummary();
        }, 200);
        return;
      }
      
      // Use the helper already declared above
      // const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Check for valuation adjustments (primary source) and fallback sources
      if (!helper.valuation?.adjustments && !helper.levisummary && !helper.levi_report && !helper.expertise?.levi_report) {
        autoPopulationInProgress = false;
        return;
      }
      
      clearLeviAdjustments();
      
      // Get Levi data from valuation adjustments (primary) or fallback sources
      const leviData = helper.valuation?.adjustments || helper.levisummary || helper.levi_report || helper.expertise?.levi_report || {};
      const featuresData = leviData.features || {};
      const registrationData = leviData.registration || {};
      
      // Auto-populate features adjustments (מאפיינים) - GROSS section only
      // ENHANCED: Try multiple possible field locations for better data capture
      const featuresPercent = featuresData.percent || featuresData.percentage || 
                             leviData['מחיר מאפיינים %'] || leviData['מאפיינים %'] || 
                             helper['מחיר מאפיינים %'] || helper['מאפיינים %'] ||
                             helper.levi?.['מחיר מאפיינים %'] ||
                             helper.expertise?.levi_report?.['מחיר מאפיינים %'] || '';
      const featuresAmount = featuresData.amount || featuresData.value || 
                            leviData['ערך ש"ח מאפיינים'] || leviData['ערך מאפיינים'] || 
                            helper['ערך ש"ח מאפיינים'] || helper['ערך מאפיינים'] ||
                            helper.levi?.['ערך ש"ח מאפיינים'] ||
                            helper.expertise?.levi_report?.['ערך ש"ח מאפיינים'] || '';
      const featuresDescription = featuresData.description || featuresData.reason || 'תוספות מאפיינים';
      
      if (featuresPercent || featuresAmount) {
        if (typeof addFeatureAdjustment === 'function') {
          addFeatureAdjustment();
        }
        
        const rows = document.querySelectorAll('#featuresAdjustmentsList > div');
        const lastRow = rows[rows.length - 1];
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            inputs[0].value = featuresDescription || 'תוספות מאפיינים (מלוי יצחק)';
            inputs[1].value = String(featuresPercent).includes('-') ? 'minus' : 'plus';
            // CRITICAL FIX: Display minus sign for negative values
            const featuresPercentValue = parseFloat(String(featuresPercent).replace(/[%\s+]/g, '')) || 0;
            const displayFeaturesPercent = String(featuresPercent).includes('-') ? `-${Math.abs(featuresPercentValue)}` : Math.abs(featuresPercentValue);
            inputs[2].value = displayFeaturesPercent || '';
            // CRITICAL FIX: Display minus sign for amount values too
            const featuresAmountValue = parseFloat(String(featuresAmount).replace(/[₪,\s]/g, '')) || 0;
            const displayFeaturesAmount = String(featuresPercent).includes('-') ? `-${Math.abs(featuresAmountValue)}` : Math.abs(featuresAmountValue);
            inputs[3].value = featuresAmount ? `₪${displayFeaturesAmount.toLocaleString()}` : '';
            
            lastRow.setAttribute('data-source', 'levi');
            lastRow.style.background = '#f0f8ff';
          }
        }
      }
      
      // Auto-populate registration adjustments (עליה לכביש) - GROSS section only  
      // ENHANCED: Try multiple possible field locations for better data capture
      const registrationPercent = registrationData.percent || registrationData.percentage || 
                                 leviData['עליה לכביש %'] || 
                                 helper['עליה לכביש %'] ||
                                 helper.levi?.['עליה לכביש %'] ||
                                 helper.expertise?.levi_report?.['עליה לכביש %'] || '';
      const registrationAmount = registrationData.amount || registrationData.value ||
                                leviData['ערך ש"ח עליה לכביש'] || leviData['ערך עליה לכביש'] ||
                                helper['ערך ש"ח עליה לכביש'] || helper['ערך עליה לכביש'] ||
                                helper.levi?.['ערך ש"ח עליה לכביש'] ||
                                helper.expertise?.levi_report?.['ערך ש"ח עליה לכביש'] || '';
      const registrationDescription = registrationData.description || registrationData.reason || 'עליה לכביש';
      
      if (registrationPercent || registrationAmount) {
        if (typeof addRegistrationAdjustment === 'function') {
          addRegistrationAdjustment();
        }
        
        const rows = document.querySelectorAll('#registrationAdjustmentsList > div');
        const lastRow = rows[rows.length - 1];
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            inputs[0].value = registrationDescription || 'עליה לכביש (מלוי יצחק)';
            inputs[1].value = String(registrationPercent).includes('-') ? 'minus' : 'plus';
            // CRITICAL FIX: Display minus sign for negative values
            const registrationPercentValue = parseFloat(String(registrationPercent).replace(/[%\s+]/g, '')) || 0;
            const displayRegistrationPercent = String(registrationPercent).includes('-') ? `-${Math.abs(registrationPercentValue)}` : Math.abs(registrationPercentValue);
            inputs[2].value = displayRegistrationPercent || '';
            
            // CRITICAL FIX: Display minus sign for amount values too
            const registrationAmountValue = parseFloat(String(registrationAmount).replace(/[₪,\s]/g, '')) || 0;
            const displayRegistrationAmount = String(registrationPercent).includes('-') ? `-${Math.abs(registrationAmountValue)}` : Math.abs(registrationAmountValue);
            inputs[3].value = registrationAmount ? `₪${displayRegistrationAmount.toLocaleString()}` : '';
            
            lastRow.setAttribute('data-source', 'levi');
            lastRow.style.background = '#f0f8ff';
          }
        }
      }
      
      // ===== END OF GROSS ADJUSTMENTS =====
      // Note: Market adjustments (mileage, ownership, owners) belong in "Full Market Value" section,
      // not in the gross value section which is only for car properties (features + registration)
      
      // Trigger calculations after auto-population
      setTimeout(() => {
        if (typeof updateGrossMarketValueCalculation === 'function') {
          updateGrossMarketValueCalculation();
        }
        // REMOVED: updateHelperFromAdjustments() to prevent overwriting calculated amounts on page load
        if (window.FinalReportCalculations && typeof window.FinalReportCalculations.refresh3BulkCalculations === 'function') {
          window.FinalReportCalculations.refresh3BulkCalculations();
        }
      }, 100);
      
      autoPopulationInProgress = false;
      autoPopulationCompleted = true;
      sessionStorage.setItem('autoPopulationCompleted', 'true');
    }
    
    /**
     * Auto-populate market adjustments (mileage, ownership) for Full Market Value section
     */
    function autoPopulateMarketAdjustments() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const adjustments = helper.estimate?.adjustments || {};
      
      console.log('🏪 Auto-populating market adjustments from helper.estimate.adjustments');
      console.log('🔍 Available adjustments:', adjustments);
      
      // Get base price for calculations
      let basePrice = 0;
      const basicPriceField = document.getElementById('basicPrice');
      if (basicPriceField && basicPriceField.value) {
        basePrice = parseFloat(basicPriceField.value.replace(/[₪,]/g, '')) || 0;
      }
      console.log('📊 Base price for calculations:', basePrice);
      
      // Clear existing auto-populated adjustments from ALL containers
      const containers = [
        'fullFeaturesAdjustmentsList',
        'fullRegistrationAdjustmentsList', 
        'mileageAdjustmentsList',
        'ownershipAdjustmentsList',
        'ownersAdjustmentsList'
      ];
      
      containers.forEach(containerId => {
        const container = document.getElementById(containerId);
        if (container) {
          const leviRows = container.querySelectorAll('div[data-source="levi"]');
          leviRows.forEach(row => row.remove());
          console.log(`🧹 Cleared ${leviRows.length} Levi rows from ${containerId}`);
        }
      });
      
      // Auto-populate adjustments in CORRECT ORDER as per user requirements:
      // 1. Features → 2. Registration → 3. Mileage → 4. Ownership → 5. Owners
      // FIXED: Use correct keys from helper data structure
      const adjustmentMapping = [
        { key: 'features', label: 'תוספות מאפיינים', containerId: 'fullFeaturesAdjustmentsList', addFunction: addFullFeaturesAdjustment },
        { key: 'registration', label: 'עליה לכביש', containerId: 'fullRegistrationAdjustmentsList', addFunction: addFullRegistrationAdjustment },
        { key: 'mileage', label: 'מס ק"מ', containerId: 'mileageAdjustmentsList', addFunction: addMileageAdjustment },
        { key: 'ownership_type', label: 'סוג בעלות', containerId: 'ownershipAdjustmentsList', addFunction: addOwnershipAdjustment },
        { key: 'ownership_history', label: 'מספר בעלים', containerId: 'ownersAdjustmentsList', addFunction: addOwnersAdjustment }
      ];
      
      adjustmentMapping.forEach(({ key, label, containerId, addFunction }) => {
        const adjData = adjustments[key] || [];
        console.log(`🔍 Processing ${key}:`, adjData);
        
        // Handle both array and single object data from estimate.adjustments
        const items = Array.isArray(adjData) ? adjData : (adjData && (adjData.percent || adjData.percentage || adjData.amount) ? [adjData] : []);
        
        items.forEach((item, index) => {
          if (item && (item.percent || item.percentage || item.amount)) {
            // Extract percentage - handle negative values  
            let percent = parseFloat(item.percent || item.percentage) || 0;
            
            // Extract amount
            let amount = parseFloat(item.amount) || 0;
            
            // Field mapping: value → תיאור
            const description = item.value || item.description || label;
          
            
            console.log(`📝 Importing ${key} item ${index}:`, {
              description,
              percent,
              amount,
              type: item.type
            });
            
            // Add the adjustment row
            addFunction();
            
            const container = document.getElementById(containerId);
            const rows = container.querySelectorAll('div.adjustment-row');
            const lastRow = rows[rows.length - 1];
            
            if (lastRow) {
              const inputs = lastRow.querySelectorAll('input, select');
              if (inputs.length >= 4) {
                // Use exact estimator builder logic for field assignment
                inputs[0].value = item.value || '';
                const itemPercent = item.percentage || item.percent;
                const itemAmount = item.amount;
                // FIX: Use stored type directly instead of detection
                const storedType = item.type || 'plus';
                if (storedType === 'הפחתה' || storedType === 'הפחתה (-)' || storedType === 'הורדה' || storedType === 'minus') {
                  inputs[1].value = 'minus';
                } else if (storedType === 'תוספת' || storedType === 'תוספת (+)' || storedType === 'plus') {
                  inputs[1].value = 'plus';
                } else {
                  inputs[1].value = storedType; // Use as-is for %, ₪ etc
                }
                // CRITICAL FIX: Display minus sign for negative values
                const displayPercent = isReductionType(item.type) && itemPercent > 0 ? `-${Math.abs(itemPercent)}` : Math.abs(itemPercent || 0);
                const displayAmount = isReductionType(item.type) && item.amount > 0 ? `-${Math.abs(item.amount)}` : Math.abs(item.amount || 0);
                
                inputs[2].value = itemPercent ? displayPercent : '';
                inputs[3].value = item.amount_display || (item.amount ? `₪${displayAmount.toLocaleString()}` : '');
              
              // Trigger onchange events to ensure handlers are active
              inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
              if (inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
              if (inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
              
              // Mark as Levi data
              lastRow.setAttribute('data-source', 'levi');
              lastRow.style.background = '#f0f8ff';
              lastRow.style.border = '1px solid #4a90e2';
              
              console.log(`✅ Populated ${key}:`, {
                description: inputs[0].value,
                type: inputs[1].value,
                percent: inputs[2].value,
                amount: inputs[3].value
              });
            }
          }
          }
        });
        
        if (items.length === 0) {
          console.log(`⚠️ No valid data for ${key}:`, adjData);
        }
      });
      
      // Trigger calculation after populating all adjustments
      if (typeof updateFullMarketValueCalculation === 'function') {
        setTimeout(() => {
          updateFullMarketValueCalculation();
          console.log('✅ Full market value calculation triggered after auto-population');
        }, 100);
      }
      
      console.log('✅ Market adjustments auto-population completed from helper.valuation.adjustments');
    }
    
    // RELOAD FULL MARKET ADJUSTMENTS - triggered by reload button
    function reloadFullMarketAdjustments() {
      try {
        console.log('🔄 Reloading Total Value adjustments with mixed sources: Features/Registration from final_report, Others from estimate');
        
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Mixed data sources for Total Value section reload:
        // - Features & Registration: from final_report.adjustments (sync with Gross section)
        // - Others (KM, Ownership, Owners, Additional): from estimate.adjustments (original Levi data)
        const estimateAdjustments = helper.estimate?.adjustments || helper.valuation?.adjustments || {};
        const finalReportAdjustments = helper.final_report?.adjustments || {};
        
        console.log('🔍 estimate.adjustments:', estimateAdjustments);
        console.log('🔍 final_report.adjustments:', finalReportAdjustments);
        
        // Clear existing rows from NON-SYNCED containers only (preserve features/registration)
        const containersToReload = [
          'mileageAdjustmentsList',
          'ownershipAdjustmentsList', 
          'ownersAdjustmentsList',
          'allAdjustmentsList'
        ];
        
        containersToReload.forEach(containerId => {
          const container = document.getElementById(containerId);
          if (container) {
            container.innerHTML = '';
            console.log(`🧹 Cleared container: ${containerId}`);
          }
        });
        
        console.log('⚠️ SKIPPING features/registration reload to preserve Total Value manual additions');
        
        // Load ONLY non-synced categories (skip features/registration to preserve manual additions)
        const adjustmentMapping = [
          // SKIPPED: features and registration to preserve Total Value manual additions
          { key: 'mileage', label: 'מס ק"מ', containerId: 'mileageAdjustmentsList', addFunction: addMileageAdjustment },
          { key: 'ownership_type', label: 'סוג בעלות', containerId: 'ownershipAdjustmentsList', addFunction: addOwnershipAdjustment },
          { key: 'ownership_history', label: 'מספר בעלים', containerId: 'ownersAdjustmentsList', addFunction: addOwnersAdjustment }
          // REMOVED: additional - it's handled separately in loadFullMarketValueData to avoid duplicates
        ];
        
        adjustmentMapping.forEach(({ key, label, containerId, addFunction }) => {
          // All categories now load from estimate.adjustments (no features/registration)
          const categoryData = estimateAdjustments[key];
          console.log(`📦 Loading ${key} from estimate.adjustments:`, categoryData);
          if (categoryData) {
            console.log(`📝 Loading ${key} adjustments:`, categoryData);
            
            const container = document.getElementById(containerId);
            if (container) {
              // Handle both array and single object data
              const items = Array.isArray(categoryData) ? categoryData : (categoryData && (categoryData.percent || categoryData.percentage || categoryData.amount) ? [categoryData] : []);
              
              items.forEach((item, index) => {
                if (item && (item.percent || item.percentage || item.amount)) {
                  // Add new row
                  addFunction();
                  
                  // Fill the data
                  const rows = container.querySelectorAll('div[id*="Adj_"]');
                  const lastRow = rows[rows.length - 1];
                  
                  if (lastRow) {
                    const inputs = lastRow.querySelectorAll('input, select');
                    if (inputs.length >= 4) {
                      // Field mapping: value → תיאור (description)
                      inputs[0].value = item.value || '';
                      
                      // Type dropdown - use stored type directly  
                      const itemPercent = item.percentage || item.percent;
                      const itemAmount = item.amount;
                      const storedType = item.type || 'plus';
                      if (storedType === 'minus' || storedType === 'הפחתה' || storedType === 'הפחתה (-)') {
                        inputs[1].value = 'minus';
                      } else if (storedType === 'plus' || storedType === 'תוספת' || storedType === 'תוספת (+)') {
                        inputs[1].value = 'plus';
                      } else {
                        inputs[1].value = storedType; // For % or ₪ types
                      }
                      
                      // Percent and amount - preserve sign based on type
                      inputs[2].value = itemPercent ? Math.abs(itemPercent) : '';
                      // Check if it's a reduction type to preserve minus sign
                      const isReduction = isReductionType(item.type);
                      let displayAmount = Math.abs(item.amount || 0);
                      if (isReduction && displayAmount > 0) {
                        displayAmount = -displayAmount;
                      }
                      inputs[3].value = item.amount_display || (item.amount ? `₪${displayAmount.toLocaleString()}` : '');
                      
                      // Trigger change events
                      inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
                      if (inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
                      if (inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
                      
                      // Mark as loaded data
                      lastRow.setAttribute('data-source', 'estimate');
                      lastRow.style.background = '#e8f5e8';
                      lastRow.style.border = '1px solid #28a745';
                      
                      console.log(`✅ Reloaded ${key} item ${index}:`, {
                        description: inputs[0].value,
                        type: inputs[1].value,
                        percent: inputs[2].value,
                        amount: inputs[3].value
                      });
                      
                      // Apply unified formatting to ensure proper minus signs
                      setTimeout(() => {
                        formatAdjustmentDisplay(lastRow, inputs[1].value, itemPercent, itemAmount);
                      }, 10);
                    }
                  }
                }
              });
            }
          }
        });
        
        // Trigger calculation after reloading
        if (typeof updateFullMarketValueCalculation === 'function') {
          setTimeout(() => {
            updateFullMarketValueCalculation();
            console.log('✅ Full market value calculation triggered after reload');
          }, 100);
        }
        
        // REMOVED: updateHelperFromAdjustments() to prevent overwriting calculated amounts on page load
        
        // CRITICAL: Save Total Value sections to helper after reload
        updateFullMarketValueToFinalReportAndValuation(helper);
        
        // Save updated helper to storage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        console.log('💾 Saved updated helper to storage after reload');
        
        console.log('✅ Full market adjustments reload completed');
        
      } catch (error) {
        console.error('❌ Error reloading full market adjustments:', error);
      }
    }
    
    /**
     * Clear existing auto-populated Levi adjustments before re-populating
     */
    function clearLeviAdjustments() {
      // Clear features adjustments marked as Levi data
      const featureRows = document.querySelectorAll('#featuresAdjustmentsList div[data-source="levi"]');
      console.log(`🧹 Clearing ${featureRows.length} Levi feature rows`);
      featureRows.forEach(row => row.remove());
      
      // Clear registration adjustments marked as Levi data
      const registrationRows = document.querySelectorAll('#registrationAdjustmentsList div[data-source="levi"]');
      console.log(`🧹 Clearing ${registrationRows.length} Levi registration rows`);
      registrationRows.forEach(row => row.remove());
      
      // Clear market adjustments marked as Levi data 
      const marketRows = document.querySelectorAll('#allAdjustmentsList div[data-source="levi"]');
      console.log(`🧹 Clearing ${marketRows.length} Levi market rows`);
      marketRows.forEach(row => row.remove());
      
      console.log('✅ Cleared all existing Levi adjustments');
    }
    
    /**
     * Enhanced two-way data binding: sync individual adjustment changes to helper
     */
    // UNIFIED DISPLAY FORMATTING FOR FEATURES AND REGISTRATION
    function formatAdjustmentDisplay(row, type, percent, amount) {
      try {
        const inputs = row.querySelectorAll('input, select');
        if (inputs.length < 4) return;
        
        const percentInput = inputs[2];
        const amountInput = inputs[3];
        
        
        // Determine if it's a reduction/subtraction
        const isReduction = isReductionType(type);
        
        
        // Determine field type based on category and data source
        // Features, KM, Ownership are typically percentage-based
        // Registration is typically amount-based
        const containerId = percentInput.closest('[id$="AdjustmentsList"]')?.id || '';
        
        // Simple logic: if we have percent data, show percentage mode; if we have amount data, show amount mode
        const hasPercent = (percent !== null && percent !== undefined && percent !== 0);
        const hasAmount = (amount !== null && amount !== undefined && amount !== 0);
        
        if (hasPercent && !hasAmount) {
          // Percentage mode: show percent value, make both editable
          percentInput.value = isReduction ? `-${Math.abs(percent)}` : Math.abs(percent);
          percentInput.readOnly = false;
          percentInput.style.background = '';
          amountInput.value = '';
          amountInput.readOnly = false;
          amountInput.style.background = '';
        } else if (hasAmount && !hasPercent) {
          // Amount mode: show amount value, make both editable
          const validAmount = safeParseAmount(amount);
          amountInput.value = validAmount === 0 ? '' : (isReduction ? `-₪${Math.abs(validAmount).toLocaleString()}` : `₪${Math.abs(validAmount).toLocaleString()}`);
          amountInput.readOnly = false;
          amountInput.style.background = '';
          percentInput.value = '';
          percentInput.readOnly = false;
          percentInput.style.background = '';
        } else {
          // Default: make both fields editable
          const validAmount = safeParseAmount(amount);
          percentInput.value = isReduction && percent ? `-${Math.abs(percent)}` : Math.abs(percent || 0);
          amountInput.value = validAmount === 0 ? '' : (isReduction ? `-₪${Math.abs(validAmount).toLocaleString()}` : `₪${Math.abs(validAmount).toLocaleString()}`);
          percentInput.readOnly = false;
          amountInput.readOnly = false;
          percentInput.style.background = '';
          amountInput.style.background = '';
        }
        
        
      } catch (error) {
        console.error('Error in formatAdjustmentDisplay:', error);
      }
    }

    // Save adjustment amount immediately without waiting for field change
    function saveAdjustmentAmount(category, amount, cumulativeValue) {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Ensure structures exist
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // Round amount to whole number
        const roundedAmount = Math.round(amount);
        const roundedCumulative = cumulativeValue !== undefined ? Math.round(cumulativeValue) : undefined;
        
        // Format amount display with rounded value
        const amountDisplay = roundedAmount !== 0 ? `₪${Math.abs(roundedAmount).toLocaleString()}` : '';
        
        // Update valuation.adjustments
        if (!helper.valuation.adjustments[category]) {
          helper.valuation.adjustments[category] = {};
        }
        helper.valuation.adjustments[category].amount = roundedAmount;
        helper.valuation.adjustments[category].amount_display = amountDisplay;
        if (roundedCumulative !== undefined) {
          helper.valuation.adjustments[category].cumulative = roundedCumulative;
        }
        
        // Update final_report.adjustments (ensure array exists and update first item)
        if (!helper.final_report.adjustments[category]) {
          helper.final_report.adjustments[category] = [];
        }
        if (helper.final_report.adjustments[category].length === 0) {
          helper.final_report.adjustments[category].push({});
        }
        helper.final_report.adjustments[category][0].amount = roundedAmount;
        helper.final_report.adjustments[category][0].amount_display = amountDisplay;
        if (roundedCumulative !== undefined) {
          helper.final_report.adjustments[category][0].cumulative = roundedCumulative;
        }
        
        // Save to storage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        console.log(`💾 Saved amount for ${category}: ${roundedAmount} (cumulative: ${roundedCumulative})`);
      } catch (error) {
        console.error('Error saving adjustment amount:', error);
      }
    }

    // Restore adjustment amounts from helper data on page load
    function restoreAdjustmentAmounts() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        console.log('🔄 Restoring adjustment amounts from helper...');
        console.log('🔍 DEBUG: helper.valuation.adjustments:', helper.valuation?.adjustments);
        
        // Restore amounts for our three categories plus additional
        const categories = ['mileage', 'ownership_type', 'ownership_history', 'additional'];
        
        categories.forEach(category => {
          // Check both locations for amount data
          const valuationAmount = helper.valuation?.adjustments?.[category]?.amount;
          const finalReportAmount = helper.final_report?.adjustments?.[category]?.[0]?.amount;
          
          console.log(`🔍 DEBUG ${category}: valuationAmount=${valuationAmount}, finalReportAmount=${finalReportAmount}`);
          
          // Use valuation amount if available, otherwise final_report
          const amount = valuationAmount !== undefined ? valuationAmount : finalReportAmount;
          
          if (amount !== undefined && amount !== 0) {
            // Round the amount to ensure no fractions
            const roundedAmount = Math.round(amount);
            console.log(`📖 Found saved amount for ${category}: ${roundedAmount}`);
            
            // Find the corresponding container
            let containerId = '';
            if (category === 'mileage') containerId = 'mileageAdjustmentsList';
            else if (category === 'ownership_type') containerId = 'ownershipAdjustmentsList';
            else if (category === 'ownership_history') containerId = 'ownersAdjustmentsList';
            else if (category === 'additional') containerId = 'allAdjustmentsList';
            
            const container = document.getElementById(containerId);
            if (container) {
              const rows = container.querySelectorAll('div[id*="Adj_"]');
              if (rows.length > 0) {
                // Update the first row's amount field (original working logic)
                const firstRow = rows[0];
                const inputs = firstRow.querySelectorAll('input[type="text"]');
                if (inputs.length >= 3) {
                  const valueInput = inputs[2]; // Amount field
                  if (valueInput) {
                    valueInput.value = roundedAmount < 0 ? `-₪${Math.abs(roundedAmount).toLocaleString()}` : `₪${Math.abs(roundedAmount).toLocaleString()}`;
                    console.log(`✅ Restored amount for ${category} first row in UI`);
                  }
                }
              }
              
              // EXTEND: Also restore added rows (index > 0) from final_report.adjustments
              const finalReportAdjustments = helper.final_report?.adjustments?.[category];
              if (finalReportAdjustments && finalReportAdjustments.length > 1) {
                for (let i = 1; i < finalReportAdjustments.length; i++) {
                  const savedAdjustment = finalReportAdjustments[i];
                  if (savedAdjustment && savedAdjustment.amount !== undefined && rows[i]) {
                    const addedRow = rows[i];
                    const addedInputs = addedRow.querySelectorAll('input[type="text"]');
                    if (addedInputs.length >= 3) {
                      const addedValueInput = addedInputs[2]; // Amount field
                      if (addedValueInput) {
                        const savedAmount = Math.round(savedAdjustment.amount);
                        addedValueInput.value = savedAmount < 0 ? `-₪${Math.abs(savedAmount).toLocaleString()}` : `₪${Math.abs(savedAmount).toLocaleString()}`;
                        console.log(`✅ Restored amount for ${category} added row ${i}: ${savedAmount}`);
                        console.log(`🔍 Input value after restore: "${addedValueInput.value}"`);
                      }
                    }
                  }
                }
              }
            }
          }
        });
        
        // Trigger calculation update to refresh cumulative displays
        setTimeout(() => {
          updateFullMarketValueCalculation();
          
          // IMPORTANT: Restore added rows amounts AFTER calculation to prevent clearing
          setTimeout(() => {
            restoreAddedRowsAmounts();
          }, 200);
        }, 100);
        
      } catch (error) {
        console.error('Error restoring adjustment amounts:', error);
      }
    }

    // Separate function to restore added rows amounts after calculations
    function restoreAddedRowsAmounts() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        console.log('🔄 Restoring added rows amounts after calculations...');
        
        const categories = ['mileage', 'ownership_type', 'ownership_history', 'additional', 'features', 'registration'];
        
        categories.forEach(category => {
          let containerId = '';
          if (category === 'mileage') containerId = 'mileageAdjustmentsList';
          else if (category === 'ownership_type') containerId = 'ownershipAdjustmentsList';
          else if (category === 'ownership_history') containerId = 'ownersAdjustmentsList';
          else if (category === 'additional') containerId = 'allAdjustmentsList';
          else if (category === 'features') {
            // Check both gross and full market sections
            const grossContainer = document.getElementById('featuresAdjustmentsList');
            const fullContainer = document.getElementById('fullFeaturesAdjustmentsList');
            if (grossContainer && grossContainer.children.length > 0) containerId = 'featuresAdjustmentsList';
            else if (fullContainer && fullContainer.children.length > 0) containerId = 'fullFeaturesAdjustmentsList';
          }
          else if (category === 'registration') {
            // Check both gross and full market sections  
            const grossContainer = document.getElementById('registrationAdjustmentsList');
            const fullContainer = document.getElementById('fullRegistrationAdjustmentsList');
            if (grossContainer && grossContainer.children.length > 0) containerId = 'registrationAdjustmentsList';
            else if (fullContainer && fullContainer.children.length > 0) containerId = 'fullRegistrationAdjustmentsList';
          }
          
          if (!containerId) return;
          
          const container = document.getElementById(containerId);
          if (!container) return;
          
          const rows = container.querySelectorAll('div[id*="Adj_"]');
          const finalReportAdjustments = helper.final_report?.adjustments?.[category];
          
          if (finalReportAdjustments && finalReportAdjustments.length > 1) {
            for (let i = 1; i < finalReportAdjustments.length; i++) {
              const savedAdjustment = finalReportAdjustments[i];
              if (savedAdjustment && savedAdjustment.amount !== undefined && rows[i]) {
                const addedRow = rows[i];
                const addedInputs = addedRow.querySelectorAll('input[type="text"]');
                if (addedInputs.length >= 3) {
                  const addedValueInput = addedInputs[2]; // Amount field
                  if (addedValueInput) {
                    const savedAmount = Math.round(savedAdjustment.amount);
                    addedValueInput.value = savedAmount < 0 ? `-₪${Math.abs(savedAmount).toLocaleString()}` : `₪${Math.abs(savedAmount).toLocaleString()}`;
                    console.log(`✅ FINAL restore: ${category} added row ${i}: ${savedAmount}`);
                  }
                }
              }
            }
          }
        });
        
      } catch (error) {
        console.error('Error in restoreAddedRowsAmounts:', error);
      }
    }

    // Load additional adjustments from helper to UI
    function loadAdditionalAdjustments() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        console.log('🔄 Loading additional adjustments from helper...');
        
        // Check for additional adjustments in final_report
        const additionalAdjustments = helper.final_report?.adjustments?.additional || [];
        
        if (additionalAdjustments.length > 0) {
          const container = document.getElementById('allAdjustmentsList');
          if (!container) return;
          
          // Clear existing rows first
          container.innerHTML = '';
          
          // Create rows for each saved adjustment
          additionalAdjustments.forEach((adjustment, index) => {
            const rowId = 'fullAdj_' + Date.now() + '_' + index;
            const type = adjustment.type || 'plus';
            const description = adjustment.value || '';
            const percentage = adjustment.percentage || adjustment.percent || 0;
            const amount = adjustment.amount || 0;
            const amountDisplay = adjustment.amount_display || (amount !== 0 ? `₪${Math.abs(amount).toLocaleString()}` : '');
            
            const newRow = `
              <div id="${rowId}" class="adjustment-row" data-source="restored" style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
                <div><input type="text" placeholder="תיאור התאמה נוספת" value="${description}" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(inputs[2].value) || 0, safeParseAmount(inputs[3].value));" /></div>
                <div><select onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, parseFloat(inputs[2].value) || 0, safeParseAmount(inputs[3].value));">
                  <option value="plus" ${type === 'plus' ? 'selected' : ''}>תוספת (+)</option>
                  <option value="minus" ${type === 'minus' ? 'selected' : ''}>הפחתה (-)</option>
                </select></div>
                <div><input type="text" placeholder="אחוז" value="${Math.abs(percentage)}" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(this.value) || 0, safeParseAmount(inputs[3].value));" /></div>
                <div><input type="text" placeholder="₪" value="${amountDisplay}" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(inputs[2].value) || 0, safeParseAmount(this.value));" /></div>
                <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
              </div>
            `;
            
            container.insertAdjacentHTML('beforeend', newRow);
          });
          
          console.log(`✅ Loaded ${additionalAdjustments.length} additional adjustments to UI`);
        }
        
      } catch (error) {
        console.error('Error loading additional adjustments:', error);
      }
    }

    // Save only cumulative value for an adjustment category (without other fields)
    function saveAdjustmentCumulativeOnly(category, cumulativeValue) {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Ensure structures exist
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // Round cumulative value
        const roundedCumulative = Math.round(cumulativeValue);
        
        // Update valuation.adjustments cumulative
        if (!helper.valuation.adjustments[category]) {
          helper.valuation.adjustments[category] = {};
        }
        helper.valuation.adjustments[category].cumulative = roundedCumulative;
        
        // Update final_report.adjustments cumulative for all items in array
        if (helper.final_report.adjustments[category] && Array.isArray(helper.final_report.adjustments[category])) {
          helper.final_report.adjustments[category].forEach(item => {
            item.cumulative = roundedCumulative;
          });
        }
        
        // Save to storage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        console.log(`💾 Saved cumulative for ${category}: ${roundedCumulative}`);
      } catch (error) {
        console.error('Error saving adjustment cumulative:', error);
      }
    }

    // Sync cumulative values for gross section categories after calculations
    function syncGrossCumulativeValues() {
      try {
        console.log('🔄 Syncing gross section cumulative values...');
        
        // For features
        const featuresContainer = document.getElementById('featuresAdjustmentsList');
        if (featuresContainer && featuresContainer.children.length > 0) {
          const firstInput = featuresContainer.children[0].querySelector('input');
          if (firstInput) {
            syncAdjustmentToHelper(firstInput, 'features');
          }
        }
        
        // For registration
        const registrationContainer = document.getElementById('registrationAdjustmentsList');
        if (registrationContainer && registrationContainer.children.length > 0) {
          const firstInput = registrationContainer.children[0].querySelector('input');
          if (firstInput) {
            syncAdjustmentToHelper(firstInput, 'registration');
          }
        }
        
        console.log('✅ Gross cumulative values synced');
      } catch (error) {
        console.error('Error syncing gross cumulative values:', error);
      }
    }

    function syncAdjustmentToHelper(element, category) {
      try {
        console.log(`🔥 syncAdjustmentToHelper called for category: ${category}, element:`, element);
        
        // Skip sync during page load to prevent clearing saved data
        if (window.pageLoadInProgress) {
          console.log('⏸️ Skipping sync during page load to preserve data');
          return;
        }
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Ensure structures exist
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.estimate) helper.estimate = {};
        if (!helper.estimate.adjustments) helper.estimate.adjustments = {};
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // Map category to container ID - Check both full market and gross containers
        let containerId = '';
        if (category === 'features') {
          // Check if element is from gross section or full market section
          const row = element.closest('div');
          const grossContainer = document.getElementById('featuresAdjustmentsList');
          const fullContainer = document.getElementById('fullFeaturesAdjustmentsList');
          
          if (grossContainer && grossContainer.contains(row)) {
            containerId = 'featuresAdjustmentsList'; // Gross section
            console.log(`🎯 Detected GROSS features section for ${category}`);
          } else {
            containerId = 'fullFeaturesAdjustmentsList'; // Full market section
            console.log(`🎯 Detected FULL MARKET features section for ${category}`);
          }
        }
        else if (category === 'registration') {
          // Check if element is from gross section or full market section  
          const row = element.closest('div');
          const grossContainer = document.getElementById('registrationAdjustmentsList');
          const fullContainer = document.getElementById('fullRegistrationAdjustmentsList');
          
          if (grossContainer && grossContainer.contains(row)) {
            containerId = 'registrationAdjustmentsList'; // Gross section
            console.log(`🎯 Detected GROSS registration section for ${category}`);
          } else {
            containerId = 'fullRegistrationAdjustmentsList'; // Full market section
            console.log(`🎯 Detected FULL MARKET registration section for ${category}`);
          }
        }
        else if (category === 'mileage') containerId = 'mileageAdjustmentsList';
        else if (category === 'ownership_type') containerId = 'ownershipAdjustmentsList';
        else if (category === 'ownership_history') containerId = 'ownersAdjustmentsList';
        else if (category === 'additional') containerId = 'allAdjustmentsList';
        
        if (!containerId) {
          console.error('❌ Unknown category:', category);
          return;
        }
        
        const container = document.getElementById(containerId);
        if (!container) {
          console.error('❌ Container not found:', containerId);
          return;
        }
        
        console.log(`🔄 Rebuilding ${category} from all UI rows in ${containerId}`);
        
        // FINAL REPORT PATTERN: Rebuild entire category array from ALL visible UI rows
        // DO NOT WRITE TO estimate.adjustments - it should be READ-ONLY!
        const allRows = Array.from(container.children);
        
        // PRESERVE EXISTING DATA: Don't clear the entire array, preserve entries beyond UI rows
        const existingAdjustments = helper.final_report.adjustments[category] || [];
        helper.final_report.adjustments[category] = [];
        
        allRows.forEach((row, index) => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            // Start with existing data if available
            const existingData = existingAdjustments[index] || {};
            
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percentage: parseFloat(inputs[2].value) || 0,
              percent: parseFloat(inputs[2].value) || 0, // Backward compatibility
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value) || existingData.amount || 0, // PRESERVE existing amount if UI is empty
              source: 'manual',
              timestamp: new Date().toISOString()
            };
            
            
            // Calculate amount from percentage if needed (BEFORE applying signs)
            // FIXED: Only calculate if BOTH conditions are met:
            // 1. Percentage exists and is non-zero
            // 2. Amount is truly empty (not manually entered)
            const amountFromUI = safeParseAmount(inputs[3].value);
            const hasManualAmount = amountFromUI !== 0 || inputs[3].value.trim() !== '';
            
            if (adjustmentData.percentage && !hasManualAmount) {
              const baseValue = parseFloat(helper.estimate?.market_value_base) || 0;
              if (baseValue > 0) {
                const amount = Math.round((baseValue * Math.abs(adjustmentData.percentage)) / 100);
                adjustmentData.amount = amount; // Set as positive first
                adjustmentData.isCalculatedAmount = true; // Flag for calculated amounts
              }
            } else if (hasManualAmount) {
              adjustmentData.amount = amountFromUI;
              adjustmentData.isManualAmount = true; // Flag for manual amounts
            }
            
            // Round the amount to ensure no fractions
            adjustmentData.amount = Math.round(adjustmentData.amount);
            
            // Apply sign based on type (CRITICAL FOR MINUS SIGNS) - AFTER amount calculation
            if (adjustmentData.type === 'minus') {
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
            }
            
            // Add cumulative tracking for all adjustment categories
            if (category === 'mileage' || category === 'ownership_type' || category === 'ownership_history' || 
                category === 'features' || category === 'registration' || category === 'additional') {
              // FIXED: Get cumulative from the row itself, not the category total
              const rowCumulativeSpan = row.querySelector('.row-cumulative');
              if (rowCumulativeSpan) {
                const cumulativeText = rowCumulativeSpan.textContent.replace(/[₪,]/g, '');
                const cumulativeValue = parseFloat(cumulativeText) || 0;
                // Round cumulative value to ensure no fractions
                adjustmentData.cumulative = Math.round(cumulativeValue);
                console.log(`📊 Captured row cumulative for ${category}[${index}]: ${adjustmentData.cumulative}`);
              } else {
                // Fallback to category cumulative for backward compatibility
                let cumulativeId = '';
                
                // For features and registration, determine if it's gross or full market section
                if (category === 'features') {
                  // Check if it's gross section or full market section based on container
                  if (containerId === 'featuresAdjustmentsList') {
                    cumulativeId = 'grossFeaturesCumulative'; // Gross section
                  } else {
                    cumulativeId = 'featuresCumulative'; // Full market section
                  }
                }
                else if (category === 'registration') {
                  // Check if it's gross section or full market section based on container
                  if (containerId === 'registrationAdjustmentsList') {
                    cumulativeId = 'grossRegistrationCumulative'; // Gross section
                  } else {
                    cumulativeId = 'registrationCumulative'; // Full market section
                  }
                }
                else if (category === 'mileage') cumulativeId = 'mileageCumulative';
                else if (category === 'ownership_type') cumulativeId = 'ownershipCumulative';
                else if (category === 'ownership_history') cumulativeId = 'ownersCumulative';
                
                const cumulativeElement = document.getElementById(cumulativeId);
                if (cumulativeElement) {
                  const cumulativeSpan = cumulativeElement.querySelector('span');
                  if (cumulativeSpan) {
                    const cumulativeText = cumulativeSpan.textContent.replace(/[₪,]/g, '');
                    const cumulativeValue = parseFloat(cumulativeText) || 0;
                    // Round cumulative value to ensure no fractions
                    adjustmentData.cumulative = Math.round(cumulativeValue);
                    console.log(`📊 Captured category cumulative for ${category}: ${adjustmentData.cumulative}`);
                  }
                }
              }
            }
            
            // ONLY write to final_report - estimate should remain READ-ONLY
            helper.final_report.adjustments[category].push(adjustmentData);
            console.log(`📝 Added row ${index} to final_report.${category}:`, adjustmentData.value);
          }
        });
        
        console.log(`✅ Rebuilt ${category}: ${helper.final_report.adjustments[category].length} items total`);
        console.log(`📊 Final final_report.adjustments.${category}:`, helper.final_report.adjustments[category]);
        
        // FINAL REPORT PATTERN: Update valuation.adjustments with first item (for backward compatibility)
        if (helper.final_report.adjustments[category].length > 0) {
          helper.valuation.adjustments[category] = helper.final_report.adjustments[category][0];
          
          // Ensure cumulative is also copied to valuation for all categories with cumulative tracking
          if ((category === 'mileage' || category === 'ownership_type' || category === 'ownership_history' || 
               category === 'features' || category === 'registration') && 
              helper.final_report.adjustments[category][0].cumulative !== undefined) {
            helper.valuation.adjustments[category].cumulative = helper.final_report.adjustments[category][0].cumulative;
          }
        } else {
          // Clear valuation if no items remain
          if (helper.valuation.adjustments[category]) {
            delete helper.valuation.adjustments[category];
          }
        }
        
        // Save to storage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper; // Update window.helper
        
      } catch (error) {
        console.error('Error in syncAdjustmentToHelper:', error);
      }
    }
    
    // Sync UI section with data array (for bidirectional sync)
    function syncUISection(containerId, dataArray) {
      try {
        const container = document.getElementById(containerId);
        if (!container) {
          console.log(`Container ${containerId} not found`);
          return;
        }
        
        console.log(`🔄 Syncing ${dataArray.length} items to ${containerId}`);
        
        // Get existing rows
        const existingRows = container.querySelectorAll('div[id^="featureAdj_"], div[id^="regAdj_"], div[id^="fullFeatureAdj_"], div[id^="fullRegAdj_"]');
        
        // Try to preserve existing rows where possible
        dataArray.forEach((item, index) => {
          if (index < existingRows.length) {
            // Update existing row
            const row = existingRows[index];
            const inputs = row.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              inputs[0].value = item.value || '';
              inputs[1].value = item.type || '%';
              inputs[2].value = item.percentage || '';
              inputs[3].value = item.amount || '';
              
              // Update readonly states based on type - ONLY for Full Market sections with %/₪ dropdowns
              if (containerId.includes('full') || containerId.includes('all')) {
                // Full Market sections use %/₪ type dropdowns
                if (inputs[1].value === '%') {
                  inputs[2].removeAttribute('readonly');
                  inputs[2].style.background = '';
                  inputs[3].setAttribute('readonly', 'readonly');
                  inputs[3].style.background = '#f0f0f0';
                } else {
                  inputs[2].setAttribute('readonly', 'readonly');
                  inputs[2].style.background = '#f0f0f0';
                  inputs[3].removeAttribute('readonly');
                  inputs[3].style.background = '';
                }
              } else {
                // Gross sections use plus/minus dropdowns - both percent and amount should be editable
                inputs[2].removeAttribute('readonly');
                inputs[2].style.background = '';
                inputs[3].removeAttribute('readonly');
                inputs[3].style.background = '';
              }
            }
          } else {
            // Add new row
            if (containerId === 'featuresAdjustmentsList') {
              addFeatureAdjustment();
            } else if (containerId === 'registrationAdjustmentsList') {
              addRegistrationAdjustment();
            } else if (containerId === 'fullFeaturesAdjustmentsList') {
              addFullFeaturesAdjustment();
            } else if (containerId === 'fullRegistrationAdjustmentsList') {
              addFullRegistrationAdjustment();
            }
            
            // Get the newly added row and populate it
            const newRows = container.querySelectorAll('div[id^="featureAdj_"], div[id^="regAdj_"], div[id^="fullFeatureAdj_"], div[id^="fullRegAdj_"]');
            const newRow = newRows[newRows.length - 1];
            if (newRow) {
              const inputs = newRow.querySelectorAll('input, select');
              if (inputs.length >= 4) {
                inputs[0].value = item.value || '';
                inputs[1].value = item.type || '%';
                inputs[2].value = item.percentage || '';
                inputs[3].value = item.amount || '';
                
                // Update readonly states - ONLY for Full Market sections with %/₪ dropdowns
                if (containerId.includes('full') || containerId.includes('all')) {
                  // Full Market sections use %/₪ type dropdowns
                  if (inputs[1].value === '%') {
                    inputs[2].removeAttribute('readonly');
                    inputs[2].style.background = '';
                    inputs[3].setAttribute('readonly', 'readonly');
                    inputs[3].style.background = '#f0f0f0';
                  } else {
                    inputs[2].setAttribute('readonly', 'readonly');
                    inputs[2].style.background = '#f0f0f0';
                    inputs[3].removeAttribute('readonly');
                    inputs[3].style.background = '';
                  }
                } else {
                  // Gross sections use plus/minus dropdowns - both percent and amount should be editable
                  inputs[2].removeAttribute('readonly');
                  inputs[2].style.background = '';
                  inputs[3].removeAttribute('readonly');
                  inputs[3].style.background = '';
                }
              }
            }
          }
        });
        
        // Remove extra rows
        for (let i = dataArray.length; i < existingRows.length; i++) {
          existingRows[i].remove();
        }
        
        console.log(`✅ Synced ${containerId}`);
        
      } catch (error) {
        console.error(`Error syncing UI section ${containerId}:`, error);
      }
    }
    
    // Remove adjustment row
    function removeAdjustmentRow(rowId) {
      const row = document.getElementById(rowId);
      if (row) {
        // Determine which section this row belongs to
        const isGrossFeatures = row.closest('#featuresAdjustmentsList');
        const isGrossRegistration = row.closest('#registrationAdjustmentsList');
        const isFullSection = row.closest('#fullFeaturesAdjustmentsList, #fullRegistrationAdjustmentsList, #mileageAdjustmentsList, #ownershipAdjustmentsList, #ownersAdjustmentsList, #allAdjustmentsList');
        
        // Check if this is an additional adjustment row
        const isAdditionalAdjustment = row.closest('#allAdjustmentsList');
        
        // CRITICAL FIX: Get the description BEFORE removing the row
        let description = '';
        let category = '';
        if (isAdditionalAdjustment) {
          const inputs = row.querySelectorAll('input');
          description = inputs[0]?.value || '';
          category = 'additional';
          console.log(`🗑️ Preparing to remove additional adjustment: "${description}"`);
        } else {
          // Determine category for other sections
          if (row.closest('#featuresAdjustmentsList') || row.closest('#fullFeaturesAdjustmentsList')) category = 'features';
          else if (row.closest('#registrationAdjustmentsList') || row.closest('#fullRegistrationAdjustmentsList')) category = 'registration';
          else if (row.closest('#mileageAdjustmentsList')) category = 'mileage';
          else if (row.closest('#ownershipAdjustmentsList')) category = 'ownership_type';
          else if (row.closest('#ownersAdjustmentsList')) category = 'ownership_history';
        }
        
        // Remove the row from UI
        row.remove();
        
        // For any category, trigger the sync function to rebuild arrays properly
        if (category) {
          console.log(`🔄 Triggering sync for category: ${category} after row deletion`);
          
          // Find the container and trigger sync with remaining rows
          let containerId = '';
          if (category === 'features') {
            containerId = isGrossFeatures ? 'featuresAdjustmentsList' : 'fullFeaturesAdjustmentsList';
          } else if (category === 'registration') {
            containerId = isGrossRegistration ? 'registrationAdjustmentsList' : 'fullRegistrationAdjustmentsList';
          } else if (category === 'mileage') containerId = 'mileageAdjustmentsList';
          else if (category === 'ownership_type') containerId = 'ownershipAdjustmentsList';
          else if (category === 'ownership_history') containerId = 'ownersAdjustmentsList';
          else if (category === 'additional') containerId = 'allAdjustmentsList';
          
          const container = document.getElementById(containerId);
          if (container && container.children.length > 0) {
            // Use first remaining input to trigger sync
            const firstInput = container.children[0].querySelector('input');
            if (firstInput) {
              syncAdjustmentToHelper(firstInput, category);
            }
          } else {
            // No rows left, manually clear the category
            const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
            
            // Clear from all locations
            if (helper.estimate?.adjustments?.[category]) {
              helper.estimate.adjustments[category] = [];
            }
            if (helper.final_report?.adjustments?.[category]) {
              helper.final_report.adjustments[category] = [];
            }
            if (helper.valuation?.adjustments?.[category]) {
              delete helper.valuation.adjustments[category];
            }
            
            sessionStorage.setItem('helper', JSON.stringify(helper));
            window.helper = helper;
            
            console.log(`🧹 Cleared all data for category: ${category}`);
          }
        }
        
        // Call appropriate calculation function based on section
        if (isGrossFeatures || isGrossRegistration) {
          console.log('🔄 Updating GROSS calculation after row removal');
          updateGrossMarketValueCalculation();
        }
        if (isFullSection) {
          console.log('🔄 Updating FULL calculation after row removal');
          updateFullMarketValueCalculation();
        }
        
        // OLD BROKEN CODE - KEEPING FOR REFERENCE BUT IT'S NOT NEEDED WITH SYNC PATTERN
        /*
        // For additional adjustments, we need to remove from helper arrays before updating
        if (isAdditionalAdjustment) {
          console.log('🗑️ Removing additional adjustment from helper arrays');
          
          // Get the description/value from the row to identify which item to remove
          const inputs = row.querySelectorAll('input');
          const description = inputs[0]?.value || '';
        */
        
        console.log(`✅ Successfully removed row and synced data using new estimator pattern`);
      }
    }
    
    // Calculate adjustment value for simple percentage input
    function calculateAdjustmentValueSimple(percentInput) {
      const row = percentInput.closest('div[id*="Adj_"]');
      if (!row) return;
      
      const inputs = row.querySelectorAll('input, select');
      if (inputs.length < 4) return;
      
      const percent = parseFloat(percentInput.value) || 0;
      if (percent === 0) return;
      
      // Get actual base price from UI or use default
      let basicPrice = 0;
      const basicPriceField = document.getElementById('basicPrice');
      if (basicPriceField?.value) {
        basicPrice = parseFloat(basicPriceField.value.replace(/[₪,]/g, '')) || 0;
      }
      
      // Fallback to helper data if needed
      if (basicPrice === 0) {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        basicPrice = helper.estimate?.market_value_base || helper.levisummary?.base_price || 118000;
      }
      
      const calculatedValue = (basicPrice * percent) / 100;
      const type = inputs[1].value;
      
      // Apply sign based on type
      if (type === 'minus' || type === 'הפחתה' || type === 'הפחתה (-)') {
        inputs[3].value = `-₪${Math.round(calculatedValue).toLocaleString()}`;
      } else {
        inputs[3].value = `₪${Math.round(calculatedValue).toLocaleString()}`;
      }
    }
    
    // ============================================================================
    // END OF AUTO-POPULATION FUNCTIONS
    // ============================================================================
    
    // Update helper from adjustments - IMPROVED VERSION with proper save pattern
    function updateHelperFromAdjustments() {
      try {
        console.log('🔄 updateHelperFromAdjustments called');
        
        const helper = window.helper || {};
        
        // Call the new dedicated save functions for each section
        updateGrossValueToFinalReportAndValuation(helper);
        updateFullMarketValueToFinalReportAndValuation(helper);
        
        // Save to sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper; // Update window.helper too
        
        console.log('✅ updateHelperFromAdjustments completed - used dedicated save functions');
        
      } catch (error) {
        console.error('❌ Error in updateHelperFromAdjustments:', error);
      }
    }

    /**
     * Trigger change events on all adjustment fields to ensure formatAdjustmentDisplay runs
     * Critical for minus sign detection on page refresh
     */
    function triggerAllAdjustmentChangeEvents() {
      try {
        console.log('🔄 Triggering all adjustment change events for proper formatting');
        
        // Find all adjustment containers
        const containers = [
          'grossFeaturesAdjustmentsList',
          'grossRegistrationAdjustmentsList', 
          'fullFeaturesAdjustmentsList',
          'fullRegistrationAdjustmentsList',
          'mileageAdjustmentsList',
          'ownershipAdjustmentsList',
          'ownersAdjustmentsList',
          'allAdjustmentsList'
        ];
        
        containers.forEach(containerId => {
          const container = document.getElementById(containerId);
          if (container) {
            const rows = container.querySelectorAll('div[id*="Adj_"]');
            rows.forEach(row => {
              const inputs = row.querySelectorAll('input, select');
              if (inputs.length >= 4) {
                // Get current values for formatAdjustmentDisplay
                const type = inputs[1].value;
                const percent = parseFloat(inputs[2].value) || 0;
                const amountText = inputs[3].value || '';
                const amount = parseFloat(amountText.replace(/[₪,-]/g, '')) || 0;
                
                // Call formatAdjustmentDisplay directly to ensure proper formatting
                formatAdjustmentDisplay(row, type, percent, amount);
                
                // Also trigger change events
                if (inputs[1]) inputs[1].dispatchEvent(new Event('change', { bubbles: true }));
                if (inputs[2] && inputs[2].value) inputs[2].dispatchEvent(new Event('change', { bubbles: true }));
                if (inputs[3] && inputs[3].value) inputs[3].dispatchEvent(new Event('change', { bubbles: true }));
              }
            });
            console.log(`✅ Triggered change events for ${rows.length} rows in ${containerId}`);
          }
        });
        
        console.log('✅ Completed triggering all adjustment change events');
        
      } catch (error) {
        console.error('❌ Error triggering adjustment change events:', error);
      }
    }

    /**
     * Update gross value adjustments to BOTH final_report.adjustments AND valuation.adjustments
     * Based on working pattern from estimator-builder.html
     */
    function updateGrossValueToFinalReportAndValuation(helper) {
      try {
        // Initialize structures
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // 1. FEATURES - Copy EXACT estimator pattern
        const featuresRows = document.querySelectorAll('#featuresAdjustmentsList > div');
        helper.final_report.adjustments.features = [];
        
        featuresRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value),
              source: row.getAttribute('data-source') || 'manual'
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.final_report.adjustments.features.push(adjustmentData);
          }
        });
        
        // Update valuation.adjustments ONLY with ORIGINAL rows (not additional manual rows)
        if (helper.estimate?.adjustments?.features && Array.isArray(helper.estimate.adjustments.features) && helper.estimate.adjustments.features.length > 0) {
          helper.valuation.adjustments.features = helper.estimate.adjustments.features[0];
          console.log('💾 Updated valuation.adjustments.features from estimate (Levi data)');
        } else {
          // Look for ORIGINAL rows only (not manual additions)
          const originalRow = [...featuresRows].find(row => {
            const dataSource = row.getAttribute('data-source');
            return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
          });
          
          if (originalRow) {
            const inputs = originalRow.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              const adjustmentData = {
                value: inputs[0].value || '',
                type: inputs[1].value || 'plus',
                percent: parseFloat(inputs[2].value) || 0,
                percentage: parseFloat(inputs[2].value) || 0,
                amount_display: inputs[3].value || '',
                amount: safeParseAmount(inputs[3].value),
                source: originalRow.getAttribute('data-source') || 'original'
              };
              
              // Apply sign based on type
              if (inputs[1].value === 'minus') {
                adjustmentData.amount = -Math.abs(adjustmentData.amount);
                adjustmentData.percent = -Math.abs(adjustmentData.percent);
                adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
              }
              
              helper.valuation.adjustments.features = adjustmentData;
              console.log('💾 Updated valuation.adjustments.features from ORIGINAL row');
            }
          } else {
            // Only delete if we're certain there's no original data
            if (!helper.valuation?.adjustments?.features?.value && !helper.valuation?.adjustments?.features?.percent) {
              delete helper.valuation.adjustments.features;
              console.log('🗑️ Cleared valuation.adjustments.features (no original data)');
            }
          }
        }
        
        // 2. REGISTRATION - Copy EXACT estimator pattern
        const registrationRows = document.querySelectorAll('#registrationAdjustmentsList > div');
        helper.final_report.adjustments.registration = [];
        
        registrationRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value),
              source: row.getAttribute('data-source') || 'manual'
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.final_report.adjustments.registration.push(adjustmentData);
          }
        });
        
        // Update valuation.adjustments ONLY with ORIGINAL rows (not additional manual rows)
        if (helper.estimate?.adjustments?.registration && Array.isArray(helper.estimate.adjustments.registration) && helper.estimate.adjustments.registration.length > 0) {
          helper.valuation.adjustments.registration = helper.estimate.adjustments.registration[0];
          console.log('💾 Updated valuation.adjustments.registration from estimate (Levi data)');
        } else {
          // Look for ORIGINAL rows only (not manual additions)
          const originalRow = [...registrationRows].find(row => {
            const dataSource = row.getAttribute('data-source');
            return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
          });
          
          if (originalRow) {
            const inputs = originalRow.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              const adjustmentData = {
                value: inputs[0].value || '',
                type: inputs[1].value || 'plus',
                percent: parseFloat(inputs[2].value) || 0,
                percentage: parseFloat(inputs[2].value) || 0,
                amount_display: inputs[3].value || '',
                amount: safeParseAmount(inputs[3].value),
                source: originalRow.getAttribute('data-source') || 'original'
              };
              
              // Apply sign based on type
              if (inputs[1].value === 'minus') {
                adjustmentData.amount = -Math.abs(adjustmentData.amount);
                adjustmentData.percent = -Math.abs(adjustmentData.percent);
                adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
              }
              
              helper.valuation.adjustments.registration = adjustmentData;
              console.log('💾 Updated valuation.adjustments.registration from ORIGINAL row');
            }
          } else {
            // Only delete if we're certain there's no original data
            if (!helper.valuation?.adjustments?.registration?.value && !helper.valuation?.adjustments?.registration?.percent) {
              delete helper.valuation.adjustments.registration;
              console.log('🗑️ Cleared valuation.adjustments.registration (no original data)');
            }
          }
        }
        
        console.log('✅ Updated gross value adjustments to BOTH final_report.adjustments AND valuation.adjustments');
        
        // DISABLED: Auto-populate that clears Total Value manual additions
        // if (helper.final_report.adjustments.features) {
        //   syncFullMarketFeaturesWithGross(helper.final_report.adjustments.features);
        // }
        // if (helper.final_report.adjustments.registration) {
        //   syncFullMarketRegistrationWithGross(helper.final_report.adjustments.registration);
        // }
        
      } catch (error) {
        console.error('❌ Error updating gross value to final_report and valuation adjustments:', error);
      }
    }

    /**
     * Update FULL MARKET VALUE categories to BOTH final_report.adjustments AND valuation.adjustments
     * Based on working pattern from estimator-builder.html
     */
    function updateFullMarketValueToFinalReportAndValuation(helper) {
      try {
        // Initialize structures
        if (!helper.valuation) helper.valuation = {};
        if (!helper.valuation.adjustments) helper.valuation.adjustments = {};
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) {
          helper.final_report.adjustments = {
            features: [],
            registration: [],
            mileage: [],
            ownership_type: [],
            ownership_history: [],
            usage: [],
            additional: []
          };
        }
        
        // 1. FEATURES - Only sync ORIGINAL rows to valuation (not additional manual rows)
        const fullFeaturesRows = document.querySelectorAll('#fullFeaturesAdjustmentsList > div');
        const originalFeatureRow = [...fullFeaturesRows].find(row => {
          const dataSource = row.getAttribute('data-source');
          return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
        });
        
        if (originalFeatureRow) {
          const inputs = originalFeatureRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            helper.valuation.adjustments.features = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value)
            };
            console.log('💾 Updated valuation.adjustments.features from ORIGINAL Total Market Value row');
          }
        }
        
        // 2. REGISTRATION - Only sync ORIGINAL rows to valuation (not additional manual rows)
        const fullRegistrationRows = document.querySelectorAll('#fullRegistrationAdjustmentsList > div');
        const originalRegistrationRow = [...fullRegistrationRows].find(row => {
          const dataSource = row.getAttribute('data-source');
          return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
        });
        
        if (originalRegistrationRow) {
          const inputs = originalRegistrationRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            helper.valuation.adjustments.registration = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value)
            };
            console.log('💾 Updated valuation.adjustments.registration from ORIGINAL Total Market Value row');
          }
        }
        
        // 3. MILEAGE (KM) - Save ALL rows to final_report, ONLY ORIGINAL rows to valuation
        const mileageRows = document.querySelectorAll('#mileageAdjustmentsList > div');
        helper.final_report.adjustments.mileage = [];
        
        // Save ALL mileage rows to final_report.adjustments
        mileageRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value),
              source: row.getAttribute('data-source') || 'manual'
            };
            
            // Apply sign based on type - CRITICAL FOR MINUS VALUES
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.final_report.adjustments.mileage.push(adjustmentData);
          }
        });
        
        // Save ONLY ORIGINAL row to valuation.adjustments
        const originalMileageRow = [...mileageRows].find(row => {
          const dataSource = row.getAttribute('data-source');
          return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
        });
        
        if (originalMileageRow) {
          const inputs = originalMileageRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value)
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.valuation.adjustments.mileage = adjustmentData;
            console.log('💾 Updated valuation.adjustments.mileage from ORIGINAL row');
          }
        }
        
        // 4. OWNERSHIP TYPE - Save ALL rows to final_report, ONLY ORIGINAL rows to valuation
        const ownershipRows = document.querySelectorAll('#ownershipAdjustmentsList > div');
        helper.final_report.adjustments.ownership_type = [];
        
        // Save ALL ownership rows to final_report.adjustments
        ownershipRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value),
              source: row.getAttribute('data-source') || 'manual'
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.final_report.adjustments.ownership_type.push(adjustmentData);
          }
        });
        
        // Save ONLY ORIGINAL row to valuation.adjustments
        const originalOwnershipRow = [...ownershipRows].find(row => {
          const dataSource = row.getAttribute('data-source');
          return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
        });
        
        if (originalOwnershipRow) {
          const inputs = originalOwnershipRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value)
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.valuation.adjustments.ownership_type = adjustmentData;
            console.log('💾 Updated valuation.adjustments.ownership_type from ORIGINAL row');
          }
        }
        
        // 5. OWNERSHIP HISTORY - Save ALL rows to final_report, ONLY ORIGINAL rows to valuation
        const ownersRows = document.querySelectorAll('#ownersAdjustmentsList > div');
        helper.final_report.adjustments.ownership_history = [];
        
        // Save ALL ownership history rows to final_report.adjustments
        ownersRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value),
              source: row.getAttribute('data-source') || 'manual'
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.final_report.adjustments.ownership_history.push(adjustmentData);
          }
        });
        
        // Save ONLY ORIGINAL row to valuation.adjustments
        const originalOwnersRow = [...ownersRows].find(row => {
          const dataSource = row.getAttribute('data-source');
          return dataSource === 'original' || dataSource === 'levi' || dataSource === 'valuation';
        });
        
        if (originalOwnersRow) {
          const inputs = originalOwnersRow.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const adjustmentData = {
              value: inputs[0].value || '',
              type: inputs[1].value || 'plus',
              percent: parseFloat(inputs[2].value) || 0,
              percentage: parseFloat(inputs[2].value) || 0,
              amount_display: inputs[3].value || '',
              amount: safeParseAmount(inputs[3].value)
            };
            
            // Apply sign based on type
            if (inputs[1].value === 'minus') {
              adjustmentData.amount = -Math.abs(adjustmentData.amount);
              adjustmentData.percent = -Math.abs(adjustmentData.percent);
              adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
            }
            
            helper.valuation.adjustments.ownership_history = adjustmentData;
            console.log('💾 Updated valuation.adjustments.ownership_history from ORIGINAL row');
          }
        }
        
        // 6. ADDITIONAL - Only in Full Market Value
        const additionalRows = document.querySelectorAll('#allAdjustmentsList > div');
        if (additionalRows.length > 0) {
          helper.final_report.adjustments.additional = [];
          additionalRows.forEach(row => {
            const inputs = row.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              const adjustmentData = {
                value: inputs[0].value || '',
                type: inputs[1].value || 'plus',
                percent: parseFloat(inputs[2].value) || 0,
                percentage: parseFloat(inputs[2].value) || 0,
                amount_display: inputs[3].value || '',
                amount: safeParseAmount(inputs[3].value),
                source: row.getAttribute('data-source') || 'manual'
              };
              
              // Apply sign based on type - CRITICAL FOR MINUS VALUES
              if (inputs[1].value === 'minus') {
                adjustmentData.amount = -Math.abs(adjustmentData.amount);
                adjustmentData.percent = -Math.abs(adjustmentData.percent);
                adjustmentData.percentage = -Math.abs(adjustmentData.percentage);
              }
              
              helper.final_report.adjustments.additional.push(adjustmentData);
            }
          });
          
          // CRITICAL: DO NOT write additional categories to valuation.adjustments
          // Additional adjustments should ONLY exist in final_report.adjustments
        } else {
          helper.final_report.adjustments.additional = [];
          // Don't touch valuation.adjustments for additional categories
        }
        
        console.log('✅ Updated full market value adjustments to BOTH final_report.adjustments AND valuation.adjustments');
        
      } catch (error) {
        console.error('❌ Error updating full market value to final_report and valuation adjustments:', error);
      }
    }
    
    /**
     * Sync Full Market Value Registration with Gross Value Section
     * CRITICAL for Issue 5: Data Sync Between Sections
     */
    function syncFullMarketRegistrationWithGross(grossRegistrations) {
      try {
        const container = document.getElementById('fullRegistrationAdjustmentsList');
        if (!container || !grossRegistrations || grossRegistrations.length === 0) return;
        
        // Clear existing Full Market registration
        container.innerHTML = '';
        
        // Add each gross registration to Full Market section
        grossRegistrations.forEach(registration => {
          addFullMarketRegistrationAdjustment();
          const lastRow = container.querySelector('div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              inputs[0].value = registration.value || '';
              inputs[1].value = registration.type || 'plus';
              
              // CRITICAL FIX: Display minus sign for negative values
              const displayPercent = isReductionType(registration.type) && registration.percent > 0 ? 
                `-${Math.abs(registration.percent)}` : Math.abs(registration.percent || 0);
              const displayAmount = isReductionType(registration.type) && registration.amount > 0 ? 
                `-${Math.abs(registration.amount)}` : Math.abs(registration.amount || 0);
              
              inputs[2].value = displayPercent || '';
              inputs[3].value = registration.amount_display || (registration.amount ? `₪${displayAmount.toLocaleString()}` : '');
              lastRow.setAttribute('data-source', registration.source || 'gross_sync');
            }
          }
        });
        
        console.log('✅ Synced Full Market Registration with Gross Value section');
        
      } catch (error) {
        console.error('❌ Error syncing Full Market Registration with Gross Value:', error);
      }
    }

    /**
     * Sync Full Market Value Features with Gross Value Section
     * CRITICAL for Issue 5: Data Sync Between Sections
     */
    function syncFullMarketFeaturesWithGross(grossFeatures) {
      try {
        const container = document.getElementById('fullFeaturesAdjustmentsList');
        if (!container || !grossFeatures || grossFeatures.length === 0) return;
        
        // Clear existing Full Market features
        container.innerHTML = '';
        
        // Add each gross feature to Full Market section
        grossFeatures.forEach(feature => {
          addFullMarketFeatureAdjustment();
          const lastRow = container.querySelector('div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              inputs[0].value = feature.value || '';
              inputs[1].value = feature.type || 'plus';
              
              // CRITICAL FIX: Display minus sign for negative values
              const displayPercent = isReductionType(feature.type) && feature.percent > 0 ? 
                `-${Math.abs(feature.percent)}` : Math.abs(feature.percent || 0);
              const displayAmount = isReductionType(feature.type) && feature.amount > 0 ? 
                `-${Math.abs(feature.amount)}` : Math.abs(feature.amount || 0);
              
              inputs[2].value = displayPercent || '';
              inputs[3].value = feature.amount_display || (feature.amount ? `₪${displayAmount.toLocaleString()}` : '');
              lastRow.setAttribute('data-source', feature.source || 'gross_sync');
            }
          }
        });
        
        console.log('✅ Synced Full Market features with Gross Value section');
        
      } catch (error) {
        console.error('❌ Error syncing Full Market features:', error);
      }
    }

    /**
     * Sync Full Market Value Registration with Gross Value Section
     * CRITICAL for Issue 5: Data Sync Between Sections
     */
    function syncFullMarketRegistrationWithGross(grossRegistration) {
      try {
        const container = document.getElementById('fullRegistrationAdjustmentsList');
        if (!container || !grossRegistration || grossRegistration.length === 0) return;
        
        // Clear existing Full Market registration
        container.innerHTML = '';
        
        // Add each gross registration to Full Market section
        grossRegistration.forEach(registration => {
          addFullMarketRegistrationAdjustment();
          const lastRow = container.querySelector('div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input, select');
            if (inputs.length >= 4) {
              inputs[0].value = registration.value || '';
              inputs[1].value = registration.type || 'plus';
              
              // CRITICAL FIX: Display minus sign for negative values
              const displayPercent = isReductionType(registration.type) && registration.percent > 0 ? 
                `-${Math.abs(registration.percent)}` : Math.abs(registration.percent || 0);
              const displayAmount = isReductionType(registration.type) && registration.amount > 0 ? 
                `-${Math.abs(registration.amount)}` : Math.abs(registration.amount || 0);
              
              inputs[2].value = displayPercent || '';
              inputs[3].value = registration.amount_display || (registration.amount ? `₪${displayAmount.toLocaleString()}` : '');
              lastRow.setAttribute('data-source', registration.source || 'gross_sync');
            }
          }
        });
        
        console.log('✅ Synced Full Market registration with Gross Value section');
        
      } catch (error) {
        console.error('❌ Error syncing Full Market registration:', error);
      }
    }

    /**
     * Add Full Market Feature Adjustment (for sync with Gross Value)
     */
    function addFullMarketFeatureAdjustment() {
      const container = document.getElementById('fullFeaturesAdjustmentsList');
      const rowId = 'fullFeatureAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
          <div><input type="text" placeholder="תיאור המאפיין" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features');" /></div>
          <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features');">
            <option value="plus">תוספת (+)</option>
            <option value="minus">הפחתה (-)</option>
          </select></div>
          <div><input type="text" placeholder="אחוז" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features');" /></div>
          <div><input type="text" placeholder="₪" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features');" /></div>
          <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
    }

    /**
     * Add Full Market Registration Adjustment (for sync with Gross Value)
     */
    function addFullMarketRegistrationAdjustment() {
      const container = document.getElementById('fullRegistrationAdjustmentsList');
      const rowId = 'fullRegAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
          <div><input type="text" placeholder="תיאור עליה לכביש" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');" /></div>
          <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');">
            <option value="plus">תוספת (+)</option>
            <option value="minus">הפחתה (-)</option>
          </select></div>
          <div><input type="text" placeholder="אחוז" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');" /></div>
          <div><input type="text" placeholder="₪" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');" /></div>
          <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
    }

    // NOTE: Duplicate function removed - using the updated version with dedicated save functions
    
    /**
     * Listen for helper updates to trigger re-population when Levi data changes
     */
    let lastLeviDataHash = null;
    function setupLeviDataListener() {
      // Calculate initial Levi data hash to detect real changes
      function getLeviDataHash(helperData) {
        if (!helperData) return null;
        const leviData = {
          summary: helperData.levisummary,
          report: helperData.levi_report
        };
        return JSON.stringify(leviData);
      }
      
      // Set initial hash
      lastLeviDataHash = getLeviDataHash(helper);
      
      // Listen for storage events (when helper data changes)
      window.addEventListener('storage', (event) => {
        if (event.key === 'helper' && event.newValue) {
          try {
            const newHelper = JSON.parse(event.newValue);
            const newLeviDataHash = getLeviDataHash(newHelper);
            
            // Only clear and re-populate if Levi data actually changed
            if (newLeviDataHash !== lastLeviDataHash && (newHelper.levisummary || newHelper.levi_report)) {
              console.log('📡 Detected Levi data update, re-populating adjustments...');
              lastLeviDataHash = newLeviDataHash;
              clearLeviAdjustments();
              helper = newHelper; // Update global helper
              autoPopulateFromLeviSummary();
            } else {
              // Just update the helper reference without clearing user input
              helper = newHelper;
            }
          } catch (error) {
            console.error('❌ Error processing helper update:', error);
          }
        }
      });
      
      // Also listen for custom events
      document.addEventListener('helperUpdate', (event) => {
        if (event.detail && (event.detail.section === 'levisummary' || event.detail.section === 'levi_report')) {
          console.log('📡 Detected Levi data event, re-populating adjustments...');
          clearLeviAdjustments();
          autoPopulateFromLeviSummary();
        }
      });
      
      console.log('📡 Levi data listener setup completed');
    }
    
    // Calculate adjustment value from percentage - ENHANCED
    function calculateAdjustmentValue(percentInput) {
      const row = percentInput.closest('div[id^="featureAdj_"], div[id^="regAdj_"]');
      if (!row) {
        console.warn('⚠️ Cannot find adjustment row for calculation');
        return;
      }
      
      const percent = parseFloat(percentInput.value.replace('%', '')) || 0;
      let basicPrice = parseFloat(document.getElementById('basicPrice')?.value.replace(/[₪,]/g, '')) || 0;
      
      // Try alternative price sources if basicPrice is empty
      if (basicPrice === 0) {
        // Try grossMarketValue first (from calculations)
        const grossMarketValue = parseFloat(document.getElementById('grossMarketValue')?.value.replace(/[₪,]/g, '')) || 0;
        if (grossMarketValue > 0) {
          basicPrice = grossMarketValue;
          console.log('📊 Using grossMarketValue for calculation:', basicPrice);
        }
      }
      
      // If still no price, try to get BASE PRICE from helper
      if (basicPrice === 0) {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        if (helper.levi_report?.base_price) {
          basicPrice = parseFloat(helper.levi_report.base_price);
        } else if (helper.expertise?.levi_report?.base_price) {
          basicPrice = parseFloat(helper.expertise.levi_report.base_price);
        } else if (helper.levisummary?.base_price) {
          basicPrice = parseFloat(helper.levisummary.base_price);
        } else if (helper.car_details?.base_price) {
          basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[₪,]/g, ''));
        } else {
          // REMOVED market_value fallback - we need BASE price only for calculations
          console.warn('⚠️ No Levi BASE PRICE found for adjustment calculation');
        }
        
        // If we found a basic price, update the field
        if (basicPrice > 0) {
          const basicPriceField = document.getElementById('basicPrice');
          if (basicPriceField) {
            basicPriceField.value = `₪${basicPrice.toLocaleString()}`;
          }
        }
      }
      
      const valueInput = row.querySelector('input[placeholder="₪"]');
      
      if (!valueInput) {
        console.error('⚠️ Cannot find value input field in adjustment row');
        return;
      }
      
      if (basicPrice > 0 && percent !== 0) {
        const calculatedValue = (basicPrice * percent) / 100;
        valueInput.value = `₪${Math.round(calculatedValue).toLocaleString()}`;
        console.log(`💰 Calculated adjustment value: ${percent}% × ₪${basicPrice.toLocaleString()} = ₪${Math.round(calculatedValue).toLocaleString()}`);
        
        // Trigger change event to update other calculations
        valueInput.dispatchEvent(new Event('change', { bubbles: true }));
      } else {
        console.warn(`⚠️ Cannot calculate adjustment value - basicPrice: ${basicPrice}, percent: ${percent}`);
        if (basicPrice === 0) {
          console.warn('⚠️ No car price found. Please set the basic price first.');
        }
      }
    }
    
    // SIMPLE ADJUSTMENT CALCULATION - COPIED FROM WORKING DEPRECIATION
    // Duplicate function - removing to avoid conflicts
    // (Already defined above with proper implementation)

    // SIMPLE FINAL REPORTADJUSTMENT CALCULATION - COPIED FROM WORKING DEPRECIATION
    function calculateFinalReportAdjustmentValueSimple(percentInput) {
      const percent = parseFloat(percentInput.value) || 0;
      const row = percentInput.closest('div');
      
      if (!row) return;
      
      // Get helper data like the working depreciation does
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const marketValue = parseFloat(helper.expertise?.levi_report?.final_price) || 0;
      
      // Calculate value exactly like working depreciation
      const calculatedValue = Math.round((marketValue * percent) / 100);
      
      // Find value input (third input in row)
      const inputs = row.querySelectorAll('input');
      if (inputs.length > 2) {
        const valueInput = inputs[2];
        valueInput.value = calculatedValue || '';
      }
    }

    // Test function to manually add adjustment data for debugging
    function addTestAdjustments() {
      console.log('🧪 Adding test adjustments for debugging');
      
      // Add test features adjustment
      addFeatureAdjustment();
      const featuresContainer = document.getElementById('featuresAdjustmentsList');
      const lastFeaturesRow = featuresContainer.querySelector('div:last-child');
      if (lastFeaturesRow) {
        const inputs = lastFeaturesRow.querySelectorAll('input[type="text"]');
        inputs[0].value = 'מאפיין בדיקה';
        inputs[1].value = '5%';
        inputs[2].value = '₪1000';
        lastFeaturesRow.querySelector('select').value = 'plus';
      }
      
      // Add test registration adjustment
      addRegistrationAdjustment();
      const registrationContainer = document.getElementById('registrationAdjustmentsList');
      const lastRegistrationRow = registrationContainer.querySelector('div:last-child');
      if (lastRegistrationRow) {
        const inputs = lastRegistrationRow.querySelectorAll('input[type="text"]');
        inputs[0].value = 'עליה לכביש בדיקה';
        inputs[1].value = '10%';
        inputs[2].value = '₪2000';
        lastRegistrationRow.querySelector('select').value = 'plus';
      }
      
      // Trigger the update
      updateHelperFromAdjustments();
    }
    
    // Expose test function globally
    window.addTestAdjustments = addTestAdjustments;
    
    // CRITICAL FIX: Add function to completely reset adjustment data
    function resetAdjustmentData() {
      console.log('🧹 RESET: Completely clearing all adjustment data');
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Clear all adjustment data
      if (helper.levi_report) {
        helper.levi_report.adjustments = [];
      }
      if (helper.levi) {
        helper.levi.custom_adjustments = [];
      }
      
      // Clear DOM
      // Final report adjustments container was removed - no action needed
      
      // Save cleaned helper
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      console.log('✅ RESET: All adjustment data cleared');
    }
    
    // Expose reset function globally for testing
    window.resetAdjustmentData = resetAdjustmentData;
    
    
    // Calculate and update GROSS PRICE (car properties only: base + features + registration)
    function updateGrossMarketValueCalculation() {
      try {
        // Get base price from the visible field that shows ₪118,000
        let basicPrice = 0;
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Priority 1: Direct from the basicPrice field that shows ₪118,000
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField?.value) {
          basicPrice = parseFloat(basicPriceField.value.replace(/[₪,]/g, '')) || 0;
          console.log('🔍 Using basicPrice field:', basicPrice);
        }
        // Priority 2: Try the visible field in the ערך הרכב ע"פ מחירון section
        else {
          const allInputs = document.querySelectorAll('input[type="text"]');
          for (let input of allInputs) {
            const numericValue = parseFloat(input.value.replace(/[₪,]/g, ''));
            if (numericValue > 0) {
              basicPrice = numericValue;
              console.log('🔍 Found price in field:', input.id || 'unknown', 'value:', basicPrice);
              break;
            }
          }
        }
        
        // Fallback: Use helper base price or market value if available, otherwise 0
        if (basicPrice === 0) {
          basicPrice = helper.calculations?.base_market_value || helper.levisummary?.base_price || helper.valuation?.base_price || 0;
          console.log('🔍 FALLBACK: Using helper base price:', basicPrice);
        }
        
        console.log('🔍 DEBUG: Final basic price for calculation:', basicPrice);
        
        // Collect features adjustments (car properties)
        const featuresAdjustments = [];
        const featuresRows = document.querySelectorAll('#featuresAdjustmentsList > div');
        featuresRows.forEach(row => {
          const type = row.querySelector('select').value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const description = inputs[0]?.value || '';
          const percent = parseFloat(inputs[1]?.value) || 0;
          const rawValue = parseFloat(inputs[2]?.value.replace(/[₪,]/g, '')) || 0;
          // SIMPLE FIX: Treat values exactly as they are - if minus then minus, if without then positive
          const hasMinusSign = inputs[2]?.value.includes('-');
          const signedValue = (type === 'minus' || hasMinusSign) ? -Math.abs(rawValue) : Math.abs(rawValue);

          if (signedValue !== 0) {
            featuresAdjustments.push({
              description,
              type,
              percent,
              value: signedValue,
              category: 'features'
            });
          }
        });
        
        // Collect registration adjustments (car properties)
        const registrationAdjustments = [];
        const registrationRows = document.querySelectorAll('#registrationAdjustmentsList > div');
        registrationRows.forEach(row => {
          const type = row.querySelector('select').value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const description = inputs[0]?.value || '';
          const percent = parseFloat(inputs[1]?.value) || 0;
          const rawValue = parseFloat(inputs[2]?.value.replace(/[₪,]/g, '')) || 0;
          // SIMPLE FIX: Treat values exactly as they are - if minus then minus, if without then positive
          const hasMinusSign = inputs[2]?.value.includes('-');
          const signedValue = (type === 'minus' || hasMinusSign) ? -Math.abs(rawValue) : Math.abs(rawValue);

          if (signedValue !== 0) {
            registrationAdjustments.push({
              description,
              type,
              percent,
              value: signedValue,
              category: 'registration'
            });
          }
        });
        
        // USE EXACT SAME LOGIC AS WORKING updateFullMarketValueCalculation
        let currentValue = basicPrice;
        
        // Process features section - CORRECTED CALCULATION LOGIC
        const grossFeaturesRows = document.querySelectorAll('#featuresAdjustmentsList > div');
        grossFeaturesRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            // FIXED: Parse amount preserving sign, then apply dropdown type logic
            const amountText = (inputs[3].value || '').trim();
            let amount = parseFloat(amountText.replace(/[₪,\s]/g, '')) || 0;
            const type = inputs[1].value;
            
            // Apply type logic: if type is minus and amount is positive, make negative
            // If type is plus and amount is negative, use absolute value
            if (isReductionType(type) && amount > 0) {
              amount = -amount;
            } else if (!isReductionType(type) && amount < 0) {
              amount = Math.abs(amount);
            }
            
            currentValue += amount;
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update features cumulative
        const grossFeaturesCumulativeEl = document.getElementById('grossFeaturesCumulative');
        if (grossFeaturesCumulativeEl) {
          const span = grossFeaturesCumulativeEl.querySelector('span');
          if (span) {
            span.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
            span.style.color = currentValue >= basicPrice ? '#28a745' : '#dc3545';
          }
        }
        
        // Save features cumulative value
        const featuresCumulativeValue = Math.round(currentValue);
        saveAdjustmentCumulativeOnly('features', featuresCumulativeValue);
        
        // Process registration section - Add fixed values to cumulative
        const grossRegistrationRows = document.querySelectorAll('#registrationAdjustmentsList > div');
        grossRegistrationRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            const type = inputs[1]?.value || 'plus';
            const valueInput = inputs[3]; // ערך field
            if (valueInput && valueInput.value) {
              const value = parseFloat(valueInput.value.replace(/[₪,\s-]/g, '')) || 0;
              const signedValue = isReductionType(type) ? -value : value;
              currentValue += signedValue;
            }
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update registration cumulative
        const grossRegistrationCumulativeEl = document.getElementById('grossRegistrationCumulative');
        if (grossRegistrationCumulativeEl) {
          const span = grossRegistrationCumulativeEl.querySelector('span');
          if (span) {
            span.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
            span.style.color = currentValue >= basicPrice ? '#28a745' : '#dc3545';
          }
        }
        
        // Save registration cumulative value
        const registrationCumulativeValue = Math.round(currentValue);
        saveAdjustmentCumulativeOnly('registration', registrationCumulativeValue);
        
        // Update result field
        const resultField = document.getElementById('grossMarketValueResult');
        if (resultField) {
          resultField.value = `₪${Math.round(currentValue).toLocaleString()}`;
        }
        
        const grossPrice = currentValue;
        
        console.log(`🏠 GROSS PRICE CALCULATION: Base ₪${basicPrice.toLocaleString()} → Final ₪${grossPrice.toLocaleString()}`);
        console.log('✅ Corrected calculation: Base + (Base × Features%) + Registration = Final');
        console.log('📋 Features adjustments:', featuresAdjustments);
        console.log('📋 Registration adjustments:', registrationAdjustments);
        
        // Save to helper.calculations.vehicle_value_gross
        if (!helper.calculations) helper.calculations = {};
        helper.calculations.vehicle_value_gross = grossPrice;
        
        // PHASE 6: Add totals structure to final_report.adjustments
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.adjustments) helper.final_report.adjustments = {};
        if (!helper.final_report.adjustments.totals) {
          helper.final_report.adjustments.totals = {};
        }
        
        // Calculate and save features total
        let featuresTotalValue = 0;
        let featuresTotalPercent = 0;
        featuresAdjustments.forEach(adj => {
          featuresTotalValue += adj.value;
          if (adj.percent) {
            featuresTotalPercent += (adj.type === 'minus' ? -adj.percent : adj.percent);
          }
        });
        
        // Calculate and save registration total
        let registrationTotalValue = 0;
        let registrationTotalPercent = 0;
        registrationAdjustments.forEach(adj => {
          registrationTotalValue += adj.value;
          if (adj.percent) {
            registrationTotalPercent += (adj.type === 'minus' ? -adj.percent : adj.percent);
          }
        });
        
        // Save totals
        helper.final_report.adjustments.totals.features = {
          value: featuresTotalValue,
          percent: featuresTotalPercent,
          count: featuresAdjustments.length
        };
        
        helper.final_report.adjustments.totals.registration = {
          value: registrationTotalValue,
          percent: registrationTotalPercent,
          count: registrationAdjustments.length
        };
        
        helper.final_report.adjustments.totals.gross_total = {
          value: featuresTotalValue + registrationTotalValue,
          percent: featuresTotalPercent + registrationTotalPercent,
          final_value: grossPrice
        };
        
        // Update helper in window and session storage
        window.helper = helper;
        if (typeof updateHelper === 'function') {
          updateHelper('calculations', helper.calculations);
          updateHelper('final_report', helper.final_report);
        }
        // Calculate and restore adjustments_value
        if (typeof window.calculateValuationAdjustments === 'function') {
          window.calculateValuationAdjustments();
        }
        
        if (typeof saveHelperToStorage === 'function') {
          saveHelperToStorage();
        }
        
        console.log('✅ Saved gross value to helper.calculations.vehicle_value_gross:', grossPrice);
        
        // Update bridge fields in helper.calculations for consistency (base_price only)
        const rawBasePrice = helper.valuation?.base_price || 
                             helper.car_details?.base_price || 
                             helper.levi_report?.base_price || 0;
        const originalBasePrice = parseFloat(String(rawBasePrice).replace(/[₪,]/g, '')) || 0;
        helper.calculations.base_price = originalBasePrice;
        // Note: final_adjustments_value should only be updated by the final market value calculation
        
        // Update gross percentage calculation immediately
        setTimeout(() => {
          updateGrossPercentageFromGrossValue();
        }, 100);
        
        // Sync cumulative values to ensure they persist
        setTimeout(() => {
          syncGrossCumulativeValues();
        }, 200);
        
      } catch (error) {
        console.error('Error calculating gross price:', error);
      }
    }
    
    // Load data from helper for gross calculation
    function loadGrossCalculationData() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Load basic price from multiple sources
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField) {
          let basicPrice = 0;
          
          // Priority 1: Check carBasePrice field first
          const carBasePriceField = document.getElementById('carBasePrice');
          if (carBasePriceField && carBasePriceField.value) {
            const carBasePriceStr = carBasePriceField.value.replace(/[₪,]/g, '') || '0';
            basicPrice = parseFloat(carBasePriceStr) || 0;
          }
          
          // Priority 2: Try helper data sources if field is empty
          if (basicPrice === 0) {
            if (helper.valuation?.base_price) {
              basicPrice = parseFloat(helper.valuation.base_price.toString().replace(/[₪,]/g, ''));
            } else if (helper.levi_report?.base_price) {
              basicPrice = parseFloat(helper.levi_report.base_price);
            } else if (helper.expertise?.levi_report?.base_price) {
              basicPrice = parseFloat(helper.expertise.levi_report.base_price);
            } else if (helper.levisummary?.base_price) {
              basicPrice = parseFloat(helper.levisummary.base_price);
            } else if (helper.car_details?.base_price) {
              basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[₪,]/g, ''));
            }
          }
          
          if (basicPrice > 0) {
            basicPriceField.value = `₪${basicPrice.toLocaleString()}`;
          }
        }
        
        // DON'T clear containers or load Levi data here - loadGrossAdjustments() already handles that
        // This function now only handles manual entries to avoid duplication
        
        // Skip Levi data loading - already handled by loadGrossAdjustments()
        // Jump directly to manual entries
        if (featuresData && (featuresData.percent || featuresData.percentage || featuresData.amount)) {
          let percent = 0;
          if (featuresData.percent) {
            const percentStr = String(featuresData.percent).replace(/[%\s]/g, '');
            percent = parseFloat(percentStr) || 0;
          } else if (featuresData.percentage) {
            const percentStr = String(featuresData.percentage).replace(/[%\s]/g, '');
            percent = parseFloat(percentStr) || 0;
          }
          
          let amount = 0;
          if (featuresData.amount) {
            const amountStr = String(featuresData.amount).replace(/[₪,\sש]/g, '');
            amount = parseFloat(amountStr) || 0;
          }
          
          const description = featuresData.value || featuresData.description || 'תוספות מאפיינים';
          const isReduction = percent < 0 || amount < 0;
          
          addFeatureAdjustment();
          const lastRow = document.querySelector('#featuresAdjustmentsList > div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input[type="text"]');
            inputs[0].value = description;
            lastRow.querySelector('select').value = isReduction ? 'minus' : 'plus';
            
            // CRITICAL FIX: Display minus sign for negative values
            const displayPercent = isReduction ? `-${Math.abs(percent)}` : Math.abs(percent);
            const displayAmount = isReduction ? `-${Math.abs(amount)}` : Math.abs(amount);
            
            inputs[1].value = percent ? `${displayPercent}%` : '';
            inputs[2].value = amount ? `₪${displayAmount.toLocaleString()}` : '';
          }
        }
        
        // Load registration adjustments using EXACT working logic
        const registrationData = adjustments['registration'];
        if (registrationData && (registrationData.percent || registrationData.percentage || registrationData.amount)) {
          let percent = 0;
          if (registrationData.percent) {
            const percentStr = String(registrationData.percent).replace(/[%\s]/g, '');
            percent = parseFloat(percentStr) || 0;
          } else if (registrationData.percentage) {
            const percentStr = String(registrationData.percentage).replace(/[%\s]/g, '');
            percent = parseFloat(percentStr) || 0;
          }
          
          let amount = 0;
          if (registrationData.amount) {
            const amountStr = String(registrationData.amount).replace(/[₪,\sש]/g, '');
            amount = parseFloat(amountStr) || 0;
          }
          
          const description = registrationData.value || registrationData.description || 'עליה לכביש';
          const isReduction = percent < 0 || amount < 0;
          
          addRegistrationAdjustment();
          const lastRow = document.querySelector('#registrationAdjustmentsList > div:last-child');
          if (lastRow) {
            const inputs = lastRow.querySelectorAll('input[type="text"]');
            inputs[0].value = description;
            lastRow.querySelector('select').value = isReduction ? 'minus' : 'plus';
            
            // CRITICAL FIX: Display minus sign for negative values
            const displayPercent = isReduction ? `-${Math.abs(percent)}` : Math.abs(percent);
            const displayAmount = isReduction ? `-${Math.abs(amount)}` : Math.abs(amount);
            
            inputs[1].value = percent ? `${displayPercent}%` : '';
            inputs[2].value = amount ? `₪${displayAmount.toLocaleString()}` : '';
          }
        }
        
        // Also check for direct registration fields in levi_report (structured data)
        if (helper.expertise?.levi_report?.adjustments?.registration) {
          const regAdj = helper.expertise.levi_report.adjustments.registration;
          const registrationValue = parseFloat(regAdj.value || regAdj.total || 0);
          
          if (registrationValue !== 0) {
            console.log('🔧 Loading registration from expertise.levi_report.adjustments:', regAdj);
            addRegistrationAdjustment();
            const lastRow = document.querySelector('#registrationAdjustmentsList > div:last-child');
            if (lastRow) {
              lastRow.querySelector('input[type="text"]:first-of-type').value = 'עליה לכביש';
              lastRow.querySelector('select').value = registrationValue >= 0 ? 'plus' : 'minus';
              // CRITICAL FIX: Display minus sign for negative values
              const displayRegValue = registrationValue >= 0 ? Math.abs(registrationValue) : `-${Math.abs(registrationValue)}`;
              lastRow.querySelector('input[type="text"]:last-of-type').value = `₪${displayRegValue.toLocaleString()}`;
            }
          }
        }
        
        // Also check for features in structured data
        if (helper.expertise?.levi_report?.adjustments?.features) {
          const featAdj = helper.expertise.levi_report.adjustments.features;
          const featuresValue = parseFloat(featAdj.value || featAdj.total || 0);
          
          if (featuresValue !== 0) {
            console.log('🔧 Loading features from expertise.levi_report.adjustments:', featAdj);
            addFeatureAdjustment();
            const lastRow = document.querySelector('#featuresAdjustmentsList > div:last-child');
            if (lastRow) {
              lastRow.querySelector('input[type="text"]:first-of-type').value = 'מאפיינים';
              lastRow.querySelector('select').value = featuresValue >= 0 ? 'plus' : 'minus';
              // CRITICAL FIX: Display minus sign for negative values
              const displayFeatValue = featuresValue >= 0 ? Math.abs(featuresValue) : `-${Math.abs(featuresValue)}`;
              lastRow.querySelector('input[type="text"]:last-of-type').value = `₪${displayFeatValue.toLocaleString()}`;
            }
          }
        }
        
        // Check for additional adjustments from levisummary (backup structure) - Handle object or array
        if (helper.levisummary?.adjustments) {
          const adjustments = Array.isArray(helper.levisummary.adjustments) ? helper.levisummary.adjustments : Object.values(helper.levisummary.adjustments);
          adjustments.forEach(adj => {
            const desc = adj.description?.toLowerCase() || '';
            const value = parseFloat(adj.value || 0);
            
            if (value !== 0) {
              if (desc.includes('עליה לכביש') || desc.includes('registration')) {
                console.log('🔧 Loading registration from levisummary:', adj);
                addRegistrationAdjustment();
                const lastRow = document.querySelector('#registrationAdjustmentsList > div:last-child');
                if (lastRow) {
                  lastRow.querySelector('input[type="text"]:first-of-type').value = adj.description || 'עליה לכביש';
                  lastRow.querySelector('select').value = value >= 0 ? 'plus' : 'minus';
                  // CRITICAL FIX: Display minus sign for negative values
                  const displayValue = value >= 0 ? Math.abs(value) : `-${Math.abs(value)}`;
                  lastRow.querySelector('input[type="text"]:last-of-type').value = `₪${displayValue.toLocaleString()}`;
                }
              } else if (desc.includes('מאפיינים') || desc.includes('features')) {
                console.log('🔧 Loading features from levisummary:', adj);
                addFeatureAdjustment();
                const lastRow = document.querySelector('#featuresAdjustmentsList > div:last-child');
                if (lastRow) {
                  lastRow.querySelector('input[type="text"]:first-of-type').value = adj.description || 'מאפיינים';
                  lastRow.querySelector('select').value = value >= 0 ? 'plus' : 'minus';
                  // CRITICAL FIX: Display minus sign for negative values
                  const displayValue = value >= 0 ? Math.abs(value) : `-${Math.abs(value)}`;
                  lastRow.querySelector('input[type="text"]:last-of-type').value = `₪${displayValue.toLocaleString()}`;
                }
              }
            }
          });
        }
        
        // LOAD MANUAL ENTRIES from final_report.adjustments (after Levi data)
        if (helper.final_report?.adjustments) {
          const finalReportAdjustments = helper.final_report.adjustments;
          
          // Load manual features
          const manualFeatures = finalReportAdjustments.features?.filter(item => item.source === 'manual') || [];
          if (manualFeatures.length > 0) {
            console.log(`📝 Loading ${manualFeatures.length} manual features adjustments`);
            manualFeatures.forEach((item, index) => {
              addFeatureAdjustment();
              const rows = document.querySelectorAll('#featuresAdjustmentsList > div');
              const lastRow = rows[rows.length - 1];
              
              if (lastRow) {
                const inputs = lastRow.querySelectorAll('input, select');
                if (inputs.length >= 4) {
                  inputs[0].value = item.value || '';
                  inputs[1].value = item.type || 'plus';
                  inputs[2].value = item.percentage || item.percent || '';
                  // Check if it's a reduction type to preserve minus sign
                  const isReduction = item.type === 'minus' || item.type === 'הפחתה' || 
                                     item.type === 'הפחתה (-)' || item.type === 'הורדה';
                  let displayAmount = Math.abs(item.amount || 0);
                  if (isReduction && displayAmount > 0) {
                    displayAmount = -displayAmount;
                  }
                  inputs[3].value = item.amount_display || (item.amount ? `₪${displayAmount.toLocaleString()}` : '');
                  
                  // Keep as manual source
                  lastRow.setAttribute('data-source', 'manual');
                  
                  console.log(`✅ Loaded manual features item ${index}:`, {
                    description: inputs[0].value,
                    type: inputs[1].value,
                    percent: inputs[2].value,
                    amount: inputs[3].value
                  });
                }
              }
            });
          }
          
          // Load manual registration
          const manualRegistration = finalReportAdjustments.registration?.filter(item => item.source === 'manual') || [];
          if (manualRegistration.length > 0) {
            console.log(`📝 Loading ${manualRegistration.length} manual registration adjustments`);
            manualRegistration.forEach((item, index) => {
              addRegistrationAdjustment();
              const rows = document.querySelectorAll('#registrationAdjustmentsList > div');
              const lastRow = rows[rows.length - 1];
              
              if (lastRow) {
                const inputs = lastRow.querySelectorAll('input, select');
                if (inputs.length >= 4) {
                  inputs[0].value = item.value || '';
                  inputs[1].value = item.type || 'plus';
                  inputs[2].value = item.percentage || item.percent || '';
                  // Check if it's a reduction type to preserve minus sign
                  const isReduction = item.type === 'minus' || item.type === 'הפחתה' || 
                                     item.type === 'הפחתה (-)' || item.type === 'הורדה';
                  let displayAmount = Math.abs(item.amount || 0);
                  if (isReduction && displayAmount > 0) {
                    displayAmount = -displayAmount;
                  }
                  inputs[3].value = item.amount_display || (item.amount ? `₪${displayAmount.toLocaleString()}` : '');
                  
                  // Keep as manual source
                  lastRow.setAttribute('data-source', 'manual');
                  
                  console.log(`✅ Loaded manual registration item ${index}:`, {
                    description: inputs[0].value,
                    type: inputs[1].value,
                    percent: inputs[2].value,
                    amount: inputs[3].value
                  });
                }
              }
            });
          }
        }
        
        // Calculate initial gross market value
        updateGrossMarketValueCalculation();
        
        // Trigger calculation for all existing adjustment rows
        setTimeout(() => {
          const allPercentInputs = document.querySelectorAll('#featuresAdjustmentsList input[placeholder="אחוז"], #registrationAdjustmentsList input[placeholder="אחוז"]');
          allPercentInputs.forEach(input => {
            if (input.value) {
              calculateAdjustmentValue(input);
            }
          });
          
          // Recalculate final values
          updateGrossMarketValueCalculation();
        }, 300);
        
        // Load second bulk data if available
        setTimeout(() => {
          loadSecondBulkData();
        }, 500);
        
      } catch (error) {
        console.error('Error loading gross calculation data:', error);
      }
    }
    
    // Load data for second bulk (gross percentage)
    function loadSecondBulkData() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Load claims data if available
        if (helper.claims_data) {
          const totalClaimField = document.getElementById('totalClaim');
          const leviPriceListField = document.getElementById('leviPriceList');
          const grossPercentField = document.getElementById('grossPercent');
          
          if (totalClaimField && helper.claims_data.total_claim) {
            totalClaimField.value = helper.claims_data.total_claim;
          }
          
          
          if (leviPriceListField && helper.claims_data.gross_value) {
            leviPriceListField.value = helper.claims_data.gross_value;
          }
          
          if (grossPercentField && helper.claims_data.gross_percent) {
            grossPercentField.value = helper.claims_data.gross_percent;
          }
        }
        
        // If no saved data, calculate from current state
        if (!helper.claims_data?.total_claim) {
          updateGrossPercentageFromGrossValue();
        }
        
      } catch (error) {
        console.error('Error loading second bulk data:', error);
      }
    }
    
    // Update gross percentage when gross market value changes
    function updateGrossPercentageFromGrossValue() {
      // Get GROSS price (car properties only)
      let grossPrice = 0;
      
      if (window.CalculationInterface && typeof window.CalculationInterface.getGrossMarketValue === 'function') {
        grossPrice = window.CalculationInterface.getGrossMarketValue();
      } else {
        // Fallback: calculate gross price directly from fields
        const grossResultField = document.getElementById('grossMarketValueResult');
        if (grossResultField && grossResultField.value) {
          grossPrice = parseFloat(grossResultField.value.replace(/[₪,]/g, '')) || 0;
        } else {
          // Further fallback: use basic price
          const basicPriceField = document.getElementById('basicPrice');
          if (basicPriceField && basicPriceField.value) {
            grossPrice = parseFloat(basicPriceField.value.replace(/[₪,]/g, '')) || 0;
          }
        }
      }
      
      // Get total claim from damage centers calculation
      const totalClaim = calculateTotalClaimFromDamageCenters();
      
      console.log('🔍 Updating GROSS DAMAGE PERCENTAGE (using gross price, not market price):', {
        grossPrice,
        totalClaim
      });
      
      // Update the display fields
      const totalClaimField = document.getElementById('totalClaim');
      const leviPriceListField = document.getElementById('leviPriceList');
      
      if (totalClaimField && totalClaim > 0) {
        totalClaimField.value = `₪${totalClaim.toLocaleString()}`;
      }
      
      if (leviPriceListField && grossPrice > 0) {
        leviPriceListField.value = `₪${grossPrice.toLocaleString()}`;
      }
      
      // Get authorized claim instead of total claim
      const authorizedClaimField = document.getElementById('authorizedClaim');
      const authorizedClaimValue = authorizedClaimField?.value || '';
      const authorizedClaim = parseFloat(authorizedClaimValue.replace(/[₪,]/g, '')) || totalClaim; // fallback to totalClaim if no authorized claim
      
      // Calculate and update GROSS DAMAGE PERCENTAGE (authorized claim ÷ gross price)
      if (grossPrice > 0 && authorizedClaim > 0) {
        const grossDamagePercentage = (authorizedClaim / grossPrice) * 100;
        const grossPercentField = document.getElementById('grossPercent');
        if (grossPercentField) {
          const formattedPercentage = `${Math.round(grossDamagePercentage * 100) / 100}%`;
          grossPercentField.value = formattedPercentage;
          
          // Update helper with GROSS damage percentage (separate from market damage percentage)
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          helper.calculations = helper.calculations || {};
          helper.calculations.damage_percent_gross = grossDamagePercentage;
          helper.calculations.total_damage = totalClaim;
          
          // Update claims data for backward compatibility
          helper.claims_data = helper.claims_data || {};
          helper.claims_data.gross_percent = formattedPercentage;
          
          
          helper.claims_data.gross_value = `₪${grossPrice.toLocaleString()}`;
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          console.log(`📊 GROSS DAMAGE %: ${authorizedClaim.toLocaleString()} ÷ ${grossPrice.toLocaleString()} = ${formattedPercentage}`);
          console.log(`🏠 This uses GROSS PRICE (car properties only), not market price`);
        }
      }
    }
    
    // CALCULATE TOTAL CLAIM FROM DAMAGE CENTERS
    function calculateTotalClaimFromDamageCenters() {
      try {
        let totalClaim = 0;
        
        // Get damage centers from the summary or helper
        const damageCentersContent = document.getElementById('damageCentersContent');
        if (damageCentersContent) {
          const damageRows = damageCentersContent.querySelectorAll('.damage-center-row');
          damageRows.forEach(row => {
            const totalField = row.querySelector('.total-field');
            if (totalField && totalField.value) {
              const total = parseFloat(totalField.value.replace(/[₪,]/g, '')) || 0;
              totalClaim += total;
            }
          });
        }
        
        // Fallback: try to get from summary section
        if (totalClaim === 0) {
          const sumClaimField = document.getElementById('sumClaim');
          if (sumClaimField && sumClaimField.value) {
            totalClaim = parseFloat(sumClaimField.value.replace(/[₪,]/g, '')) || 0;
          }
        }
        
        // Fallback: try to get from helper
        if (totalClaim === 0) {
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          if (helper.expertise?.damage_blocks) {
            helper.expertise.damage_blocks.forEach(block => {
              totalClaim += (parseFloat(block.parts_cost) || 0) + 
                           (parseFloat(block.work_cost) || 0) + 
                           (parseFloat(block.repairs_cost) || 0);
            });
          }
        }
        
        console.log('💰 Total claim from damage centers:', totalClaim);
        return totalClaim;
      } catch (error) {
        console.error('Error calculating total claim from damage centers:', error);
        return 0;
      }
    }
    
    // SIMPLE CALCULATION FUNCTIONS FOR NEW SYSTEM
    /**
     * Calculate the final appraised vehicle value based on adjustments.
     * Implements the correct calculation order from todo.md lines 337-391
     */
    function calculateVehicleValue(basePrice, adjustments) {
      if (typeof basePrice !== 'number' || isNaN(basePrice)) {
        throw new Error('Invalid base price');
      }

      const safeAdj = (adj, current) => {
        if (!adj) return 0;
        if (adj.percent && typeof adj.percent === 'number') {
          return current * (adj.percent / 100);
        }
        if (adj.fixed && typeof adj.fixed === 'number') {
          return adj.fixed;
        }
        return 0;
      };

      // Step 1: Independent adjustments (Features + Registration) using Base Price
      const featuresAdj = safeAdj(adjustments.features, basePrice);
      const registrationAdj = safeAdj(adjustments.registration, basePrice);

      const grossValue = basePrice + featuresAdj + registrationAdj;

      // Step 2: Sequential adjustments (Ownership → Mileage → Number of Owners)
      let currentValue = grossValue;

      for (const key of ['ownershipType', 'mileage', 'numOwners']) {
        const adj = adjustments[key];
        if (!adj) continue; // skip if missing or zero
        const adjAmount = safeAdj(adj, currentValue);
        currentValue += adjAmount; // apply sequentially
      }

      return Math.round(currentValue); // round to nearest whole currency unit
    }

    function calculateGrossMarketValue() {
      updateGrossMarketValueCalculation();
    }
    
    function calculateGrossPercentage() {
      updateGrossPercentageFromGrossValue();
    }
    
    function calculateFullMarketValue() {
      // updateFullMarketValueCalculation() removed
    }
    
    // FULL MARKET VALUE CALCULATION FUNCTIONS
    
    // Add full market adjustment row
    // Add Full Features Adjustment
    function addFullFeaturesAdjustment() {
      const container = document.getElementById('fullFeaturesAdjustmentsList');
      const rowId = 'fullFeaturesAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור תוספת מאפיין" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));" title="">
              <option value="plus">תוספת (+)</option>
              <option value="minus">הפחתה (-)</option>
            </select></div>
            <div><input type="text" placeholder="אחוז" title="" oninput="calculateAdjustmentValueSimple(this); this.title = this.value;" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(this.value) || 0), safeParseAmount(inputs[3].value)); this.title = this.value;" /></div>
            <div><input type="text" placeholder="₪" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'features'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(this.value)); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Add Full Registration Adjustment
    function addFullRegistrationAdjustment() {
      const container = document.getElementById('fullRegistrationAdjustmentsList');
      const rowId = 'fullRegistrationAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור עליה לכביש" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration');" /></div>
            <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));">
              <option value="plus">תוספת (+)</option>
              <option value="minus">הפחתה (-)</option>
            </select></div>
            <div><input type="text" placeholder="אחוז" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(this.value) || 0), safeParseAmount(inputs[3].value));" /></div>
            <div><input type="text" placeholder="₪" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'registration'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(this.value));" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Add Mileage Adjustment
    function addMileageAdjustment() {
      const container = document.getElementById('mileageAdjustmentsList');
      const rowId = 'mileageAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור מס ק"מ" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'mileage'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'mileage'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));" title="">
              <option value="plus">תוספת (+)</option>
              <option value="minus">הפחתה (-)</option>
            </select></div>
            <div><input type="text" placeholder="אחוז" title="" oninput="calculateAdjustmentValueSimple(this); this.title = this.value;" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'mileage'); this.title = this.value;" /></div>
            <div><input type="text" placeholder="₪" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'mileage'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Add Ownership Type Adjustment
    function addOwnershipAdjustment() {
      const container = document.getElementById('ownershipAdjustmentsList');
      const rowId = 'ownershipAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור סוג בעלות" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_type'); this.title = this.value;" oninput="this.title = this.value;" /></div>
          <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_type'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));" title="">
            <option value="plus">תוספת (+)</option>
            <option value="minus">הפחתה (-)</option>
          </select></div>
            <div><input type="text" placeholder="אחוז" title="" oninput="calculateAdjustmentValueSimple(this); this.title = this.value;" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_type'); this.title = this.value;" /></div>
            <div><input type="text" placeholder="₪" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_type'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Add Number of Owners Adjustment
    function addOwnersAdjustment() {
      const container = document.getElementById('ownersAdjustmentsList');
      const rowId = 'ownersAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור מספר בעלים" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_history'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><select onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_history'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, Math.abs(parseFloat(inputs[2].value) || 0), safeParseAmount(inputs[3].value));" title="">
              <option value="plus">תוספת (+)</option>
              <option value="minus">הפחתה (-)</option>
            </select></div>
            <div><input type="text" placeholder="אחוז" title="" oninput="calculateAdjustmentValueSimple(this); this.title = this.value;" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_history'); this.title = this.value;" /></div>
            <div><input type="text" placeholder="₪" title="" onchange="updateFullMarketValueCalculation(); syncAdjustmentToHelper(this, 'ownership_history'); this.title = this.value;" oninput="this.title = this.value;" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Add General Full Market Adjustment (additional)
    function addFullMarketAdjustment() {
      const container = document.getElementById('allAdjustmentsList');
      const rowId = 'fullAdj_' + Date.now();
      
      const newRow = `
        <div id="${rowId}" class="adjustment-row" data-source="manual">
          <div style="display:grid; grid-template-columns:2fr 1fr 1fr 1fr 80px; gap:10px; margin-bottom:8px;">
            <div><input type="text" placeholder="תיאור התאמה נוספת" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(inputs[2].value) || 0, safeParseAmount(inputs[3].value));" /></div>
            <div><select onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, this.value, parseFloat(inputs[2].value) || 0, safeParseAmount(inputs[3].value));">
              <option value="plus">תוספת (+)</option>
              <option value="minus">הפחתה (-)</option>
            </select></div>
            <div><input type="text" placeholder="אחוז" oninput="calculateAdjustmentValueSimple(this);" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(this.value) || 0, safeParseAmount(inputs[3].value));" /></div>
            <div><input type="text" placeholder="₪" onchange="updateFullMarketValueCalculation(); updateHelperFromAdjustments(); syncAdjustmentToHelper(this, 'additional'); const row = this.closest('.adjustment-row'); const inputs = row.querySelectorAll('input, select'); formatAdjustmentDisplay(row, inputs[1].value, parseFloat(inputs[2].value) || 0, safeParseAmount(this.value));" /></div>
            <div><button class="btn remove" onclick="removeAdjustmentRow('${rowId}')">מחק</button></div>
          </div>
          <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
            ערך מצטבר: <span class="row-cumulative" style="font-weight: bold; color: #28a745;">₪0</span>
          </div>
        </div>
      `;
      
      container.insertAdjacentHTML('beforeend', newRow);
      // updateFullMarketValueCalculation() removed
    }
    
    // Remove full market adjustment row
    function removeFullMarketAdjustmentRow(rowId) {
      const row = document.getElementById(rowId);
      if (row) {
        row.remove();
        // updateFullMarketValueCalculation() removed
      }
    }
    
    // DELETED: updateFullMarketValueCalculation() function removed
    // Full market value now comes only from UI input, not automatic calculations
    
    // Update cumulative display for each section
    function updateCumulativeDisplay(sectionName, currentValue) {
      const nameMapping = {
        'תוספות מאפיינים': 'featuresCumulative',
        'עליה לכביש': 'registrationCumulative', 
        'מס ק"מ': 'mileageCumulative',
        'סוג בעלות': 'ownershipCumulative',
        'מספר בעלים': 'ownersCumulative'
      };
      
      const cumulativeId = nameMapping[sectionName];
      if (cumulativeId) {
        const cumulativeElement = document.getElementById(cumulativeId);
        if (cumulativeElement) {
          const span = cumulativeElement.querySelector('span');
          if (span) {
            span.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
            const minExpectedValue = helper.calculations?.base_market_value || helper.levisummary?.base_price || 100000;
            span.style.color = currentValue >= minExpectedValue ? '#28a745' : '#dc3545';
          }
        }
      }
    }
    
    // Calculate full market value with cumulative updates
    function updateFullMarketValueCalculation() {
      try {
        // Get helper object first
        const helper = window.helper || {};
        
        // Get base price from fullBasicPrice field
        let basicPrice = 0;
        const fullBasicPriceField = document.getElementById('fullBasicPrice');
        if (fullBasicPriceField?.value) {
          basicPrice = parseFloat(fullBasicPriceField.value.replace(/[₪,]/g, '')) || 0;
        }
        
        // Fallback: Use helper base price if field is empty
        if (basicPrice === 0) {
          basicPrice = helper.calculations?.base_market_value || helper.levisummary?.base_price || helper.valuation?.base_price || 0;
        }
        let currentValue = basicPrice;
        
        // 1. Process Features Adjustments
        const fullFeaturesRows = document.querySelectorAll('#fullFeaturesAdjustmentsList > div');
        fullFeaturesRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            // FIXED: Parse amount preserving sign, then apply dropdown type logic
            const amountText = (inputs[3].value || '').trim();
            let amount = parseFloat(amountText.replace(/[₪,\s]/g, '')) || 0;
            const type = inputs[1].value;
            
            // Apply type logic: if type is minus and amount is positive, make negative
            // If type is plus and amount is negative, use absolute value
            if (isReductionType(type) && amount > 0) {
              amount = -amount;
            } else if (!isReductionType(type) && amount < 0) {
              amount = Math.abs(amount);
            }
            
            currentValue += amount;
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update features cumulative - this shows currentValue after features
        updateCumulativeDisplay('תוספות מאפיינים', currentValue);
        const afterFeatures = currentValue; // Store value after features
        
        // 2. Process Registration Adjustments
        const fullRegistrationRows = document.querySelectorAll('#fullRegistrationAdjustmentsList > div');
        fullRegistrationRows.forEach(row => {
          const inputs = row.querySelectorAll('input, select');
          if (inputs.length >= 4) {
            // FIXED: Parse amount preserving sign, then apply dropdown type logic
            const amountText = (inputs[3].value || '').trim();
            let amount = parseFloat(amountText.replace(/[₪,\s]/g, '')) || 0;
            const type = inputs[1].value;
            
            // Apply type logic: if type is minus and amount is positive, make negative
            // If type is plus and amount is negative, use absolute value
            if (isReductionType(type) && amount > 0) {
              amount = -amount;
            } else if (!isReductionType(type) && amount < 0) {
              amount = Math.abs(amount);
            }
            
            currentValue += amount;
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update registration cumulative - this shows currentValue after features + registration
        updateCumulativeDisplay('עליה לכביש', currentValue);
        const afterRegistration = currentValue; // This is the GROSS price that subsequent calculations use
        
        // 3. Process Mileage Adjustments
        const mileageRows = document.querySelectorAll('#mileageAdjustmentsList > div');
        mileageRows.forEach((row, index) => {
          const select = row.querySelector('select');
          const type = select?.value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const percentInput = inputs[1]; // Percentage field
          const valueInput = inputs[2];   // Value field
          
          // Conditional logic: percentage vs direct value
          if (percentInput && percentInput.value && parseFloat(percentInput.value) !== 0) {
            // HAS PERCENTAGE: Calculate SPECIFIC result from PREVIOUS CUMULATIVE (not base price)
            const percent = parseFloat(percentInput.value);
            const previousCumulative = currentValue; // This is the previous cumulative result (132,620)
            const specificResult = previousCumulative * (Math.abs(percent) / 100); // Calculate from previous cumulative
            
            // Apply dropdown selection to get final cumulative
            if (type === 'minus') {
              currentValue = previousCumulative - specificResult;
            } else {
              currentValue = previousCumulative + specificResult;
            }
            
            // UPDATE THE UI: Set the correct specific value in the value field
            // Skip updating during page load to preserve manual amounts
            if (valueInput && !window.pageLoadInProgress) {
              const roundedResult = Math.round(specificResult);
              const displayAmount = roundedResult.toLocaleString();
              valueInput.value = (type === 'minus') ? `-₪${displayAmount}` : `₪${displayAmount}`;
            }
          } else if (valueInput && valueInput.value) {
            // FIXED: Parse amount considering it might already have a minus sign
            const amountText = (valueInput.value || '').trim();
            const hasMinusSign = amountText.includes('-');
            const value = Math.abs(parseFloat(amountText.replace(/[₪,\s-]/g, '')) || 0);
            const signedValue = (type === 'minus') ? -value : value;
            currentValue += signedValue;
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update mileage cumulative - this shows currentValue after mileage
        updateCumulativeDisplay('מס ק"מ', currentValue);
        const afterMileage = currentValue; // Store value after mileage
        
        // Removed saveAdjustmentAmount - syncAdjustmentToHelper handles row-level cumulative properly
        
        // 4. Process Ownership Adjustments
        const ownershipRows = document.querySelectorAll('#ownershipAdjustmentsList > div');
        ownershipRows.forEach((row, index) => {
          const select = row.querySelector('select');
          const type = select?.value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const percentInput = inputs[1]; // Percentage field
          const valueInput = inputs[2];   // Value field
          
          // Conditional logic: percentage vs direct value
          if (percentInput && percentInput.value && parseFloat(percentInput.value) !== 0) {
            // HAS PERCENTAGE: Calculate SPECIFIC result from PREVIOUS CUMULATIVE (after mileage)
            const percent = parseFloat(percentInput.value);
            const previousCumulative = currentValue; // This is the previous cumulative result (after mileage)
            const specificResult = previousCumulative * (Math.abs(percent) / 100); // Calculate from previous cumulative
            
            // Apply dropdown selection to get final cumulative
            if (type === 'minus') {
              currentValue = previousCumulative - specificResult;
            } else {
              currentValue = previousCumulative + specificResult;
            }
            
            // UPDATE THE UI: Set the correct specific value in the value field
            // Skip updating during page load to preserve manual amounts
            if (valueInput && !window.pageLoadInProgress) {
              const roundedResult = Math.round(specificResult);
              const displayAmount = roundedResult.toLocaleString();
              valueInput.value = (type === 'minus') ? `-₪${displayAmount}` : `₪${displayAmount}`;
            }
          } else if (valueInput && valueInput.value) {
            // FIXED: Parse amount considering it might already have a minus sign
            const amountText = (valueInput.value || '').trim();
            const hasMinusSign = amountText.includes('-');
            const value = Math.abs(parseFloat(amountText.replace(/[₪,\s-]/g, '')) || 0);
            if (type === 'minus') {
              currentValue = currentValue - value;
            } else {
              currentValue = currentValue + value;
            }
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update ownership cumulative - this shows currentValue after ownership
        updateCumulativeDisplay('סוג בעלות', currentValue);
        const afterOwnership = currentValue; // Store value after ownership
        
        // Removed saveAdjustmentAmount - syncAdjustmentToHelper handles row-level cumulative properly
        
        // 5. Process Owners Adjustments
        const ownersRows = document.querySelectorAll('#ownersAdjustmentsList > div');
        ownersRows.forEach((row, index) => {
          const select = row.querySelector('select');
          const type = select?.value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const percentInput = inputs[1]; // Percentage field
          const valueInput = inputs[2];   // Value field
          
          // Conditional logic: percentage vs direct value
          if (percentInput && percentInput.value && parseFloat(percentInput.value) !== 0) {
            // HAS PERCENTAGE: Calculate SPECIFIC result from PREVIOUS CUMULATIVE (after ownership)
            const percent = parseFloat(percentInput.value);
            const previousCumulative = currentValue; // This is the previous cumulative result (after ownership)
            const specificResult = previousCumulative * (Math.abs(percent) / 100); // Calculate from previous cumulative
            
            // Apply dropdown selection to get final cumulative
            if (type === 'minus') {
              currentValue = previousCumulative - specificResult;
            } else {
              currentValue = previousCumulative + specificResult;
            }
            
            // UPDATE THE UI: Set the correct specific value in the value field
            // Skip updating during page load to preserve manual amounts
            if (valueInput && !window.pageLoadInProgress) {
              const roundedResult = Math.round(specificResult);
              const displayAmount = roundedResult.toLocaleString();
              valueInput.value = (type === 'minus') ? `-₪${displayAmount}` : `₪${displayAmount}`;
            }
          } else if (valueInput && valueInput.value) {
            // FIXED: Parse amount considering it might already have a minus sign
            const amountText = (valueInput.value || '').trim();
            const hasMinusSign = amountText.includes('-');
            const value = Math.abs(parseFloat(amountText.replace(/[₪,\s-]/g, '')) || 0);
            if (type === 'minus') {
              currentValue = currentValue - value;
            } else {
              currentValue = currentValue + value;
            }
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update owners cumulative
        updateCumulativeDisplay('מספר בעלים', currentValue);
        
        // Removed saveAdjustmentAmount - syncAdjustmentToHelper handles row-level cumulative properly
        
        // 6. Process Additional Market Adjustments
        const additionalRows = document.querySelectorAll('#allAdjustmentsList > div');
        additionalRows.forEach((row, index) => {
          const type = row.querySelector('select')?.value;
          const inputs = row.querySelectorAll('input[type="text"]');
          const percentInput = inputs[1]; // Percentage field
          const valueInput = inputs[2];   // Value field
          
          if (percentInput && percentInput.value) {
            const percent = parseFloat(percentInput.value) || 0;
            if (percent !== 0) { // Changed from > 0 to !== 0 to handle negative percentages
              const adjustment = basicPrice * (Math.abs(percent) / 100);
              const signedAdjustment = (type === 'minus' || percent < 0) ? -adjustment : adjustment;
              currentValue += signedAdjustment;
            }
          } else if (valueInput && valueInput.value) {
            // FIXED: Parse amount considering it might already have a minus sign
            const amountText = (valueInput.value || '').trim();
            const hasMinusSign = amountText.includes('-');
            const value = Math.abs(parseFloat(amountText.replace(/[₪,\s-]/g, '')) || 0);
            const signedValue = (type === 'minus') ? -value : value;
            currentValue += signedValue;
          }
          
          // Update row's cumulative display
          const rowCumulativeSpan = row.querySelector('.row-cumulative');
          if (rowCumulativeSpan) {
            rowCumulativeSpan.textContent = `₪${Math.round(currentValue).toLocaleString()}`;
          }
        });
        
        // Update final result field
        const resultField = document.getElementById('fullMarketValueResult');
        if (resultField) {
          resultField.value = `₪${Math.round(currentValue).toLocaleString()}`;
        }
        
        // Update bridge fields in helper.calculations for consistency (base_price only)
        if (helper.calculations) {
          const rawBasePrice = helper.valuation?.base_price || 
                               helper.car_details?.base_price || 
                               helper.levi_report?.base_price || 0;
          const originalBasePrice = parseFloat(String(rawBasePrice).replace(/[₪,]/g, '')) || 0;
          helper.calculations.base_price = originalBasePrice;
          helper.calculations.full_market_value = Math.round(currentValue);
          // Note: final_adjustments_value should only be updated by the main calculation function
        }
        
      } catch (error) {
        console.error('Error in FULL market value calculation:', error);
      }
    }
    
    // Load data from helper for full market value calculation
    function loadFullMarketValueData() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        
        // Load basic price (same as gross calculation)
        const fullBasicPriceField = document.getElementById('fullBasicPrice');
        const basicPriceField = document.getElementById('basicPrice');
        if (fullBasicPriceField && basicPriceField) {
          fullBasicPriceField.value = basicPriceField.value;
        } else if (fullBasicPriceField && helper.levi_report?.base_price) {
          fullBasicPriceField.value = `₪${parseFloat(helper.levi_report.base_price).toLocaleString()}`;
        }
        
        // AGGRESSIVE FIX: Clear container completely and verify it's empty
        const container = document.getElementById('allAdjustmentsList');
        if (container) {
          // Remove all child elements one by one to ensure proper cleanup
          while (container.firstChild) {
            container.removeChild(container.firstChild);
          }
          // Double-check with innerHTML as backup
          container.innerHTML = '';
          // Force DOM refresh
          container.offsetHeight;
          
          // Add a flag to prevent duplicate loading
          if (container.hasAttribute('data-loading')) {
            return;
          }
          container.setAttribute('data-loading', 'true');
        }
        
        // Create a unified adjustments array to prevent duplicates
        const allAdjustments = [];
        const seenAdjustments = new Set();
        
        // Add Levi adjustments first (these are the main ones)
        if (helper.levi_report?.adjustments) {
          helper.levi_report.adjustments.forEach(adj => {
            const adjustmentType = adj.value >= 0 ? 'plus' : 'minus';
            const key = `${adj.description}-${adj.percentage || adj.percent || 0}-${adjustmentType}`;
            if (!seenAdjustments.has(key)) {
              allAdjustments.push({
                description: adj.description || 'התאמה מלוי יצחק',
                percentage: adj.percentage || adj.percent || 0,
                value: adj.value || 0,
                type: adjustmentType,
                source: 'levi'
              });
              seenAdjustments.add(key);
            }
          });
        }
        
        // Add custom adjustments only if they're not duplicates
        if (helper.custom_adjustments?.full_market_adjustments) {
          helper.custom_adjustments.full_market_adjustments.forEach(adj => {
            const adjustmentType = adj.type || 'plus';
            const key = `${adj.description}-${adj.percentage || adj.percent || 0}-${adjustmentType}`;
            if (!seenAdjustments.has(key)) {
              allAdjustments.push({
                description: adj.description || 'התאמה מותאמת',
                percentage: adj.percentage || adj.percent || 0,
                value: adj.value || 0,
                type: adjustmentType,
                source: 'custom'
              });
              seenAdjustments.add(key);
            }
          });
        }
        
        // REMOVED: Auto-population of allAdjustmentsList (התאמות שוק נוספות)
        // These should be manual fields only, not auto-populated
        
        // Calculate initial full market value
        // updateFullMarketValueCalculation() removed
        
        // DISABLED: autoPopulateMarketAdjustments - causes override of final_report data
        // setTimeout(() => {
        //   autoPopulateMarketAdjustments();
        // }, 100);
        
        // Remove loading flag
        if (container) {
          container.removeAttribute('data-loading');
        }
        
        // Trigger calculation after data is loaded
        setTimeout(() => {
          updateFullMarketValueCalculation();
        }, 200);
        
      } catch (error) {
        console.error('Error loading full market value data:', error);
        // Remove loading flag on error too
        const container = document.getElementById('allAdjustmentsList');
        if (container) {
          container.removeAttribute('data-loading');
        }
      }
    }
    
    
    // FULL MARKET ADJUSTMENT CALCULATION - COPIED FROM WORKING DEPRECIATION
    function calculateFullMarketAdjustmentValue(percentInput) {
      const percent = parseFloat(percentInput.value) || 0;
      const row = percentInput.closest('.adjustment-row');
      
      if (!row) {
        console.log('❌ No adjustment row found for percentage input');
        return;
      }
      
      // Get market value from same sources as depreciation calculation
      let marketValue = 0;
      
      // First try the basic price field from the same section
      const basicPriceField = document.getElementById('fullBasicPrice');
      if (basicPriceField && basicPriceField.value) {
        marketValue = parseFloat(basicPriceField.value.replace(/[₪,]/g, '')) || 0;
        console.log('📊 Using fullBasicPrice:', marketValue);
      }
      
      // If no basic price, try summary market value (priority)
      if (marketValue === 0) {
        const sumMarketValueField = document.getElementById('sumMarketValue');
        if (sumMarketValueField && sumMarketValueField.value) {
          marketValue = parseFloat(sumMarketValueField.value.replace(/[₪,]/g, '')) || 0;
          console.log('📊 Using sumMarketValue:', marketValue);
        }
      }
      
      // If still no value, try car market value
      if (marketValue === 0) {
        const carMarketValueField = document.getElementById('carMarketValue');
        if (carMarketValueField && carMarketValueField.value) {
          marketValue = parseFloat(carMarketValueField.value.replace(/[₪,]/g, '')) || 0;
          console.log('📊 Using carMarketValue:', marketValue);
        }
      }
      
      if (marketValue === 0) {
        console.log('❌ No market value found for calculation');
      }
      
      // Calculate value exactly like working depreciation
      const calculatedValue = Math.round((marketValue * percent) / 100);
      console.log('💰 Calculation:', { marketValue, percent, calculatedValue });
      
      // Find value input (fourth column in the grid)
      const inputs = row.querySelectorAll('input');
      console.log('📝 Found inputs:', inputs.length);
      // Row structure: [description, select, percentage, value, button]
      // Input indices: [0=description, 1=percentage, 2=value]
      if (inputs.length >= 3) {
        const valueInput = inputs[2]; // Third input (value field)
        valueInput.value = calculatedValue ? `₪${calculatedValue.toLocaleString()}` : '';
        console.log('✅ Set value input to:', valueInput.value);
      } else {
        console.log('❌ Not enough inputs found, expected >= 3, got:', inputs.length);
      }
      
      // Trigger calculation update
      // updateFullMarketValueCalculation() removed
    }
    
    // FINAL REPORT ADJUSTMENTS FUNCTIONS
    
    // Add final report adjustment row
    
    // Calculate final report adjustment value from percentage
    function calculateFinalReportAdjustmentValue(percentageInput) {
      const row = percentageInput.closest('div');
      let basicPrice = parseFloat(document.getElementById('basicPrice')?.value.replace(/[₪,]/g, '')) || 0;
      const percentage = parseFloat(percentageInput.value) || 0;
      
      // Try alternative price sources if basicPrice is empty
      if (basicPrice === 0) {
        // Try grossMarketValue first (from calculations)
        const grossMarketValue = parseFloat(document.getElementById('grossMarketValue')?.value.replace(/[₪,]/g, '')) || 0;
        if (grossMarketValue > 0) {
          basicPrice = grossMarketValue;
          console.log('📊 Using grossMarketValue for final report adjustment calculation:', basicPrice);
        }
      }
      
      // If still no price, try to get from helper
      if (basicPrice === 0) {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        if (helper.levi_report?.base_price) {
          basicPrice = parseFloat(helper.levi_report.base_price);
        } else if (helper.expertise?.levi_report?.base_price) {
          basicPrice = parseFloat(helper.expertise.levi_report.base_price);
        } else if (helper.car_details?.base_price) {
          basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[₪,]/g, ''));
        }
        console.log('📊 Using helper price for final report adjustment calculation:', basicPrice);
      }
      
      if (percentage && basicPrice) {
        const calculatedValue = basicPrice * percentage / 100;
        const inputs = row.querySelectorAll('input');
        if (inputs.length > 2) {
          const valueInput = inputs[2]; // value field is the third input
          valueInput.value = `₪${Math.round(calculatedValue).toLocaleString()}`;
          console.log(`💰 Calculated final report adjustment value: ${percentage}% × ₪${basicPrice.toLocaleString()} = ₪${Math.round(calculatedValue).toLocaleString()}`);
          
          // Trigger change event to update other calculations
          valueInput.dispatchEvent(new Event('change', { bubbles: true }));
        } else {
          console.error('Cannot find value input field for final report adjustment calculation');
        }
      } else {
        console.warn(`⚠️ Cannot calculate final report adjustment value - basicPrice: ${basicPrice}, percentage: ${percentage}`);
        if (basicPrice === 0) {
          console.warn('⚠️ No car price found. Please set the basic price first.');
        }
      }
    }
    
    // Update final report adjustments in helper
    function updateFinalReportAdjustments() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      // Final report container removed - will return empty NodeList
      const adjustmentRows = document.querySelectorAll('#allAdjustmentsRows-final-report div[data-source="custom"]');
      const adjustments = [];
      
      adjustmentRows.forEach(row => {
        const inputs = row.querySelectorAll('input');
        const description = inputs[0].value;
        const type = row.querySelector('select').value;
        const percentage = parseFloat(inputs[1].value) || 0;
        const value = parseFloat(inputs[2].value.replace(/[₪,]/g, '')) || 0;
        
        if (description && (percentage || value)) {
          adjustments.push({ description, type, percentage, value });
        }
      });
      
      // Save to helper
      if (!helper.levi) helper.levi = {};
      helper.levi.custom_adjustments = adjustments;
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      console.log('final report adjustments updated:', adjustments);
      
      // REMOVED: updateHelperFromAdjustments() to prevent overwriting calculated amounts during bulk updates
    }
    
    // REFRESH SECOND BULK FIELDS
    function refreshSecondBulkFields() {
      updateGrossPercentageFromGrossValue();
    }
    
    // UPDATE AUTHORIZED CLAIM DATA
    function updateAuthorizedClaim(element) {
      try {
        const helper = window.helper || {};
        let value = element.value;
        
        // Parse the numeric value from the input
        const numericValue = parseFloat(value.replace(/[₪,]/g, '')) || 0;
        
        // Format currency display
        if (numericValue > 0) {
          value = `₪${numericValue.toLocaleString()}`;
          element.value = value;
        }
        
        // Initialize helper sections if they don't exist
        if (!helper.claims_data) helper.claims_data = {};
        if (!helper.calculations) helper.calculations = {};
        
        // Write to both locations
        helper.claims_data.total_claim = value;
        helper.calculations.total_damage = numericValue;
        
        // Save to session storage and window.helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        console.log(`💰 Updated authorizedClaim: claims_data.total_claim = "${value}", calculations.total_damage = ${numericValue}`);
        console.log(`🔍 DEBUG: helper.calculations after update:`, helper.calculations);
        console.log(`🔍 DEBUG: sessionStorage updated successfully`);
        
      } catch (error) {
        console.error('Error updating authorized claim:', error);
      }
    }

    // UPDATE GROSS PERCENTAGE FIELD
    function updateGrossPercentageField() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        let vehicleValueGross = helper.calculations?.vehicle_value_gross;
        
        // Get AUTHORIZED claim from the field (סה"כ תביעה מאושר) instead of total claim
        const authorizedClaimField = document.getElementById('authorizedClaim');
        const authorizedClaimValue = authorizedClaimField?.value || '';
        const authorizedClaim = parseFloat(authorizedClaimValue.replace(/[₪,]/g, '')) || 0;
        
        // If vehicle_value_gross is missing, try to get it from the leviPriceList field
        if (!vehicleValueGross) {
          const leviPriceListField = document.getElementById('leviPriceList');
          if (leviPriceListField && leviPriceListField.value) {
            vehicleValueGross = parseFloat(leviPriceListField.value.replace(/[₪,]/g, '')) || 0;
            console.log(`🔧 Got vehicle_value_gross from leviPriceList field: ${vehicleValueGross}`);
          }
        }
        
        console.log('🔍 Gross percentage calculation:', {
          vehicleValueGross: vehicleValueGross,
          authorizedClaim: authorizedClaim,
          authorizedClaimRaw: authorizedClaimValue,
          helperCalculations: helper.calculations
        });
        
        if (vehicleValueGross && vehicleValueGross > 0 && authorizedClaim > 0) {
          // Calculate gross percentage: (Authorized Claim ÷ Gross Market Value) × 100
          const grossPercentage = (authorizedClaim / vehicleValueGross) * 100;
          const formattedPercentage = `${Math.round(grossPercentage * 100) / 100}%`;
          
          const grossPercentField = document.getElementById('grossPercent');
          if (grossPercentField) {
            grossPercentField.value = formattedPercentage;
            
            // Update helper claims data to maintain consistency
            helper.claims_data = helper.claims_data || {};
            helper.claims_data.gross_percent = formattedPercentage;
            
            // Also update expertise.calculations for system compatibility
            helper.expertise = helper.expertise || {};
            helper.expertise.calculations = helper.expertise.calculations || {};
            helper.expertise.calculations.damage_percent = Math.round(grossPercentage * 100) / 100;
            
            sessionStorage.setItem('helper', JSON.stringify(helper));
            
            console.log(`📊 Updated gross percentage: ${authorizedClaim.toLocaleString()} ÷ ${vehicleValueGross.toLocaleString()} = ${formattedPercentage}`);
          }
        } else {
          console.log('ℹ️ Gross percentage calculation skipped - values not ready:', {
            vehicleValueGross: vehicleValueGross,
            authorizedClaim: authorizedClaim
          });
          
          // Do NOT call updateGrossMarketValueField here to avoid infinite loop
        }
      } catch (error) {
        console.error('Error updating gross percentage field:', error);
      }
    }
    
    // UPDATE GROSS MARKET VALUE FIELD
    function updateGrossMarketValueField() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        let vehicleValueGross = helper.calculations?.vehicle_value_gross;
        
        console.log('🔍 Updating gross market value field:', {
          vehicleValueGross: vehicleValueGross,
          helperCalculations: helper.calculations
        });
        
        // If no vehicle_value_gross, try to calculate from current gross calculation
        if (!vehicleValueGross) {
          const grossMarketValueField = document.getElementById('grossMarketValueResult');
          if (grossMarketValueField && grossMarketValueField.value) {
            vehicleValueGross = parseFloat(grossMarketValueField.value.replace(/[₪,]/g, '')) || 0;
            console.log(`🔧 Got vehicle_value_gross from grossMarketValueResult field: ${vehicleValueGross}`);
          }
        }
        
        // If still no value, try to get from gross value field  
        if (!vehicleValueGross) {
          const leviPriceListField = document.getElementById('leviPriceList');
          if (leviPriceListField && leviPriceListField.value) {
            vehicleValueGross = parseFloat(leviPriceListField.value.replace(/[₪,]/g, '')) || 0;
            console.log(`🔧 Got vehicle_value_gross from gross value field: ${vehicleValueGross}`);
          }
        }
        
        // Update the leviPriceList field with the gross market value
        const leviPriceListField = document.getElementById('leviPriceList');
        if (leviPriceListField && vehicleValueGross > 0) {
          leviPriceListField.value = `₪${vehicleValueGross.toLocaleString()}`;
          console.log(`📊 Updated leviPriceList field with gross market value: ${vehicleValueGross}`);
        }
        
        // Update helper if we found a value
        if (vehicleValueGross > 0) {
          helper.calculations = helper.calculations || {};
          helper.calculations.vehicle_value_gross = vehicleValueGross;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          console.log(`✅ Updated helper with vehicle_value_gross: ${vehicleValueGross}`);
        } else {
          console.log('ℹ️ vehicle_value_gross not found - will be calculated when needed');
        }
        
      } catch (error) {
        console.error('Error updating gross market value field:', error);
      }
    }
    
    // DEBUG CALCULATIONS
    function debugCalculations() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        console.log('🐛 DEBUG CALCULATIONS:', {
          helper_calculations: helper.calculations,
          helper_expertise_calculations: helper.expertise?.calculations,
          helper_claims_data: helper.claims_data,
          grossMarketValueResult: document.getElementById('grossMarketValueResult')?.value,
          fullMarketValueResult: document.getElementById('fullMarketValueResult')?.value,
          totalClaim: document.getElementById('totalClaim')?.value,
          leviPriceList: document.getElementById('leviPriceList')?.value,
          grossPercent: document.getElementById('grossPercent')?.value,
          basicPrice: document.getElementById('basicPrice')?.value,
          carMarketValue: document.getElementById('carMarketValue')?.value,
          sumMarketValue: document.getElementById('sumMarketValue')?.value,
          sumClaim: document.getElementById('sumClaim')?.value,
          sumTotalClaim: document.getElementById('sumTotalClaim')?.value
        });
        
      } catch (error) {
        console.error('Error in debug calculations:', error);
      }
    }
    
    // CALCULATE DAMAGE PERCENTAGE
    function calculateDamagePercentage() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // Get total claim from damage centers or helper
        let totalClaim = 0;
        const totalClaimField = document.getElementById('totalClaim');
        if (totalClaimField && totalClaimField.value) {
          totalClaim = parseFloat(totalClaimField.value.replace(/[₪,]/g, '')) || 0;
        } else {
          totalClaim = calculateTotalClaimFromDamageCenters();
        }
        
        // Get gross market value from helper or DOM
        let grossMarketValue = helper.calculations?.vehicle_value_gross || 0;
        if (!grossMarketValue) {
          const grossMarketValueField = document.getElementById('grossMarketValueResult');
          if (grossMarketValueField && grossMarketValueField.value) {
            grossMarketValue = parseFloat(grossMarketValueField.value.replace(/[₪,]/g, '')) || 0;
          }
        }
        
        // Calculate damage percentage
        let damagePercentage = 0;
        if (grossMarketValue > 0 && totalClaim > 0) {
          damagePercentage = (totalClaim / grossMarketValue) * 100;
        }
        
        console.log('🔢 Damage percentage calculation:', {
          totalClaim,
          grossMarketValue,
          damagePercentage
        });
        
        return damagePercentage;
        
      } catch (error) {
        console.error('Error calculating damage percentage:', error);
        return 0;
      }
    }

    // TRIGGER GLOBAL DEPRECIATION CALCULATION
    function triggerGlobalDepreciationCalc() {
      const globalDepInput = document.getElementById('globalDep1');
      if (globalDepInput && globalDepInput.value) {
        const event = new Event('input', { bubbles: true });
        globalDepInput.dispatchEvent(event);
      }
    }

    // 🏛️ ADMIN HUB COMMUNICATION SETUP
    function initAdminHubCommunication() {
      console.log('🔌 Initializing admin hub communication...');
      
      // Listen for messages from admin hub (parent frame)
      window.addEventListener('message', function(event) {
        // Security: Check origin if needed
        // if (event.origin !== 'https://yaron-cayouf-portal.netlify.app') return;
        
        console.log('📨 Received message from admin hub:', event.data);
        
        if (event.data && event.data.type) {
          switch (event.data.type) {
            case 'VAT_RATE_UPDATED':
              // Admin hub notifies us of VAT rate change
              const newVatRate = event.data.vatRate;
              console.log('📢 Received VAT rate update from admin hub:', newVatRate + '%');
              
              // Check if we should ignore admin updates due to recent manual override
              const now = Date.now();
              if (window.ignoreAdminVatUntil && now < window.ignoreAdminVatUntil) {
                const remainingTime = Math.ceil((window.ignoreAdminVatUntil - now) / 1000);
                console.log(`🛡️ IGNORING admin hub VAT update due to recent manual override (${remainingTime}s remaining) (final-report)`);
                console.log('💡 Manual session override takes precedence');
                break; // Exit without updating
              }
              
              // Clear protection flags if expired
              if (window.ignoreAdminVatUntil && now >= window.ignoreAdminVatUntil) {
                window.ignoreAdminVatUntil = null;
                window.lastManualVatUpdate = null;
                console.log('🔓 Manual VAT override protection expired, admin updates allowed (final-report)');
              }
              
              // CRITICAL: Update helper.calculations.vat_rate directly (source of truth)
              console.log('🔍 Checking setHelperVatRateFromAdmin availability:', typeof window.setHelperVatRateFromAdmin);
              
              if (typeof window.setHelperVatRateFromAdmin === 'function') {
                console.log('🎯 Calling setHelperVatRateFromAdmin with rate:', newVatRate);
                const success = window.setHelperVatRateFromAdmin(newVatRate, 'admin_hub');
                console.log(success ? '✅ Helper VAT rate updated successfully' : '❌ Failed to update helper VAT rate');
                
                // Verify the change
                setTimeout(() => {
                  const currentHelperVat = window.helper?.calculations?.vat_rate;
                  console.log('🔍 Verified helper.calculations.vat_rate:', currentHelperVat);
                  console.log('🔍 getHelperVatRate() returns:', window.getHelperVatRate ? window.getHelperVatRate() : 'function not available');
                }, 100);
                
              } else {
                console.warn('⚠️ setHelperVatRateFromAdmin function not available');
                console.log('🔍 Available window functions:', Object.keys(window).filter(k => k.includes('Helper') || k.includes('Vat')));
              }
              
              // Refresh VAT display
              if (window.initVatDisplay) {
                window.initVatDisplay();
              }
              
              // Refresh all calculations
              if (typeof refreshAllCalculations === 'function') {
                refreshAllCalculations();
              }
              
              break;
              
            case 'GET_VAT_RATE':
              // Admin hub requests current VAT rate
              const currentVat = window.getHelperVatRate ? window.getHelperVatRate() : 18;
              event.source.postMessage({
                type: 'VAT_RATE_RESPONSE',
                vatRate: currentVat
              }, event.origin);
              break;
              
            default:
              console.log('📨 Unknown message from admin hub:', event.data);
          }
        }
      });
      
      // Try to establish connection with admin hub
      if (window.parent && window.parent !== window) {
        console.log('🔗 Attempting to connect to admin hub...');
        
        // Request current VAT rate from admin hub
        setTimeout(() => {
          window.parent.postMessage({ type: 'GET_VAT_RATE' }, '*');
        }, 500);
        
        // Notify admin hub that we're ready
        window.parent.postMessage({ 
          type: 'MODULE_READY', 
          module: 'final-report-builder',
          timestamp: Date.now()
        }, '*');
      } else {
        console.log('ℹ️ No parent frame detected (not in admin hub iframe)');
      }
    }

    // Cleanup function to remove deprecated data structures
    function cleanupDeprecatedData() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        let updated = false;
        
        // Keep final_report.adjustments - it's now the primary data structure
        
        if (updated) {
          sessionStorage.setItem('helper', JSON.stringify(helper));
        }
      } catch (error) {
        console.error('Error cleaning deprecated data:', error);
      }
    }

    // Cleanup function to fix duplicated damage center numbers
    function cleanupDamageCenterNumbers() {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        if (helper.centers && Array.isArray(helper.centers)) {
          let updated = false;
          
          helper.centers.forEach((center, index) => {
            if (center["Damage center Number"] && typeof center["Damage center Number"] === 'string') {
              // Check if it contains duplicated text
              if (center["Damage center Number"].includes('מוקד')) {
                // Extract just the number
                const match = center["Damage center Number"].match(/\d+$/);
                const cleanNumber = match ? match[0] : String(index + 1);
                center["Damage center Number"] = cleanNumber;
                updated = true;
              }
            }
          });
          
          if (updated) {
            sessionStorage.setItem('helper', JSON.stringify(helper));
            // Also update window.helper if it exists
            if (window.helper && window.helper.centers) {
              window.helper.centers = helper.centers;
            }
            console.log('Cleaned up damage center numbers');
          }
        }
      } catch (error) {
        console.error('Error cleaning damage center numbers:', error);
      }
    }

    // Initialize on load - FIXED ORDER
    document.addEventListener('DOMContentLoaded', () => {
      
      // Initialize window.helper from sessionStorage FIRST
      window.helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('🚀 Initialized window.helper from sessionStorage:', window.helper);
      
      // Debug depreciation data locations
      console.log('🔍 DEBUG - Depreciation data locations:');
      console.log('  helper.depreciation:', window.helper.depreciation);
      console.log('  helper.final_report?.depreciation:', window.helper.final_report?.depreciation);
      console.log('  helper.expertise?.depreciation:', window.helper.expertise?.depreciation);
      
      // Clean up deprecated data structures
      cleanupDeprecatedData();
      
      // First clean up any duplicated damage center numbers in helper
      // cleanupDamageCenterNumbers(); // Commented out - leave existing data as is
      
      // First initialize the FinalReportCalculations object
      console.log('🚀 Initializing FinalReportCalculations object first');
      
      // Then load data from helper after FinalReportCalculations is available
      setTimeout(() => {
        loadDataFromHelper();
        loadAttachmentsData();
        loadClaimsDataToUI(); // Load claims data to UI fields
        loadLegalText().catch(console.error);
        updateGlobalDepreciationCalculation();
        
        // Load additional notes field and summary fields IMMEDIATELY
        loadAdditionalNotesField();
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        loadSummaryFieldsFromHelper(helper);
        
        // Initialize summary fields and manual inputs immediately
        initializeSummaryFieldsFix();
        initializeHelperDataSafeguards();
        
        // Calculate totals after fields are populated
        setTimeout(() => {
          calculateSummaryTotals();
        }, 100);
        
        // DO NOT initialize admin hub communication here - wait for helper.js to load first
        console.log('ℹ️ Waiting for helper.js to load before initializing admin hub communication...');
        
        // Wait for MathEngine to be ready before initializing VAT display
        if (typeof window.MathEngine !== 'undefined') {
          // MathEngine already loaded
          if (typeof window.initVatDisplay === 'function') {
            window.initVatDisplay();
          }
        } else {
          // Wait for MathEngine ready event
          window.addEventListener('mathEngineReady', function() {
            console.log('🎯 MathEngine ready, initializing VAT display...');
            if (typeof window.initVatDisplay === 'function') {
              window.initVatDisplay();
            }
          });
        }
        
        // Log that admin hub functions are now available
        console.log('🔧 Admin hub functions loaded. Try: verifyAdminHubFunctions() or testAdminHubConnection()');
        
        // Automatically verify functions are loaded (after MathEngine loads)
        setTimeout(() => {
          if (typeof window.verifyAdminHubFunctions === 'function') {
            window.verifyAdminHubFunctions();
          }
        }, 200);
      }, 100);
      
      // Initialize adjustment system with event listeners
      setTimeout(() => {
        console.log('🚀 Initializing adjustment system on page load');
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // DISABLED: Legacy loadAllAdjustments that overrides new configuration
        // if (helper.levi?.custom_adjustments || helper.levi?.adjustments) {
        //   loadAllAdjustments(helper);
        // }
        console.log('⚠️ Legacy loadAllAdjustments disabled - using new loadTotalValueSectionAdjustments instead');
        
        // Ensure event listeners are attached
        addAdjustmentEventListeners();
        
        // Trigger initial auto-calculation for existing adjustments
        if (helper.levi?.custom_adjustments && helper.levi.custom_adjustments.length > 0) {
          console.log('🔄 Running initial auto-calculation for existing adjustments');
          helper.levi.custom_adjustments.forEach((adjustment, index) => {
            if (adjustment.percentage && adjustment.percentage !== 0) {
              calculateAdjustmentValue('custom', index, adjustment.percentage);
            }
          });
        }
      }, 400);
      
      // Trigger initial calculation after page loads
      setTimeout(triggerGlobalDepreciationCalc, 500);
      
      // Add listener to garage days field
      const garageDaysField = document.getElementById('garageDays');
      if (garageDaysField) {
        garageDaysField.addEventListener('input', loadLegalText);
      }
      
      // Add listener to payment method field
      const paymentMethodField = document.getElementById('paymentMethod');
      if (paymentMethodField) {
        paymentMethodField.addEventListener('input', loadLegalText);
      }
      
      // Add listener to legal text textarea to save changes
      const legalTextArea = document.getElementById('legal-text-content');
      if (legalTextArea) {
        // Function to save legal text to helper
        function saveLegalTextToHelper() {
          const helper = window.helper || {};
          
          // Initialize final_report object if it doesn't exist
          if (!helper.final_report) {
            helper.final_report = {};
          }
          helper.final_report.legal_text = legalTextArea.value;
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          // ✅ BIDIRECTIONAL INTEGRATION: Update builder state in real-time
          updateBuilderCurrentState('final_report.legal_text', legalTextArea.value);
        }
        
        // Save on input
        legalTextArea.addEventListener('input', saveLegalTextToHelper);
        
        // Save on change (when user finishes editing)
        legalTextArea.addEventListener('change', saveLegalTextToHelper);
        
        // Initial save if there's already content (after page load)
        setTimeout(() => {
          if (legalTextArea.value && legalTextArea.value.trim() !== '') {
            saveLegalTextToHelper();
            console.log('✅ Initial legal text saved to helper:', legalTextArea.value.substring(0, 100) + '...');
          }
        }, 1000);
      }
      
      // Add listener to additional notes textarea to save comments
      const additionalNotesArea = document.getElementById('additional-notes');
      if (additionalNotesArea) {
        // Function to save comments to helper
        function saveCommentsToHelper() {
          const helper = window.helper || {};
          
          // Initialize final_report object if it doesn't exist
          if (!helper.final_report) {
            helper.final_report = {};
          }
          // Save to both 'comments' and 'notes' for consistency
          helper.final_report.comments = additionalNotesArea.value;
          helper.final_report.notes = additionalNotesArea.value;
          
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          // ✅ BIDIRECTIONAL INTEGRATION: Update builder state in real-time
          updateBuilderCurrentState('final_report.comments', additionalNotesArea.value);
          updateBuilderCurrentState('final_report.notes', additionalNotesArea.value);
        }
        
        // Save on input
        additionalNotesArea.addEventListener('input', saveCommentsToHelper);
        
        // Save on change (when user finishes editing)
        additionalNotesArea.addEventListener('change', saveCommentsToHelper);
        
        // Initial save if there's already content (after page load)
        setTimeout(() => {
          if (additionalNotesArea.value && additionalNotesArea.value.trim() !== '') {
            saveCommentsToHelper();
            console.log('✅ Initial comments saved to helper:', additionalNotesArea.value.substring(0, 50) + '...');
          }
        }, 1000);
      }
      
      // Capture all summary fields to helper.final_report.summary
      function captureSummaryFields() {
        const helper = window.helper || {};
        
        // Initialize final_report object if it doesn't exist
        if (!helper.final_report) {
          helper.final_report = {};
        }
        if (!helper.final_report.summary) {
          helper.final_report.summary = {};
        }
        
        // Get all summary input fields from all summary blocks
        const summaryInputs = document.querySelectorAll('.summary-block input[type="text"], .summary-block input[type="date"], .summary-block input[type="number"]');
        
        summaryInputs.forEach(input => {
          if (input.id && input.value) {
            helper.final_report.summary[input.id] = input.value;
          }
        });
        
        // Save to sessionStorage
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('✅ Summary fields captured:', helper.final_report.summary);
      }
      
      // Add event listeners to all summary fields (EXCLUDING calculated fields that get overridden)
      function addSummaryFieldListeners() {
        const summaryInputs = document.querySelectorAll('.summary-block input[type="text"]:not(#afterSaleDamage):not(#afterSaleTotal):not(#afterSaleLegal), .summary-block input[type="date"], .summary-block input[type="number"]');
        
        summaryInputs.forEach(input => {
          // Save on input
          input.addEventListener('input', captureSummaryFields);
          // Save on change
          input.addEventListener('change', captureSummaryFields);
        });
        
        console.log(`✅ Added listeners to ${summaryInputs.length} summary fields`);
      }
      
      // Initialize summary field listeners
      setTimeout(() => {
        addSummaryFieldListeners();
        // Capture initial values
        captureSummaryFields();
      }, 1000);
      
      // AUTO-SAVE ATTACHMENTS ON INPUT
      const attachmentsArea = document.getElementById('attachments-content');
      if (attachmentsArea) {
        attachmentsArea.addEventListener('input', function() {
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          if (!helper.final_report) helper.final_report = {};
          helper.final_report.attachments = this.value;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          // ✅ BIDIRECTIONAL INTEGRATION: Update builder state in real-time
          updateBuilderCurrentState('final_report.attachments', this.value);
        });
      }
      
      // Combined report type change handler
      const reportTypeSelect = document.getElementById('reportType');
      if (reportTypeSelect) {
        reportTypeSelect.addEventListener('change', function() {
          const selectedType = this.value;
          
          // Save dropdown selection to helper
          const helper = window.helper || {};
          if (!helper.final_report) helper.final_report = {};
          helper.final_report.dropdown_type = selectedType;
          window.helper = helper;
          console.log('💾 Saved dropdown report type to helper:', selectedType);
          
          updateReportType();
          loadLegalText().catch(console.error);
          
          // Re-initialize summary field listeners after report type changes
          setTimeout(() => {
            addSummaryFieldListeners();
            captureSummaryFields();
          }, 500); // Wait for summary blocks to update
        });
      }
    });

    // PARTS SEARCH FUNCTIONALITY
    function showPartSuggestions(input, centerIndex, partIndex) {
      const query = input.value.toLowerCase().trim();
      const suggestionsDiv = input.nextElementSibling;
      
      if (query.length < 2) {
        suggestionsDiv.style.display = 'none';
        return;
      }
      
      // Get stored search results from helper
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const storedResults = helper.parts_search?.results || [];
      
      // Filter results based on query
      const filteredResults = storedResults.filter(part => 
        part.name?.toLowerCase().includes(query) || 
        part.desc?.toLowerCase().includes(query)
      );
      
      if (filteredResults.length > 0) {
        let suggestionsHTML = '';
        filteredResults.slice(0, 10).forEach(part => {
          suggestionsHTML += `
            <div onclick="selectPartSuggestion('${part.name}', '${part.desc}', '${part.price || 0}', '${part.source || ''}', ${centerIndex}, ${partIndex})" 
                 style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 13px;"
                 onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='white'">
              <strong>${part.name}</strong><br>
              <small style="color: #666;">${part.desc || ''} ${part.price ? '- ₪' + part.price : ''}</small>
            </div>
          `;
        });
        
        // Add option to search for new parts
        suggestionsHTML += `
          <div onclick="openPartsSearchModule('${query}', ${centerIndex}, ${partIndex})" 
               style="padding: 8px; cursor: pointer; background: #e3f2fd; border-top: 1px solid #ddd; font-size: 13px; color: #1976d2;"
               onmouseover="this.style.background='#bbdefb'" onmouseout="this.style.background='#e3f2fd'">
            🔍 חפש חלקים חדשים עבור: "${query}"
          </div>
        `;
        
        suggestionsDiv.innerHTML = suggestionsHTML;
        suggestionsDiv.style.display = 'block';
      } else {
        // Show only search option if no stored results
        suggestionsDiv.innerHTML = `
          <div onclick="openPartsSearchModule('${query}', ${centerIndex}, ${partIndex})" 
               style="padding: 8px; cursor: pointer; background: #e3f2fd; font-size: 13px; color: #1976d2;"
               onmouseover="this.style.background='#bbdefb'" onmouseout="this.style.background='#e3f2fd'">
            🔍 חפש חלקים עבור: "${query}"
          </div>
        `;
        suggestionsDiv.style.display = 'block';
      }
    }

    // SELECT PART FROM SUGGESTIONS
    function selectPartSuggestion(name, desc, price, source, centerIndex, partIndex) {
      const partRow = document.querySelector(`.part-row[data-center="${centerIndex}"][data-part="${partIndex}"]`);
      if (partRow) {
        partRow.querySelector('.part-name').value = name;
        partRow.querySelector('.part-desc').value = desc;
        partRow.querySelector('.part-price').value = price;
        partRow.querySelector('.part-source').value = source;
        
        // Hide suggestions
        partRow.querySelector('.part-suggestions').style.display = 'none';
        
        // Trigger save and recalculation
        saveDamageCenterChanges();
      }
    }

    // OPEN PARTS SEARCH MODULE
    function openPartsSearchModule(query, centerIndex, partIndex) {
      // Store the target location for the search result
      sessionStorage.setItem('partSearchTarget', JSON.stringify({
        centerIndex,
        partIndex,
        query
      }));
      
      // Open independent parts search module
      const partsSearchUrl = 'parts search.html?query=' + encodeURIComponent(query);
      window.open(partsSearchUrl, 'partsSearch', 'width=1000,height=700,scrollbars=yes,resizable=yes');
    }

    // ADD/REMOVE ROW FUNCTIONS
    function addPartRow(centerIndex) {
      const partsList = document.querySelector(`.parts-list[data-center="${centerIndex}"]`);
      const newPartIndex = partsList.children.length;
      const newPartHTML = createEditablePartRow({}, centerIndex, newPartIndex);
      partsList.insertAdjacentHTML('beforeend', newPartHTML);
      
      // Add event listeners to new row
      setTimeout(addDamageCenterEventListeners, 50);
    }

    function addWorkRow(centerIndex) {
      const worksList = document.querySelector(`.works-list[data-center="${centerIndex}"]`);
      const newWorkIndex = worksList.children.length;
      const newWorkHTML = createEditableWorkRow('', centerIndex, newWorkIndex);
      worksList.insertAdjacentHTML('beforeend', newWorkHTML);
      
      // Add event listeners to new row
      setTimeout(addDamageCenterEventListeners, 50);
    }

    function addRepairRow(centerIndex) {
      const repairsList = document.querySelector(`.repairs-list[data-center="${centerIndex}"]`);
      const newRepairIndex = repairsList.children.length;
      const newRepairHTML = createEditableRepairRow('', centerIndex, newRepairIndex);
      repairsList.insertAdjacentHTML('beforeend', newRepairHTML);
      
      // Add event listeners to new row
      setTimeout(addDamageCenterEventListeners, 50);
    }

    function removePartRow(centerIndex, partIndex) {
      const partRow = document.querySelector(`.part-row[data-center="${centerIndex}"][data-part="${partIndex}"]`);
      if (partRow) {
        partRow.remove();
        saveDamageCenterChanges();
      }
    }

    function removeWorkRow(centerIndex, workIndex) {
      const workRow = document.querySelector(`.work-row[data-center="${centerIndex}"][data-work="${workIndex}"]`);
      if (workRow) {
        workRow.remove();
        saveDamageCenterChanges();
      }
    }

    function removeRepairRow(centerIndex, repairIndex) {
      const repairRow = document.querySelector(`.repair-row[data-center="${centerIndex}"][data-repair="${repairIndex}"]`);
      if (repairRow) {
        repairRow.remove();
        saveDamageCenterChanges();
      }
    }

    function removeDamageCenter(centerIndex) {
      if (confirm('האם אתה בטוח שברצונך למחוק את מוקד הנזק הזה?')) {
        const centerCard = document.querySelector(`.editable-damage-card[data-center-index="${centerIndex}"]`);
        if (centerCard) {
          centerCard.remove();
          saveDamageCenterChanges();
        }
      }
    }

    function addNewDamageCenter() {
      const container = document.getElementById('editableDamageCenters');
      if (!container) {
        // If no container exists, create it
        document.getElementById('damageCentersContent').innerHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters"></div>';
      }
      
      const newIndex = document.querySelectorAll('.editable-damage-card').length;
      const newBlock = {
        damage_center_name: `מוקד נזק ${newIndex + 1}`,
        parts: [],
        works: [],
        repairs: [],
        work_cost: 0,
        parts_cost: 0
      };
      
      const newCardHTML = createEditableDamageCenterCard(newBlock, newIndex);
      document.getElementById('editableDamageCenters').insertAdjacentHTML('beforeend', newCardHTML);
      
      setTimeout(addDamageCenterEventListeners, 100);
    }

    // SAVE DAMAGE CENTER CHANGES TO HELPER
    function saveDamageCenterChanges() {
      try {
        // 🔧 2-WAY DATA FLOW: Save back to helper.centers (the source of truth)
        const helper = window.helper || {};
        
        // Initialize centers if not exists
        if (!helper.centers) helper.centers = [];
        
        // Clean up any redundant damage_assessment.centers (duplicate section)
        if (helper.damage_assessment?.centers) {
          console.log('🧹 Cleaning up redundant damage_assessment.centers');
          delete helper.damage_assessment.centers;
          if (Object.keys(helper.damage_assessment).length === 0) {
            delete helper.damage_assessment;
          }
        }
        
        // Also maintain expertise.damage_blocks for backward compatibility
        if (!helper.expertise) helper.expertise = {};
        if (!helper.expertise.damage_blocks) helper.expertise.damage_blocks = [];
        
        // Clear both structures
        helper.centers = [];
        helper.expertise.damage_blocks = [];
        
        // Store damage center names for depreciation section
        const damageCenterNames = [];
        
        // Collect data from all damage center cards
        document.querySelectorAll('.editable-damage-card').forEach((card, index) => {
          // Extract just the number from the damage center number field
          const centerNumberField = card.querySelector('.damage-center-number').value;
          // Extract the number (e.g., "מוקד נזק מס' 1" -> "1")
          const numberMatch = centerNumberField.match(/\d+$/);
          const centerNumber = numberMatch ? numberMatch[0] : String(index + 1);
          const centerLocation = card.querySelector('.damage-center-location').value;
          const centerDescription = card.querySelector('.damage-center-description').value;
          const centerRepairNature = card.querySelector('.damage-center-repair-nature')?.value || '';
          
          // Collect parts
          const parts = [];
          card.querySelectorAll('.part-row').forEach(row => {
            const name = row.querySelector('.part-name').value;
            const desc = row.querySelector('.part-desc').value;
            const price = row.querySelector('.part-price').value;
            const source = row.querySelector('.part-source').value;
            
            if (name.trim()) {
              parts.push({ name, desc, price: parseFloat(price) || 0, source });
            }
          });
          
          // Collect works
          const works = [];
          card.querySelectorAll('.work-row').forEach(row => {
            let type = row.querySelector('.work-type').value;
            const note = row.querySelector('.work-note').value;
            const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
            
            // If "אחר" is selected, get the custom text from the input
            if (type === 'אחר') {
              const otherInput = row.querySelector('.work-type-other');
              if (otherInput && otherInput.value.trim()) {
                type = otherInput.value.trim();
              }
            }
            
            if (type) {
              works.push({ category: type, comments: note, cost });
            }
          });
          
          // Collect repairs - PRESERVE EXISTING DATA
          const repairs = [];
          const existingCenter = helper.centers ? helper.centers[index] : null;
          const existingRepairs = existingCenter?.Repairs?.repairs || [];
          
          card.querySelectorAll('.repair-row').forEach((row, repairIndex) => {
            const name = row.querySelector('.repair-name').value;
            const text = row.querySelector('.repair-text').value;
            const hours = parseFloat(row.querySelector('.repair-hours').value) || 0;
            const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
            
            if (text.trim() || name.trim()) {
              // Get existing repair data to preserve all fields
              const existingRepair = existingRepairs[repairIndex] || {};
              
              // Merge existing data with new data (preserve all fields)
              const repairObject = {
                ...existingRepair,           // Preserve all existing fields
                name: name,                  // Update name from UI
                description: text,           // Update description from UI
                hours: hours,                // Update hours from UI
                cost: cost                   // Update cost from UI
              };
              
              repairs.push(repairObject);
            }
          });
          
          // Calculate costs using individual cost fields
          const partsCost = parts.reduce((sum, part) => sum + (parseFloat(part.price) || 0), 0);
          const workCost = works.reduce((sum, work) => sum + (parseFloat(work.cost) || 0), 0);
          const repairsCost = repairs.reduce((sum, repair) => sum + (parseFloat(repair.cost) || 0), 0);
          const totalCost = partsCost + workCost + repairsCost;
          
          // Create center object in helper.centers format (source of truth)
          const centerObject = {
            Id: `dc_${Date.now()}_${index + 1}`, // Generate unique ID
            "Damage center Number": centerNumber || (index + 1),
            Location: centerLocation,
            Description: centerDescription,
            RepairNature: centerRepairNature,
            Parts: {
              parts_required: parts,
              parts_meta: {
                total_items: parts.length,
                total_cost: partsCost
              }
            },
            Works: {
              works: works,
              works_meta: {
                total_items: works.length,
                total_cost: workCost
              }
            },
            Repairs: {
              repairs: repairs,
              repairs_meta: {
                total_items: repairs.length,
                total_cost: repairsCost
              }
            },
            Summary: {
              "Total with VAT": totalCost * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100)
            }
          };
          
          // Save to helper.centers (primary source)
          helper.centers.push(centerObject);
          
          // Also save to damage_blocks for backward compatibility
          helper.expertise.damage_blocks.push({
            damage_center_name: centerLocation,
            damage_center_number: index + 1,
            center_header: centerNumber,
            description: centerDescription,
            repair_nature: centerRepairNature,
            parts,
            works,
            repairs,
            parts_cost: partsCost,
            work_cost: workCost,
            repairs_cost: repairsCost
          });
          
          
          // Store damage center data for depreciation section (complete object)
          if (centerLocation.trim()) {
            damageCenterNames.push({
              name: centerLocation.trim(),
              number: centerNumber || (index + 1),
              description: centerDescription || '',
              RepairNature: centerRepairNature
            });
          }
          
          // Update cost display for this card
          updateCostDisplay(card, partsCost, workCost, repairsCost);
        });
        
        // 🆕 UPDATE SPECIFIC DESTINATIONS (like estimator does)
        
        // 1. Update damage_centers array with ALL data + source = 'final_report'
        helper.damage_centers = helper.centers.map((center, index) => ({
          "Id": center.Id || `dc_${Date.now()}_${index + 1}`,
          "Damage center Number": center["Damage center Number"] || (index + 1).toString(),
          "Location": center.Location || '',
          "Description": center.Description || '',
          "RepairNature": center.RepairNature || '',
          "Parts": center.Parts || {
            "parts_required": [],
            "parts_meta": { "total_items": 0, "total_cost": 0 }
          },
          "Works": center.Works || {
            "works": [],
            "works_meta": { "total_items": 0, "total_cost": 0 }
          },
          "Repairs": center.Repairs || {
            "repairs": [],
            "repairs_meta": { "total_items": 0, "total_cost": 0 }
          },
          "Summary": center.Summary || { "Total with VAT": 0 },
          source: 'final_report',
          last_updated: new Date().toISOString()
        }));
        console.log('✅ Updated damage_centers from final_report with source tracking');
        
        // 2. Recreate damage_assessment.damage_centers with id + repair_nature + source
        if (!helper.damage_assessment) helper.damage_assessment = {};
        helper.damage_assessment.damage_centers = helper.centers.map(center => ({
          Id: center.Id || `dc_${Date.now()}_${Math.random()}`,
          repair_nature: center.RepairNature || '',
          source: 'final_report',
          last_updated: new Date().toISOString()
        }));
        console.log('✅ Recreated damage_assessment.damage_centers from final_report');
        
        // 3. Recreate damage_assessment.comprehensive.centers with descriptions only + source
        if (!helper.damage_assessment.comprehensive) helper.damage_assessment.comprehensive = {};
        helper.damage_assessment.comprehensive.centers = helper.centers.map(center => ({
          location: center.Location || '',
          description: center.Description || '',
          RepairNature: center.RepairNature || '',
          repair_nature: center.RepairNature || '', // Duplicate field for compatibility
          source: 'final_report',
          last_updated: new Date().toISOString()
        }));
        console.log('✅ Recreated damage_assessment.comprehensive.centers from final_report');
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // DON'T auto-update depreciation - preserve manual entries
        // updateDepreciationFromDamageCenters(damageCenterNames);
        
        // Update/recreate damage_assessment summary sections with current data
        updateDamageAssessmentSummary(helper);
        
        // Trigger floating screen refresh
        triggerFloatingScreenRefresh();
        
        console.log('Damage centers saved:', helper.expertise.damage_blocks);
        
      } catch (error) {
        console.error('Error saving damage center changes:', error);
      }
    }
    
    // UPDATE DEPRECIATION SECTION FROM DAMAGE CENTERS
    function updateDepreciationFromDamageCenters(damageCenterNames) {
      try {
        
        // If no data provided, get current data from helper.centers
        if (!damageCenterNames || damageCenterNames.length === 0) {
          const helper = window.helper || {};
          damageCenterNames = [];
          
          if (helper.centers && helper.centers.length > 0) {
            helper.centers.forEach((center, index) => {
              // Get the actual location and center number properly
              const location = center.Location || center.damage_center_name || '';
              
              // Extract just the number from "Damage center Number" field
              // e.g., "מוקד נזק מס' מוקד נזק מס' 1" -> "1"
              let centerNum = center["Damage center Number"] || String(index + 1);
              // Extract all numbers and take the last one
              const numberMatch = String(centerNum).match(/\d+/g);
              centerNum = numberMatch ? numberMatch[numberMatch.length - 1] : String(index + 1);
              
              damageCenterNames.push({
                name: location,  // The actual location/part name
                number: centerNum,  // Just the number (1, 2, 3, etc.)
                description: center.Description || '',
                RepairNature: center.RepairNature || ''
              });
            });
          }
        }
        
        
        const depreciationTable = document.getElementById('depreciationBulkTable');
        if (!depreciationTable) {
          return;
        }
        
        // DON'T clear existing depreciation rows - preserve manual data!
        // Only add new rows if the table is empty
        const existingRows = depreciationTable.querySelectorAll('.dep-row');
        if (existingRows.length > 0) {
          console.log('⚠️ Depreciation table already has data - preserving existing manual entries');
          return;
        }
        
        // Add a row for each damage center
        damageCenterNames.forEach(centerData => {
          // Handle both old string format and new object format
          const centerName = (typeof centerData === 'string') ? centerData : centerData.name;
          const centerNumber = (typeof centerData === 'object') ? centerData.number : null;
          const centerDescription = (typeof centerData === 'object') ? centerData.description : '';
          const centerRepairNature = (typeof centerData === 'object') ? centerData.RepairNature : '';
          
          // ✅ FIXED: Correct field mapping for depreciation from damage centers
          // "מס' מוקד" should show the center number
          // "החלק הניזוק" should show LOCATION/PART (use centerName which contains the damage location)  
          // "מהות התיקון" should show REPAIR NATURE (use centerRepairNature which contains repair nature details)
          const centerNum = centerNumber || (damageCenterNames.indexOf(centerData) + 1); // Fallback to index + 1
          const damageLocation = centerName || ''; // This is the location/part that was damaged
          const workEssence = centerRepairNature || '';
          
          // Create row directly in the table
          const row = document.createElement('div');
          row.className = 'dep-row';
          row.style.cssText = 'display:grid; grid-template-columns:70px 2fr 2fr 80px 90px 80px; gap:10px; margin-bottom:8px;';
          
          row.innerHTML = `
            <div><input type="text" placeholder="מס' מוקד" value="${centerNum || ''}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" style="text-align: center;" title="${centerNum || ''}" /></div>
            <div><input type="text" placeholder="החלק הניזוק" value="${damageLocation}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="${damageLocation}" /></div>
            <div><input type="text" placeholder="מהות התיקון" value="${workEssence}" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="${workEssence}" /></div>
            <div><input type="text" placeholder="ירידת ערך (מספר)" value="" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="" style="direction: ltr; text-align: right;" /></div>
            <div><input type="text" placeholder="ערך ב-₪" value="" onchange="saveDepreciationData();" oninput="saveDepreciationData();" title="" /></div>
            <div><button class="btn remove" onclick="removeDepField('${row.id || 'depRow_' + Date.now()}')">מחק</button></div>
          `;
          
          // Set unique ID for the row
          row.id = 'depRow_' + Date.now() + '_' + (damageCenterNames.indexOf(centerData));
          
          // Append to table
          depreciationTable.appendChild(row);
          
          // Add tooltip update listeners to all input fields
          const inputs = row.querySelectorAll('input');
          inputs.forEach(input => {
            input.addEventListener('input', function() {
              this.title = this.value;
            });
          });
          
          // Add auto-calculation functionality to the percentage field
          const percentInput = row.querySelector('input[placeholder="ירידת ערך (מספר)"]');
          const valueInput = row.querySelector('input[placeholder="ערך ב-₪"]');
          
          if (percentInput && valueInput) {
            percentInput.addEventListener('input', function() {
              // Clean the value to extract the numeric part
              const cleanValue = this.value.replace('%', '').replace(/[^0-9.-]/g, '');
              let percent = parseFloat(cleanValue) || 0;
              
              // Keep value as clean decimal number without % sign
              this.value = cleanValue;
              
              // Calculate value from market price automatically
              const marketValueField = document.getElementById('carMarketValue') || document.getElementById('sumMarketValue');
              const marketValueStr = marketValueField?.value.replace(/[₪,]/g, '') || '0';
              const marketValue = parseFloat(marketValueStr) || 0;
              
              const calculatedValue = (marketValue * percent) / 100;
              valueInput.value = calculatedValue ? `₪${Math.round(calculatedValue).toLocaleString()}` : '';
              
              // Save data after calculation
              saveDepreciationData();
            });
          }
        });
        
        
      } catch (error) {
        console.error('Error updating depreciation from damage centers:', error);
      }
    }

    // ADD EVENT LISTENERS
    function addDamageCenterEventListeners() {
      // Remove existing listeners by cloning elements (prevents duplicates)
      document.querySelectorAll('.damage-center-number, .damage-center-location, .damage-center-name, .damage-center-area-name, .damage-center-description, .damage-center-repair-nature, .part-name, .part-desc, .part-price, .work-type, .work-type-other, .work-note, .work-cost, .repair-name, .repair-text, .repair-hours, .repair-cost').forEach(input => {
        // Check if already has listeners
        if (!input.hasAttribute('data-listeners-added')) {
          input.addEventListener('change', () => {
            saveDamageCenterChanges();
            updateAllCostDisplays();
          });
          input.addEventListener('blur', () => {
            saveDamageCenterChanges();
            updateAllCostDisplays();
          });
          input.addEventListener('input', () => {
            updateAllCostDisplays();
          });
          
          // Mark as having listeners to prevent duplicates
          input.setAttribute('data-listeners-added', 'true');
          console.log(`📝 Added event listeners to: ${input.className}`);
        }
      });
      
      // Hide suggestions when clicking outside
      document.addEventListener('click', function(e) {
        if (!e.target.closest('.part-row')) {
          document.querySelectorAll('.part-suggestions').forEach(div => {
            div.style.display = 'none';
          });
        }
      });
    }

    // UPDATE WORK COST FROM TYPE SELECTION
    function updateWorkCostFromType(selectElement, centerIndex, workIndex) {
      // REMOVED: Predefined work rates that were forcing costs
      // Work costs should be manually entered based on specific case requirements
      
      // Only trigger save and recalculation without changing cost
      saveDamageCenterChanges();
      updateAllCostDisplays();
      
      console.log(`🔧 Work type changed: ${selectElement.value} (cost remains manual)`);
    }

    function handleWorkTypeChange(selectElement, centerIndex, workIndex) {
      const workRow = selectElement.closest('.work-row');
      const otherInput = workRow.querySelector('.work-type-other');
      
      if (selectElement.value === 'אחר') {
        otherInput.style.display = 'block';
        otherInput.focus();
      } else {
        otherInput.style.display = 'none';
        otherInput.value = '';
      }
      
      // Call the original function
      updateWorkCostFromType(selectElement, centerIndex, workIndex);
    }

    // COST CALCULATION FUNCTIONS
    function calculateWorkCost(works) {
      return works.reduce((total, work) => {
        const cost = typeof work === 'object' ? (work.cost || 0) : 0;
        return total + parseFloat(cost);
      }, 0);
    }

    function calculateRepairsCost(repairs) {
      return repairs.reduce((total, repair) => {
        const cost = typeof repair === 'object' ? (repair.cost || 0) : 0;
        return total + parseFloat(cost);
      }, 0);
    }

    function calculatePartsCost(parts) {
      return parts.reduce((total, part) => {
        const cost = typeof part === 'object' ? (part.price || 0) : 0;
        return total + parseFloat(cost);
      }, 0);
    }

    function updateCostDisplay(card, partsCost, workCost, repairsCost) {
      const totalCost = partsCost + workCost + repairsCost;
      const totalWithVAT = totalCost * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100);
      
      // Update display elements
      const workDisplay = card.querySelector('.work-costs-display');
      const partsDisplay = card.querySelector('.parts-costs-display');
      const repairsDisplay = card.querySelector('.repairs-costs-display');
      const totalDisplay = card.querySelector('.total-with-vat-display');
      
      if (workDisplay) {
        workDisplay.textContent = `₪${workCost.toLocaleString()}`;
        console.log(`💼 Work costs updated: ₪${workCost.toLocaleString()}`);
      }
      if (partsDisplay) {
        partsDisplay.textContent = `₪${partsCost.toLocaleString()}`;
        console.log(`🔧 Parts costs updated: ₪${partsCost.toLocaleString()}`);
      }
      if (repairsDisplay) {
        repairsDisplay.textContent = `₪${repairsCost.toLocaleString()}`;
        console.log(`🔨 Repairs costs updated (ONLY repairs): ₪${repairsCost.toLocaleString()}`);
      }
      if (totalDisplay) {
        totalDisplay.textContent = `₪${Math.round(totalWithVAT).toLocaleString()}`;
        console.log(`💰 Total with VAT updated: ₪${Math.round(totalWithVAT).toLocaleString()}`);
      }
    }

    function updateAllCostDisplays() {
      document.querySelectorAll('.editable-damage-card').forEach(card => {
        // Recalculate costs for this card using individual cost fields
        let partsCost = 0;
        card.querySelectorAll('.part-row').forEach(row => {
          const price = parseFloat(row.querySelector('.part-price').value) || 0;
          partsCost += price;
        });
        
        let workCost = 0;
        card.querySelectorAll('.work-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
          workCost += cost;
        });
        
        let repairsCost = 0;
        card.querySelectorAll('.repair-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
          repairsCost += cost;
        });
        
        updateCostDisplay(card, partsCost, workCost, repairsCost);
      });
      
      // Update summary section totals
      updateSummaryTotalsFromDamageCenters();
      
      // Update damage centers subtotal
      updateDamageCentersSubtotal();
    }

    function updateSummaryTotalsFromDamageCenters() {
      let totalClaimBeforeVAT = 0;
      
      document.querySelectorAll('.editable-damage-card').forEach(card => {
        // Calculate total cost for each damage center (parts + works + repairs)
        let partsCost = 0;
        card.querySelectorAll('.part-row').forEach(row => {
          const price = parseFloat(row.querySelector('.part-price').value) || 0;
          partsCost += price;
        });
        
        let workCost = 0;
        card.querySelectorAll('.work-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
          workCost += cost;
        });
        
        let repairsCost = 0;
        card.querySelectorAll('.repair-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
          repairsCost += cost;
        });
        
        totalClaimBeforeVAT += partsCost + workCost + repairsCost;
      });
      
      // Calculate total claim with VAT (admin configured rate)
      const totalClaimWithVAT = Math.round(totalClaimBeforeVAT * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100));
      
      // Update summary fields
      const sumClaimField = document.getElementById('sumClaim');
      const totalClaimField = document.getElementById('totalClaim');
      
      if (totalClaimWithVAT > 0) {
        const formattedAmount = `₪${totalClaimWithVAT.toLocaleString()}`;
        
        // Update both summary claim and total claim fields WITH VAT
        if (sumClaimField) {
          sumClaimField.value = formattedAmount;
        }
        // Update main total claim field (div element)
        if (totalClaimField && totalClaimField.tagName === 'DIV') {
          totalClaimField.innerText = formattedAmount;
        } else if (totalClaimField) {
          totalClaimField.value = formattedAmount;
        }
        
        console.log(`💰 Updated total claim with VAT: ${totalClaimBeforeVAT.toLocaleString()} → ${totalClaimWithVAT.toLocaleString()}`);
        
        // SAFE SUMMARY UPDATE: Update helper directly instead of triggering events that cascade
        setTimeout(() => {
          if (sumClaimField) {
            // Update helper directly without triggering event cascade that overrides calculations
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            helper.final_report = helper.final_report || {};
            helper.final_report.summary = helper.final_report.summary || {};
            helper.final_report.summary.total_claim = formattedAmount;
            sessionStorage.setItem('helper', JSON.stringify(helper));
            console.log('🔒 SAFE UPDATE: Updated total_claim in helper without triggering calculation overrides');
          }
        }, 100);
        
        // New bulk system will handle gross calculations when total claim changes
      }
    }

    // Make functions global
    window.loadDataFromHelper = loadDataFromHelper;
    window.loadLegalText = loadLegalText;
    window.loadLegalTextFromVault = loadLegalTextFromVault;
    window.resetLegalText = resetLegalText;
    window.loadAttachmentsFromVault = loadAttachmentsFromVault;
    window.resetAttachments = resetAttachments;
    window.addDepField = addDepField;
    window.updateReportType = updateReportType;
    window.addCustomSummaryField = addCustomSummaryField;
    window.loadDamageCentersSummary = loadDamageCentersSummary;
    window.loadAllAdjustments = loadAllAdjustments;
    window.updateGlobalDepreciationCalculation = updateGlobalDepreciationCalculation;
    window.calculateDamagePercentage = calculateDamagePercentage;
    window.triggerGlobalDepreciationCalc = triggerGlobalDepreciationCalc;
    window.showPartSuggestions = showPartSuggestions;
    window.selectPartSuggestion = selectPartSuggestion;
    window.openPartsSearchModule = openPartsSearchModule;
    window.addPartRow = addPartRow;
    window.addWorkRow = addWorkRow;
    window.addRepairRow = addRepairRow;
    window.removePartRow = removePartRow;
    window.removeWorkRow = removeWorkRow;
    window.removeRepairRow = removeRepairRow;
    window.removeDamageCenter = removeDamageCenter;
    window.addNewDamageCenter = addNewDamageCenter;
    window.saveDamageCenterChanges = saveDamageCenterChanges;
    window.addDamageCenterEventListeners = addDamageCenterEventListeners;
    window.calculateWorkCost = calculateWorkCost;
    window.updateWorkCostFromType = updateWorkCostFromType;
    window.updateCostDisplay = updateCostDisplay;
    window.updateAllCostDisplays = updateAllCostDisplays;
    window.updateSummaryTotalsFromDamageCenters = updateSummaryTotalsFromDamageCenters;
    window.updateGrossMarketValueField = updateGrossMarketValueField;
    window.updateAuthorizedClaim = updateAuthorizedClaim;
    window.updateGrossPercentageField = updateGrossPercentageField;
    window.calculateGrossMarketValue = calculateGrossMarketValue;
    window.calculateGrossPercentage = calculateGrossPercentage;
    window.calculateFullMarketValue = calculateFullMarketValue;
    window.addFeatureAdjustment = addFeatureAdjustment;
    window.addRegistrationAdjustment = addRegistrationAdjustment;
    window.removeAdjustmentRow = removeAdjustmentRow;
    window.updateHelperFromContactField = updateHelperFromContactField;
    window.loadGrossAdjustments = loadGrossAdjustments;
    window.loadTotalValueSectionAdjustments = loadTotalValueSectionAdjustments;
    window.syncUISection = syncUISection;
    window.updateGrossMarketValueCalculation = updateGrossMarketValueCalculation;
    window.loadGrossCalculationData = loadGrossCalculationData;
    
    // loadGrossAdjustments is now properly called during data loading
    
    // FORCE MANUAL CALCULATION - Last resort function
    function forceManualCalculation() {
      console.log('🔧 === FORCE MANUAL CALCULATION ===');
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Manual gross market value calculation
      let vehicleValueGross = 0;
      const leviPriceListField = document.getElementById('leviPriceList');
      const grossPercentField = document.getElementById('grossPercent');
      const totalClaimField = document.getElementById('totalClaim');
      
      // Try to get a market value from anywhere
      if (helper.levi_report?.final_price) {
        vehicleValueGross = parseFloat(helper.levi_report.final_price);
        console.log('🔧 Using levi_report.final_price as vehicleValueGross:', vehicleValueGross);
      } else if (helper.calculations?.full_market_value) {
        vehicleValueGross = parseFloat(helper.calculations.full_market_value);
        console.log('🔧 Using calculations.full_market_value as vehicleValueGross:', vehicleValueGross);
      } else if (helper.levisummary?.final_price) {
        vehicleValueGross = parseFloat(helper.levisummary.final_price);
        console.log('🔧 Using levisummary.final_price as vehicleValueGross:', vehicleValueGross);
      }
      
      // If we have a value, populate the field
      if (vehicleValueGross > 0) {
        leviPriceListField.value = `₪${vehicleValueGross.toLocaleString()}`;
        
        // Update helper
        helper.calculations = helper.calculations || {};
        helper.calculations.vehicle_value_gross = vehicleValueGross;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('🔧 Manually set vehicleValueGross:', vehicleValueGross);
        
        // Now calculate percentage
        const totalClaim = parseFloat(totalClaimField?.value?.replace(/[₪,]/g, '') || '0');
        if (totalClaim > 0) {
          const grossPercentage = (totalClaim / vehicleValueGross) * 100;
          const formattedPercentage = `${Math.round(grossPercentage * 100) / 100}%`;
          
          grossPercentField.value = formattedPercentage;
          
          // Update helper
          helper.claims_data = helper.claims_data || {};
          helper.claims_data.gross_percent = formattedPercentage;
          sessionStorage.setItem('helper', JSON.stringify(helper));
          
          console.log('🔧 Manually calculated gross percentage:', formattedPercentage);
        }
      } else {
        console.warn('⚠️ No market value found for manual calculation');
      }
      
      console.log('🔧 === FORCE MANUAL CALCULATION COMPLETE ===');
    }
    
    // DEBUG HELPER FUNCTION
    function debugCalculations() {
      console.log('🔍 === DEBUG CALCULATIONS ===');
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('Helper data:', helper);
      console.log('Calculations:', helper.calculations);
      console.log('Levi report:', helper.levi_report);
      console.log('Expertise:', helper.expertise);
      
      // Check current field values
      const leviPriceListField = document.getElementById('leviPriceList');
      const grossPercentField = document.getElementById('grossPercent');
      const totalClaimField = document.getElementById('totalClaim');
      
      console.log('🔍 Current field values:', {
        leviPriceList: leviPriceListField?.value || 'NOT FOUND',
        grossPercent: grossPercentField?.value || 'NOT FOUND',
        totalClaim: totalClaimField?.value || 'NOT FOUND'
      });
      
      // Force refresh all calculations
      updateAllCostDisplays();
      updateSummaryTotalsFromDamageCenters();
      // New bulk system will handle gross calculations
      
      // Check values after refresh
      setTimeout(() => {
        console.log('🔍 After refresh field values:', {
          leviPriceList: leviPriceListField?.value || 'NOT FOUND',
          grossPercent: grossPercentField?.value || 'NOT FOUND',
          totalClaim: totalClaimField?.value || 'NOT FOUND'
        });
        
        // If still empty, try force manual calculation
        if (!leviPriceListField?.value || !grossPercentField?.value) {
          console.log('🔧 Fields still empty, trying force manual calculation...');
          forceManualCalculation();
        }
      }, 100);
      
      console.log('🔍 === DEBUG CALCULATIONS COMPLETE ===');
    }
    window.debugCalculations = debugCalculations;
    window.forceManualCalculation = forceManualCalculation;
    
    // 🌍 GLOBAL CALCULATION INTERFACE FOR FINAL REPORT MODULES
    window.FinalReportCalculations = {
      // Main calculation functions
      updateGrossMarketValueField: updateGrossMarketValueField,
      updateGrossPercentageField: updateGrossPercentageField,
      updateSummaryTotalsFromDamageCenters: updateSummaryTotalsFromDamageCenters,
      updateAllCostDisplays: updateAllCostDisplays,
      calculateDamagePercentage: calculateDamagePercentage,
      
      // Cost calculation functions
      calculateRepairsCost: calculateRepairsCost,
      calculatePartsCost: calculatePartsCost,
      calculateWorkCost: calculateWorkCost,
      updateCostDisplay: updateCostDisplay,
      
      // Helper utilities
      updateHelperFromField: updateHelperFromField,
      loadDataFromHelper: loadDataFromHelper,
      saveDamageCenterChanges: saveDamageCenterChanges,
      debugCalculations: debugCalculations,
      
      // Get calculated values from 3-bulk system
      getGrossMarketValue: function() {
        try {
          // First try to get from the gross market value result field (Bulk 1)
          const grossMarketValueField = document.getElementById('grossMarketValueResult');
          if (grossMarketValueField && grossMarketValueField.value) {
            return parseFloat(grossMarketValueField.value.replace(/[₪,]/g, '')) || 0;
          }
          
          // Fallback to helper data
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          return helper.calculations?.vehicle_value_gross || 0;
        } catch (error) {
          console.error('Error getting gross market value:', error);
          return 0;
        }
      },
      
      getFullMarketValue: function() {
        try {
          // First try to get from the full market value result field (Bulk 3)
          const fullMarketValueField = document.getElementById('fullMarketValueResult');
          if (fullMarketValueField && fullMarketValueField.value) {
            return parseFloat(fullMarketValueField.value.replace(/[₪,]/g, '')) || 0;
          }
          
          // Fallback to helper data
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          return helper.calculations?.market_value || helper.calculations?.full_market_value || helper.levi_report?.final_price || 0;
        } catch (error) {
          console.error('Error getting full market value:', error);
          return 0;
        }
      },
      
      getTotalClaim: function() {
        try {
          // First try to get from the total claim field (Bulk 2)
          const totalClaimField = document.getElementById('totalClaim');
          if (totalClaimField && totalClaimField.value) {
            return parseFloat(totalClaimField.value.replace(/[₪,]/g, '')) || 0;
          }
          
          // Fallback: calculate from damage centers
          const totalFromDamageCenters = calculateTotalClaimFromDamageCenters();
          if (totalFromDamageCenters > 0) {
            return totalFromDamageCenters;
          }
          
          // Final fallback to helper data
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          return parseFloat(helper.claims_data?.total_claim?.replace(/[₪,]/g, '') || '0') || 
                 parseFloat(helper.calculations?.total_damage) || 0;
        } catch (error) {
          console.error('Error getting total claim:', error);
          return 0;
        }
      },
      
      getGrossPercentage: function() {
        try {
          // First try to get from the gross percentage field (Bulk 2)
          const grossPercentField = document.getElementById('grossPercent');
          if (grossPercentField && grossPercentField.value) {
            return parseFloat(grossPercentField.value.replace(/[%]/g, '')) || 0;
          }
          
          // Calculate from current values if not available
          const grossMarketValue = this.getGrossMarketValue();
          const totalClaim = this.getTotalClaim();
          if (grossMarketValue > 0 && totalClaim > 0) {
            return (totalClaim / grossMarketValue) * 100;
          }
          
          // Fallback to helper data
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          return parseFloat(helper.claims_data?.gross_percent?.replace(/[%]/g, '') || '0') || 
                 parseFloat(helper.calculations?.damage_percent) || 0;
        } catch (error) {
          console.error('Error getting gross percentage:', error);
          return 0;
        }
      },
      
      // Get damage centers data
      getDamageCentersData: function() {
        try {
          // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
          return helper.expertise?.damage_centers || [];
        } catch (error) {
          console.error('Error getting damage centers data:', error);
          return [];
        }
      },
      
      // Calculate totals from damage centers
      calculateDamageCentersTotals: function() {
        const damageCenters = this.getDamageCentersData();
        let totalParts = 0;
        let totalWorks = 0;
        let totalRepairs = 0;
        
        damageCenters.forEach(center => {
          totalParts += this.calculatePartsCost(center.parts || []);
          totalWorks += this.calculateWorkCost(center.works || []);
          totalRepairs += this.calculateRepairsCost(center.repairs || []);
        });
        
        return {
          parts: totalParts,
          works: totalWorks,
          repairs: totalRepairs,
          total: totalParts + totalWorks + totalRepairs,
          totalWithVAT: (totalParts + totalWorks + totalRepairs) * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100)
        };
      },
      
      // Force refresh all calculations
      refreshAllCalculations: function() {
        this.updateAllCostDisplays();
        this.updateSummaryTotalsFromDamageCenters();
        
        // Refresh all 3 bulks
        setTimeout(() => {
          try {
            // Refresh Bulk 1 (Gross Market Value)
            if (typeof updateGrossMarketValueCalculation === 'function') {
              updateGrossMarketValueCalculation();
            }
            
            // Refresh Bulk 2 (Gross Percentage)
            if (typeof refreshSecondBulkFields === 'function') {
              refreshSecondBulkFields();
            }
            
            // Refresh Bulk 3 (Full Market Value)
            if (typeof updateFullMarketValueCalculation === 'function') {
              // updateFullMarketValueCalculation() removed
            }
            
            // Trigger floating screen refresh with updated calculations
            if (typeof triggerFloatingScreenRefresh === 'function') {
              triggerFloatingScreenRefresh();
            }
            
            console.log('✅ All 3-bulk calculations refreshed from FinalReportCalculations interface');
          } catch (error) {
            console.error('Error refreshing 3-bulk calculations:', error);
          }
        }, 100);
      }
    };
    
    // Make it also available via window for backward compatibility
    window.getFinalReportCalculations = () => window.FinalReportCalculations;
    // Maintain backward compatibility
    window.getFinalReportCalculations = () => window.FinalReportCalculations;

    // MESSAGE LISTENER FOR PARTS SEARCH RESULTS
    window.addEventListener('message', function(event) {
      if (event.data.type === 'PARTS_SELECTED') {
        try {
          const { parts, target } = event.data;
          const { centerIndex, partIndex } = target;
          
          // Find the specific part row
          const targetCard = document.querySelector(`.editable-damage-card[data-center-index="${centerIndex}"]`);
          if (targetCard) {
            const partRows = targetCard.querySelectorAll('.part-row');
            const targetRow = partRows[partIndex];
            
            if (targetRow && parts.length > 0) {
              // Fill the first selected part into the target row
              const firstPart = parts[0];
              const nameInput = targetRow.querySelector('.part-name');
              const descInput = targetRow.querySelector('.part-desc');
              const priceInput = targetRow.querySelector('.part-price');
              const sourceInput = targetRow.querySelector('.part-source');
              
              if (nameInput) nameInput.value = firstPart.name || '';
              if (descInput) descInput.value = firstPart.description || '';
              if (priceInput) priceInput.value = firstPart.price || '';
              if (sourceInput) sourceInput.value = firstPart.source || '';
              
              // Add additional parts if more than one selected
              if (parts.length > 1) {
                const partsList = targetCard.querySelector('.parts-list');
                for (let i = 1; i < parts.length; i++) {
                  const part = parts[i];
                  const newPartIndex = partsList.children.length;
                  const newPartHTML = createEditablePartRow(part, centerIndex, newPartIndex);
                  partsList.insertAdjacentHTML('beforeend', newPartHTML);
                }
              }
              
              // Save changes and update costs
              saveDamageCenterChanges();
              updateAllCostDisplays();
              
              console.log(`✅ Added ${parts.length} parts to damage center ${centerIndex + 1}`);
            }
          }
        } catch (error) {
          console.error('Error processing parts selection:', error);
        }
      }
    });
    
    // LOAD HELPER DATA AND POPULATE FIELDS
    function loadHelperData() {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        // Ensure window.helper is initialized from sessionStorage
        if (!window.helper || Object.keys(window.helper).length === 0) {
          window.helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        }
        const helper = window.helper;
        
        console.log('📥 Loading helper data:', helper);
        
        // Load report type selection from helper
        const savedReportType = helper.final_report?.type || helper.manual_final_report_type?.finalReportType;
        if (savedReportType) {
          const radioButton = document.querySelector(`input[name="final-report-type"][value="${savedReportType}"]`);
          if (radioButton) {
            radioButton.checked = true;
            console.log('📋 Loaded report type from helper:', savedReportType);
            // Trigger change event to update legal text and attachments
            setTimeout(() => {
              loadLegalText().catch(console.error);
              loadAttachmentsFromVault();
            }, 100);
          }
        }
        
        // Load dropdown report type selection from helper
        const savedDropdownType = helper.final_report?.dropdown_type || helper.reportType;
        if (savedDropdownType) {
          const dropdown = document.getElementById('reportType');
          if (dropdown) {
            dropdown.value = savedDropdownType;
            console.log('📋 Loaded dropdown report type from helper:', savedDropdownType);
            // Trigger change to update summary visibility and legal text
            setTimeout(() => {
              updateReportType();
              loadLegalText().catch(console.error);
            }, 150);
          }
        }
        
        // Auto-fill basic price field from helper - ENHANCED
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField) {
          let basicPrice = 0;
          
          // Try multiple sources for BASE PRICE (not market value) - FIXED PRIORITY
          if (helper.levi_report?.base_price) {
            basicPrice = parseFloat(helper.levi_report.base_price);
            console.log('📄 Found BASE PRICE in helper.levi_report.base_price:', basicPrice);
          } else if (helper.expertise?.levi_report?.base_price) {
            basicPrice = parseFloat(helper.expertise.levi_report.base_price);
            console.log('📄 Found BASE PRICE in helper.expertise.levi_report.base_price:', basicPrice);
          } else if (helper.levisummary?.base_price) {
            basicPrice = parseFloat(helper.levisummary.base_price);
            console.log('📄 Found BASE PRICE in helper.levisummary.base_price:', basicPrice);
          } else if (helper.car_details?.base_price) {
            basicPrice = parseFloat(helper.car_details.base_price.toString().replace(/[₪,]/g, ''));
            console.log('📄 Found BASE PRICE in helper.car_details.base_price:', basicPrice);
          } else {
            // REMOVED market_value fallback - we need BASE price only
            console.warn('⚠️ No BASE PRICE found in helper - this field requires Levi base price, not market value');
          }
          
          if (basicPrice > 0) {
            basicPriceField.value = `₪${basicPrice.toLocaleString()}`;
            console.log('✅ Auto-filled basic price field:', basicPrice);
            
            // Trigger calculation after loading
            setTimeout(() => {
              updateGrossMarketValueCalculation();
            }, 100);
          } else {
            // Check if the field already has a value before warning
            const currentFieldValue = basicPriceField?.value;
            if (!currentFieldValue) {
              console.warn('⚠️ No base price found in helper, basic price field will be empty');
            } else {
              console.info('ℹ️ Basic price field already populated with:', currentFieldValue, '(not from helper data)');
            }
            console.log('Debug helper data:', {
              levi_report: helper.levi_report,
              expertise: helper.expertise,
              levisummary: helper.levisummary,
              car_details: helper.car_details
            });
            
            // Enhanced debugging: Log full helper structure
            console.group('🔍 FULL HELPER STRUCTURE DEBUG');
            console.log('Complete helper object keys:', Object.keys(helper));
            console.log('Helper size:', JSON.stringify(helper).length);
            
            // Check all possible base price locations
            console.log('All possible base price locations:');
            console.log('- helper.levi_report?.base_price:', helper.levi_report?.base_price);
            console.log('- helper.expertise?.levi_report?.base_price:', helper.expertise?.levi_report?.base_price);
            console.log('- helper.levisummary?.base_price:', helper.levisummary?.base_price);
            console.log('- helper.car_details?.base_price:', helper.car_details?.base_price);
            console.log('- helper.vehicle?.base_price:', helper.vehicle?.base_price);
            console.log('- helper.calculations?.base_price:', helper.calculations?.base_price);
            console.log('- helper.expertise?.calculations?.base_price:', helper.expertise?.calculations?.base_price);
            
            // Check vehicle_value_gross locations
            console.log('All possible vehicle_value_gross locations:');
            console.log('- helper.calculations?.vehicle_value_gross:', helper.calculations?.vehicle_value_gross);
            console.log('- helper.expertise?.calculations?.vehicle_value_gross:', helper.expertise?.calculations?.vehicle_value_gross);
            
            // Check damage data locations
            console.log('All possible damage data locations:');
            console.log('- helper.expertise?.damage_blocks:', helper.expertise?.damage_blocks);
            console.log('- helper.damage_centers:', helper.damage_centers);
            console.log('- helper.damage_sections:', helper.damage_sections);
            
            // Log sessionStorage raw data
            console.log('Raw sessionStorage helper:', sessionStorage.getItem('helper'));
            console.groupEnd();
          }
        }
        
        // Auto-fill car details fields
        const carFields = {
          carPlate: helper.meta?.plate || helper.car_details?.plate || '',
          carManufacturer: helper.car_details?.manufacturer || helper.vehicle?.manufacturer || '',
          carModel: helper.car_details?.model || helper.vehicle?.model || '',
          carYear: helper.car_details?.year || helper.vehicle?.year || '',
          carModelCode: helper.car_details?.model_code || helper.vehicle?.model_code || '',
          carBasePrice: helper.levi_report?.base_price || helper.expertise?.levi_report?.base_price || '',
          carMarketValue: helper.car_details?.market_value || helper.vehicle?.market_value || helper.levi_report?.final_price || '',
          carReportDate: convertToDateInputFormat(helper.car_details?.report_date || new Date().toISOString().split('T')[0])
        };
        
        Object.entries(carFields).forEach(([fieldId, value]) => {
          const field = document.getElementById(fieldId);
          if (field && !field.value && value) {
            field.value = value;
          }
        });
        
        // DEBUGGING: Check all possible damage center data locations
        console.log('🔍 DEBUG: Checking all damage center data sources...');
        console.log('helper.expertise?.damage_blocks:', helper.expertise?.damage_blocks);
        console.log('helper.centers:', helper.centers);
        console.log('helper.damage_centers:', helper.damage_centers);
        
        // Load damage centers from helper - PRIORITIZE helper.centers (has parts_required data)
        if (helper.centers && helper.centers.length > 0) {
          console.log('🔄 Loading from helper.centers (PRIMARY SOURCE - has parts_required data)');
          const normalizedBlocks = helper.centers.map((center, index) => adaptCenterToBlock(center, index));
          loadDamageCentersFromHelper(normalizedBlocks);
        } else if (helper.expertise?.damage_blocks && helper.expertise.damage_blocks.length > 0) {
          console.log('🔄 Loading from helper.expertise.damage_blocks (FALLBACK - may have empty parts)');
          const normalizedBlocks = helper.expertise.damage_blocks.map((center, index) => adaptCenterToBlock(center, index));
          loadDamageCentersFromHelper(normalizedBlocks);
        } else if (helper.damage_centers && helper.damage_centers.length > 0) {
          console.log('🔄 Loading from helper.damage_centers');
          const normalizedBlocks = helper.damage_centers.map((center, index) => adaptCenterToBlock(center, index));
          loadDamageCentersFromHelper(normalizedBlocks);
        } else {
          console.log('❌ No damage center data found in any location');
        }
        
        console.log('✅ Helper data loaded successfully');
        
      } catch (error) {
        console.error('Error loading helper data:', error);
      }
    }
    
    // UPDATE DAMAGE ASSESSMENT SUMMARY SECTIONS
    function updateDamageAssessmentSummary(helper) {
      try {
        // Calculate current totals from helper.centers
        let totalWorks = 0;
        let totalParts = 0; 
        let totalRepairs = 0;
        let totalCenters = 0;
        
        if (helper.centers && helper.centers.length > 0) {
          totalCenters = helper.centers.length;
          
          helper.centers.forEach(center => {
            // Sum from parts_required
            if (center.Parts?.parts_required) {
              center.Parts.parts_required.forEach(part => {
                totalParts += parseFloat(part.price) || 0;
              });
            }
            
            // Sum from works
            if (center.Works?.works) {
              center.Works.works.forEach(work => {
                totalWorks += parseFloat(work.cost) || 0;
              });
            }
            
            // Sum from repairs
            if (center.Repairs?.repairs) {
              center.Repairs.repairs.forEach(repair => {
                totalRepairs += parseFloat(repair.cost) || 0;
              });
            }
          });
        }
        
        const totalWithoutVAT = totalWorks + totalParts + totalRepairs;
        const totalWithVAT = totalWithoutVAT * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100);
        
        // Update or create damage_assessment section - PRESERVE comprehensive section
        if (!helper.damage_assessment) helper.damage_assessment = {};
        
        // Update only the specific sections, preserving comprehensive and other existing data
        helper.damage_assessment.total_centers = totalCenters;
        helper.damage_assessment.total_items = totalCenters;
        
        helper.damage_assessment.summary = {
          total_works: totalWorks,
          total_parts: totalParts,
          total_repairs: totalRepairs,
          total_without_vat: Math.round(totalWithoutVAT),
          total_with_vat: Math.round(totalWithVAT)
        };
        
        helper.damage_assessment.totals = {
          "Total works": totalWorks,
          "Total parts": totalParts,
          "Total repairs": totalRepairs,
          "Total without VAT": Math.round(totalWithoutVAT),
          "Total with VAT": Math.round(totalWithVAT)
        };
        
        helper.damage_assessment.last_updated = new Date().toISOString();
        
        // Preserve existing comprehensive section if it exists
        
        console.log('✅ Updated damage_assessment summary:', helper.damage_assessment);
        
      } catch (error) {
        console.error('❌ Error updating damage assessment summary:', error);
      }
    }
    
    // UPDATE DAMAGE CENTERS SUBTOTAL DISPLAY
    function updateDamageCentersSubtotal() {
      let totalWorks = 0;
      let totalParts = 0;
      let totalRepairs = 0;
      
      // Calculate totals from all damage center cards
      document.querySelectorAll('.editable-damage-card').forEach(card => {
        // Sum parts costs
        card.querySelectorAll('.part-row').forEach(row => {
          const price = parseFloat(row.querySelector('.part-price').value) || 0;
          totalParts += price;
        });
        
        // Sum work costs
        card.querySelectorAll('.work-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.work-cost').value) || 0;
          totalWorks += cost;
        });
        
        // Sum repair costs
        card.querySelectorAll('.repair-row').forEach(row => {
          const cost = parseFloat(row.querySelector('.repair-cost').value) || 0;
          totalRepairs += cost;
        });
      });
      
      let rawTotalWithoutVat = totalWorks + totalParts + totalRepairs;
      let rawTotalWithVat = rawTotalWithoutVat * (1 + (window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100);
      
      // Calculate category-specific differentials
      let finalTotalWorks = totalWorks;
      let finalTotalParts = totalParts;
      let finalTotalRepairs = totalRepairs;
      let finalTotalWithoutVat = rawTotalWithoutVat;
      let finalTotalWithVat = rawTotalWithVat;
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (helper.final_report?.differential?.has_differentials && helper.final_report?.differential?.items) {
        const differentialItems = helper.final_report.differential.items;
        
        // Calculate category-specific differential totals
        let worksDiff = 0, partsDiff = 0, repairsDiff = 0, otherDiff = 0;
        let worksDiffWithVat = 0, partsDiffWithVat = 0, repairsDiffWithVat = 0, otherDiffWithVat = 0;
        
        differentialItems.forEach(item => {
          const amount = item.amount_without_vat || 0;
          const amountWithVat = item.amount_with_vat || 0;
          
          switch(item.nature) {
            case 'works':
              worksDiff += amount;
              worksDiffWithVat += amountWithVat;
              break;
            case 'parts':
              partsDiff += amount;
              partsDiffWithVat += amountWithVat;
              break;
            case 'repairs':
              repairsDiff += amount;
              repairsDiffWithVat += amountWithVat;
              break;
            default:
              otherDiff += amount;
              otherDiffWithVat += amountWithVat;
              break;
          }
        });
        
        // Apply category-specific differentials
        finalTotalWorks = Math.max(0, totalWorks - worksDiff);
        finalTotalParts = Math.max(0, totalParts - partsDiff);
        finalTotalRepairs = Math.max(0, totalRepairs - repairsDiff);
        
        // Recalculate totals with category-specific deductions
        const finalRawTotal = finalTotalWorks + finalTotalParts + finalTotalRepairs;
        finalTotalWithoutVat = finalRawTotal - otherDiff; // Other differentials affect overall total
        
        // Apply VAT to the final amount (after subtracting "other" differentials without VAT)
        const vatRate = window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18);
        finalTotalWithVat = finalTotalWithoutVat * (1 + vatRate / 100);
        
        console.log('📉 Applying category-specific differentials:', {
          worksDiff, partsDiff, repairsDiff, otherDiff,
          finalTotalWorks, finalTotalParts, finalTotalRepairs,
          finalTotalWithoutVat, finalTotalWithVat
        });
      }
      
      // Check if we're using dual container layout
      const hasDifferentials = helper.final_report?.differential?.has_differentials && 
                              helper.final_report?.differential?.summary &&
                              (helper.final_report.differential.summary.total_amount_without_vat > 0 || 
                               helper.final_report.differential.summary.total_amount_with_vat > 0);
      
      if (hasDifferentials) {
        // Update ORIGINAL values (left container - כללי)
        const totalWorksOriginal = document.getElementById('totalWorksOriginal');
        const totalPartsOriginal = document.getElementById('totalPartsOriginal');
        const totalRepairsOriginal = document.getElementById('totalRepairsOriginal');
        const totalWithoutVatOriginal = document.getElementById('totalWithoutVatOriginal');
        const totalWithVatOriginal = document.getElementById('totalWithVatOriginal');
        
        if (totalWorksOriginal) totalWorksOriginal.textContent = `₪${totalWorks.toLocaleString()}`;
        if (totalPartsOriginal) totalPartsOriginal.textContent = `₪${totalParts.toLocaleString()}`;
        if (totalRepairsOriginal) totalRepairsOriginal.textContent = `₪${totalRepairs.toLocaleString()}`;
        if (totalWithoutVatOriginal) totalWithoutVatOriginal.textContent = `₪${Math.round(rawTotalWithoutVat).toLocaleString()}`;
        if (totalWithVatOriginal) totalWithVatOriginal.textContent = `₪${Math.round(rawTotalWithVat).toLocaleString()}`;
        
        // Update AFTER DIFFERENTIALS values (right container - אחרי הפרשים)
        const totalWorksSubtotal = document.getElementById('totalWorksSubtotal');
        const totalPartsSubtotal = document.getElementById('totalPartsSubtotal');
        const totalRepairsSubtotal = document.getElementById('totalRepairsSubtotal');
        const totalWithoutVatSubtotal = document.getElementById('totalWithoutVatSubtotal');
        const totalWithVatSubtotal = document.getElementById('totalWithVatSubtotal');
        
        if (totalWorksSubtotal) totalWorksSubtotal.textContent = `₪${Math.round(finalTotalWorks).toLocaleString()}`;
        if (totalPartsSubtotal) totalPartsSubtotal.textContent = `₪${Math.round(finalTotalParts).toLocaleString()}`;
        if (totalRepairsSubtotal) totalRepairsSubtotal.textContent = `₪${Math.round(finalTotalRepairs).toLocaleString()}`;
        if (totalWithoutVatSubtotal) totalWithoutVatSubtotal.textContent = `₪${Math.round(finalTotalWithoutVat).toLocaleString()}`;
        if (totalWithVatSubtotal) totalWithVatSubtotal.textContent = `₪${Math.round(finalTotalWithVat).toLocaleString()}`;
        
      } else {
        // Single container - use final values (which equals raw values when no differentials)
        const totalWorksElement = document.getElementById('totalWorksSubtotal');
        const totalPartsElement = document.getElementById('totalPartsSubtotal');
        const totalRepairsElement = document.getElementById('totalRepairsSubtotal');
        const totalWithoutVatElement = document.getElementById('totalWithoutVatSubtotal');
        const totalWithVatElement = document.getElementById('totalWithVatSubtotal');
        
        if (totalWorksElement) totalWorksElement.textContent = `₪${Math.round(finalTotalWorks).toLocaleString()}`;
        if (totalPartsElement) totalPartsElement.textContent = `₪${Math.round(finalTotalParts).toLocaleString()}`;
        if (totalRepairsElement) totalRepairsElement.textContent = `₪${Math.round(finalTotalRepairs).toLocaleString()}`;
        if (totalWithoutVatElement) totalWithoutVatElement.textContent = `₪${Math.round(finalTotalWithoutVat).toLocaleString()}`;
        if (totalWithVatElement) totalWithVatElement.textContent = `₪${Math.round(finalTotalWithVat).toLocaleString()}`;
      }
      
      // Update helper with after differentials totals
      if (!helper.damage_assessment) helper.damage_assessment = {};
      if (!helper.damage_assessment.totals_after_differentials) {
        helper.damage_assessment.totals_after_differentials = {};
      }
      
      helper.damage_assessment.totals_after_differentials = {
        "Total works": Math.round(finalTotalWorks),
        "Total parts": Math.round(finalTotalParts), 
        "Total repairs": Math.round(finalTotalRepairs),
        "Total without VAT": Math.round(finalTotalWithoutVat),
        "Total with VAT": Math.round(finalTotalWithVat),
        "last_updated": new Date().toISOString()
      };
      
      // Save updated helper
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Also update window.helper
      if (window.helper) {
        if (!window.helper.damage_assessment) window.helper.damage_assessment = {};
        window.helper.damage_assessment.totals_after_differentials = helper.damage_assessment.totals_after_differentials;
      }
      
      console.log('💰 Updated damage centers subtotal:', {
        originalWorks: totalWorks,
        originalParts: totalParts,
        originalRepairs: totalRepairs,
        finalWorks: finalTotalWorks,
        finalParts: finalTotalParts,
        finalRepairs: finalTotalRepairs,
        finalWithoutVat: finalTotalWithoutVat,
        finalWithVat: finalTotalWithVat,
        showingDifferentialsOverlay: hasDifferentials
      });
      
      console.log('📊 Saved totals_after_differentials to helper:', helper.damage_assessment.totals_after_differentials);
      
      // Update authorizedClaim field - always update whether differentials exist or not
      const authorizedClaimField = document.getElementById('authorizedClaim');
      if (authorizedClaimField) {
        let claimTotal, claimValue;
        
        if (hasDifferentials) {
          // Use after-differentials value when differentials exist
          claimTotal = helper.damage_assessment.totals_after_differentials["Total with VAT"];
          claimValue = `₪${claimTotal.toLocaleString()}`;
          console.log('🔄 Updated authorizedClaim to after-differentials value:', claimTotal);
        } else {
          // Use original totals when no differentials
          claimTotal = helper.damage_assessment?.totals?.["Total with VAT"] || finalTotalWithVat;
          claimValue = `₪${claimTotal.toLocaleString()}`;
          console.log('🔄 Updated authorizedClaim to original value (no differentials):', claimTotal);
        }
        
        authorizedClaimField.value = claimValue;
        
        // Update helper data
        if (!helper.claims_data) helper.claims_data = {};
        if (!helper.calculations) helper.calculations = {};
        helper.claims_data.total_claim = claimValue;
        helper.calculations.total_damage = claimTotal;
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        if (window.helper) {
          if (!window.helper.claims_data) window.helper.claims_data = {};
          if (!window.helper.calculations) window.helper.calculations = {};
          window.helper.claims_data.total_claim = claimValue;
          window.helper.calculations.total_damage = claimTotal;
        }
        
        // Trigger gross percentage recalculation
        setTimeout(() => {
          if (typeof updateGrossPercentageField === 'function') {
            updateGrossPercentageField();
          }
        }, 100);
      }
    }
    
    // CREATE הפרשים SECTION FOR DAMAGE CENTERS AREA
    function createDifferentialsSection() {
      return `
        <div class="form-section" id="differentialsSection" style="margin-top: 20px;">
          <h3>הפרשים</h3>
          <label style="margin-bottom:5px;">האם קיימים הפרשים?
            <input type="checkbox" id="hasDifferentials" style="width:auto; margin-left:6px;" onchange="toggleDifferentialsTable(); setTimeout(saveDifferentialsToHelper, 100);">
          </label>
          
          <div id="differentialsTable" style="display:none; margin-top:15px;">
            <!-- Mobile-optimized header - No static header needed for 2-row layout -->
            <div id="differentialsRows"></div>
            <button class="btn add" type="button" onclick="addDifferentialRow()">הוסף הפרש</button>
          </div>
          <div id="differentialsSummary" style="display:none; margin-top:15px;">
            <div class="form-grid">
              <div>
                <label>סה"כ הפרשים (ללא מע"מ):</label>
                <div class="readonly-box" id="totalDifferentials">₪0</div>
              </div>
              <div>
                <label>סה"כ מע"מ:</label>
                <div class="readonly-box" id="totalVAT">₪0</div>
              </div>
              <div>
                <label>סה"כ הפרשים כולל מע"מ:</label>
                <div class="readonly-box" id="totalDifferentialsWithVAT">₪0</div>
              </div>
            </div>
          </div>
          
          <!-- Save button inside differentials section with proper styling -->
          <div id="differentialsSaveSection" style="display:none; margin-top:15px; text-align:center;">
            <button class="btn save" type="button" onclick="saveDifferentials()" style="background:#28a745; color:white; padding:10px 20px; border-radius:6px; border:none; font-size:14px; cursor:pointer; transition: all 0.3s ease;">שמור הפרשים</button>
          </div>
        </div>
      `;
    }

    // CREATE DAMAGE CENTERS SUBTOTAL SECTION
    function createDamageCentersSubtotal(hasDifferentials = false) {
      if (!hasDifferentials) {
        // Single container when no differentials
        return `
          <div id="damageCentersSubtotal" style="background: #f8f9fa; border: 2px solid #28a745; border-radius: 6px; padding: 12px; margin-top: 15px;">
            <h4 style="margin: 0 0 10px 0; color: #28a745; text-align: center; font-size: 14px; font-weight: bold;">🧮 סיכום כללי - מרכזי נזק</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 8px;">
              <div style="background: #17a2b8; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                <div style="font-size: 16px; font-weight: bold;" id="totalWorksSubtotal">₪0</div>
                <div style="font-size: 10px; opacity: 0.9;">סה"כ עבודות</div>
              </div>
              <div style="background: #28a745; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                <div style="font-size: 16px; font-weight: bold;" id="totalPartsSubtotal">₪0</div>
                <div style="font-size: 10px; opacity: 0.9;">סה"כ חלקים</div>
              </div>
              <div style="background: #ffc107; color: #212529; padding: 8px; border-radius: 4px; text-align: center;">
                <div style="font-size: 16px; font-weight: bold;" id="totalRepairsSubtotal">₪0</div>
                <div style="font-size: 10px; opacity: 0.9;">סה"כ תיקונים</div>
              </div>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
              <div style="background: #6c757d; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                <div style="font-size: 18px; font-weight: bold;" id="totalWithoutVatSubtotal">₪0</div>
                <div style="font-size: 11px; opacity: 0.9;">סה"כ ללא מע"מ</div>
              </div>
              <div style="background: #dc3545; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                <div style="font-size: 18px; font-weight: bold;" id="totalWithVatSubtotal">₪0</div>
                <div style="font-size: 11px; opacity: 0.9;">סה"כ כולל מע"מ</div>
              </div>
            </div>
          </div>
        `;
      } else {
        // Dual containers when differentials exist (50/50)
        return `
          <div id="damageCentersSubtotal" style="margin-top: 15px;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
              
              <!-- Left Container: כללי -->
              <div style="background: #f8f9fa; border: 2px solid #28a745; border-radius: 6px; padding: 12px;">
                <h4 style="margin: 0 0 10px 0; color: #28a745; text-align: center; font-size: 14px; font-weight: bold;">כללי</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 6px; margin-bottom: 6px;">
                  <div style="background: #17a2b8; color: white; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalWorksOriginal">₪0</div>
                    <div style="font-size: 9px; opacity: 0.9;">עבודות</div>
                  </div>
                  <div style="background: #28a745; color: white; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalPartsOriginal">₪0</div>
                    <div style="font-size: 9px; opacity: 0.9;">חלקים</div>
                  </div>
                  <div style="background: #ffc107; color: #212529; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalRepairsOriginal">₪0</div>
                    <div style="font-size: 9px; opacity: 0.9;">תיקונים</div>
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                  <div style="background: #6c757d; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold;" id="totalWithoutVatOriginal">₪0</div>
                    <div style="font-size: 10px; opacity: 0.9;">ללא מע"מ</div>
                  </div>
                  <div style="background: #dc3545; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold;" id="totalWithVatOriginal">₪0</div>
                    <div style="font-size: 10px; opacity: 0.9;">כולל מע"מ</div>
                  </div>
                </div>
              </div>
              
              <!-- Right Container: אחרי הפרשים -->
              <div style="background: #f8f9fa; border: 2px solid #dc3545; border-radius: 6px; padding: 12px;">
                <h4 style="margin: 0 0 10px 0; color: #dc3545; text-align: center; font-size: 14px; font-weight: bold;">אחרי הפרשים</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 6px; margin-bottom: 6px;">
                  <div style="background: #17a2b8; color: white; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalWorksSubtotal">₪0</div>
                    <div style="font-size: 9px; opacity: 0.9;">עבודות</div>
                  </div>
                  <div style="background: #28a745; color: white; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalPartsSubtotal">₪0</div>
                    <div style="font-size: 9px; opacity: 0.9;">חלקים</div>
                  </div>
                  <div style="background: #ffc107; color: #212529; padding: 6px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold;" id="totalRepairsSubtotal">₪0</div>
                    <div style="font-size: 9px; opacity: 0.9;">תיקונים</div>
                  </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                  <div style="background: #6c757d; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold;" id="totalWithoutVatSubtotal">₪0</div>
                    <div style="font-size: 10px; opacity: 0.9;">ללא מע"מ</div>
                  </div>
                  <div style="background: #dc3545; color: white; padding: 8px; border-radius: 4px; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold;" id="totalWithVatSubtotal">₪0</div>
                    <div style="font-size: 10px; opacity: 0.9;">כולל מע"מ</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;
      }
    }
    
    // HANDLE NATURE DROPDOWN CHANGES - SHOW/HIDE OTHER TEXT FIELD
    function toggleNatureOtherField(dropdown) {
      const row = dropdown.closest('.differential-row');
      const otherField = row.querySelector('.diff-nature-other');
      const hiddenField = row.querySelector('.diff-nature');
      
      if (dropdown.value === 'other') {
        otherField.style.display = 'block';
        otherField.focus();
        hiddenField.value = otherField.value;
      } else {
        otherField.style.display = 'none';
        hiddenField.value = dropdown.value;
      }
      
      console.log('🔄 Nature changed to:', dropdown.value);
      setTimeout(saveDifferentialsToHelper, 100);
    }
    
    // REFRESH DAMAGE CENTERS CONTAINER LAYOUT WHEN DIFFERENTIALS TOGGLE
    function refreshDamageCentersContainerLayout() {
      console.log('🔄 Refreshing damage centers container layout...');
      
      // Check current differential state
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const hasDifferentials = helper.final_report?.differential?.has_differentials && 
                              helper.final_report?.differential?.summary &&
                              (helper.final_report.differential.summary.total_amount_without_vat > 0 || 
                               helper.final_report.differential.summary.total_amount_with_vat > 0);
      
      // Find existing subtotal container and replace it
      const existingSubtotal = document.getElementById('damageCentersSubtotal');
      if (existingSubtotal) {
        const newSubtotalHTML = createDamageCentersSubtotal(hasDifferentials);
        existingSubtotal.outerHTML = newSubtotalHTML;
        
        // Update calculations with new layout
        setTimeout(() => {
          updateDamageCentersSubtotal();
        }, 100);
        
        console.log('✅ Container layout refreshed - hasDifferentials:', hasDifferentials);
      }
    }
    
    // REPOSITION DAMAGE CENTERS SAVE BUTTON TO APPEAR BEFORE SUMMARY
    function repositionDamageCentersSaveButton() {
      try {
        const damageCentersSection = document.getElementById('damageCentersSummary');
        const saveButton = damageCentersSection?.querySelector('.section-save-button');
        const subtotal = damageCentersSection?.querySelector('#damageCentersSubtotal');
        
        if (saveButton && subtotal) {
          const buttonContainer = saveButton.parentElement;
          // Move button container to before the subtotal
          subtotal.parentNode.insertBefore(buttonContainer, subtotal);
          console.log('✅ Repositioned damage centers save button before summary');
        }
      } catch (error) {
        console.error('Error repositioning damage centers save button:', error);
      }
    }
    
    // LOAD DAMAGE CENTERS FROM HELPER
    function loadDamageCentersFromHelper(damageBlocksOrHelper) {
      try {
        const damageCentersContent = document.getElementById('damageCentersContent');
        if (!damageCentersContent) return;
        
        // Handle two cases: called with damageBlocks array OR helper object (from refresh)
        let damageBlocks;
        if (Array.isArray(damageBlocksOrHelper)) {
          // Called with damage blocks directly
          damageBlocks = damageBlocksOrHelper;
        } else {
          // Called with helper object (from refresh system) - extract and normalize damage centers
          const helper = damageBlocksOrHelper || {};
          if (helper.centers && helper.centers.length > 0) {
            damageBlocks = helper.centers.map((center, index) => adaptCenterToBlock(center, index));
          } else if (helper.expertise?.damage_blocks && helper.expertise.damage_blocks.length > 0) {
            damageBlocks = helper.expertise.damage_blocks.map((center, index) => adaptCenterToBlock(center, index));
          } else {
            damageBlocks = [];
          }
        }
        
        console.log('🔄 loadDamageCentersFromHelper: Loading', damageBlocks.length, 'damage centers');
        
        // Clear existing content
        damageCentersContent.innerHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters"></div>';
        
        // Add each damage center from helper
        damageBlocks.forEach((block, index) => {
          const newCardHTML = createEditableDamageCenterCard(block, index);
          document.getElementById('editableDamageCenters').insertAdjacentHTML('beforeend', newCardHTML);
        });
        
        // Add הפרשים section before subtotal
        const differentialsHTML = createDifferentialsSection();
        document.getElementById('editableDamageCenters').insertAdjacentHTML('afterend', differentialsHTML);
        
        // Check if differentials exist to determine layout
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        const hasDifferentials = helper.final_report?.differential?.has_differentials && 
                                helper.final_report?.differential?.summary &&
                                (helper.final_report.differential.summary.total_amount_without_vat > 0 || 
                                 helper.final_report.differential.summary.total_amount_with_vat > 0);
        
        // Add subtotal section after differentials
        const subtotalHTML = createDamageCentersSubtotal(hasDifferentials);
        document.getElementById('differentialsSection').insertAdjacentHTML('afterend', subtotalHTML);
        
        // Reposition save button after subtotal is added
        setTimeout(repositionDamageCentersSaveButton, 100);
        
        // Add event listeners
        setTimeout(() => {
          addDamageCenterEventListeners();
          updateAllCostDisplays();
          
          // DON'T auto-update depreciation - preserve manual entries
          // updateDepreciationFromDamageCenters([]);
          // Update damage assessment totals
          updateDamageAssessmentSummary(window.helper || {});
        }, 100);
        
        
      } catch (error) {
        console.error('Error loading damage centers from helper:', error);
      }
    }
    
    // ADD FIELD CHANGE LISTENERS - CRITICAL FOR HELPER UPDATES
    function addFieldChangeListeners() {
      try {
        console.log('🔗 Adding field change listeners...');
        
        // Car details fields
        const carFields = [
          'carPlate', 'carManufacturer', 'carModel', 'carYear', 'carModelCode',
          'carBasePrice', 'carMarketValue', 'carReportDate', 'carMileage'
        ];
        
        carFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
              
              // Recalculate adjustment values when base price changes
              if (fieldId === 'carBasePrice') {
                console.log('📊 Base price changed, recalculating all adjustment values');
                setTimeout(() => {
                  recalculateAllAdjustmentValues();
                }, 100);
              }
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Contact/communication fields
        const contactFields = [
          'ownerName', 'ownerPhone', 'ownerAddress', 'ownerEmail',
          'insuranceAgent', 'agentPhone', 'agentEmail',
          'insuranceCompany', 'insuranceEmail'
        ];
        
        contactFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Claims data fields
        const claimsFields = ['totalClaim'];
        
        claimsFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
              
              // Update gross percentage when total claim changes
              if (fieldId === 'totalClaim') {
                updateGrossPercentageFromGrossValue();
              }
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Basic price field with special handling for 3-bulk system
        const basicPriceField = document.getElementById('basicPrice');
        if (basicPriceField) {
          basicPriceField.addEventListener('change', function() {
            updateHelperFromField({ target: this });
            updateGrossMarketValueCalculation();
            recalculateAllAdjustmentValues();
          });
          basicPriceField.addEventListener('blur', function() {
            updateHelperFromField({ target: this });
            updateGrossMarketValueCalculation();
          });
        }
        
        // Full basic price field
        const fullBasicPriceField = document.getElementById('fullBasicPrice');
        if (fullBasicPriceField) {
          fullBasicPriceField.addEventListener('change', function() {
            updateHelperFromField({ target: this });
            // updateFullMarketValueCalculation() removed
          });
        }
        
        // Summary data fields
        const summaryFields = ['sumMarketValue', 'sumClaim', 'sumVAT', 'sumTotalClaim', 'depCompensation', 'salvageValue', 'garageDays'];
        
        summaryFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            field.addEventListener('change', function() {
              updateHelperFromField({ target: this });
            });
            field.addEventListener('blur', function() {
              updateHelperFromField({ target: this });
            });
          }
        });
        
        // Legal text field
        const legalTextField = document.getElementById('legal-text-content');
        if (legalTextField) {
          legalTextField.addEventListener('change', function() {
            updateHelperFromField({ target: this });
          });
        }
        
        // Final report type change listener
        document.querySelectorAll('input[name="final-report-type"]').forEach(radio => {
          radio.addEventListener('change', function() {
            updateReportType();
            loadLegalText().catch(console.error);
          });
        });
        
        console.log('✅ Field change listeners added successfully');
        
      } catch (error) {
        console.error('Error adding field change listeners:', error);
      }
    }
    
    // INITIALIZE 3-BULK SYSTEM ON PAGE LOAD
    document.addEventListener('DOMContentLoaded', function() {
      console.log('🚀 Initializing 3-bulk system...');
      
      // Wait for all objects to be initialized before loading data
      setTimeout(() => {
        // Load saved helper data first
        loadHelperData();
        
        // Add field change listeners - CRITICAL FOR HELPER UPDATES
        addFieldChangeListeners();
      }, 200);
      
      // Initialize gross calculation data
      setTimeout(() => {
        // loadGrossCalculationData(); // DISABLED - causes duplicate Levi data
        console.log('✅ Bulk 1 & 2 initialized');
        
        // REMOVED: Auto-call updateHelperFromAdjustments on page load to prevent duplication
        // updateHelperFromAdjustments should only be called when user makes actual changes
        // setTimeout(() => {
        //   updateHelperFromAdjustments();
        //   console.log('🔧 Initial helper update completed for Levi floating screen');
        // }, 500);
      }, 500);
      
      // Initialize full market value calculation
      setTimeout(() => {
        loadFullMarketValueData();
        console.log('✅ Bulk 3 initialized');
        console.log('✅ Complete 3-bulk system initialized');
        
        // Restore saved adjustment amounts after data is loaded
        setTimeout(() => {
          console.log('🎯 About to call restoreAdjustmentAmounts...');
          restoreAdjustmentAmounts();
          console.log('✅ Adjustment amounts restored');
          
          // Load additional adjustments UI
          loadAdditionalAdjustments();
          console.log('✅ Additional adjustments loaded');
          
          // Clear flag after restoration is complete
          setTimeout(() => {
            window.pageLoadInProgress = false;
            console.log('✅ Page load complete, sync enabled');
            
            // Trigger final calculations to update cumulative values
            console.log('🔄 Running final calculations to update cumulative values...');
            updateGrossMarketValueCalculation();
            updateFullMarketValueCalculation();
            
            // Sync all adjustments to ensure cumulative values are saved
            setTimeout(() => {
              console.log('🔄 Syncing all adjustment data to helper...');
              const categories = ['features', 'registration', 'mileage', 'ownership_type', 'ownership_history', 'additional'];
              categories.forEach(category => {
                const containers = {
                  'features': ['featuresAdjustmentsList', 'fullFeaturesAdjustmentsList'],
                  'registration': ['registrationAdjustmentsList', 'fullRegistrationAdjustmentsList'],
                  'mileage': ['mileageAdjustmentsList'],
                  'ownership_type': ['ownershipAdjustmentsList'],
                  'ownership_history': ['ownersAdjustmentsList'],
                  'additional': ['allAdjustmentsList']
                };
                
                const categoryContainers = containers[category] || [];
                categoryContainers.forEach(containerId => {
                  const container = document.getElementById(containerId);
                  if (container) {
                    const firstInput = container.querySelector('input');
                    if (firstInput) {
                      syncAdjustmentToHelper(firstInput, category);
                    }
                  }
                });
              });
              console.log('✅ All adjustments synced with cumulative values');
            }, 100);
          }, 500);
        }, 200);
      }, 700);
      
      // Add event listeners for damage center changes
      const damageCentersContent = document.getElementById('damageCentersContent');
      if (damageCentersContent) {
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'childList' || mutation.type === 'subtree') {
              // When damage centers change, update second bulk
              setTimeout(() => {
                refreshSecondBulkFields();
              }, 100);
            }
          });
        });
        
        observer.observe(damageCentersContent, {
          childList: true,
          subtree: true
        });
      }
    });
    
    // ENHANCED SAVE DAMAGE CENTER CHANGES TO TRIGGER BULK UPDATES
    const originalSaveDamageCenterChanges = saveDamageCenterChanges;
    saveDamageCenterChanges = function() {
      originalSaveDamageCenterChanges.call(this);
      
      // After saving damage centers, update second bulk
      setTimeout(() => {
        refreshSecondBulkFields();
      }, 100);
    };
    
    // ENHANCED UPDATE ALL COST DISPLAYS TO TRIGGER BULK UPDATES
    const originalUpdateAllCostDisplays = updateAllCostDisplays;
    updateAllCostDisplays = function() {
      originalUpdateAllCostDisplays.call(this);
      
      // After updating costs, update second bulk
      setTimeout(() => {
        refreshSecondBulkFields();
      }, 100);
    };
    
    // ENHANCED CALCULATE SUMMARY TOTALS TO TRIGGER BULK UPDATES
    const originalCalculateSummaryTotals = calculateSummaryTotals;
    calculateSummaryTotals = function() {
      originalCalculateSummaryTotals.call(this);
      
      // After calculating summary totals, update second bulk
      setTimeout(() => {
        refreshSecondBulkFields();
      }, 100);
    };
    
    // GLOBAL FUNCTIONS FOR EXTERNAL ACCESS
    window.calculateGrossMarketValue = calculateGrossMarketValue;
    window.calculateGrossPercentage = calculateGrossPercentage;
    window.calculateFullMarketValue = calculateFullMarketValue;
    window.refreshSecondBulkFields = refreshSecondBulkFields;
    window.updateGrossMarketValueCalculation = updateGrossMarketValueCalculation;
    window.updateGrossPercentageFromGrossValue = updateGrossPercentageFromGrossValue;
    window.updateFullMarketValueCalculation = updateFullMarketValueCalculation;
    window.testFullCalculation = updateFullMarketValueCalculation; // Easy test function
    
    // Test function to verify dropdown functionality
    window.testDropdowns = function() {
      console.log('🔧 Testing all dropdowns in FULL section...');
      const containers = ['mileageAdjustmentsList', 'ownershipAdjustmentsList', 'ownersAdjustmentsList'];
      
      containers.forEach(containerId => {
        const container = document.getElementById(containerId);
        if (container) {
          const dropdowns = container.querySelectorAll('select');
          dropdowns.forEach((dropdown, index) => {
            console.log(`🔧 ${containerId} dropdown[${index}]:`, dropdown.value, 'onchange:', dropdown.onchange ? 'EXISTS' : 'MISSING');
            
            // Test changing the dropdown
            const originalValue = dropdown.value;
            const newValue = originalValue === 'plus' ? 'minus' : 'plus';
            console.log(`🔧 Changing ${containerId} dropdown[${index}] from ${originalValue} to ${newValue}`);
            dropdown.value = newValue;
            dropdown.dispatchEvent(new Event('change', { bubbles: true }));
            
            // Change it back
            setTimeout(() => {
              dropdown.value = originalValue;
              dropdown.dispatchEvent(new Event('change', { bubbles: true }));
            }, 100);
          });
        }
      });
    };
    window.loadFullMarketValueData = loadFullMarketValueData;
    window.addFullMarketAdjustment = addFullMarketAdjustment;
    window.debugCalculations = debugCalculations;
    
    // Global debug function for helper data structure investigation
    window.debugHelperDataStructure = function() {
      console.group('🔍 HELPER DATA STRUCTURE INVESTIGATION');
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      console.log('=== HELPER OVERVIEW ===');
      console.log('Helper keys:', Object.keys(helper));
      console.log('Helper size:', JSON.stringify(helper).length, 'characters');
      
      console.log('\n=== BASE PRICE INVESTIGATION ===');
      const basePriceLocations = {
        'helper.levi_report?.base_price': helper.levi_report?.base_price,
        'helper.expertise?.levi_report?.base_price': helper.expertise?.levi_report?.base_price,
        'helper.levisummary?.base_price': helper.levisummary?.base_price,
        'helper.car_details?.base_price': helper.car_details?.base_price,
        'helper.vehicle?.base_price': helper.vehicle?.base_price,
        'helper.calculations?.base_price': helper.calculations?.base_price,
        'helper.expertise?.calculations?.base_price': helper.expertise?.calculations?.base_price
      };
      
      Object.entries(basePriceLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`✅ FOUND: ${path} = ${value}`);
        } else {
          console.log(`❌ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== VEHICLE VALUE GROSS INVESTIGATION ===');
      const vehicleValueLocations = {
        'helper.calculations?.vehicle_value_gross': helper.calculations?.vehicle_value_gross,
        'helper.expertise?.calculations?.vehicle_value_gross': helper.expertise?.calculations?.vehicle_value_gross,
        'helper.levi_report?.final_price': helper.levi_report?.final_price,
        'helper.expertise?.levi_report?.final_price': helper.expertise?.levi_report?.final_price,
        'helper.levisummary?.final_price': helper.levisummary?.final_price
      };
      
      Object.entries(vehicleValueLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`✅ FOUND: ${path} = ${value}`);
        } else {
          console.log(`❌ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== DAMAGE DATA INVESTIGATION ===');
      const damageLocations = {
        'helper.expertise?.damage_blocks': helper.expertise?.damage_blocks,
        'helper.damage_centers': helper.damage_centers,
        'helper.damage_sections': helper.damage_sections,
        'helper.expertise?.damage_sections': helper.expertise?.damage_sections
      };
      
      Object.entries(damageLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`✅ FOUND: ${path} = ${Array.isArray(value) ? value.length + ' items' : typeof value}`);
          if (Array.isArray(value) && value.length > 0) {
            console.log(`  First item keys:`, Object.keys(value[0]));
          }
        } else {
          console.log(`❌ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== CALCULATION INVESTIGATION ===');
      const calculationLocations = {
        'helper.calculations': helper.calculations,
        'helper.expertise?.calculations': helper.expertise?.calculations
      };
      
      Object.entries(calculationLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`✅ FOUND: ${path} =`, value);
        } else {
          console.log(`❌ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== LEVI DATA INVESTIGATION ===');
      const leviLocations = {
        'helper.levi_report': helper.levi_report,
        'helper.expertise?.levi_report': helper.expertise?.levi_report,
        'helper.levisummary': helper.levisummary
      };
      
      Object.entries(leviLocations).forEach(([path, value]) => {
        if (value !== undefined) {
          console.log(`✅ FOUND: ${path} =`, value);
        } else {
          console.log(`❌ MISSING: ${path}`);
        }
      });
      
      console.log('\n=== RAW SESSION STORAGE ===');
      console.log('sessionStorage.getItem("helper"):', sessionStorage.getItem('helper'));
      
      console.groupEnd();
      
      return helper;
    };
    
    // Manual trigger for all calculations
    window.forceCalculateAllAdjustments = function() {
      console.log('🔄 Forcing calculation of all adjustments...');
      
      // First ensure basic price is loaded
      loadHelperData();
      
      setTimeout(() => {
        // Calculate all adjustment values
        const allPercentInputs = document.querySelectorAll('#featuresAdjustmentsList input[placeholder="אחוז"], #registrationAdjustmentsList input[placeholder="אחוז"]');
        console.log(`Found ${allPercentInputs.length} percentage inputs`);
        
        allPercentInputs.forEach((input, index) => {
          if (input.value) {
            console.log(`Calculating adjustment ${index + 1}: ${input.value}`);
            calculateAdjustmentValue(input);
          }
        });
        
        // Update gross market value calculation
        updateGrossMarketValueCalculation();
        
        console.log('✅ All adjustment calculations completed');
      }, 200);
    };
    
    console.log('🎯 3-bulk system functions loaded and ready');
    
    // SECTION-SPECIFIC SAVE AND REFRESH FUNCTIONALITY
    
    // Section configuration mapping - Updated to include ALL sections with editable fields
    const sectionConfig = {
      'final-report-type': {
        helperKey: 'manual_final_report_type',
        fields: ['final-report-type'],
        loadFunction: null,
        name: 'סוג אומדן'
      },
      'vehicle-data': {
        helperKey: 'manual_vehicle_data',
        fields: ['carPlate', 'carManufacturer', 'carModel', 'carYear', 'carModelCode', 'carBasePrice', 'carMarketValue', 'carReportDate'],
        loadFunction: 'loadVehicleData',
        name: 'נתוני הרכב'
      },
      'contact-data': {
        helperKey: 'manual_contact_data',
        fields: ['ownerName', 'ownerAddress', 'ownerPhone', 'insuranceCompany', 'insuranceEmail', 'insuranceAgent', 'insuranceAgentPhone', 'insuranceAgentEmail'],
        loadFunction: 'loadContactData',
        name: 'פרטי קשר'
      },
      'damage-centers': {
        helperKey: 'manual_damage_centers',
        fields: [],
        loadFunction: 'loadDamageCentersFromHelper',
        name: 'מרכזי נזק',
        dynamicContent: true
      },
      'gross-calculation': {
        helperKey: 'manual_gross_calculation',
        fields: ['basicPrice'],
        loadFunction: 'loadGrossCalculationData',
        name: 'חישוב אחוז נזק ברוטו',
        dynamicContent: true
      },
      'gross-result': {
        helperKey: 'manual_gross_result',
        fields: ['grossMarketValueResult', 'totalClaim', 'grossPercent'],
        loadFunction: null,
        name: 'תוצאת חישוב ברוטו'
      },
      'full-market-value': {
        helperKey: 'manual_full_market_value',
        fields: ['fullBasicPrice', 'fullMarketValueResult'],
        loadFunction: 'loadFullMarketValueData',
        name: 'חישוב ערך השוק המלא',
        dynamicContent: true
      },
      'depreciation': {
        helperKey: 'depreciation',
        fields: ['globalDep1', 'globalDepValue', 'garageDays'],
        loadFunction: 'loadDepreciationData',
        name: 'חישוב ירידת ערך',
        dynamicContent: true
      },
      'summary': {
        helperKey: 'manual_summary',
        fields: ['sumMarketValue', 'sumClaim', 'sumGrossPercent', 'sumAuthorizedClaim', 'sumTotalVat', 'sumSalvageValue', 'sumNetClaim'],
        loadFunction: 'loadSummaryData',
        name: 'סיכום חוות הדעת'
      },
      'notes': {
        helperKey: 'manual_notes',
        fields: ['additional-notes'],
        loadFunction: null,
        name: 'הערות נוספות'
      },
      'legal-text': {
        helperKey: 'manual_legal_text',
        fields: ['legal-text'],
        loadFunction: 'loadLegalText',
        name: 'טקסט משפטי'
      }
    };
    
    // Generic save function for any section
    function saveSectionData(sectionId) {
      try {
        const config = sectionConfig[sectionId];
        if (!config) {
          console.error(`Unknown section: ${sectionId}`);
          return;
        }
        
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        const sectionData = {};
        
        // Collect data from all fields in the section
        config.fields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            if (field.type === 'radio') {
              const checked = document.querySelector(`input[name="${field.name}"]:checked`);
              sectionData[fieldId] = checked ? checked.value : '';
            } else {
              sectionData[fieldId] = field.value;
            }
          }
        });
        
        // Handle special cases for dynamic content
        if (sectionId === 'final-report-type') {
          const checkedRadio = document.querySelector('input[name="final-report-type"]:checked');
          sectionData.finalReportType = checkedRadio ? checkedRadio.value : '';
        } else if (sectionId === 'damage-centers') {
          sectionData.damageCenters = collectDamageCentersData();
        } else if (sectionId === 'gross-calculation') {
          sectionData.featuresAdjustments = collectAdjustmentData('#featuresAdjustmentsList');
          sectionData.registrationAdjustments = collectAdjustmentData('#registrationAdjustmentsList');
        } else if (sectionId === 'full-market-value') {
          sectionData.allAdjustments = collectAdjustmentData('#allAdjustmentsList');
        } else if (sectionId === 'depreciation') {
          // ✅ FIX: Use saveDepreciationData() instead of collectDepreciationData() to avoid conflicts
          saveDepreciationData();
          return; // Exit early, saveDepreciationData handles everything
        }
        
        // Save to helper with timestamp
        helper[config.helperKey] = {
          ...sectionData,
          lastSaved: new Date().toISOString(),
          isManualSave: true
        };
        
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        
        // Show success message
        showSectionMessage(sectionId, `✅ ${config.name} נשמר בהצלחה`, 'success');
        
        // Trigger refresh for related screens
        triggerFloatingScreenRefresh();
        
        console.log(`✅ Section ${sectionId} saved successfully`);
        
      } catch (error) {
        console.error(`Error saving section ${sectionId}:`, error);
        showSectionMessage(sectionId, `❌ שגיאה בשמירת ${config.name}`, 'error');
      }
    }
    
    // Update depreciation calculations for all fields
    function updateDepreciationCalculation() {
      try {
        // Trigger calculation for global depreciation
        const globalDepInput = document.getElementById('globalDep1');
        if (globalDepInput && globalDepInput.value) {
          const event = new Event('input', { bubbles: true });
          globalDepInput.dispatchEvent(event);
        }
        
        // Trigger calculation for all bulk depreciation rows
        const depRows = document.querySelectorAll('#depreciationBulkTable .dep-row');
        depRows.forEach(row => {
          const percentInput = row.querySelector('input[placeholder="ירידת ערך (מספר)"]');
          if (percentInput && percentInput.value) {
            const event = new Event('input', { bubbles: true });
            percentInput.dispatchEvent(event);
          }
        });
        
        console.log('📊 Depreciation calculations updated');
      } catch (error) {
        console.error('Error updating depreciation calculations:', error);
      }
    }
    
    // Refresh system - SIMPLE VERSION: Just reload page
    function refreshSectionData(sectionId) {
      console.log(`🔄 Refreshing section ${sectionId} by reloading page...`);
      window.location.reload();
    }
    
    // Helper function to collect adjustment data from dynamic tables
    function collectAdjustmentData(containerSelector) {
      const container = document.querySelector(containerSelector);
      if (!container) return [];
      
      const adjustments = [];
      container.querySelectorAll('div[class*="adjustment-row"], div[id*="Adj_"]').forEach(row => {
        const inputs = row.querySelectorAll('input');
        const select = row.querySelector('select');
        
        if (inputs.length >= 2) {
          adjustments.push({
            description: inputs[0].value,
            percentage: inputs[1].value,
            value: inputs[2] ? inputs[2].value : '',
            type: select ? select.value : 'plus'
          });
        }
      });
      
      return adjustments;
    }
    
    // Helper function to collect depreciation data
    function collectDepreciationData(containerSelector) {
      const container = document.querySelector(containerSelector);
      if (!container) return [];
      
      console.log('🔄 Collecting depreciation data from container:', containerSelector);
      const depreciations = [];
      container.querySelectorAll('div[class*="dep-row"], div[id*="depRow_"]').forEach(row => {
        const inputs = row.querySelectorAll('input');
        
        // Depreciation rows have 5 inputs: center_number, damaged_part, repair_type, percent, value
        if (inputs.length >= 5) {
          depreciations.push({
            center_number: inputs[0].value,
            damaged_part: inputs[1].value,
            repair_type: inputs[2].value,
            percent: inputs[3].value,
            value: inputs[4].value
          });
        } else if (inputs.length >= 4) {
          // Fallback for older format (missing center_number)
          depreciations.push({
            center_number: '',
            damaged_part: inputs[0].value,
            repair_type: inputs[1].value,
            percent: inputs[2].value,
            value: inputs[3].value
          });
        }
      });
      
      console.log('🔄 Collected depreciation data:', depreciations);
      return depreciations;
    }
    
    // Helper function to collect damage centers data
    function collectDamageCentersData() {
      const container = document.getElementById('damageCentersContent');
      if (!container) return [];
      
      const damageCenters = [];
      container.querySelectorAll('div[class*="damage-center-card"], div[id*="damage-center-"]').forEach(card => {
        const nameInput = card.querySelector('input[id*="damage-center-name"]');
        const center = {
          name: nameInput ? nameInput.value : '',
          parts: [],
          works: [],
          repairs: []
        };
        
        // Collect parts
        card.querySelectorAll('div[id*="parts-"] input').forEach((input, index) => {
          if (index % 2 === 0) { // Name inputs
            const priceInput = card.querySelector(`div[id*="parts-"] input:nth-child(${index + 2})`);
            center.parts.push({
              name: input.value,
              price: priceInput ? priceInput.value : ''
            });
          }
        });
        
        // Collect works
        card.querySelectorAll('div[id*="works-"] input').forEach((input, index) => {
          if (index % 2 === 0) { // Name inputs
            const priceInput = card.querySelector(`div[id*="works-"] input:nth-child(${index + 2})`);
            center.works.push({
              name: input.value,
              price: priceInput ? priceInput.value : ''
            });
          }
        });
        
        // Collect repairs
        card.querySelectorAll('div[id*="repairs-"] input').forEach((input, index) => {
          if (index % 2 === 0) { // Name inputs
            const priceInput = card.querySelector(`div[id*="repairs-"] input:nth-child(${index + 2})`);
            center.repairs.push({
              name: input.value,
              price: priceInput ? priceInput.value : ''
            });
          }
        });
        
        damageCenters.push(center);
      });
      
      return damageCenters;
    }
    
    // Helper function to restore damage centers data from manual save
    function restoreDamageCentersData(damageCenters) {
      try {
        console.log('🔄 Restoring damage centers data from manual save:', damageCenters);
        
        if (!damageCenters || !Array.isArray(damageCenters)) {
          console.log('❌ No valid damage centers data to restore');
          return;
        }
        
        const container = document.getElementById('damageCentersContent');
        if (!container) {
          console.error('❌ Damage centers container not found');
          return;
        }
        
        // Clear existing content
        container.innerHTML = '<div style="display: grid; gap: 15px;" id="editableDamageCenters"></div>';
        const editableContainer = document.getElementById('editableDamageCenters');
        
        // Restore each damage center
        damageCenters.forEach((centerData, index) => {
          // Create simplified damage center structure for restoration
          const adaptedCenter = {
            damage_center_name: centerData.name || `מוקד נזק ${index + 1}`,
            damage_center_number: index + 1,
            description: '',
            parts: centerData.parts || [],
            works: centerData.works || [],
            repairs: centerData.repairs || []
          };
          
          // Use existing function to create the card
          const newCardHTML = createEditableDamageCenterCard(adaptedCenter, index);
          editableContainer.insertAdjacentHTML('beforeend', newCardHTML);
        });
        
        // Add event listeners and update calculations
        setTimeout(() => {
          addDamageCenterEventListeners();
          updateAllCostDisplays();
          // DON'T auto-update depreciation - preserve manual entries
          // updateDepreciationFromDamageCenters([]);
          // Update damage assessment totals
          updateDamageAssessmentSummary(window.helper || {});
        }, 100);
        
        
      } catch (error) {
        console.error('❌ Error restoring damage centers data:', error);
      }
    }
    
    // Helper function to restore adjustment data to dynamic tables
    function restoreAdjustmentData(containerSelector, adjustments) {
      const container = document.querySelector(containerSelector);
      if (!container) return;
      
      // Clear existing rows
      container.innerHTML = '';
      
      // Add each adjustment
      adjustments.forEach(adj => {
        // Use existing add functions
        if (containerSelector.includes('features')) {
          addFeatureAdjustment();
        } else if (containerSelector.includes('registration')) {
          addRegistrationAdjustment();
        } else if (containerSelector.includes('allAdjustments')) {
          addFullMarketAdjustment();
        }
        
        // Fill the last added row
        const lastRow = container.querySelector('div:last-child');
        if (lastRow) {
          const inputs = lastRow.querySelectorAll('input');
          const select = lastRow.querySelector('select');
          
          if (inputs[0]) inputs[0].value = adj.description;
          if (inputs[1]) inputs[1].value = adj.percentage;
          if (inputs[2]) inputs[2].value = adj.value;
          if (select) select.value = adj.type;
        }
      });
    }
    
    // Helper function to restore depreciation data
    function restoreDepreciationData(containerSelector, depreciations) {
      try {
        console.log('🔄 Restoring depreciation data:', depreciations);
        
        const container = document.querySelector(containerSelector);
        if (!container) {
          console.error('❌ Depreciation container not found:', containerSelector);
          return;
        }
        
        // Clear existing rows
        container.innerHTML = '';
        
        // Add each depreciation
        if (Array.isArray(depreciations)) {
          depreciations.forEach(dep => {
            console.log('🔄 Restoring depreciation item:', dep);
            addDepField(dep);
          });
        }
        
        
      } catch (error) {
        console.error('❌ Error restoring depreciation data:', error);
      }
    }
    
    
    // Helper function to show section messages
    function showSectionMessage(sectionId, message, type) {
      const messageId = `section-message-${sectionId}`;
      let messageDiv = document.getElementById(messageId);
      
      if (!messageDiv) {
        messageDiv = document.createElement('div');
        messageDiv.id = messageId;
        messageDiv.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 10px 15px;
          border-radius: 5px;
          font-size: 14px;
          font-weight: bold;
          z-index: 9999;
          box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          transition: all 0.3s ease;
        `;
        document.body.appendChild(messageDiv);
      }
      
      // Set message style based on type
      const colors = {
        success: { bg: '#d4edda', text: '#155724', border: '#c3e6cb' },
        error: { bg: '#f8d7da', text: '#721c24', border: '#f5c6cb' },
        info: { bg: '#d1ecf1', text: '#0c5460', border: '#bee5eb' }
      };
      
      const color = colors[type] || colors.info;
      messageDiv.style.backgroundColor = color.bg;
      messageDiv.style.color = color.text;
      messageDiv.style.border = `1px solid ${color.border}`;
      messageDiv.textContent = message;
      
      // Auto-hide after 3 seconds
      setTimeout(() => {
        if (messageDiv.parentNode) {
          messageDiv.parentNode.removeChild(messageDiv);
        }
      }, 3000);
    }
    
    // Function to add Save and Refresh buttons to sections with editable fields
    function addSectionButtons() {
      // Define sections that should have save buttons with auto-refresh
      const sections = [
        { id: 'vehicle-data', selector: '#vehicleData', name: 'נתוני הרכב', collapsible: true },
        { id: 'contact-data', selector: '#contactData', name: 'פרטי קשר', collapsible: true },
        { id: 'damage-centers', selector: '#damageCentersContent', name: 'מרכזי נזק', collapsible: true },
        { id: 'gross-calculation', selector: '#grossCalc', name: 'חישוב אחוז נזק ברוטו', collapsible: true },
        { id: 'gross-result', selector: '#grossPercentageResult', name: 'תוצאת חישוב ברוטו', collapsible: true },
        { id: 'full-market-value', selector: '#fullMarketValue', name: 'חישוב ערך השוק המלא', collapsible: true },
        { id: 'depreciation', selector: '#depreciationContent', name: 'חישוב ירידת ערך לפי מוקדי נזק', collapsible: true },
        { id: 'summary', selector: '#sumMarketValue', name: 'סיכום חוות הדעת', collapsible: false },
        { id: 'notes', selector: '#additional-notes', name: 'הערות נוספות', collapsible: false },
        { id: 'legal-text', selector: '#legal-text-content', name: 'טקסט משפטי', collapsible: false }
      ];
      
      sections.forEach(section => {
        let sectionElement = null;
        
        // For collapsible sections, find by ID
        if (section.collapsible) {
          sectionElement = document.getElementById(section.selector.replace('#', ''));
        } else {
          // For non-collapsible sections, find by selector and get parent form-section
          const keyElement = document.querySelector(section.selector);
          if (keyElement) {
            sectionElement = keyElement.closest('.form-section');
            if (!sectionElement) {
              sectionElement = keyElement.parentElement;
              while (sectionElement && !sectionElement.classList.contains('form-section')) {
                sectionElement = sectionElement.parentElement;
              }
            }
          }
        }
        
        if (sectionElement) {
          // Check if save button already exists
          if (sectionElement.querySelector('.section-save-button')) {
            return; // Skip if button already exists
          }
          
          // Create a container for both buttons
          const buttonContainer = document.createElement('div');
          buttonContainer.style.cssText = `
            display: flex;
            gap: 10px;
            margin-top: 12px;
            margin-bottom: 8px;
            justify-content: flex-start;
            margin-left: 15px;
          `;
          
          // Create save button with auto-refresh functionality
          const saveButton = document.createElement('button');
          saveButton.className = 'btn section-save-button';
          saveButton.textContent = 'שמור';
          saveButton.style.cssText = `
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            display: inline-block;
            width: auto;
            transition: background-color 0.3s;
          `;
          saveButton.onmouseover = function() { this.style.background = '#218838'; };
          saveButton.onmouseout = function() { this.style.background = '#28a745'; };
          saveButton.onclick = function() { 
            console.log('💾 Saving section to helper:', section.id);
            saveSectionData(section.id);
            console.log('✅ Section saved successfully - no page refresh');
          };
          
          // Create collapse button
          const collapseButton = document.createElement('button');
          collapseButton.className = 'btn section-collapse-button';
          collapseButton.textContent = 'כווץ';
          collapseButton.style.cssText = `
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            display: inline-block;
            width: auto;
            transition: background-color 0.3s;
          `;
          collapseButton.onmouseover = function() { this.style.background = '#5a6268'; };
          collapseButton.onmouseout = function() { this.style.background = '#6c757d'; };
          collapseButton.onclick = function() {
            // Get the section ID from the selector
            let sectionToToggle = '';
            if (section.id === 'vehicle-data') {
              sectionToToggle = 'vehicleData';
            } else if (section.id === 'contact-data') {
              sectionToToggle = 'contactData';
            } else if (section.id === 'damage-centers') {
              sectionToToggle = 'damageCentersSummary';
            } else if (section.id === 'gross-calculation') {
              sectionToToggle = 'grossCalc';
            } else if (section.id === 'gross-result') {
              sectionToToggle = 'grossPercentageResult';
            } else if (section.id === 'full-market-value') {
              sectionToToggle = 'fullMarketValue';
            } else if (section.id === 'depreciation') {
              sectionToToggle = 'depreciationContent';
            }
            
            if (sectionToToggle && window.toggleSection) {
              window.toggleSection(sectionToToggle);
            }
          };
          
          // Add buttons to container
          buttonContainer.appendChild(saveButton);
          
          // Only add collapse button if the section is collapsible
          if (section.collapsible) {
            buttonContainer.appendChild(collapseButton);
          }
          
          // Add button container to section
          if (section.collapsible) {
            // For collapsible sections, add the button to the collapsible content div
            const contentDiv = sectionElement.querySelector('#damageCentersSummary, #priceData, #contactData, #grossCalc, #grossPercentageResult, #fullMarketValue');
            if (contentDiv) {
              // Special handling for damage centers - insert before summary if it exists
              if (section.id === 'damage-centers') {
                const damageCentersSubtotal = contentDiv.querySelector('#damageCentersSubtotal');
                if (damageCentersSubtotal) {
                  // Insert button before the summary section
                  damageCentersSubtotal.parentNode.insertBefore(buttonContainer, damageCentersSubtotal);
                } else {
                  const damageCentersContent = contentDiv.querySelector('#damageCentersContent');
                  if (damageCentersContent) {
                    // Insert button right after damageCentersContent if no summary exists
                    damageCentersContent.parentNode.insertBefore(buttonContainer, damageCentersContent.nextSibling);
                  } else {
                    contentDiv.appendChild(buttonContainer);
                  }
                }
              } else {
                contentDiv.appendChild(buttonContainer);
              }
            } else {
              sectionElement.appendChild(buttonContainer);
            }
          } else {
            sectionElement.appendChild(buttonContainer);
          }
          
          console.log(`✅ Added Save button with auto-refresh to section: ${section.name} (collapsible: ${section.collapsible})`);
        }
      });
    }
    
    // Initialize section buttons when page loads
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(() => {
        addSectionButtons();
        
        // Restore damage centers section state (default collapsed)
        const damageCentersState = sessionStorage.getItem('damageCentersSection') || 'collapsed';
        const damageCentersSection = document.getElementById('damageCentersSummary');
        const damageCentersToggleBtn = document.getElementById('damageCentersToggleBtn');
        if (damageCentersSection && damageCentersToggleBtn) {
          if (damageCentersState === 'collapsed') {
            damageCentersSection.style.display = 'none';
            damageCentersToggleBtn.innerHTML = '🔼 פתח';
            damageCentersToggleBtn.style.background = '#28a745';
          } else {
            damageCentersSection.style.display = 'block';
            damageCentersToggleBtn.innerHTML = '🔽 סגור';
            damageCentersToggleBtn.style.background = '#6c757d';
          }
          console.log(`🔄 Restored damage centers section as ${damageCentersState}`);
        }
        
        // Initialize vehicle data and depreciation sections as collapsed (using standard toggleSection logic)
        const vehicleDataSection = document.getElementById('vehicleData');
        if (vehicleDataSection) {
          vehicleDataSection.style.display = 'none';
          console.log('🔄 Vehicle data section initialized as collapsed');
        }
        
        const depreciationContentSection = document.getElementById('depreciationContent');
        if (depreciationContentSection) {
          depreciationContentSection.style.display = 'none';
          console.log('🔄 Depreciation section initialized as collapsed');
        }
      }, 1000);
    });
    
    console.log('📄 Section Save/Refresh functionality initialized');
    
    // =========================
    // PLATE INPUT AND DOCUMENT ACTIONS FUNCTIONALITY
    // =========================
    
    // Load existing case for builder
    window.loadExistingCaseForBuilder = async function() {
      const plateNumber = document.getElementById('builderPlateInput').value.trim();
      
      // Get password - check if it's masked by password-prefill.js
      const passwordField = document.getElementById('builderPasswordInput');
      const actualPassword = passwordField.getAttribute('data-actual-password');
      const password = actualPassword || passwordField.value.trim();
      
      if (!plateNumber) {
        alert('אנא הכנס מספר רכב');
        return;
      }
      
      // Validate password against stored login credentials if password is provided
      if (password) {
        try {
          const encryptedPassword = sessionStorage.getItem("auth");
          if (encryptedPassword) {
            const { decryptPassword } = await import('./auth.js');
            const storedPassword = await decryptPassword(encryptedPassword);
            if (password !== storedPassword) {
              alert('סיסמה שגויה');
              return;
            }
          } else {
            alert('אין אימות נתונים זמין');
            return;
          }
        } catch (error) {
          console.error('Error validating password:', error);
          alert('שגיאה באימות הסיסמה');
          return;
        }
      }
      
      const loadBtn = document.getElementById('builderLoadCaseBtn');
      const originalText = loadBtn.textContent;
      
      try {
        loadBtn.disabled = true;
        loadBtn.textContent = 'טוען תיק...';
        
        // Check if main selection page has loaded a case
        const existingHelper = sessionStorage.getItem('helper');
        const existingPlate = sessionStorage.getItem('plate');
        
        if (existingHelper && existingPlate === plateNumber) {
          // Use existing data
          const caseData = JSON.parse(existingHelper);
          
          document.getElementById('builderPlateStatus').style.display = 'block';
          document.getElementById('builderPlateStatus').textContent = '✓ נתוני הרכב נטענו בהצלחה';
          document.getElementById('builderPlateStatus').style.color = '#059669';
          
          // Update car details from helper
          if (caseData.car_details) {
            document.getElementById('carPlate').value = caseData.car_details.plate || caseData.meta?.plate || '';
            document.getElementById('carManufacturer').value = caseData.car_details.manufacturer || '';
            document.getElementById('carModel').value = caseData.car_details.model || '';
            document.getElementById('carYear').value = caseData.car_details.year || '';
            document.getElementById('carModelCode').value = caseData.car_details.model_code || '';
            document.getElementById('carReportDate').value = convertToDateInputFormat(caseData.car_details.report_date || '');
          }
          
          // Update page title
          // Standardize plate format
          const standardizedPlateNumber = String(plateNumber).replace(/[-\s]/g, '');
          document.getElementById('pageTitle').textContent = `רכב מס. ${standardizedPlateNumber}`;
          
          return;
        }
        
        // Make webhook call to load case
        const payload = { plate: plateNumber };
        if (password) {
          payload.password = password;
        }
        
        // Import webhook function
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('ADMIN_FETCH_CASE', payload);
        
        if (response?.success && response?.data) {
          const caseData = response.data;
          
          // Store the data
          sessionStorage.setItem('helper', JSON.stringify(caseData));
          sessionStorage.setItem('plate', plateNumber);
          sessionStorage.setItem('caseLoaded', 'true');
          
          document.getElementById('builderPlateStatus').style.display = 'block';
          document.getElementById('builderPlateStatus').textContent = '✓ נתוני הרכב נטענו בהצלחה';
          document.getElementById('builderPlateStatus').style.color = '#059669';
          
          // Update car details from helper
          if (caseData.car_details) {
            document.getElementById('carPlate').value = caseData.car_details.plate || caseData.meta?.plate || '';
            document.getElementById('carManufacturer').value = caseData.car_details.manufacturer || '';
            document.getElementById('carModel').value = caseData.car_details.model || '';
            document.getElementById('carYear').value = caseData.car_details.year || '';
            document.getElementById('carModelCode').value = caseData.car_details.model_code || '';
            document.getElementById('carReportDate').value = convertToDateInputFormat(caseData.car_details.report_date || '');
          }
          
          // Update page title
          // Standardize plate format
          const standardizedPlateNumber = String(plateNumber).replace(/[-\s]/g, '');
          document.getElementById('pageTitle').textContent = `רכב מס. ${standardizedPlateNumber}`;
          
          // Reload data from helper
          loadDataFromHelper();
          
        } else {
          document.getElementById('builderPlateStatus').style.display = 'block';
          document.getElementById('builderPlateStatus').textContent = '❌ תיק לא נמצא במערכת';
          document.getElementById('builderPlateStatus').style.color = '#dc2626';
        }
        
      } catch (error) {
        console.error('Error loading case:', error);
        document.getElementById('builderPlateStatus').style.display = 'block';
        document.getElementById('builderPlateStatus').textContent = '❌ שגיאה בטעינת התיק';
        document.getElementById('builderPlateStatus').style.color = '#dc2626';
      } finally {
        loadBtn.disabled = false;
        loadBtn.textContent = originalText;
      }
    };
    
    // Request expertise for builder
    window.requestExpertiseForBuilder = async function() {
      const plateNumber = document.getElementById('builderPlateInput').value.trim();
      const helper = sessionStorage.getItem('helper');
      
      if (!plateNumber) {
        alert('אנא הכנס מספר רכב');
        return;
      }
      
      if (!helper) {
        alert('נתוני התיק לא נמצאו במערכת');
        return;
      }
      
      const requestBtn = document.getElementById('builderRequestExpertiseBtn');
      const originalText = requestBtn.textContent;
      
      try {
        requestBtn.disabled = true;
        requestBtn.textContent = 'מבקש אקספירטיזה...';
        
        const caseData = JSON.parse(helper);
        const payload = {
          plate: plateNumber,
          case_id: caseData.meta?.case_id,
          helper: caseData
        };
        
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('CALL_EXPERTISE', payload);
        
        if (response?.success) {
          const successMessage = response.message || 'האקספירטיזה נשלחה בהצלחה! בדוק את האימייל שלך לקבלת הקובץ.';
          alert(successMessage);
          
          if (response.pdf_url) {
            showFloatingPDF(response.pdf_url, 'אקספירטיזה PDF');
            
            // Update helper with expertise data
            // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
            if (!helper.expertise) helper.expertise = {};
            helper.expertise.document_url = response.pdf_url;
            helper.expertise.requested_at = new Date().toISOString();
            sessionStorage.setItem('helper', JSON.stringify(helper));
            
            // Update button states
            initializeExpertiseButtonState();
          }
        } else {
          alert('שגיאה בשליחת בקשה לאקספירטיזה. אנא נסה שוב.');
        }
        
      } catch (error) {
        console.error('Error requesting expertise:', error);
        alert('שגיאה בשליחת בקשה לאקספירטיזה. אנא נסה שוב.');
      } finally {
        requestBtn.disabled = false;
        requestBtn.textContent = originalText;
      }
    };
    
    // Fetch expertise PDF for builder
    window.fetchExpertisePDFForBuilder = async function() {
      const plateNumber = document.getElementById('builderPlateInput').value.trim();
      const helper = sessionStorage.getItem('helper');
      
      if (!plateNumber) {
        alert('אנא הכנס מספר רכב');
        return;
      }
      
      const fetchBtn = document.getElementById('builderFetchExpertiseBtn');
      const originalText = fetchBtn.textContent;
      
      try {
        fetchBtn.disabled = true;
        fetchBtn.textContent = 'טוען PDF...';
        
        const caseData = helper ? JSON.parse(helper) : null;
        const payload = {
          plate: plateNumber,
          case_id: caseData?.meta?.case_id,
          document_type: 'expertise'
        };
        
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('FETCH_EXPERTISE_PDF', payload);
        
        if (response?.success && response?.pdf_url) {
          showFloatingPDF(response.pdf_url, 'אקספירטיזה PDF');
        } else {
          alert('אקספירטיזה לא נמצאה במערכת או לא הופקה עדיין');
        }
        
      } catch (error) {
        console.error('Error fetching expertise PDF:', error);
        alert('שגיאה בטעינת אקספירטיזה PDF');
      } finally {
        fetchBtn.disabled = false;
        fetchBtn.textContent = originalText;
      }
    };
    
    // Show floating PDF display
    function showFloatingPDF(pdfUrl, title) {
      const overlay = document.getElementById('floatingPdfOverlay');
      const titleElement = document.getElementById('floatingPdfTitle');
      const iframe = document.getElementById('pdfViewer');
      
      titleElement.textContent = title;
      
      console.log(`🔍 Attempting to display PDF: ${pdfUrl}`);
      
      // Try to load PDF in iframe
      iframe.src = pdfUrl;
      
      // Add error handling for iframe loading
      iframe.onload = function() {
        console.log('✅ PDF loaded successfully in iframe');
      };
      
      iframe.onerror = function() {
        console.error('❌ Failed to load PDF in iframe');
        // Fallback: show link to open in new tab
        iframe.style.display = 'none';
        const fallbackDiv = document.createElement('div');
        fallbackDiv.style.cssText = 'padding: 20px; text-align: center; direction: rtl;';
        fallbackDiv.innerHTML = `
          <h3 style="color: #1e3a8a; margin-bottom: 15px;">לא ניתן להציג את הPDF בחלון זה</h3>
          <p style="margin-bottom: 15px;">אנא לחץ על הקישור להצגת הקובץ:</p>
          <a href="${pdfUrl}" target="_blank" style="display: inline-block; padding: 10px 20px; background: #1e3a8a; color: white; text-decoration: none; border-radius: 6px;">
            פתח PDF בחלון חדש
          </a>
        `;
        iframe.parentNode.appendChild(fallbackDiv);
      };
      
      overlay.style.display = 'flex';
      
      // Setup event listeners for controls
      setupFloatingPDFControls();
    }
    
    
    // Setup floating PDF controls with mobile optimization
    function setupFloatingPDFControls() {
      const toggleBtn = document.getElementById('togglePdfBtn');
      const closeBtn = document.getElementById('closePdfBtn');
      const content = document.getElementById('floatingPdfContent');
      const container = document.querySelector('.floating-pdf-container');
      
      // Add touch-friendly event handlers
      function addTouchFriendlyHandler(button, callback) {
        // Handle both click and touch events
        button.addEventListener('click', callback);
        button.addEventListener('touchend', function(e) {
          e.preventDefault();
          callback();
        });
        
        // Add touch visual feedback
        button.addEventListener('touchstart', function() {
          this.style.backgroundColor = 'rgba(255, 255, 255, 0.4)';
        });
        
        button.addEventListener('touchend', function() {
          this.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
        });
      }
      
      // Toggle minimize/maximize with touch support
      addTouchFriendlyHandler(toggleBtn, function() {
        content.classList.toggle('minimized');
        container.classList.toggle('minimized');
        toggleBtn.textContent = content.classList.contains('minimized') ? '□' : '_';
      });
      
      // Close PDF display with touch support
      addTouchFriendlyHandler(closeBtn, function() {
        const overlay = document.getElementById('floatingPdfOverlay');
        const iframe = document.getElementById('pdfViewer');
        overlay.style.display = 'none';
        iframe.src = '';
        
        // Reset minimize state
        content.classList.remove('minimized');
        container.classList.remove('minimized');
        toggleBtn.textContent = '_';
      });
      
      // Close on overlay click
      document.getElementById('floatingPdfOverlay').onclick = function(e) {
        if (e.target === this) {
          closeBtn.click();
        }
      };
    }
    
    // Initialize plate input and password prefill
    document.addEventListener('DOMContentLoaded', function() {
      // Prefill plate from session storage
      const existingPlate = sessionStorage.getItem('plate');
      if (existingPlate) {
        document.getElementById('builderPlateInput').value = existingPlate;
      }
      
      // Prefill password from session storage
      const prefillPassword = sessionStorage.getItem('prefillPassword') || 
                              sessionStorage.getItem('mainGatePassword') || 
                              sessionStorage.getItem('originalPassword');
      if (prefillPassword) {
        document.getElementById('builderPasswordInput').value = prefillPassword;
      }
      
      // Initialize expertise button state
      initializeExpertiseButtonState();
    });

    // Initialize expertise button state based on existing data
    function initializeExpertiseButtonState() {
      const fetchBtn = document.getElementById('builderFetchExpertiseBtn');
      const requestBtn = document.getElementById('builderRequestExpertiseBtn');
      
      if (!fetchBtn || !requestBtn) return;
      
      // Check if expertise exists in helper data
      const helper = sessionStorage.getItem('helper');
      let expertiseExists = false;
      
      if (helper) {
        try {
          const helperData = JSON.parse(helper);
          expertiseExists = helperData.expertise_data?.completed || 
                           helperData.documents?.expertise_pdf || 
                           helperData.expertise?.document_url ||
                           helperData.expertise_pdf;
        } catch (error) {
          console.error('Error parsing helper data:', error);
        }
      }
      
      // Set button states based on expertise existence
      if (expertiseExists) {
        // Enable fetch button
        fetchBtn.disabled = false;
        fetchBtn.style.opacity = '1';
        fetchBtn.style.cursor = 'pointer';
        
        // Change request button to "re-request" style
        requestBtn.textContent = 'בקש אקספירטיזה מחדש';
        requestBtn.style.background = '#f59e0b'; // Orange for re-request
      } else {
        // Disable fetch button
        fetchBtn.disabled = true;
        fetchBtn.style.opacity = '0.5';
        fetchBtn.style.cursor = 'not-allowed';
        
        // Set request button to normal style
        requestBtn.textContent = 'בקש אקספירטיזה';
        requestBtn.style.background = '#059669'; // Green for new request
      }
      
      console.log('🔘 Expertise button state initialized:', { expertiseExists });
    }
    
    // ✅ BIDIRECTIONAL INTEGRATION: Builder State Management
    // This allows validation page to read current builder state instead of helper directly
    function updateBuilderCurrentState(key, value) {
      try {
        let builderState = {};
        
        // Get existing builder state
        const existingState = sessionStorage.getItem('builderCurrentState');
        if (existingState) {
          builderState = JSON.parse(existingState);
        }
        
        // Update the specific key
        builderState[key] = value;
        builderState.last_update = new Date().toISOString();
        builderState.source = 'final-report-builder';
        
        // Save updated state
        sessionStorage.setItem('builderCurrentState', JSON.stringify(builderState));
        
        console.log(`✅ Builder state updated: ${key}`, value);
        
        // Trigger broadcast to validation pages
        if (typeof broadcastBuilderStateUpdate === 'function') {
          broadcastBuilderStateUpdate(key, value);
        }
        
      } catch (error) {
        console.error('❌ Error updating builder state:', error);
      }
    }
    
    // Initialize builder state when page loads
    function initializeBuilderState() {
      try {
        console.log('📝 Final Report Builder: Initializing with ENHANCED helper integration...');
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        
        // ENHANCED: Create initial builder state from proper helper paths
        const initialState = {
          // Car details - use proper vehicle section
          plate: helper.vehicle?.plate || helper.meta?.plate,
          manufacturer: helper.vehicle?.manufacturer || helper.car_details?.manufacturer,
          model: helper.vehicle?.model || helper.car_details?.model,
          year: helper.vehicle?.year || helper.car_details?.year,
          
          // Owner details - use stakeholders section
          owner_name: helper.stakeholders?.owner?.name || helper.client?.name || helper.owner,
          owner_address: helper.stakeholders?.owner?.address,
          owner_phone: helper.stakeholders?.owner?.phone,
          insurance_company: helper.stakeholders?.insurance?.company || helper.client?.insurance_company || helper.insurance_company,
          
          // Final report data - use final report section
          final_report_type: helper.final_report?.type || helper.final_report_type,
          final_report_notes: helper.final_report?.notes || helper.final_report_notes,
          final_report_work_days: helper.final_report?.work_days || helper.final_report_work_days,
          // Legal text for final report comes from final_report object
          final_report_legal_text: helper.final_report?.legal_text || '',
          final_report_depreciation: helper.final_report?.depreciation,
          
          // Calculations
          calculations: helper.calculations,
          claims_data: helper.claims_data,
          
          // Metadata
          initialized_at: new Date().toISOString(),
          source: 'final-report-builder',
          version: '1.0'
        };
        
        sessionStorage.setItem('builderCurrentState', JSON.stringify(initialState));
        console.log('🏗️ Builder state initialized from helper data');
        
      } catch (error) {
        console.error('❌ Error initializing builder state:', error);
      }
    }
    
    // Initialize builder state when page loads
    document.addEventListener('DOMContentLoaded', initializeBuilderState);
    
    
    
    // Update helper structure from contact field changes using field mapping dictionary
    function updateHelperFromContactField(element) {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        const fieldId = element.id;
        const value = element.value;
        
        console.log(`📝 Contact field change: ${fieldId} = "${value}"`);
        
        // Set nested value helper function
        const setNestedValue = (obj, path, val) => {
          const keys = path.split('.');
          let current = obj;
          for (let i = 0; i < keys.length - 1; i++) {
            const key = keys[i];
            if (!(key in current) || typeof current[key] !== 'object') {
              current[key] = {};
            }
            current = current[key];
          }
          current[keys[keys.length - 1]] = val;
        };
        
        // Map field IDs to helper structure paths using field mapping dictionary
        const fieldMappings = {
          'ownerName': 'stakeholders.owner.name',
          'ownerAddress': 'stakeholders.owner.address', 
          'ownerPhone': 'stakeholders.owner.phone',
          'insuranceCompany': 'stakeholders.insurance.company',
          'insuranceEmail': 'stakeholders.insurance.email',
          'insuranceAgent': 'stakeholders.insurance.agent.name',
          'agentPhone': 'stakeholders.insurance.agent.phone',
          'agentEmail': 'stakeholders.insurance.agent.email',
          'garageName': 'stakeholders.garage.name',
          'garagePhone': 'stakeholders.garage.phone',
          'garageEmail': 'stakeholders.garage.email',
          'carReportDate': 'case_info.issue_date'
        };
        
        // Update standardized helper structure
        if (fieldMappings[fieldId]) {
          setNestedValue(helper, fieldMappings[fieldId], value);
          console.log(`✅ Updated ${fieldMappings[fieldId]} = "${value}"`);
        }
        
        // Also maintain legacy structure for backward compatibility
        helper.client = helper.client || {};
        helper.car_details = helper.car_details || {};
        
        const legacyMappings = {
          'ownerName': () => {
            helper.client.name = value;
            helper.car_details.owner = value;
          },
          'ownerAddress': () => {
            helper.client.address = value;
            helper.car_details.ownerAddress = value;
          },
          'ownerPhone': () => {
            helper.client.phone = value;
            helper.car_details.ownerPhone = value;
          },
          'insuranceCompany': () => {
            helper.client.insurance_company = value;
            helper.car_details.insuranceCompany = value;
          },
          'insuranceEmail': () => {
            helper.client.insurance_email = value;
          },
          'insuranceAgent': () => {
            helper.client.insurance_agent = value;
            helper.car_details.agentName = value;
          },
          'agentPhone': () => {
            helper.client.insurance_agent_phone = value;
            helper.car_details.insurance_agent_phone = value;
          },
          'agentEmail': () => {
            helper.client.insurance_agent_email = value;
            helper.car_details.insurance_agent_email = value;
          }
        };
        
        if (legacyMappings[fieldId]) {
          legacyMappings[fieldId]();
        }
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        localStorage.setItem('helper', JSON.stringify(helper));
        
        console.log(`💾 Helper updated for field: ${fieldId}`);
        
      } catch (error) {
        console.error('❌ Error updating helper from contact field:', error);
      }
    }
    
    // Update helper structure from vehicle field changes using field mapping dictionary
    function updateHelperFromVehicleField(element) {
      try {
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        const fieldId = element.id;
        let value = element.value;
        
        console.log(`📝 Vehicle field change: ${fieldId} = "${value}"`);
        
        // Set nested value helper function
        const setNestedValue = (obj, path, val) => {
          const keys = path.split('.');
          let current = obj;
          for (let i = 0; i < keys.length - 1; i++) {
            const key = keys[i];
            if (!(key in current) || typeof current[key] !== 'object') {
              current[key] = {};
            }
            current = current[key];
          }
          current[keys[keys.length - 1]] = val;
        };
        
        // Process price fields - remove currency symbol and commas
        if (fieldId === 'carBasePrice' || fieldId === 'carMarketValue') {
          value = value.replace(/[₪,]/g, '').trim();
          if (value && !isNaN(value)) {
            value = parseInt(value);
          }
        }
        
        // Map field IDs to helper structure paths
        const fieldMappings = {
          'carBasePrice': 'valuation.base_price',
          'carMarketValue': 'vehicle.market_value', 
          'carReportDate': 'case_info.issue_date'
        };
        
        // Update standardized helper structure
        if (fieldMappings[fieldId]) {
          setNestedValue(helper, fieldMappings[fieldId], value);
          console.log(`✅ Updated ${fieldMappings[fieldId]} = "${value}"`);
        }
        
        // Also maintain legacy structure for backward compatibility
        helper.car_details = helper.car_details || {};
        helper.levi_report = helper.levi_report || {};
        helper.expertise = helper.expertise || {};
        helper.expertise.calculations = helper.expertise.calculations || {};
        
        const legacyMappings = {
          'carBasePrice': () => {
            helper.car_details.base_price = value;
            helper.levi_report.base_price = value;
          },
          'carMarketValue': () => {
            helper.car_details.market_value = value;
            helper.expertise.calculations.market_value = value;
          },
          'carReportDate': () => {
            helper.car_details.report_date = value;
            // Do NOT update levi_report.report_date - this is for final report only
          }
        };
        
        if (legacyMappings[fieldId]) {
          legacyMappings[fieldId]();
        }
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        localStorage.setItem('helper', JSON.stringify(helper));
        
        console.log(`💾 Helper updated for vehicle field: ${fieldId}`);
        
      } catch (error) {
        console.error('❌ Error updating helper from vehicle field:', error);
      }
    }
    
    // DEPRECIATION MODULE INTEGRATION - COMPLETE DYNAMIC SYSTEM
    
    // Initialize depreciation functionality on page load
    document.addEventListener('DOMContentLoaded', function() {
      console.log('🚀 Initializing complete dynamic depreciation system...');
      
      // Initialize report type handler
      const reportTypeSelect = document.getElementById('reportType');
      if (reportTypeSelect) {
        reportTypeSelect.addEventListener('change', function() {
          const selectedType = this.value;
          console.log('Report type changed to:', selectedType);
          
          // Save dropdown selection to helper
          const helper = window.helper || {};
          if (!helper.final_report) helper.final_report = {};
          helper.final_report.dropdown_type = selectedType;
          window.helper = helper;
          console.log('💾 Saved dropdown report type to helper:', selectedType);
          
          updateReportType();
          loadLegalText().catch(console.error); // Update legal text when report type changes
          loadAttachmentsFromVault(); // Update attachments when report type changes
          saveAndRefreshComplete(); // Save and refresh calculations
        });
        
        // Initialize with current selection
        updateSummaryVisibility();
      }
      
      // Initialize company selection for VAT calculation
      const companySelect = document.getElementById('isCompanyClient');
      if (companySelect) {
        companySelect.addEventListener('change', function() {
          console.log('Company selection changed:', this.value);
          saveAndRefreshComplete();
        });
      }
      
      // Initialize global depreciation field
      const globalDep1 = document.getElementById('globalDep1');
      if (globalDep1) {
        globalDep1.addEventListener('input', function() {
          // Clean the value to allow decimal numbers
          let value = this.value;
          
          // Remove % for processing
          value = value.replace('%', '');
          
          // Allow only numbers, decimal point, and minus sign
          value = value.replace(/[^0-9.-]/g, '');
          
          // Ensure only one decimal point
          const parts = value.split('.');
          if (parts.length > 2) {
            value = parts[0] + '.' + parts.slice(1).join('');
          }
          
          // Keep as clean number during input
          this.value = value;
          
          console.log('Global depreciation changed:', this.value);
          
          // Call the functions that were in the inline handlers
          saveDepreciationData();
          updateHelperDepreciationField(this, 'global_percentage');
          
          calculateGlobalDepreciationValue();
          triggerMathCalculation();
          saveAndRefreshComplete();
        });
        
        // Allow decimal input on keypress
        globalDep1.addEventListener('keypress', function(e) {
          // Allow: numbers (0-9), decimal point (.), minus (-), navigation keys
          const allowedKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '-', 'Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab'];
          
          if (!allowedKeys.includes(e.key) && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
          }
        });
        
        // Add % sign when user finishes editing (on blur) 
        globalDep1.addEventListener('blur', function() {
          if (this.value && !this.value.includes('%') && this.value !== '') {
            const numValue = parseFloat(this.value);
            if (!isNaN(numValue)) {
              this.value = this.value + '%';
            }
          }
        });
      }
      
      // Initialize work days field
      const workDays = document.getElementById('workDays');
      if (workDays) {
        workDays.addEventListener('input', function() {
          console.log('Work days changed:', this.value);
          saveAndRefreshComplete();
        });
      }
      
      // Initialize agreement checkbox
      const isAgreement = document.getElementById('isAgreement');
      if (isAgreement) {
        isAgreement.addEventListener('change', function() {
          console.log('Agreement checkbox changed:', this.checked);
          saveAndRefreshComplete();
        });
      }
      
      // Initialize differentials checkbox
      const differentialsCheckbox = document.getElementById('hasDifferentials');
      if (differentialsCheckbox) {
        differentialsCheckbox.addEventListener('change', function() {
          console.log('Differentials checkbox changed:', this.checked);
          toggleDifferentials();
          saveAndRefreshComplete();
        });
      }
      
      // Add dynamic event listeners to all value fields that affect calculations
      const dynamicFields = [
        'saleValueDamage', 'salvageValueTotal', 'salvageValueLegal', 'storageValueTotal'
      ];
      
      dynamicFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field) {
          field.addEventListener('input', function() {
            console.log(`${fieldId} changed:`, this.value);
            calculateSubtotals();
            saveAndRefreshComplete();
          });
        }
      });
      
      // Initialize differentials display
      toggleDifferentials();
      
      // Load existing data from helper
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const dep = helper.expertise?.depreciation || {};
      
      // TEMPORARILY DISABLE loading existing differentials data to fix corruption
      // Load existing differentials data - DISABLED to clear corrupted data
      // if (dep.differentials && dep.differentials.length > 0) {
      //   renderDifferentials(dep.differentials);
      // }
      console.log('⚠️ Differential loading temporarily disabled to clear corrupted data');
      
      // Load existing form values
      if (dep.global_percent && globalDep1) {
        globalDep1.value = dep.global_percent;
      }
      if (dep.work_days && workDays) {
        workDays.value = dep.work_days;
      }
      if (dep.is_agreement !== undefined && isAgreement) {
        isAgreement.checked = !!dep.is_agreement;
      }
      if (dep.has_differentials !== undefined && differentialsCheckbox) {
        differentialsCheckbox.checked = !!dep.has_differentials;
      }
      
      // Load company selection
      if (helper.client?.is_company_client !== undefined && companySelect) {
        companySelect.value = helper.client.is_company_client ? 'yes' : 'no';
      }
      
      // Load report type
      if (helper.meta?.report_type_display && reportTypeSelect) {
        reportTypeSelect.value = helper.meta.report_type_display;
      }
      
      // Initial complete calculation refresh
      setTimeout(() => {
        calculateGlobalDepreciationValue();
        triggerMathCalculation();
        refreshSummary();
        console.log('✅ Complete dynamic system initialized');
      }, 100);
    });
    
    // Update summary visibility based on report type
    function updateSummaryVisibility() {
      const reportTypeSelect = document.getElementById('reportType');
      const reportType = reportTypeSelect?.value || 'חוות דעת פרטית';
      console.log('🔄 Updating summary visibility for type:', reportType);
      console.log('🔄 updateSummaryVisibility() called - will call refreshSummary()');
      
      // Hide all summary sections first
      const summaryBlocks = document.querySelectorAll('.summary-block');
      summaryBlocks.forEach(block => block.style.display = 'none');
      
      // Show the correct summary section based on selected type
      let summaryId = '';
      switch(reportType) {
        case 'חוות דעת פרטית':
          summaryId = 'summaryPrivate';
          break;
        case 'חוות דעת גלובלית':
          summaryId = 'summaryGlobal';
          break;
        case 'חוות דעת מכירה מצבו הניזוק':
          summaryId = 'summaryDamage';
          break;
        case 'חוות דעת טוטלוסט':
          summaryId = 'summaryTotalLoss';
          break;
        case 'חוות דעת אובדן להלכה':
          summaryId = 'summaryLegalLoss';
          break;
        default:
          summaryId = 'summaryPrivate';
      }
      
      // Show the selected summary section
      const selectedSummary = document.getElementById(summaryId);
      if (selectedSummary) {
        selectedSummary.style.display = 'block';
        console.log('✅ Showing summary section:', summaryId);
        
        // Populate the fields with correct data mapping
        console.log('🔄 About to call refreshSummary() from updateSummaryVisibility()');
        refreshSummary();
        console.log('✅ refreshSummary() called from updateSummaryVisibility()');
      } else {
        console.warn('⚠️ Summary section not found:', summaryId);
      }

      // Control depreciation section visibility
      const depreciationSection = document.getElementById('depreciationSection');
      if (depreciationSection) {
        const hideDepreciation = (reportType === 'חוות דעת טוטלוסט' || 
                                reportType === 'חוות דעת מכירה מצבו הניזוק' || 
                                reportType === 'חוות דעת אובדן להלכה');
        depreciationSection.style.display = hideDepreciation ? 'none' : 'block';
      }
      
      // Control differentials section visibility for special report types
      const differentialsSection = document.getElementById('differentialsSection');
      if (differentialsSection) {
        const hideDifferentials = (reportType === 'חוות דעת טוטלוסט' || 
                                 reportType === 'חוות דעת מכירה מצבו הניזוק' || 
                                 reportType === 'חוות דעת אובדן להלכה');
        if (hideDifferentials) {
          differentialsSection.style.display = 'none';
          // Also uncheck the differentials checkbox
          const differentialsCheckbox = document.getElementById('hasDifferentials');
          if (differentialsCheckbox) {
            differentialsCheckbox.checked = false;
          }
        } else {
          differentialsSection.style.display = 'block';
        }
      }
    }
    
    // Refresh summary with correct field mapping as specified
    function refreshSummary() {
      console.log('🚀 refreshSummary() CALLED!');
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // DEBUG: Check what data is available
      console.log('🔍 DEBUG calculations:', helper.calculations);
      console.log('🔍 DEBUG claims_data:', helper.claims_data);
      console.log('🔍 DEBUG depreciation:', helper.depreciation);
      console.log('🔍 DEBUG full_market_value:', helper.calculations?.full_market_value);
      console.log('🔍 DEBUG total_claim:', helper.claims_data?.total_claim);
      console.log('🔍 DEBUG globalDepValue:', helper.depreciation?.globalDepValue);
      
      // Get values from YOUR specified sources - NO FALLBACKS
      const marketValue = helper.calculations?.full_market_value || 0;
      
      let totalClaim = 0;
      if (helper.claims_data?.total_claim) {
        const claimValue = helper.claims_data.total_claim;
        totalClaim = typeof claimValue === 'string' ? 
          parseFloat(claimValue.replace(/[₪,]/g, '')) || 0 : 
          parseFloat(claimValue) || 0;
      }
      
      let depCompensation = 0;
      if (helper.depreciation?.globalDepValue) {
        const depValue = helper.depreciation.globalDepValue;
        depCompensation = typeof depValue === 'string' ? 
          parseFloat(depValue.replace(/[₪,]/g, '')) || 0 : 
          parseFloat(depValue) || 0;
      }
      
      console.log('🔄 Refreshing summary with values:', { marketValue, totalClaim, depCompensation });
      
      // Update market value fields across all variants
      const marketFields = [
        'sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 
        'sumMarketValueTotal', 'sumMarketValueLegal', 'sumMarketValuePrivate',
        'sumMarketValueDefault'
      ];
      marketFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field && marketValue > 0) {
          field.value = `₪${marketValue.toLocaleString()}`;
          console.log(`🔄 refreshSummary() set ${fieldId} = ${field.value}`);
          
          // Debug: Check if value gets cleared after 200ms
          if (fieldId === 'sumMarketValue') {
            setTimeout(() => {
              console.log(`🔍 DEBUG: sumMarketValue after 200ms = "${field.value}"`);
            }, 200);
          }
        }
      });
      
      // Update total claim fields for private and global variants
      const claimFields = [
        'sumClaim', 'sumClaimGlobal', 'sumClaimPrivate', 'sumClaimDefault'
      ];
      claimFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field && totalClaim > 0) {
          field.value = `₪${totalClaim.toLocaleString()}`;
        }
      });
      
      // Update depreciation compensation fields for private and global variants
      const depFields = [
        'depCompensation', 'sumDepreciation', 'depCompensationPrivate', 'sumDepreciationDefault'
      ];
      depFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field && depCompensation > 0) {
          field.value = `₪${depCompensation.toLocaleString()}`;
        }
      });
      
      // Calculate totals for private and global variants
      const privateTotal = totalClaim + depCompensation;
      const privateTotalFields = ['sumTotalPrivate', 'sumTotalDefault', 'sumTotalGlobal'];
      privateTotalFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field && privateTotal > 0) {
          field.value = `₪${privateTotal.toLocaleString()}`;
        }
      });
    }
    
    // Dynamic summary content based on report type
    function updateSummaryContent(reportType) {
      const summaryContent = document.querySelector('#summaryPrivate .form-grid');
      if (!summaryContent) return;
      
      // Clear existing content
      summaryContent.innerHTML = '';
      
      // Create different summary structures based on report type
      switch(reportType) {
        case 'חוות דעת פרטית':
          summaryContent.innerHTML = `
            <div><label style="color: #333;">ערך השוק של הרכב:</label><input type="text" id="sumMarketValuePrivate" style="background: white; color: #333;" readonly /></div>
            <div><label style="color: #333;">סה״כ תביעה:</label><input type="text" id="sumClaimPrivate" style="background: white; color: #333;" readonly /></div>
            <div><label style="color: #333;">פיצוי בגין ירידת ערך:</label><input type="text" id="depCompensationPrivate" style="background: white; color: #333;" readonly /></div>
            <div><label style="color: #333;">תוספות והורדות (מידע בלבד):</label><input type="text" id="adjustmentsInfoPrivate" style="background: #f0f0f0; color: #666;" readonly /></div>
          `;
          break;
          
        case 'חוות דעת גלובלית':
          summaryContent.innerHTML = `
            <div><label style="color: #333;">ערך השוק של הרכב:</label><input type="text" id="sumMarketValueGlobal" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">סה״כ תביעה:</label><input type="text" id="sumClaimGlobal" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">פיצוי בגין ירידת ערך:</label><input type="text" id="sumDepreciation" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">תוספות והורדות:</label><input type="text" id="sumAdjustments" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">סה״כ נכלל בחוות הדעת:</label><input type="text" id="sumTotalGlobalDynamic" style="background: white; color: #333;" /></div>
          `;
          
          // IMMEDIATE POPULATION FOR GLOBAL VARIANT - DIRECT FROM HELPER
          setTimeout(() => {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            
            // Market Value - from helper.calculations.full_market_value
            const marketValue = helper.calculations?.full_market_value || 0;
            const marketField = document.getElementById('sumMarketValueGlobal');
            if (marketField && marketValue > 0) {
              marketField.value = `₪${marketValue.toLocaleString()}`;
            }
            
            // Total Claim - directly from helper.claims_data.total_claim
            let totalClaim = 0;
            if (helper.claims_data?.total_claim) {
              const claimValue = helper.claims_data.total_claim;
              if (typeof claimValue === 'string') {
                totalClaim = parseFloat(claimValue.replace(/[₪,]/g, '')) || 0;
              } else {
                totalClaim = parseFloat(claimValue) || 0;
              }
            }
            const claimField = document.getElementById('sumClaimGlobal');
            if (claimField && totalClaim > 0) {
              claimField.value = `₪${totalClaim.toLocaleString()}`;
            }
            
            // Depreciation - from helper.depreciation.globalDepValue
            let depCompensation = 0;
            if (helper.depreciation?.globalDepValue) {
              const depValue = helper.depreciation.globalDepValue;
              if (typeof depValue === 'string') {
                depCompensation = parseFloat(depValue.replace(/[₪,]/g, '')) || 0;
              } else {
                depCompensation = parseFloat(depValue) || 0;
              }
            }
            const depField = document.getElementById('sumDepreciation');
            if (depField && depCompensation > 0) {
              depField.value = `₪${depCompensation.toLocaleString()}`;
            }
          }, 0);
          break;
          
        case 'חוות דעת טוטלוסט':
          summaryContent.innerHTML = `
            <div><label style="color: #333;">ערך השוק של הרכב:</label><input type="text" id="sumMarketValueTotal" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">ערך שרידי הרכב:</label><input type="text" id="sumScrapValue" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">תוספת בגין גרירה ואחסנה:</label><input type="text" id="sumTowingStorage" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">סה״כ לאחר מכירת שרידים:</label><input type="text" id="sumTotalTotalLoss" style="background: white; color: #333;" /></div>
          `;
          
          // IMMEDIATE POPULATION FOR TOTAL LOSS VARIANT
          setTimeout(() => {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = helper.calculations?.full_market_value || 0;
            const marketField = document.getElementById('sumMarketValueTotal');
            if (marketField && marketValue > 0) {
              marketField.value = `₪${marketValue.toLocaleString()}`;
            }
          }, 0);
          break;
          
        case 'חוות דעת מכירה מצבו הניזוק':
          summaryContent.innerHTML = `
            <div><label style="color: #333;">ערך השוק של הרכב:</label><input type="text" id="sumMarketValueDamage" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">ערך המכירה במצבו הניזוק:</label><input type="text" id="sumDamagedSaleValue" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">שיטת תשלום:</label><input type="text" id="paymentMethod" style="background: white; color: #333;" placeholder="מזומן, צ'ק, העברה בנקאית..." /></div>
            <div><label style="color: #333;">סה״כ לאחר מכירה:</label><input type="text" id="sumTotalDamagedSale" style="background: white; color: #333;" /></div>
          `;
          
          // IMMEDIATE POPULATION FOR DAMAGED STATE VARIANT
          setTimeout(() => {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = helper.calculations?.full_market_value || 0;
            const marketField = document.getElementById('sumMarketValueDamage');
            if (marketField && marketValue > 0) {
              marketField.value = `₪${marketValue.toLocaleString()}`;
            }
          }, 0);
          break;
          
        case 'חוות דעת אובדן להלכה':
          summaryContent.innerHTML = `
            <div><label style="color: #333;">ערך השוק של הרכב:</label><input type="text" id="sumMarketValueLegal" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">ערך שרידי הרכב:</label><input type="text" id="sumScrapValueLegal" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">סה״כ לאחר מכירת שרידים:</label><input type="text" id="sumAfterScrapLegal" style="background: white; color: #333;" /></div>
          `;
          
          // IMMEDIATE POPULATION FOR LEGAL LOSS VARIANT
          setTimeout(() => {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            
            // Market Value - from helper.calculations.full_market_value
            const marketValue = helper.calculations?.full_market_value || 0;
            const marketField = document.getElementById('sumMarketValueLegal');
            if (marketField && marketValue > 0) {
              marketField.value = `₪${marketValue.toLocaleString()}`;
            }
            
            // Check if we have depreciation value (158,901) which might be used as after scrap value
            let depCompensation = 0;
            if (helper.depreciation?.globalDepValue) {
              const depValue = helper.depreciation.globalDepValue;
              if (typeof depValue === 'string') {
                depCompensation = parseFloat(depValue.replace(/[₪,]/g, '')) || 0;
              } else {
                depCompensation = parseFloat(depValue) || 0;
              }
            }
            
            // Fill the after scrap value field
            const afterScrapField = document.getElementById('sumAfterScrapLegal');
            if (afterScrapField && depCompensation > 0) {
              afterScrapField.value = `₪${depCompensation.toLocaleString()}`;
            }
          }, 0);
          break;
          
        default:
          // Default to private report structure
          summaryContent.innerHTML = `
            <div><label style="color: #333;">ערך השוק של הרכב:</label><input type="text" id="sumMarketValueDefault" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">סה״כ תביעה:</label><input type="text" id="sumClaimDefault" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">פיצוי בגין ירידת ערך:</label><input type="text" id="sumDepreciationDefault" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">תוספות והורדות:</label><input type="text" id="sumAdjustmentsDefault" style="background: white; color: #333;" /></div>
            <div><label style="color: #333;">סה״כ נכלל בחוות הדעת:</label><input type="text" id="sumTotalDefault" style="background: white; color: #333;" /></div>
          `;
      }
      
      // Load data from helper for the new summary structure IMMEDIATELY
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Populate the global claim field with the correct value
      const sumClaimGlobal = document.getElementById('sumClaimGlobal');
      if (sumClaimGlobal && totalClaim > 0) {
        sumClaimGlobal.value = `₪${totalClaim.toLocaleString()}`;
      }
      
      // Also populate private claim field if it exists
      const sumClaimPrivate = document.getElementById('sumClaimPrivate');
      if (sumClaimPrivate && totalClaim > 0) {
        sumClaimPrivate.value = `₪${totalClaim.toLocaleString()}`;
      }
      
      // Also populate default claim field if it exists
      const sumClaimDefault = document.getElementById('sumClaimDefault');
      if (sumClaimDefault && totalClaim > 0) {
        sumClaimDefault.value = `₪${totalClaim.toLocaleString()}`;
      }
      
      // 3. AUTO-FILL DEPRECIATION - Get from helper
      let depCompensation = 0;
      if (helper.depreciation?.globalDepValue) {
        const depValue = helper.depreciation.globalDepValue;
        if (typeof depValue === 'string') {
          depCompensation = parseFloat(depValue.replace(/[₪,]/g, '')) || 0;
        } else {
          depCompensation = parseFloat(depValue) || 0;
        }
      }
      
      // Populate depreciation fields
      const sumDepreciation = document.getElementById('sumDepreciation');
      if (sumDepreciation && depCompensation > 0) {
        sumDepreciation.value = `₪${depCompensation.toLocaleString()}`;
      }
      
      const depCompensationPrivate = document.getElementById('depCompensationPrivate');
      if (depCompensationPrivate && depCompensation > 0) {
        depCompensationPrivate.value = `₪${depCompensation.toLocaleString()}`;
      }
      
      const sumDepreciationDefault = document.getElementById('sumDepreciationDefault');
      if (sumDepreciationDefault && depCompensation > 0) {
        sumDepreciationDefault.value = `₪${depCompensation.toLocaleString()}`;
      }
      
      loadSummaryFieldsFromHelper(helper);
      
      // Add event listeners immediately
      addSummaryCalculationListeners();
      
      // Calculate totals AFTER all fields are populated
      setTimeout(() => {
        calculateSummaryTotals();
      }, 100);
      
      // Re-add event listeners for newly created fields and reload values
      setTimeout(() => {
        // ENHANCED: Use targeted market value population based on current report type
        const currentReportType = document.getElementById('reportType')?.value || 'חוות דעת פרטית';
        populateMarketValueForCurrentVariant(helper, currentReportType);
        
        const paymentMethodField = document.getElementById('paymentMethod');
        if (paymentMethodField) {
          // Load saved value explicitly
          const savedPayment = helper.final_report?.summary?.paymentMethod;
          if (savedPayment) {
            paymentMethodField.value = savedPayment;
          }
          
          paymentMethodField.addEventListener('input', loadLegalText);
        }
      }, 100);
    }
    
    // ENHANCED VARIANT-SPECIFIC CALCULATION ENGINE - Based on User Mappings
    function calculateSummaryTotals() {
      try {
        console.log('🧮 Starting enhanced variant-specific calculations');
        const reportType = document.getElementById('reportType')?.value || 'חוות דעת פרטית';
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Get market value from standardized source (helper.calculations.full_market_value)
        let marketValue = helper.calculations?.full_market_value || 0;
        
        // If not available, try to get from visible fields
        if (marketValue === 0) {
          const marketFields = ['sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 'sumMarketValueTotal', 'sumMarketValueLegal'];
          for (const fieldId of marketFields) {
            const field = document.getElementById(fieldId);
            if (field && field.value) {
              marketValue = parseFloat(field.value.replace(/[₪,]/g, '')) || 0;
              break;
            }
          }
        }
        
        console.log(`💰 Market value: ₪${marketValue.toLocaleString()}`);
        
        // VARIANT-SPECIFIC CALCULATION LOGIC (Based on User Mappings)
        switch(reportType) {
          case 'חוות דעת פרטית':
            calculatePrivateReport(helper, marketValue);
            break;
            
          case 'חוות דעת גלובלית':  
            calculateGlobalReport(helper, marketValue);
            break;
            
          case 'חוות דעת טוטלוסט':
            calculateTotalLossReport(helper, marketValue);
            break;
            
          case 'חוות דעת מכירה מצבו הניזוק':
            calculateDamagedSaleReport(helper, marketValue).catch(console.error);
            break;
            
          case 'חוות דעת אובדן להלכה':
            calculateLegalLossReport(helper, marketValue);
            break;
            
          default:
            calculatePrivateReport(helper, marketValue); // Default to private
        }
        
        // Save calculations back to helper
        helper.final_report = helper.final_report || {};
        helper.final_report.summary = helper.final_report.summary || {};
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        console.log('✅ Variant-specific calculations completed');
        
      } catch (error) {
        console.error('❌ Error in calculateSummaryTotals:', error);
      }
    }
    
    // PRIVATE REPORT CALCULATION (Based on User Mapping)
    function calculatePrivateReport(helper, marketValue) {
      console.log('📊 Calculating Private Report');
      
      // Get values - simplified calculation: only Total Claim + Depreciation
      let totalClaim = 0;
      if (helper.claims_data?.total_claim) {
        totalClaim = parseFloat(String(helper.claims_data.total_claim).replace(/[₪,]/g, '')) || 0;
      }
      
      let depCompensation = 0;
      if (helper.depreciation?.globalDepValue) {
        depCompensation = parseFloat(String(helper.depreciation.globalDepValue).replace(/[₪,]/g, '')) || 0;
      } else if (helper.depreciation?.globalDep1) {
        depCompensation = parseFloat(String(helper.depreciation.globalDep1).replace(/[₪,%]/g, '')) || 0;
      }
      
      // Calculation: Total Claim + Depreciation Compensation ONLY
      const calculatedTotal = totalClaim + depCompensation;
      
      // Update UI fields - use the static field instead
      const totalField = document.getElementById('sumTotalBeforeDifferentials');
      if (totalField) {
        totalField.value = `₪${calculatedTotal.toLocaleString()}`;
        totalField.style.backgroundColor = '#e8f5e8'; // Show it's calculated
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.summary) helper.final_report.summary = {};
        helper.final_report.summary.private_total = totalField.value;
      }
      
      console.log(`Private calculation: ${totalClaim} + ${depCompensation} = ${calculatedTotal}`);
      return calculatedTotal;
    }
    
    // GLOBAL REPORT CALCULATION (Based on User Mapping)  
    function calculateGlobalReport(helper, marketValue) {
      console.log('📊 Calculating Global Report');
      
      // Get values using proper parsing like Private report
      let totalClaim = 0;
      if (helper.claims_data?.total_claim) {
        totalClaim = parseFloat(String(helper.claims_data.total_claim).replace(/[₪,]/g, '')) || 0;
      }
      
      let depCompensation = 0;
      if (helper.depreciation?.globalDepValue) {
        depCompensation = parseFloat(String(helper.depreciation.globalDepValue).replace(/[₪,]/g, '')) || 0;
      } else if (helper.depreciation?.globalDep1) {
        depCompensation = parseFloat(String(helper.depreciation.globalDep1).replace(/[₪,%]/g, '')) || 0;
      }
      
      // 1. BEFORE DIFFERENTIALS: Total Claim + Depreciation Compensation (like Private)
      const beforeDifferentials = totalClaim + depCompensation;
      
      // 2. Get total differentials value from the correct source
      let totalDifferentials = 0;
      
      // Check helper.final_report.differential (where differentials are actually saved)
      if (helper.final_report?.differential?.summary?.total_amount_with_vat) {
        totalDifferentials = parseFloat(String(helper.final_report.differential.summary.total_amount_with_vat).replace(/[₪,]/g, '')) || 0;
      }
      // Also check the alternative field name
      else if (helper.final_report?.differential?.summary?.total_with_vat) {
        totalDifferentials = parseFloat(String(helper.final_report.differential.summary.total_with_vat).replace(/[₪,]/g, '')) || 0;
      }
      // Fallback to DOM elements if helper data not available
      else {
        const totalDiffField = document.getElementById('totalDifferentialsWithVAT');
        if (totalDiffField && totalDiffField.textContent) {
          totalDifferentials = parseFloat(String(totalDiffField.textContent).replace(/[₪,]/g, '')) || 0;
        }
      }
      
      // 3. AFTER DIFFERENTIALS: Before Differentials - Total Differentials  
      const afterDifferentials = beforeDifferentials - totalDifferentials;
      
      // Update "Before Differentials" field (לפני הפרשים)
      const beforeField = document.getElementById('sumTotalGlobal');
      if (beforeField) {
        beforeField.value = `₪${beforeDifferentials.toLocaleString()}`;
        beforeField.style.backgroundColor = '#e8f5e8'; // Show it's calculated
      }
      
      
      // Update helper structure
      if (!helper.final_report) helper.final_report = {};
      if (!helper.final_report.summary) helper.final_report.summary = {};
      helper.final_report.summary.global_before_differentials = `₪${beforeDifferentials.toLocaleString()}`;
      helper.final_report.summary.global_after_differentials = `₪${afterDifferentials.toLocaleString()}`;
      
      console.log(`Global calculation: Before=${totalClaim} + ${depCompensation} = ${beforeDifferentials}, After=${beforeDifferentials} - ${totalDifferentials} = ${afterDifferentials}`);
      console.log(`Total differentials source: helper.final_report.differential.summary.total_with_vat = ${totalDifferentials}`);
      return { beforeDifferentials, afterDifferentials };
    }
    
    // FIELD VALUE HELPER WITH RETRY MECHANISM AND HELPER FALLBACK
    function getFieldValueWithRetry(fieldId, maxRetries = 3, delayMs = 100) {
      return new Promise((resolve) => {
        let attempts = 0;
        
        function attemptGetValue() {
          attempts++;
          console.log(`🔄 Attempt ${attempts}/${maxRetries} to get value for ${fieldId}`);
          
          const field = document.getElementById(fieldId);
          console.log(`🔍 Field check - exists: ${!!field}, hasValue: ${!!(field && field.value)}, value: "${field?.value}"`);
          
          if (field && field.value && field.value.trim() !== '') {
            const rawValue = field.value || '';
            const cleanValue = rawValue.replace(/[₪,]/g, '');
            const parsedValue = parseFloat(cleanValue) || 0;
            if (parsedValue > 0) {
              console.log(`✅ Successfully got ${fieldId} DOM value: ${parsedValue}`);
              resolve(parsedValue);
              return;
            }
          }
          
          if (attempts < maxRetries) {
            console.log(`⏳ Retrying ${fieldId} in ${delayMs}ms...`);
            setTimeout(attemptGetValue, delayMs);
          } else {
            // Final fallback: try to get value from helper data
            console.log(`🔄 Trying helper data fallback for ${fieldId}`);
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const helperKey = getHelperMappingKey ? getHelperMappingKey(fieldId) : null;
            console.log(`🔍 Helper fallback - fieldId: ${fieldId}, helperKey: ${helperKey}`);
            
            if (helperKey && helper.final_report?.summary?.[helperKey]) {
              const helperRawValue = helper.final_report.summary[helperKey];
              const helperValue = String(helperRawValue).replace(/[₪,]/g, '');
              const parsedHelper = parseFloat(helperValue) || 0;
              console.log(`✅ Got ${fieldId} from helper fallback: raw="${helperRawValue}", clean="${helperValue}", parsed=${parsedHelper}`);
              resolve(parsedHelper);
            } else {
              console.warn(`❌ Failed to get valid value for ${fieldId} after ${maxRetries} attempts and helper fallback`);
              console.log(`🔍 Helper debug - helperKey exists: ${!!helperKey}, helper.final_report exists: ${!!helper.final_report}, helper.final_report.summary exists: ${!!helper.final_report?.summary}`);
              if (helperKey && helper.final_report?.summary) {
                console.log(`🔍 Available helper keys: ${Object.keys(helper.final_report.summary)}`);
              }
              resolve(0);
            }
          }
        }
        
        attemptGetValue();
      });
    }
    
    // TEST FUNCTION FOR FIELD VALUE READING FIX
    async function testFieldValueReading() {
      console.log('🧪 Testing field value reading fix...');
      
      // Test the retry mechanism
      const testValue = await getFieldValueWithRetry('saleValueDamage');
      console.log(`🧪 Test result: saleValueDamage = ${testValue}`);
      
      // Test helper data access
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const helperValue = helper.final_report?.summary?.sale_value_damaged;
      console.log(`🧪 Helper data: helper.final_report.summary.sale_value_damaged = ${helperValue}`);
      
      // Test DOM element access
      const field = document.getElementById('saleValueDamage');
      console.log(`🧪 DOM element: exists=${!!field}, value="${field?.value}", type="${field?.type}"`);
      
      return { testValue, helperValue, domExists: !!field };
    }
    
    // Expose test function globally for debugging
    window.testFieldValueReading = testFieldValueReading;
    
    // DAMAGED SALE REPORT CALCULATION (Based on User Mapping) - ASYNC WITH RETRY
    async function calculateDamagedSaleReport(helper, marketValue) {
      console.log('📊 Calculating Damaged Sale Report');
      
      // 1. Auto-populate market value for Damaged Sale variant
      const marketValueField = document.getElementById('sumMarketValueDamage');
      if (marketValueField) {
        marketValueField.value = `₪${marketValue.toLocaleString()}`;
        marketValueField.style.backgroundColor = '#e8f5e8'; // Show it's auto-populated
        if (!helper.final_report) helper.final_report = {};
        if (!helper.final_report.summary) helper.final_report.summary = {};
        helper.final_report.summary.market_value_damage = marketValueField.value;
      }
      
      // 2. Get sale value from manual input with retry mechanism - ENHANCED WITH VALIDATION
      console.log('🔍 Starting field value retrieval for saleValueDamage');
      const saleValue = await getFieldValueWithRetry('saleValueDamage');
      console.log(`📋 Final sale value used in calculation: ${saleValue}`);
      
      // 3. Calculation: Market Value - Sale Value (from user mapping)
      const calculatedTotal = marketValue - saleValue;
      
      // 4. Update total field
      const totalField = document.getElementById('afterSaleDamage');
      if (totalField) {
        totalField.value = `₪${calculatedTotal.toLocaleString()}`;
        totalField.style.backgroundColor = '#e8f5e8'; // Show it's calculated
        helper.final_report.summary.total_after_sale_damage = totalField.value;
      }
      
      console.log(`Damage sale calculation: Market Value=${marketValue}, Sale Value=${saleValue}, Total=${calculatedTotal}`);
      return calculatedTotal;
    }
    
    // TOTAL LOSS REPORT CALCULATION (Based on User Mapping)
    function calculateTotalLossReport(helper, marketValue) {
      console.log('📊 Calculating Total Loss Report');
      
      // Get manual input values (user specified as manual inputs)
      const salvageField = document.getElementById('salvageValueTotal');
      const storageField = document.getElementById('storageValueTotal');
      
      const salvageValue = salvageField ? parseFloat(salvageField.value.replace(/[₪,]/g, '') || '0') : 0;
      const storageValue = storageField ? parseFloat(storageField.value.replace(/[₪,]/g, '') || '0') : 0;
      
      // Calculation: Market Value - Salvage + Storage/Towing (from user mapping)
      const calculatedTotal = marketValue - salvageValue + storageValue;
      
      // Update UI fields
      const totalField = document.getElementById('afterSaleTotal');
      if (totalField) {
        totalField.value = `₪${calculatedTotal.toLocaleString()}`;
        helper.final_report.summary.total_after_salvage_total = totalField.value;
      }
      
      console.log(`Total loss calculation: ${marketValue} - ${salvageValue} + ${storageValue} = ${calculatedTotal}`);
    }
    
    // LEGAL LOSS REPORT CALCULATION (Based on User Mapping)
    function calculateLegalLossReport(helper, marketValue) {
      console.log('📊 Calculating Legal Loss Report');
      
      // Get salvage value from manual input (user specified as manual)
      const salvageField = document.getElementById('salvageValueLegal');
      const salvageValue = salvageField ? parseFloat(salvageField.value.replace(/[₪,]/g, '') || '0') : 0;
      
      // Calculation: Market Value - Salvage Value (from user mapping)
      const calculatedTotal = marketValue - salvageValue;
      
      // Update UI fields
      const totalField = document.getElementById('afterSaleLegal');
      if (totalField) {
        totalField.value = `₪${calculatedTotal.toLocaleString()}`;
        helper.final_report.summary.total_after_salvage_legal = totalField.value;
      }
      
      console.log(`Legal loss calculation: ${marketValue} - ${salvageValue} = ${calculatedTotal}`);
    }
    
    // ENHANCED MANUAL INPUT FIELD LISTENERS - Real-time persistence and calculations
    function addManualInputFieldListeners() {
      console.log('🔗 Setting up enhanced manual input field listeners');
      
      // Manual input fields for all 5 report variants
      const manualInputFields = [
        // Damaged Sale variant
        'saleValueDamage',
        
        // Total Loss variant
        'salvageValueTotal',
        'storageValueTotal', 
        
        // Legal Loss variant
        'salvageValueLegal',
        
        // Common fields that might be manually adjusted
        'salvageValue'
      ];
      
      // Add listeners to all manual input fields
      manualInputFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field) {
          // Input event for real-time updates
          field.addEventListener('input', function() {
            console.log(`📝 Manual field change: ${fieldId} = ${this.value}`);
            
            // Update helper immediately using comprehensive mapping
            updateHelperFromManualField(fieldId, this.value);
            
            // Trigger real-time calculations
            calculateSummaryTotals();
          });
          
          // Change event for when user finishes editing
          field.addEventListener('change', function() {
            console.log(`✅ Manual field completed: ${fieldId} = ${this.value}`);
            
            // Save to sessionStorage
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            sessionStorage.setItem('helper', JSON.stringify(helper));
          });
          
          // Focus/blur events for user experience
          field.addEventListener('focus', function() {
            this.style.borderColor = '#007bff';
            this.style.boxShadow = '0 0 0 0.2rem rgba(0, 123, 255, 0.25)';
          });
          
          field.addEventListener('blur', function() {
            this.style.borderColor = '';
            this.style.boxShadow = '';
          });
          
          console.log(`✅ Listeners added to manual field: ${fieldId}`);
        }
      });
    }
    
    // Update helper from manual field using comprehensive mapping
    function updateHelperFromManualField(fieldId, value) {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      helper.final_report = helper.final_report || {};
      helper.final_report.summary = helper.final_report.summary || {};
      
      // Get the helper key using our comprehensive mapping
      const mappingKey = getHelperMappingKey(fieldId);
      if (mappingKey) {
        helper.final_report.summary[mappingKey] = value;
        console.log(`📊 Updated helper: ${mappingKey} = ${value}`);
        
        // Update window.helper for immediate access
        window.helper = helper;
      } else {
        console.warn(`⚠️ No mapping found for manual field: ${fieldId}`);
      }
    }
    
    // Real-time field synchronization across all variants
    function synchronizeSummaryFields() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Auto-populate fields that should sync across variants
      const marketValue = helper.calculations?.full_market_value || 0;
      if (marketValue > 0) {
        const marketValueFields = ['sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 'sumMarketValueTotal', 'sumMarketValueLegal'];
        marketValueFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field && !field.value) { // Only update if empty
            field.value = `₪${marketValue.toLocaleString()}`;
          }
        });
      }
    }
    
    // CRITICAL FIX: Initialize Summary Fields and Manual Inputs
    function initializeSummaryFieldsFix() {
      console.log('🚨 CRITICAL FIX: Initializing summary fields and manual inputs');
      
      try {
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // TASK 1: Fix market value auto-population - Direct mapping from calculations.full_market_value
        const marketValue = helper.calculations?.full_market_value || 0;
        
        if (marketValue > 0) {
          console.log(`💰 Found market value: ₪${marketValue.toLocaleString()} (source: ${
            helper.calculations?.full_market_value ? 'calculations.full_market_value' :
            helper.valuation?.calculations?.full_price?.total ? 'valuation.calculations.full_price.total' :
            'levi_report.final_price'
          })`);
          
          // Populate ALL market value fields across variants
          const allMarketFields = [
            'sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 
            'sumMarketValueTotal', 'sumMarketValueLegal', 'sumMarketValuePrivate',
            'sumMarketValueDefault'
          ];
          
          allMarketFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
              field.value = `₪${marketValue.toLocaleString()}`;
              field.style.backgroundColor = '#e8f5e8'; // Show it's auto-populated
              console.log(`✅ Populated ${fieldId} with ₪${marketValue.toLocaleString()}`);
            }
          });
          
          // Update helper structure using consolidated key
          if (!helper.final_report) helper.final_report = {};
          if (!helper.final_report.summary) helper.final_report.summary = {};
          helper.final_report.summary.market_value = `₪${marketValue.toLocaleString()}`;
          
        } else {
          console.warn('⚠️ No market value found in helper');
        }
        
        // TASK 2: Fix Total Claim field population for ALL variants
        // Extract numeric value from total_claim which may be formatted
        let totalClaim = 0;
        if (helper.claims_data?.total_claim) {
          totalClaim = parseFloat(String(helper.claims_data.total_claim).replace(/[₪,]/g, '')) || 0;
        } else if (helper.damage_centers_summary?.total_cost) {
          totalClaim = parseFloat(String(helper.damage_centers_summary.total_cost).replace(/[₪,]/g, '')) || 0;
        } else if (helper.calculations?.total_damage) {
          totalClaim = parseFloat(String(helper.calculations.total_damage).replace(/[₪,]/g, '')) || 0;
        } else if (helper.damage_assessment?.totals?.Total_with_VAT) {
          totalClaim = parseFloat(String(helper.damage_assessment.totals.Total_with_VAT).replace(/[₪,]/g, '')) || 0;
        }
        
        if (totalClaim > 0) {
          console.log(`💰 Found total claim: ₪${totalClaim.toLocaleString()}`);
          
          // Populate ALL total claim fields across variants  
          const allClaimFields = [
            'sumClaim',          // Static Private report
            'sumClaimPrivate',   // Dynamic Private report  
            'sumClaimGlobal',    // Dynamic Global report (FIXED)
            'sumClaimDefault'    // Dynamic Default report
          ];
          
          allClaimFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
              field.value = `₪${totalClaim.toLocaleString()}`;
              field.style.backgroundColor = '#e8f5e8'; // Show it's auto-populated
              console.log(`✅ Populated ${fieldId} with ₪${totalClaim.toLocaleString()}`);
            } else {
              // Field doesn't exist - this is normal for variant-specific fields
            }
          });
          
          // Update helper structure using consolidated key
          if (!helper.final_report) helper.final_report = {};
          if (!helper.final_report.summary) helper.final_report.summary = {};
          helper.final_report.summary.total_claim = `₪${totalClaim.toLocaleString()}`;
          
        } else {
          console.warn('⚠️ No total claim found in helper');
        }
        
        // TASK 3: Fix Depreciation Compensation field population for ALL variants
        // Extract numeric value from globalDep1 which contains formatted value like "1,972₪"
        let depCompensation = 0;
        if (helper.depreciation?.globalDepValue) {
          depCompensation = parseFloat(String(helper.depreciation.globalDepValue).replace(/[₪,]/g, '')) || 0;
        } else if (helper.depreciation?.globalDep1) {
          depCompensation = parseFloat(String(helper.depreciation.globalDep1).replace(/[₪,%]/g, '')) || 0;
        } else if (helper.depreciation?.total_compensation) {
          depCompensation = parseFloat(String(helper.depreciation.total_compensation).replace(/[₪,]/g, '')) || 0;
        }
        
        if (depCompensation > 0) {
          console.log(`💰 Found depreciation compensation: ₪${depCompensation.toLocaleString()}`);
          
          // Populate ALL depreciation compensation fields across variants  
          const allDepFields = [
            'depCompensation',        // Static Private report
            'depCompensationPrivate', // Dynamic Private report  
            'depCompensationGlobal',  // Global report
            'sumDepreciation',        // Global dynamic report
            'sumDepreciationDefault'  // Default report
          ];
          
          allDepFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
              field.value = `₪${depCompensation.toLocaleString()}`;
              field.style.backgroundColor = '#e8f5e8'; // Show it's auto-populated
              console.log(`✅ Populated ${fieldId} with ₪${depCompensation.toLocaleString()}`);
            } else {
              // Field doesn't exist - this is normal for variant-specific fields
            }
          });
          
          // Update helper structure using consolidated key
          if (!helper.final_report) helper.final_report = {};
          if (!helper.final_report.summary) helper.final_report.summary = {};
          helper.final_report.summary.depreciation_compensation = `₪${depCompensation.toLocaleString()}`;
          
        } else {
          console.warn('⚠️ No depreciation compensation found in helper');
        }
        
        // TASK 4: Ensure manual input fields are enabled and working
        const manualInputFields = [
          'saleValueDamage',    // ערך המכירה במצבו הניזוק
          'salvageValueTotal',  // ערך שרידי הרכב (Total Loss)
          'salvageValueLegal',  // ערך שרידי הרכב (Legal Loss)
          'storageValueTotal',  // תוספת גרירה ואחסנה
          'salvageValue'        // General salvage value
        ];
        
        manualInputFields.forEach(fieldId => {
          const field = document.getElementById(fieldId);
          if (field) {
            console.log(`🔧 Processing manual field: ${fieldId}`, field);
            
            // Remove any readonly attributes
            field.removeAttribute('readonly');
            field.removeAttribute('disabled');
            
            // Ensure the field is editable
            field.style.backgroundColor = 'white';
            field.style.color = '#333';
            field.style.cursor = 'text';
            field.contentEditable = false; // Fix: contentEditable should be false for input elements
            
            // Ensure proper input attributes
            field.type = 'text';
            field.style.pointerEvents = 'auto';
            field.readOnly = false;
            
            // Add placeholder if empty
            if (!field.placeholder) {
              field.placeholder = 'הזן ערך...';
            }
            
            // Test typing capability
            if (!field.hasAttribute('data-typing-enabled')) {
              field.setAttribute('data-typing-enabled', 'true');
              
              // Test if field accepts input
              setTimeout(() => {
                field.focus();
                field.value = 'test';
                if (field.value === 'test') {
                  field.value = ''; // Clear test
                  console.log(`✅ ${fieldId} accepts input successfully`);
                } else {
                  console.error(`❌ ${fieldId} CANNOT accept input - investigating...`);
                  // Force clear all potential blockers
                  field.removeAttribute('readonly');
                  field.removeAttribute('disabled'); 
                  field.readOnly = false;
                  field.disabled = false;
                  field.style.pointerEvents = 'auto';
                  field.style.userSelect = 'text';
                  field.contentEditable = false;
                }
              }, 100);
              
              // Add enhanced event listeners
              field.addEventListener('input', function(e) {
                console.log(`📝 ${fieldId} input: ${e.target.value}`);
                updateHelperFromManualField(fieldId, e.target.value);
                calculateSummaryTotals();
                
                // Trigger Damaged Sale calculation if this is the sale value field
                if (fieldId === 'saleValueDamage') {
                  const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[₪,]/g, '')) || 0;
                  calculateDamagedSaleReport(helper, marketValue).catch(console.error);
                }
              });
              
              field.addEventListener('focus', function(e) {
                console.log(`🎯 ${fieldId} focused`);
                e.target.style.borderColor = '#007bff';
                e.target.style.boxShadow = '0 0 0 0.2rem rgba(0, 123, 255, 0.25)';
              });
              
              field.addEventListener('blur', function(e) {
                e.target.style.borderColor = '';
                e.target.style.boxShadow = '';
                console.log(`💾 ${fieldId} saved: ${e.target.value}`);
              });
              
              console.log(`✅ Manual input field enabled: ${fieldId}`);
            }
          } else {
            // Field doesn't exist - this is normal for variant-specific fields
          }
        });
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        // Trigger calculations and private report total calculation
        setTimeout(() => {
          calculateSummaryTotals();
          
          // NOTE: Removed all duplicate calculation function calls to prevent overrides
          // All calculations are now handled centrally by calculateSummaryTotals() based on selected report type
          // This prevents race conditions and duplicate calculations that were overriding correct values
        }, 500);
        
        console.log('✅ CRITICAL FIX: Summary fields initialization completed');
        
      } catch (error) {
        console.error('❌ CRITICAL FIX ERROR:', error);
      }
    }
    
    // HELPER DATA PERSISTENCE SAFEGUARDS
    function initializeHelperDataSafeguards() {
      console.log('🛡️ Initializing helper data persistence safeguards');
      
      try {
        // Create backup of helper data every time it changes
        const originalSetItem = sessionStorage.setItem;
        sessionStorage.setItem = function(key, value) {
          if (key === 'helper') {
            try {
              const helperData = JSON.parse(value);
              if (helperData && Object.keys(helperData).length > 0) {
                // Create backup with timestamp
                const backupKey = `helper_backup_${Date.now()}`;
                sessionStorage.setItem(backupKey, value);
                
                // Keep only last 3 backups
                const backupKeys = [];
                for (let i = 0; i < sessionStorage.length; i++) {
                  const storageKey = sessionStorage.key(i);
                  if (storageKey && storageKey.startsWith('helper_backup_')) {
                    backupKeys.push(storageKey);
                  }
                }
                
                // Sort by timestamp and remove old backups
                backupKeys.sort().slice(0, -3).forEach(oldBackup => {
                  sessionStorage.removeItem(oldBackup);
                });
                
                console.log('💾 Helper backup created:', backupKey);
              }
            } catch (e) {
              console.warn('⚠️ Could not backup helper data:', e);
            }
          }
          
          // Call original setItem
          return originalSetItem.call(this, key, value);
        };
        
        // Recovery function
        window.recoverHelperData = function() {
          const backupKeys = [];
          for (let i = 0; i < sessionStorage.length; i++) {
            const key = sessionStorage.key(i);
            if (key && key.startsWith('helper_backup_')) {
              backupKeys.push(key);
            }
          }
          
          if (backupKeys.length > 0) {
            // Get the most recent backup
            const latestBackup = backupKeys.sort().pop();
            const backupData = sessionStorage.getItem(latestBackup);
            
            if (backupData) {
              sessionStorage.setItem('helper', backupData);
              window.helper = JSON.parse(backupData);
              console.log('🔄 Helper data recovered from backup:', latestBackup);
              
              // Refresh the page to reload the data
              if (confirm('Helper data recovered! Refresh page to see changes?')) {
                location.reload();
              }
              return true;
            }
          }
          
          console.warn('⚠️ No helper backup found');
          return false;
        };
        
        // Add recovery button to console
        console.log('🆘 To recover helper data, run: window.recoverHelperData()');
        
        // Check if helper data is empty and offer recovery
        const currentHelper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        const helperKeys = Object.keys(currentHelper);
        
        if (helperKeys.length < 3) { // Helper seems empty or minimal
          console.warn('⚠️ Helper data appears to be cleared or minimal');
          console.log('🔍 Current helper keys:', helperKeys);
          
          // Try to recover automatically
          setTimeout(() => {
            if (window.recoverHelperData) {
              console.log('🚨 Attempting automatic helper data recovery...');
              window.recoverHelperData();
            }
          }, 1000);
        }
        
        console.log('✅ Helper data safeguards initialized');
        
      } catch (error) {
        console.error('❌ Error initializing helper safeguards:', error);
      }
    }
    
    // COMPREHENSIVE TESTING SYSTEM FOR ALL 5 REPORT VARIANTS
    function testSummaryFieldMappings() {
      console.log('🧪 Starting comprehensive summary field mapping tests...');
      
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const testResults = {
        passed: 0,
        failed: 0,
        details: []
      };
      
      // Test 1: Comprehensive Mapping Dictionary
      const mappingTest = testComprehensiveMapping();
      testResults.details.push(mappingTest);
      mappingTest.passed ? testResults.passed++ : testResults.failed++;
      
      // Test 2: Auto-population System
      const autoPopTest = testAutoPopulation();
      testResults.details.push(autoPopTest);
      autoPopTest.passed ? testResults.passed++ : testResults.failed++;
      
      // Test 3: Manual Input Persistence
      const persistenceTest = testManualInputPersistence();
      testResults.details.push(persistenceTest);
      persistenceTest.passed ? testResults.passed++ : testResults.failed++;
      
      // Test 4: Variant-specific Calculations
      const calcTest = testVariantCalculations();
      testResults.details.push(calcTest);
      calcTest.passed ? testResults.passed++ : testResults.failed++;
      
      // Test 5: Helper Structure Integrity
      const helperTest = testHelperStructure();
      testResults.details.push(helperTest);
      helperTest.passed ? testResults.passed++ : testResults.failed++;
      
      // Display results
      console.log(`🧪 Test Results: ${testResults.passed} passed, ${testResults.failed} failed`);
      testResults.details.forEach(test => {
        const icon = test.passed ? '✅' : '❌';
        console.log(`${icon} ${test.name}: ${test.message}`);
      });
      
      return testResults;
    }
    
    function testComprehensiveMapping() {
      const requiredFields = [
        'sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 
        'sumMarketValueTotal', 'sumMarketValueLegal', 'saleValueDamage',
        'salvageValueTotal', 'storageValueTotal', 'salvageValueLegal'
      ];
      
      const missingMappings = requiredFields.filter(fieldId => !getHelperMappingKey(fieldId));
      
      return {
        name: 'Comprehensive Mapping Dictionary',
        passed: missingMappings.length === 0,
        message: missingMappings.length === 0 ? 
          'All fields have proper mappings' : 
          `Missing mappings for: ${missingMappings.join(', ')}`
      };
    }
    
    function testAutoPopulation() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const marketValue = helper.calculations?.full_market_value || 0;
      
      if (marketValue === 0) {
        return {
          name: 'Auto-population System',
          passed: false,
          message: 'No market value found in helper.calculations.full_market_value'
        };
      }
      
      const marketFields = document.querySelectorAll('#sumMarketValue, #sumMarketValueGlobal');
      const populatedFields = Array.from(marketFields).filter(field => field.value.includes(marketValue.toLocaleString()));
      
      return {
        name: 'Auto-population System',
        passed: populatedFields.length > 0,
        message: populatedFields.length > 0 ? 
          'Market value fields are properly auto-populated' :
          'Market value auto-population failed'
      };
    }
    
    function testManualInputPersistence() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const summaryExists = helper.final_report?.summary;
      
      if (!summaryExists) {
        return {
          name: 'Manual Input Persistence',
          passed: false,
          message: 'helper.final_report.summary structure not initialized'
        };
      }
      
      // Test if manual fields have mappings in helper
      const manualFields = ['saleValueDamage', 'paymentMethod', 'salvageValueTotal', 'storageValueTotal', 'salvageValueLegal'];
      const mappedFields = manualFields.filter(fieldId => {
        const key = getHelperMappingKey(fieldId);
        return key && helper.final_report.summary.hasOwnProperty(key);
      });
      
      return {
        name: 'Manual Input Persistence',
        passed: mappedFields.length >= manualFields.length / 2,
        message: `${mappedFields.length}/${manualFields.length} manual fields properly mapped`
      };
    }
    
    function testVariantCalculations() {
      // Test calculation functions exist
      const calcFunctions = [
        'calculatePrivateReport',
        'calculateGlobalReport', 
        'calculateDamagedSaleReport',
        'calculateTotalLossReport',
        'calculateLegalLossReport'
      ];
      
      const existingFunctions = calcFunctions.filter(funcName => typeof window[funcName] === 'function');
      
      return {
        name: 'Variant-specific Calculations',
        passed: existingFunctions.length === calcFunctions.length,
        message: `${existingFunctions.length}/${calcFunctions.length} calculation functions available`
      };
    }
    
    function testHelperStructure() {
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      const requiredStructures = [
        'final_report',
        'final_report.summary'
      ];
      
      const existingStructures = requiredStructures.filter(path => {
        return path.split('.').reduce((obj, key) => obj && obj[key], helper) !== undefined;
      });
      
      return {
        name: 'Helper Structure Integrity',
        passed: existingStructures.length === requiredStructures.length,
        message: `${existingStructures.length}/${requiredStructures.length} required structures present`
      };
    }
    
    // Depreciation functionality 
    function addDepreciationRow() {
      alert('הוסף שורת ירידת ערך - יטען עם מודול depreciation_module.js');
    }
    
    // Real differential row functionality
    function createDifferentialRow(data = {}) {
      const div = document.createElement('div');
      div.className = 'differential-row';
      div.style.marginBottom = '20px';
      div.style.padding = '15px';
      div.style.background = '#f8fafc';
      div.style.borderRadius = '8px';
      div.style.border = '1px solid #e2e8f0';
      
      // Get VAT rate based on company selection
      const vatRate = getVatRate();
      const amount = data.amount || 0;
      const vat = Math.round(amount * vatRate);
      const totalWithVat = amount + vat;
      
      console.log('🔍 Creating differential row with data:', data);
      
      // Get available damage centers for dropdown
      const helper = window.helper || {};
      const damageCenters = helper.centers || [];
      
      let damageCenterOptions = '<option value="">בחר מוקד נזק</option>';
      damageCenters.forEach((center, index) => {
        const centerNumber = center['Damage center Number'] || (index + 1);
        const centerLocation = center.Location || `מוקד ${centerNumber}`;
        const isSelected = data.damage_center === centerNumber ? 'selected' : '';
        damageCenterOptions += `<option value="${centerNumber}" ${isSelected}>מוקד ${centerNumber} - ${centerLocation}</option>`;
      });

      div.innerHTML = `
        <!-- Row 1: Details (4 fields) - Responsive -->
        <div class="diff-details-row" style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px;">
          <div>
            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">חלק</label>
            <input type="text" class="diff-part" placeholder="הזן חלק" value="${data.part || ''}" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px;">
          </div>
          <div>
            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">מוקד נזק</label>
            <select class="diff-damage-center" onchange="updateDifferentialCalculations()" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px;">
              ${damageCenterOptions}
            </select>
          </div>
          <div>
            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">מהות ההפרש</label>
            <select class="diff-nature-dropdown" onchange="toggleNatureOtherField(this)" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px; margin-bottom: 5px;">
              <option value="">בחר מהות</option>
              <option value="parts" ${data.nature === 'parts' ? 'selected' : ''}>חלקים</option>
              <option value="works" ${data.nature === 'works' ? 'selected' : ''}>עבודות</option>
              <option value="repairs" ${data.nature === 'repairs' ? 'selected' : ''}>תיקונים</option>
              <option value="other" ${data.nature && !['parts', 'works', 'repairs'].includes(data.nature) ? 'selected' : ''}>אחר</option>
            </select>
            <input type="text" class="diff-nature-other" placeholder="פרט מהות אחרת" value="${data.nature && !['parts', 'works', 'repairs'].includes(data.nature) ? data.nature : ''}" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px; display: ${data.nature && !['parts', 'works', 'repairs'].includes(data.nature) ? 'block' : 'none'};">
            <input type="hidden" class="diff-nature" value="${data.nature || ''}">
          </div>
          <div>
            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">סיבת ההפרש</label>
            <input type="text" class="diff-reason" placeholder="הזן סיבה" value="${data.reason || ''}" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px;">
          </div>
        </div>
        
        <!-- Row 2: Costs (3 fields) - Responsive -->
        <div class="diff-costs-row" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
          <div>
            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">מחיר ללא מע״מ</label>
            <input type="number" class="diff-amount" placeholder="0" value="${amount}" onchange="updateDifferentialCalculations()" style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; font-size:14px;">
          </div>
          <div>
            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">ערך מע״מ</label>
            <input type="number" class="diff-vat" placeholder="0" value="${vat}" readonly style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; background:#f1f5f9; font-size:14px; color:#64748b;">
          </div>
          <div>
            <label style="display: block; font-size: 12px; color: #64748b; margin-bottom: 4px;">מחיר עם מע״מ</label>
            <input type="number" class="diff-total" placeholder="0" value="${totalWithVat}" readonly style="width:100%; padding:10px; border-radius:6px; border:1px solid #cbd5e1; background:#f1f5f9; font-size:14px; color:#64748b;">
          </div>
        </div>
        
        <!-- Remove button -->
        <div style="text-align: center; margin-top: 15px;">
          <button type="button" class="btn-remove" style="background:#ef4444; color:white; border:none; padding:8px 16px; border-radius:6px; cursor:pointer; font-size:14px; transition: all 0.2s;">🗑️ הסר הפרש</button>
        </div>
        
        <!-- Mobile-specific CSS -->
        <style>
          @media (max-width: 768px) {
            .diff-details-row, .diff-costs-row {
              grid-template-columns: 1fr !important;
              gap: 15px !important;
            }
            .differential-row {
              padding: 12px !important;
              margin-bottom: 15px !important;
            }
            .diff-details-row input, .diff-costs-row input {
              padding: 12px !important;
              font-size: 16px !important; /* Prevents zoom on iOS */
            }
          }
          
          @media (max-width: 480px) {
            .diff-details-row, .diff-costs-row {
              gap: 10px !important;
            }
            .differential-row {
              padding: 10px !important;
            }
          }
        </style>
      `;
      
      // Add event listeners
      const amountInput = div.querySelector('.diff-amount');
      const vatInput = div.querySelector('.diff-vat');
      const totalInput = div.querySelector('.diff-total');
      const removeBtn = div.querySelector('.btn-remove');
      
      amountInput.addEventListener('input', function() {
        const newAmount = parseFloat(this.value) || 0;
        const newVat = Math.round(newAmount * vatRate);
        const newTotal = newAmount + newVat;
        
        vatInput.value = newVat;
        totalInput.value = newTotal;
        
        // Recalculate summary and auto-save
        updateDifferentialsSummary();
        saveDifferentialsToHelper();
      });
      
      // Add auto-save to text inputs with delay to ensure data is captured
      setTimeout(() => {
        const partField = div.querySelector('.diff-part');
        const damageCenterDropdown = div.querySelector('.diff-damage-center');
        const natureDropdown = div.querySelector('.diff-nature-dropdown');
        const natureOtherField = div.querySelector('.diff-nature-other');
        const reasonField = div.querySelector('.diff-reason');
        
        console.log('🔗 ATTACHING EVENT LISTENERS:', {
          partField: !!partField,
          damageCenterDropdown: !!damageCenterDropdown,
          natureDropdown: !!natureDropdown,
          natureOtherField: !!natureOtherField,
          reasonField: !!reasonField
        });
        
        if (partField) {
          partField.addEventListener('input', (e) => {
            console.log('🔥 PART INPUT EVENT:', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (damageCenterDropdown) {
          damageCenterDropdown.addEventListener('change', (e) => {
            console.log('🔥 DAMAGE CENTER DROPDOWN EVENT:', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (natureDropdown) {
          natureDropdown.addEventListener('change', (e) => {
            console.log('🔥 NATURE DROPDOWN EVENT:', e.target.value);
            toggleNatureOtherField(e.target);
          });
        }
        
        if (natureOtherField) {
          natureOtherField.addEventListener('input', (e) => {
            console.log('🔥 NATURE OTHER INPUT EVENT:', e.target.value);
            const hiddenField = div.querySelector('.diff-nature');
            if (hiddenField) hiddenField.value = e.target.value;
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (reasonField) {
          reasonField.addEventListener('input', (e) => {
            console.log('🔥 REASON INPUT EVENT:', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
      }, 50);
      
      removeBtn.addEventListener('click', function() {
        div.remove();
        updateDifferentialsSummary();
        setTimeout(saveDifferentialsToHelper, 100);
      });
      
      return div;
    }
    
    function toggleDifferentialsTable() {
      console.log('🔄 TOGGLE DIFFERENTIALS TABLE CALLED');
      const checkbox = document.getElementById('hasDifferentials');
      const table = document.getElementById('differentialsTable');
      const summary = document.getElementById('differentialsSummary');
      const saveSection = document.getElementById('differentialsSaveSection');
      
      console.log('📋 Checkbox state:', checkbox?.checked);
      
      // IMMEDIATE HELPER UPDATE - sync checkbox state to helper
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (!helper.final_report) helper.final_report = {};
      if (!helper.final_report.differential) helper.final_report.differential = {};
      
      helper.final_report.differential.has_differentials = checkbox?.checked || false;
      sessionStorage.setItem('helper', JSON.stringify(helper));
      console.log('💾 Updated helper.final_report.differential.has_differentials =', checkbox?.checked);
      
      if (checkbox?.checked) {
        if (table) table.style.display = 'block';
        if (summary) summary.style.display = 'block';
        if (saveSection) saveSection.style.display = 'block';
        // Add first row automatically
        const container = document.getElementById('differentialsRows');
        if (container && container.children.length === 0) {
          addDifferentialRow();
        }
      } else {
        if (table) table.style.display = 'none';
        if (summary) summary.style.display = 'none';
        if (saveSection) saveSection.style.display = 'none';
        // Clear all differential rows when hiding
        const container = document.getElementById('differentialsRows');
        if (container) {
          container.innerHTML = '';
          updateDifferentialsSummary();
        }
        // CLEAR DIFFERENTIAL DATA when unchecked
        console.log('🗑️ CLEARING DIFFERENTIAL DATA - checkbox unchecked');
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (!helper.final_report) helper.final_report = {};
        helper.final_report.differential = {
          has_differentials: false,
          items: [],
          summary: {
            total_amount_without_vat: 0,
            total_vat: 0,
            total_amount_with_vat: 0,
            currency: '₪'
          },
          last_updated: new Date().toISOString()
        };
        sessionStorage.setItem('helper', JSON.stringify(helper));
        console.log('💾 Saved unchecked differential state');
      }
      
      // Refresh container layout after toggle
      setTimeout(refreshDamageCentersContainerLayout, 200);
    }
    
    // Alias for toggleDifferentialsTable to match HTML onclick
    function toggleDifferentials() {
      return toggleDifferentialsTable();
    }
    
    
    function addDifferentialRow() {
      const container = document.getElementById('differentialsRows');
      if (container) {
        const newRow = createDifferentialRow();
        container.appendChild(newRow);
        console.log('✅ Added new differential row');
        updateDifferentialsSummary();
        setTimeout(saveDifferentialsToHelper, 100);
        
        // Force reattach event listeners to all existing rows
        setTimeout(reattachDifferentialEventListeners, 100);
      }
    }
    
    // Force reattach event listeners to all differential rows
    function reattachDifferentialEventListeners() {
      console.log('🔗 REATTACHING ALL DIFFERENTIAL EVENT LISTENERS');
      const rows = document.querySelectorAll('#differentialsRows .differential-row');
      
      rows.forEach((row, index) => {
        const partField = row.querySelector('.diff-part');
        const damageCenterDropdown = row.querySelector('.diff-damage-center');
        const natureDropdown = row.querySelector('.diff-nature-dropdown');
        const natureOtherField = row.querySelector('.diff-nature-other');
        const reasonField = row.querySelector('.diff-reason');
        
        console.log(`🔗 Row ${index} - Reattaching to:`, {
          partField: !!partField,
          damageCenterDropdown: !!damageCenterDropdown,
          natureDropdown: !!natureDropdown,
          natureOtherField: !!natureOtherField,
          reasonField: !!reasonField
        });
        
        // Remove existing listeners and add new ones
        if (partField) {
          partField.replaceWith(partField.cloneNode(true));
          const newPartField = row.querySelector('.diff-part');
          newPartField.addEventListener('input', (e) => {
            console.log('🔥 PART INPUT (REATTACHED):', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (damageCenterDropdown) {
          damageCenterDropdown.replaceWith(damageCenterDropdown.cloneNode(true));
          const newDamageCenterDropdown = row.querySelector('.diff-damage-center');
          newDamageCenterDropdown.addEventListener('change', (e) => {
            console.log('🔥 DAMAGE CENTER DROPDOWN (REATTACHED):', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (natureDropdown) {
          natureDropdown.replaceWith(natureDropdown.cloneNode(true));
          const newNatureDropdown = row.querySelector('.diff-nature-dropdown');
          newNatureDropdown.addEventListener('change', (e) => {
            console.log('🔥 NATURE DROPDOWN (REATTACHED):', e.target.value);
            toggleNatureOtherField(e.target);
          });
        }
        
        if (natureOtherField) {
          natureOtherField.replaceWith(natureOtherField.cloneNode(true));
          const newNatureOtherField = row.querySelector('.diff-nature-other');
          newNatureOtherField.addEventListener('input', (e) => {
            console.log('🔥 NATURE OTHER INPUT (REATTACHED):', e.target.value);
            const hiddenField = row.querySelector('.diff-nature');
            if (hiddenField) hiddenField.value = e.target.value;
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
        
        if (reasonField) {
          reasonField.replaceWith(reasonField.cloneNode(true));
          const newReasonField = row.querySelector('.diff-reason');
          newReasonField.addEventListener('input', (e) => {
            console.log('🔥 REASON INPUT (REATTACHED):', e.target.value);
            setTimeout(saveDifferentialsToHelper, 100);
          });
        }
      });
    }
    
    // Auto-save differential data to helper
    function saveDifferentialsToHelper() {
      console.log('🚀 SAVE DIFFERENTIALS FUNCTION CALLED!');
      const rows = document.querySelectorAll('#differentialsRows .differential-row');
      const differentialsData = [];
      let totalAmount = 0;
      let totalVat = 0;
      let totalWithVat = 0;
      
      console.log('🔍 DEBUG: Found', rows.length, 'differential rows to save');
      console.log('🔍 DEBUG: Container element:', document.querySelector('#differentialsRows'));
      
      rows.forEach((row, index) => {
        console.log(`🔍 DEBUG: Processing row ${index}:`, row);
        
        const partField = row.querySelector('.diff-part');
        const damageCenterField = row.querySelector('.diff-damage-center');
        const natureField = row.querySelector('.diff-nature');
        const reasonField = row.querySelector('.diff-reason');
        const amountField = row.querySelector('.diff-amount');
        const vatField = row.querySelector('.diff-vat');
        const totalField = row.querySelector('.diff-total');
        
        console.log(`🔍 DEBUG: Row ${index} fields found:`, {
          partField: !!partField,
          damageCenterField: !!damageCenterField,
          natureField: !!natureField,
          reasonField: !!reasonField,
          amountField: !!amountField,
          vatField: !!vatField,
          totalField: !!totalField
        });
        
        const part = partField?.value || '';
        const damage_center = damageCenterField?.value || '';
        const nature = natureField?.value || '';
        const reason = reasonField?.value || '';
        const amount = parseFloat(amountField?.value) || 0;
        const vat = parseFloat(vatField?.value) || 0;
        const total = parseFloat(totalField?.value) || 0;
        
        console.log(`🔍 DEBUG: Row ${index} values:`, {part, damage_center, nature, reason, amount, vat, total});
        console.log(`🔍 DEBUG: Row ${index} raw field values:`, {
          partRaw: partField?.value,
          damageCenterRaw: damageCenterField?.value,
          natureRaw: natureField?.value,
          reasonRaw: reasonField?.value,
          amountRaw: amountField?.value,
          vatRaw: vatField?.value,
          totalRaw: totalField?.value
        });
        
        differentialsData.push({
          id: index + 1,
          part: part,
          damage_center: damage_center,
          nature: nature,
          reason: reason,
          amount_without_vat: amount,
          vat_amount: vat,
          amount_with_vat: total
        });
        
        totalAmount += amount;
        totalVat += vat;
        totalWithVat += total;
      });
      
      // Save to helper.final_report.differential
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (!helper.final_report) helper.final_report = {};
      
      helper.final_report.differential = {
        has_differentials: document.getElementById('hasDifferentials')?.checked || false,
        items: differentialsData,
        summary: {
          total_amount_without_vat: totalAmount,
          total_vat: totalVat,
          total_amount_with_vat: totalWithVat,
          currency: '₪'
        },
        last_updated: new Date().toISOString()
      };
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // CRITICAL FIX: Also update window.helper to prevent broadcastHelperUpdate from overwriting
      if (window.helper) {
        if (!window.helper.final_report) window.helper.final_report = {};
        window.helper.final_report.differential = helper.final_report.differential;
        console.log('🔄 Updated window.helper.final_report.differential to prevent broadcast overwrite');
      }
      
      console.log('💾 Auto-saved differentials to helper:', helper.final_report.differential);
      
      // Trigger Global report recalculation if Global report is active
      setTimeout(() => {
        const sumTotalGlobalField = document.getElementById('sumTotalGlobal');
        if (sumTotalGlobalField && sumTotalGlobalField.offsetParent !== null) { // Check if visible
          const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[₪,]/g, '')) || 0;
          calculateGlobalReport(helper, marketValue);
          console.log('🔄 Triggered Global report recalculation due to differentials change');
        }
      }, 100);
      
      // Refresh damage centers container layout after differential changes
      setTimeout(refreshDamageCentersContainerLayout, 300);
    }
    
    function updateDifferentialsSummary() {
      const rows = document.querySelectorAll('#differentialsRows .differential-row');
      let totalAmount = 0;
      let totalVat = 0;
      let totalWithVat = 0;
      
      rows.forEach(row => {
        const amount = parseFloat(row.querySelector('.diff-amount').value) || 0;
        const vat = parseFloat(row.querySelector('.diff-vat').value) || 0;
        const total = parseFloat(row.querySelector('.diff-total').value) || 0;
        
        totalAmount += amount;
        totalVat += vat;
        totalWithVat += total;
      });
      
      // Update summary display if it exists
      const summarySection = document.getElementById('differentialsSummary');
      if (summarySection) {
        summarySection.style.display = rows.length > 0 ? 'block' : 'none';
        
        const totalDiffField = document.getElementById('totalDifferentials');
        const totalVatField = document.getElementById('totalVAT');
        const totalWithVatField = document.getElementById('totalDifferentialsWithVAT');
        
        if (totalDiffField) totalDiffField.textContent = `₪${totalAmount.toLocaleString()}`;
        if (totalVatField) totalVatField.textContent = `₪${totalVat.toLocaleString()}`;
        if (totalWithVatField) totalWithVatField.textContent = `₪${totalWithVat.toLocaleString()}`;
      }
      
      // Update damage centers after differential calculations
      updateDifferentialCalculations();
    }
    
    // NEW: Update differential calculations per damage center
    function updateDifferentialCalculations() {
      try {
        const helper = window.helper || {};
        const originalTotals = helper.damage_assessment?.totals || {};
        const damageCenters = helper.centers || [];
        
        // Initialize totals_after_differentials with original values
        if (!helper.damage_assessment) helper.damage_assessment = {};
        helper.damage_assessment.totals_after_differentials = {
          'Total parts': parseInt(originalTotals['Total parts'] || 0),
          'Total works': parseInt(originalTotals['Total works'] || 0),
          'Total repairs': parseInt(originalTotals['Total repairs'] || 0),
          'Other': 0,
          'Total with VAT': parseInt(originalTotals['Total with VAT'] || 0)
        };
        
        // Process each differential row
        const rows = document.querySelectorAll('#differentialsRows .differential-row');
        rows.forEach(row => {
          const damageCenterSelect = row.querySelector('.diff-damage-center');
          const natureSelect = row.querySelector('.diff-nature-dropdown');
          const amountInput = row.querySelector('.diff-amount');
          
          if (damageCenterSelect && natureSelect && amountInput) {
            const selectedCenter = damageCenterSelect.value;
            const nature = natureSelect.value;
            const amount = parseFloat(amountInput.value) || 0;
            
            if (selectedCenter && nature && amount !== 0) {
              // Apply differential to specific category
              const vatRate = getVatRate();
              const amountWithVat = Math.round(amount * (1 + vatRate));
              
              switch(nature) {
                case 'parts':
                  helper.damage_assessment.totals_after_differentials['Total parts'] += amount;
                  break;
                case 'works':
                  helper.damage_assessment.totals_after_differentials['Total works'] += amount;
                  break;
                case 'repairs':
                  helper.damage_assessment.totals_after_differentials['Total repairs'] += amount;
                  break;
                case 'other':
                  helper.damage_assessment.totals_after_differentials['Other'] += amount;
                  break;
              }
              
              // Update total with VAT
              if (nature !== 'other') {
                helper.damage_assessment.totals_after_differentials['Total with VAT'] += amountWithVat;
              } else {
                helper.damage_assessment.totals_after_differentials['Total with VAT'] += amount;
              }
            }
          }
        });
        
        // Update session storage and window.helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        window.helper = helper;
        
        // Refresh damage centers container layout
        setTimeout(refreshDamageCentersContainerLayout, 100);
        
        console.log('🔄 Updated differential calculations:', helper.damage_assessment.totals_after_differentials);
        
      } catch (error) {
        console.error('Error updating differential calculations:', error);
      }
    }
    
    // Save differentials data with user feedback
    function saveDifferentials() {
      console.log('💾 SAVE DIFFERENTIALS BUTTON CLICKED!');
      const saveButton = document.querySelector('button[onclick="saveDifferentials()"]');
      
      // Show visual feedback
      if (saveButton) {
        saveButton.style.background = '#17a2b8';
        saveButton.innerHTML = '⏳ שומר הפרשים...';
        saveButton.disabled = true;
      }
      
      // Collect all differential row data
      const rows = document.querySelectorAll('#differentialsRows .differential-row');
      const differentialsData = [];
      let totalAmount = 0;
      let totalVat = 0;
      let totalWithVat = 0;
      
      rows.forEach((row, index) => {
        const part = row.querySelector('.diff-part')?.value || '';
        const damage_center = row.querySelector('.diff-damage-center')?.value || '';
        const nature = row.querySelector('.diff-nature')?.value || '';
        const reason = row.querySelector('.diff-reason')?.value || '';
        const amount = parseFloat(row.querySelector('.diff-amount')?.value) || 0;
        const vat = parseFloat(row.querySelector('.diff-vat')?.value) || 0;
        const total = parseFloat(row.querySelector('.diff-total')?.value) || 0;
        
        differentialsData.push({
          id: index + 1,
          part: part,
          damage_center: damage_center,
          nature: nature,
          reason: reason,
          amount_without_vat: amount,
          vat_amount: vat,
          amount_with_vat: total
        });
        
        totalAmount += amount;
        totalVat += vat;
        totalWithVat += total;
      });
      
      // Save to helper.final_report.differential
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (!helper.final_report) helper.final_report = {};
      
      helper.final_report.differential = {
        has_differentials: document.getElementById('hasDifferentials')?.checked || false,
        items: differentialsData,
        summary: {
          total_amount_without_vat: totalAmount,
          total_vat: totalVat,
          total_amount_with_vat: totalWithVat,
          currency: '₪'
        },
        last_updated: new Date().toISOString()
      };
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // CRITICAL FIX: Also update window.helper to prevent broadcastHelperUpdate from overwriting
      if (window.helper) {
        if (!window.helper.final_report) window.helper.final_report = {};
        window.helper.final_report.differential = helper.final_report.differential;
        console.log('🔄 Updated window.helper.final_report.differential to prevent broadcast overwrite');
      }
      
      // Also update the legacy format for backward compatibility
      updateDifferentialsSummary();
      
      // Show success message
      console.log('✅ הפרשים saved successfully to helper.final_report.differential:', helper.final_report.differential);
      
      if (saveButton) {
        saveButton.style.background = '#28a745';
        saveButton.innerHTML = '✅ נשמר הפרשים!';
        setTimeout(() => {
          saveButton.innerHTML = 'שמור הפרשים';
          saveButton.style.background = '#28a745';
          saveButton.disabled = false;
        }, 1500);
      }
    }
    
    // Update final report fields (agreement status and company report)
    function updateFinalReportField(fieldName, value) {
      try {
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (!helper.final_report) helper.final_report = {};
        
        helper.final_report[fieldName] = value;
        
        // Save to both storage locations
        sessionStorage.setItem('helper', JSON.stringify(helper));
        localStorage.setItem('helper', JSON.stringify(helper));
        
        // Update global helper directly to avoid setNestedValue error
        if (window.helper) {
          if (!window.helper.final_report) window.helper.final_report = {};
          window.helper.final_report[fieldName] = value;
        }
        
        console.log(`✅ Final report field updated: ${fieldName} = ${value}`);
      } catch (error) {
        console.error('❌ Error updating final report field:', error);
      }
    }
    
    // Save final report configuration function
    function saveFinalReportConfiguration() {
      try {
        // Collect current form values
        const reportType = document.getElementById('reportType')?.value;
        const isCompanyClient = document.getElementById('isCompanyClient')?.value;
        const inAgreement = document.getElementById('inAgreement')?.value;
        
        // Update helper with current values - SIMPLIFIED TO AVOID setNestedValue ERROR
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (!helper.final_report) helper.final_report = {};
        
        if (reportType) helper.final_report.report_type = reportType;
        if (isCompanyClient !== undefined) helper.final_report.report_for_company = (isCompanyClient === 'yes');
        if (inAgreement !== undefined) helper.final_report.in_agreement = (inAgreement === 'yes');
        
        // Save to storage locations directly (avoid helper.js updateHelper to prevent error)
        sessionStorage.setItem('helper', JSON.stringify(helper));
        localStorage.setItem('helper', JSON.stringify(helper));
        
        // Update global helper if available (direct assignment, no updateHelper)
        if (window.helper) {
          window.helper.final_report = helper.final_report;
        }
        
        // Show success feedback
        const button = document.querySelector('button[onclick="saveFinalReportConfiguration()"]');
        const originalText = button.textContent;
        button.textContent = '✅ נשמר';
        button.style.background = '#28a745';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = '#28a745';
        }, 2000);
        
        console.log('✅ Final report configuration saved:', {
          report_type: helper.final_report.report_type,
          report_for_company: helper.final_report.report_for_company,
          in_agreement: helper.final_report.in_agreement
        });
      } catch (error) {
        console.error('❌ Error saving final report configuration:', error);
        alert('שגיאה בשמירת הגדרות הדו"ח');
      }
    }
    
    // Load differential data from helper on page load
    function loadDifferentialData() {
      // Prevent multiple loads
      if (window.differentialDataLoaded) {
        console.log('⚠️ Differential data already loaded, skipping...');
        return;
      }
      
      try {
        console.log('📖 LOADING DIFFERENTIAL DATA FROM HELPER...');
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        console.log('🔍 Checking for differential data in helper.final_report:', helper.final_report);
        const differentialData = helper.final_report?.differential;
        
        if (!differentialData) {
          console.log('📝 No differential data found in helper.final_report.differential');
          return;
        }
        
        if (!differentialData.has_differentials) {
          console.log('📝 Differential data exists but has_differentials is false:', differentialData);
          return;
        }
        
        console.log('📖 Loading differential data from helper:', differentialData);
        
        // Check the "has differentials" checkbox
        const hasDiffCheckbox = document.getElementById('hasDifferentials');
        if (hasDiffCheckbox) {
          hasDiffCheckbox.checked = differentialData.has_differentials;
          
          // MANUALLY show/hide elements WITHOUT calling toggleDifferentialsTable to avoid overwriting data
          const table = document.getElementById('differentialsTable');
          const summary = document.getElementById('differentialsSummary');
          const saveSection = document.getElementById('differentialsSaveSection');
          
          if (differentialData.has_differentials) {
            table.style.display = 'block';
            summary.style.display = 'block';
            saveSection.style.display = 'block';
          }
          
          console.log('✅ Checkbox set to:', differentialData.has_differentials, 'without triggering toggle');
        }
        
        // Load each differential item
        const container = document.getElementById('differentialsRows');
        if (container && differentialData.items && differentialData.items.length > 0) {
          console.log('📋 Loading', differentialData.items.length, 'differential items:', differentialData.items);
          
          // Clear existing rows
          container.innerHTML = '';
          
          // Add each differential item
          differentialData.items.forEach((item, index) => {
            console.log(`📝 Loading item ${index}:`, {
              part: item.part,
              nature: item.nature, 
              reason: item.reason,
              amount: item.amount_without_vat
            });
            
            const row = createDifferentialRow({
              part: item.part || '',
              nature: item.nature || '',
              reason: item.reason || '',
              amount: item.amount_without_vat || 0
            });
            container.appendChild(row);
          });
          
          // Update summary
          updateDifferentialsSummary();
          
          // CRITICAL FIX: Reattach event listeners to loaded rows
          setTimeout(reattachDifferentialEventListeners, 200);
        }
        
        // Mark as loaded to prevent multiple loads
        window.differentialDataLoaded = true;
        console.log('✅ Differential data loaded successfully');
      } catch (error) {
        console.error('❌ Error loading differential data:', error);
      }
    }
    
    

    // Get VAT rate based on company selection
    function getVatRate() {
      const isCompanyClient = document.getElementById('isCompanyClient')?.value;
      return (isCompanyClient === 'yes') ? 0 : ((window.getHelperVatRate ? window.getHelperVatRate() : (typeof MathEngine !== 'undefined' && MathEngine.getVatRate ? MathEngine.getVatRate() : 18)) / 100); // 0% for companies, admin rate for private
    }

    // Toggle differentials display
    function toggleDifferentials() {
      const checkbox = document.getElementById('hasDifferentials');
      const table = document.getElementById('differentialsTable');
      const summary = document.getElementById('differentialsSummary');
      
      if (!checkbox) return;
      
      const show = checkbox.checked;
      console.log('Toggling differentials:', show);
      
      if (table) table.style.display = show ? 'block' : 'none';
      if (summary) summary.style.display = show ? 'block' : 'none';
      
      // Add initial row if showing for first time
      if (show && document.getElementById('differentialsRows') && document.getElementById('differentialsRows').children.length === 0) {
        addDifferentialRow();
      }
      
      // Update calculations
      if (show) {
        updateDifferentialsSummary();
      } else {
        // Clear all differentials when unchecked
        const rows = document.querySelectorAll('#differentialsRows .differential-row');
        rows.forEach(row => row.remove());
        updateDifferentialsSummary();
      }
    }

    // Save and refresh calculations
    function saveAndRefresh() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Collect differentials data
      const differentialsData = {
        has_differentials: document.getElementById('hasDifferentials')?.checked || false,
        differentials: collectDifferentials()
      };
      
      // Update helper
      if (!helper.expertise) helper.expertise = {};
      if (!helper.expertise.depreciation) helper.expertise.depreciation = {};
      
      helper.expertise.depreciation.has_differentials = differentialsData.has_differentials;
      helper.expertise.depreciation.differentials = differentialsData.differentials;
      
      // Save to storage
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Refresh calculations
      refreshSummary();
    }

    // Collect differentials data
    function collectDifferentials() {
      return Array.from(document.querySelectorAll('#differentialsRows .differential-row')).map(row => {
        const amount = parseFloat(row.querySelector('.diff-amount')?.value || '0') || 0;
        const vat = parseFloat(row.querySelector('.diff-vat')?.value || '0') || 0;
        const total = parseFloat(row.querySelector('.diff-total')?.value || '0') || 0;
        const part = row.querySelector('.diff-part')?.value?.trim() || '';
        const nature = row.querySelector('.diff-nature')?.value?.trim() || '';
        const reason = row.querySelector('.diff-reason')?.value?.trim() || '';
        
        return {
          part: part,
          nature: nature,
          reason: reason,
          amount: amount,
          vat: vat,
          total_with_vat: total
        };
      });
    }

    // Refresh summary calculations - COMPLETE DYNAMIC SYSTEM
    // DISABLED: Second refreshSummary function with wrong data sources
    // This function was overriding the correct refreshSummary and using wrong mappings:
    // - Used levi.final_price instead of calculations.full_market_value  
    // - Used calc.total_damage instead of claims_data.total_claim
    // - Used dep.global_amount instead of depreciation.globalDepValue
    /*
    function refreshSummary() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const calc = helper.expertise?.calculations || {};
      const dep = helper.expertise?.depreciation || {};
      const levi = helper.expertise?.levi_report || {};
      
      // Get base values
      const marketValue = parseFloat(levi.final_price) || 0;
      const totalClaim = parseFloat(calc.total_damage) || 0;
      const depCompensation = parseFloat(dep.global_amount) || 0;
      
      // Update all summary fields across all report types
      const summaryFields = [
        'sumMarketValue', 'sumMarketValueGlobal', 'sumMarketValueDamage', 
        'sumMarketValueTotal', 'sumMarketValueLegal'
      ];
      summaryFields.forEach(id => {
        const field = document.getElementById(id);
        if (field) field.value = marketValue ? `₪${marketValue.toLocaleString()}` : '';
      });
      
      const claimFields = [
        'sumClaim', 'sumClaimGlobal'
      ];
      claimFields.forEach(id => {
        const field = document.getElementById(id);
        if (field) field.value = totalClaim ? `₪${totalClaim.toLocaleString()}` : '';
      });
      
      // Update main totalClaim field with formatting
      const totalClaimDiv = document.getElementById('totalClaim');
      if (totalClaimDiv) {
        totalClaimDiv.innerText = totalClaim ? `₪${totalClaim.toLocaleString()}` : '';
      }
      
      const depFields = [
        'depCompensation', 'depCompensationGlobal'
      ];
      depFields.forEach(id => {
        const field = document.getElementById(id);
        if (field) field.value = depCompensation ? `₪${depCompensation.toLocaleString()}` : '';
      });
      
      // Calculate subtotals including תוספות והורדות for each report type
      calculateSubtotals();
      
      // Specific fields for different report types
      const saleValueDamage = document.getElementById('saleValueDamage');
      if (saleValueDamage) saleValueDamage.value = calc.sale_value_damaged || '';
      
      const salvageValueTotal = document.getElementById('salvageValueTotal');
      if (salvageValueTotal) salvageValueTotal.value = calc.salvage_value || '';
      
      const salvageValueLegal = document.getElementById('salvageValueLegal');
      if (salvageValueLegal) salvageValueLegal.value = calc.salvage_value || '';
      
      const storageValueTotal = document.getElementById('storageValueTotal');
      if (storageValueTotal) storageValueTotal.value = calc.storage_value || '';
      
      // Populate תוספות והורדות from levi adjustments
      populateAdditionsFromLevi();
      
      // Update differentials summary
      updateDifferentialsSummary();
    }
    */

    // Calculate subtotals including תוספות והורדות for each report type
    function calculateSubtotals() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const calc = helper.expertise?.calculations || {};
      const dep = helper.expertise?.depreciation || {};
      const levi = helper.expertise?.levi_report || {};
      
      // Get base values
      const marketValue = parseFloat(levi.final_price) || 0;
      const totalClaim = parseFloat(calc.total_damage) || 0;
      const depCompensation = parseFloat(dep.global_amount) || 0;
      
      // Calculate additions/deductions for each report type
      const reportTypes = [
        { summaryType: 'summaryPrivate', totalField: 'sumTotal' },
        { summaryType: 'summaryGlobal', totalField: 'sumTotalGlobal' },
        { summaryType: 'summaryDamage', totalField: 'afterSaleDamage' },
        { summaryType: 'summaryTotalLoss', totalField: 'afterSaleTotal' },
        { summaryType: 'summaryLegalLoss', totalField: 'afterSaleLegal' }
      ];
      
      reportTypes.forEach(({ summaryType, totalField }) => {
        const additionsTotal = calculateAdditionsTotal(summaryType);
        let subtotal = 0;
        
        // Different calculation logic for different report types
        if (summaryType === 'summaryPrivate' || summaryType === 'summaryGlobal') {
          // For private/global: market value + total claim + depreciation compensation + additions
          subtotal = marketValue + totalClaim + depCompensation + additionsTotal;
        } else if (summaryType === 'summaryDamage') {
          // For damaged state: market value - sale value + additions
          const saleValue = parseFloat(document.getElementById('saleValueDamage')?.value?.replace(/[^\d.-]/g, '')) || 0;
          subtotal = marketValue - saleValue + additionsTotal;
        } else if (summaryType === 'summaryTotalLoss') {
          // For total loss: market value - salvage value + storage + additions
          const salvageValue = parseFloat(document.getElementById('salvageValueTotal')?.value?.replace(/[^\d.-]/g, '')) || 0;
          const storageValue = parseFloat(document.getElementById('storageValueTotal')?.value?.replace(/[^\d.-]/g, '')) || 0;
          subtotal = marketValue - salvageValue + storageValue + additionsTotal;
        } else if (summaryType === 'summaryLegalLoss') {
          // For legal loss: market value - salvage value + additions
          const salvageValue = parseFloat(document.getElementById('salvageValueLegal')?.value?.replace(/[^\d.-]/g, '')) || 0;
          subtotal = marketValue - salvageValue + additionsTotal;
        }
        
        // Update the total field
        const totalFieldElement = document.getElementById(totalField);
        if (totalFieldElement) {
          totalFieldElement.value = `₪${Math.max(0, subtotal).toLocaleString()}`;
        }
      });
    }

    // Calculate total of additions/deductions for a specific report type
    function calculateAdditionsTotal(summaryType) {
      let total = 0;
      
      // Calculate additions from custom fields using exact container mapping
      const gridMapping = {
        'summaryPrivate': 'sumAdditionsGrid',
        'summaryGlobal': 'sumAdditionsGridGlobal', 
        'summaryDamage': 'sumAdditionsGridDamage',
        'summaryTotalLoss': 'sumAdditionsGridTotalLoss',
        'summaryLegalLoss': 'sumAdditionsGridLegalLoss'
      };
      
      const gridId = gridMapping[summaryType];
      const customGrid = document.getElementById(gridId);
      if (customGrid) {
        const customRows = customGrid.querySelectorAll('.custom-summary-row');
        customRows.forEach(row => {
          const value = parseFloat(row.querySelector('.custom-field-value')?.value?.replace(/[^\d.-]/g, '')) || 0;
          total += value;
        });
      }
      
      // Calculate Levi adjustments
      total += calculateLeviAdjustmentsTotal(summaryType);
      
      return total;
    }

    // Calculate total of Levi adjustments for a specific report type
    function calculateLeviAdjustmentsTotal(summaryType) {
      let total = 0;
      
      // Map summary types to Levi adjustment container IDs
      const leviMapping = {
        'summaryPrivate': 'leviAdjustmentsRows-private',
        'summaryGlobal': 'leviAdjustmentsRows-global',
        'summaryDamage': 'leviAdjustmentsRows-damage',
        'summaryTotalLoss': 'leviAdjustmentsRows-totalLoss',
        'summaryLegalLoss': 'leviAdjustmentsRows-legalLoss'
      };
      
      const leviId = leviMapping[summaryType];
      const leviContainer = document.getElementById(leviId);
      if (leviContainer) {
        const leviRows = leviContainer.querySelectorAll('.levi-adjustment-row');
        leviRows.forEach(row => {
          const value = parseFloat(row.querySelector('.levi-adjustment-value')?.value?.replace(/[^\d.-]/g, '')) || 0;
          total += value;
        });
      }
      
      return total;
    }

    // Populate תוספות והורדות from levi adjustments
    function populateAdditionsFromLevi() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const levi = helper.expertise?.levi_report || {};
      
      if (!levi.adjustments || !Array.isArray(levi.adjustments)) return;
      
      // Map summary types to Levi adjustment container IDs
      const leviMapping = {
        'summaryPrivate': 'leviAdjustmentsRows-private',
        'summaryGlobal': 'leviAdjustmentsRows-global',
        'summaryDamage': 'leviAdjustmentsRows-damage',
        'summaryTotalLoss': 'leviAdjustmentsRows-totalLoss',
        'summaryLegalLoss': 'leviAdjustmentsRows-legalLoss'
      };
      
      // Populate for each summary type
      Object.keys(leviMapping).forEach(summaryType => {
        const containerId = leviMapping[summaryType];
        const container = document.getElementById(containerId);
        if (!container) return;
        
        // Clear existing rows
        container.innerHTML = '';
        
        // Add Levi adjustments
        levi.adjustments.forEach(adjustment => {
          if (adjustment.name && adjustment.value) {
            const row = createLeviAdjustmentRow(adjustment.name, adjustment.value);
            container.appendChild(row);
          }
        });
      });
      
      console.log('✅ Levi adjustments populated across all summary types');
    }

    // Render existing differentials from data
    function renderDifferentials(list) {
      const container = document.getElementById('differentialsRows');
      if (!container) return;
      
      container.innerHTML = '';
      console.log('🔍 Loading differentials data:', list);
      
      if (list && list.length > 0) {
        // FILTER OUT CORRUPTED DATA - only load properly structured differential data
        const validDifferentials = list.filter(item => {
          return item && typeof item === 'object' && (item.part || item.nature || item.reason || item.amount);
        });
        
        console.log('✅ Valid differentials after filter:', validDifferentials);
        
        validDifferentials.forEach(item => {
          const row = createDifferentialRow(item);
          container.appendChild(row);
        });
      }
      updateDifferentialsSummary();
    }

    // Create Levi adjustment row
    function createLeviAdjustmentRow(name, value) {
      const row = document.createElement('div');
      row.className = 'levi-adjustment-row';
      row.style.display = 'grid';
      row.style.gridTemplateColumns = '1fr 120px 80px';
      row.style.gap = '10px';
      row.style.marginBottom = '8px';
      row.style.alignItems = 'center';
      
      row.innerHTML = `
        <div>
          <input type="text" class="levi-adjustment-name" value="${name}" readonly style="width:100%; padding:6px; border:1px solid #ccc; background:#f8f9fa; border-radius:4px;">
        </div>
        <div>
          <input type="number" class="levi-adjustment-value" value="${value}" style="width:100%; padding:6px; border:1px solid #ccc; border-radius:4px;">
        </div>
        <div>
          <button type="button" class="btn-remove" style="background:#dc3545; color:white; border:none; padding:6px 10px; border-radius:4px; cursor:pointer;">✕</button>
        </div>
      `;
      
      // Add event listeners
      const valueInput = row.querySelector('.levi-adjustment-value');
      const removeBtn = row.querySelector('.btn-remove');
      
      valueInput.addEventListener('input', function() {
        calculateSubtotals();
        saveAndRefresh();
      });
      
      removeBtn.addEventListener('click', function() {
        row.remove();
        calculateSubtotals();
        saveAndRefresh();
      });
      
      return row;
    }

    // Global depreciation calculation
    function calculateGlobalDepreciationValue() {
      const globalDep1 = document.getElementById('globalDep1');
      if (!globalDep1) return;
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Try multiple sources for market value
      let marketValue = 0;
      
      // First try the summary market value field (most reliable)
      const sumMarketValueField = document.getElementById('sumMarketValue');
      if (sumMarketValueField && sumMarketValueField.value) {
        const sumMarketStr = sumMarketValueField.value.replace(/[₪,]/g, '') || '0';
        marketValue = parseFloat(sumMarketStr) || 0;
      }
      
      // Fallback to helper data
      if (!marketValue) {
        marketValue = helper.calculations?.market_value || 
                     helper.expertise?.levi_report?.final_price || 
                     helper.calculations?.vehicle_value_gross || 0;
      }
      // Clean the percentage value properly to handle decimals like 2.5%
      const cleanedValue = globalDep1.value.replace('%', '').replace(/[^0-9.-]/g, '');
      const depPercent = parseFloat(cleanedValue) || 0;
      
      const globalAmount = Math.round(marketValue * (depPercent / 100));
      
      // Update helper data
      if (!helper.expertise) helper.expertise = {};
      if (!helper.expertise.depreciation) helper.expertise.depreciation = {};
      helper.expertise.depreciation.global_percent = depPercent;
      helper.expertise.depreciation.global_amount = globalAmount;
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Update display - target the correct field: globalDepValue
      const globalDepValueField = document.getElementById('globalDepValue');
      if (globalDepValueField) {
        globalDepValueField.value = `₪${globalAmount.toLocaleString()}`;
      }
      
    }

    // Trigger MathEngine calculation
    function triggerMathCalculation() {
      if (typeof MathEngine !== 'undefined' && MathEngine.calculateAll) {
        try {
          // Gather required data for calculation
          const helper = window.helper || {};
          const baseDamage = helper.damage_assessment?.totals?.base_damage || 0;
          const depreciation = helper.depreciation?.total_value || 0;
          const fees = helper.fees?.total || 0;
          const marketValue = helper.vehicle?.market_value || 0;
          const vehicleValueGross = helper.vehicle?.gross_value || marketValue;
          const shavehPercent = helper.calculations?.shaveh_percent || 0;
          const vatRate = helper.calculations?.vat_rate || 18;
          
          const calculationData = {
            baseDamage,
            depreciation,
            fees,
            marketValue,
            vehicleValueGross,
            shavehPercent,
            vatRate
          };
          
          MathEngine.calculateAll(calculationData);
          console.log('✅ MathEngine calculation triggered with data:', calculationData);
        } catch (error) {
          console.error('❌ Error triggering MathEngine calculation:', error);
        }
      }
    }

    // Enhanced saveAndRefresh with complete data collection
    function saveAndRefreshComplete() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Ensure structure exists
      if (!helper.expertise) helper.expertise = {};
      if (!helper.expertise.depreciation) helper.expertise.depreciation = {};
      
      // Collect all form data
      const reportType = document.getElementById('reportType')?.value;
      const isCompanyClient = document.getElementById('isCompanyClient')?.value;
      const globalDep1 = document.getElementById('globalDep1')?.value;
      const workDays = document.getElementById('workDays')?.value;
      const isAgreement = document.getElementById('isAgreement')?.checked;
      const hasDifferentials = document.getElementById('hasDifferentials')?.checked;
      
      // Update helper with form data
      if (reportType) helper.meta = { ...helper.meta, report_type_display: reportType };
      if (isCompanyClient) helper.client = { ...helper.client, is_company_client: isCompanyClient === 'yes' };
      if (globalDep1) helper.expertise.depreciation.global_percent = parseFloat(globalDep1);
      if (workDays) helper.expertise.depreciation.work_days = parseInt(workDays);
      helper.expertise.depreciation.is_agreement = !!isAgreement;
      helper.expertise.depreciation.has_differentials = !!hasDifferentials;
      
      // Collect differentials
      if (hasDifferentials) {
        helper.expertise.depreciation.differentials = collectDifferentials();
      }
      
      // Save to storage
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Trigger calculations
      calculateGlobalDepreciationValue();
      triggerMathCalculation();
      refreshSummary();
      
      console.log('💾 Complete data saved and calculations refreshed');
    }

    // Add custom summary field - EXACT COPY FROM WORKING DEPRECIATION MODULE
    function addCustomSummaryField(summaryType) {
      const gridMapping = {
        'summaryPrivate': 'sumAdditionsGrid',
        'summaryGlobal': 'sumAdditionsGridGlobal', 
        'summaryDamage': 'sumAdditionsGridDamage',
        'summaryTotalLoss': 'sumAdditionsGridTotalLoss',
        'summaryLegalLoss': 'sumAdditionsGridLegalLoss'
      };
      
      const gridId = gridMapping[summaryType];
      const grid = document.getElementById(gridId);
      
      if (!grid) {
        console.warn('Grid not found for summary type:', summaryType);
        return;
      }
      
      const row = document.createElement('div');
      row.className = 'custom-summary-row';
      row.style.display = 'grid';
      row.style.gridTemplateColumns = '1fr 1fr 80px';
      row.style.gap = '10px';
      row.style.marginBottom = '10px';
      
      row.innerHTML = `
        <div>
          <input type="text" class="custom-field-name" placeholder="שם השדה" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc;">
        </div>
        <div>
          <input type="text" class="custom-field-value" placeholder="ערך" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc;">
        </div>
        <div>
          <button type="button" class="btn remove" style="background:#dc3545; padding:8px 12px; margin-top:0; font-size: 14px;">✕</button>
        </div>
      `;
      
      // Add event listeners
      row.querySelector('.remove').addEventListener('click', () => {
        row.remove();
        calculateSubtotals();
        saveAndRefreshComplete();
      });
      
      row.querySelector('.custom-field-name').addEventListener('input', () => {
        calculateSubtotals();
        saveAndRefreshComplete();
      });
      
      row.querySelector('.custom-field-value').addEventListener('input', () => {
        calculateSubtotals();
        saveAndRefreshComplete();
      });
      
      grid.appendChild(row);
      console.log(`✅ Custom field added to ${summaryType}`);
    }

    // NEW: Handle final report date completely separate from everything else
    function updateFinalReportDate(element) {
      console.log('🚀 updateFinalReportDate called! Element:', element.id, 'Value:', element.value);
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      const value = element.value;
      
      // Create final report section if it doesn't exist
      if (!helper.final_report) helper.final_report = {};
      
      // Store ONLY in final report - NO connection to Levi or car details
      helper.final_report.report_date = value;
      helper.final_report.generated_date = new Date().toISOString();
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      console.log('💾 Saved to helper.final_report.report_date:', value);
      
      // Sync both final report date fields
      const topField = document.getElementById('finalReportDate');
      const summaryField = document.getElementById('finalReportDateSummary');
      if (topField && element.id !== 'finalReportDate') topField.value = value;
      if (summaryField && element.id !== 'finalReportDateSummary') summaryField.value = value;
      
      console.log('✅ Final report date updated (separate from Levi):', value);
    }

    // Alias for the same function
    function updateFinalReportDateField(element) {
      console.log('🔍 updateFinalReportDateField called with element:', element.id, 'value:', element.value);
      updateFinalReportDate(element);
      
      // Additional verification log
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('🔍 After save - final_report.report_date:', helper.final_report?.report_date);
    }

    // New workflow functions
    // REMOVED - Duplicate function that was saving to wrong location
    
    function continueToValidation() {
      // Save all current data before proceeding
      saveDepreciationData();
      
      // Set workflow state
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (!helper.workflow) helper.workflow = {};
      helper.workflow.current_stage = 'fee_calculation';
      helper.workflow.from_builder = true;
      helper.workflow.report_type = document.getElementById('reportType')?.value || 'חוות דעת פרטית';
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Navigate to fee module
      window.location.href = 'fee-module.html';
    }

    // Make functions globally available
    window.updateSummaryVisibility = updateSummaryVisibility;
    window.addDepreciationRow = addDepreciationRow;
    window.addDifferentialRow = addDifferentialRow;
    window.updateDifferentialsSummary = updateDifferentialsSummary;
    window.refreshDamageCentersContainerLayout = refreshDamageCentersContainerLayout;
    window.toggleNatureOtherField = toggleNatureOtherField;
    window.toggleDifferentials = toggleDifferentials;
    window.toggleDifferentialsTable = toggleDifferentialsTable;
    window.updateFinalReportDate = updateFinalReportDate;
    
    // Test function accessibility
    console.log('🧪 updateFinalReportDate function available:', typeof window.updateFinalReportDate);
    
    // Add event listeners programmatically as backup
    document.addEventListener('DOMContentLoaded', function() {
      const topField = document.getElementById('finalReportDate');
      const summaryField = document.getElementById('finalReportDateSummary');
      
      if (topField) {
        console.log('🔧 Adding event listener to finalReportDate');
        topField.addEventListener('change', function() {
          console.log('📅 finalReportDate changed programmatically to:', this.value);
          updateFinalReportDate(this);
        });
      }
      
      if (summaryField) {
        console.log('🔧 Adding event listener to finalReportDateSummary');
        summaryField.addEventListener('change', function() {
          console.log('📅 finalReportDateSummary changed programmatically to:', this.value);
          updateFinalReportDate(this);
        });
      }
    });
    window.saveDepreciationData = saveDepreciationData;
    window.continueToValidation = continueToValidation;
    window.saveAndRefresh = saveAndRefresh;
    window.saveAndRefreshComplete = saveAndRefreshComplete;
    window.refreshSummary = refreshSummary;
    window.calculateSubtotals = calculateSubtotals;
    window.calculateSummaryTotals = calculateSummaryTotals;
    window.calculateAdditionsTotal = calculateAdditionsTotal;
    window.calculateLeviAdjustmentsTotal = calculateLeviAdjustmentsTotal;
    window.populateAdditionsFromLevi = populateAdditionsFromLevi;
    window.collectDifferentials = collectDifferentials;
    window.getVatRate = getVatRate;
    window.renderDifferentials = renderDifferentials;
    window.saveDifferentials = saveDifferentials;
    window.updateFinalReportField = updateFinalReportField;
    window.loadDifferentialData = loadDifferentialData;
    window.reattachDifferentialEventListeners = reattachDifferentialEventListeners;
    window.saveDifferentials = saveDifferentials;
    window.saveDifferentialsToHelper = saveDifferentialsToHelper;
    window.addDifferentialRow = addDifferentialRow;
    window.toggleDifferentialsTable = toggleDifferentialsTable;
    window.testDifferentialSave = () => {
      console.log('🧪 MANUAL TEST: Reattaching listeners and saving...');
      reattachDifferentialEventListeners();
      setTimeout(saveDifferentialsToHelper, 200);
    };
    
    window.debugDifferentialData = () => {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('🔍 CURRENT HELPER DIFFERENTIAL DATA:', {
        exists: !!helper.final_report?.differential,
        has_differentials: helper.final_report?.differential?.has_differentials,
        items_count: helper.final_report?.differential?.items?.length || 0,
        items: helper.final_report?.differential?.items,
        full_structure: helper.final_report?.differential
      });
    };
    
    window.forceLoadDifferentials = () => {
      window.differentialDataLoaded = false;
      loadDifferentialData();
    };
    window.createLeviAdjustmentRow = createLeviAdjustmentRow;
    window.calculateGlobalDepreciationValue = calculateGlobalDepreciationValue;
    window.triggerMathCalculation = triggerMathCalculation;
    window.addCustomSummaryField = addCustomSummaryField;

    // Document Operations Functions
    window.returnToSelection = function() {
      if (confirm('האם אתה בטוח שברצונך לחזור לדף הבחירה? השינויים שלא נשמרו יאבדו.')) {
        window.location.href = 'selection.html';
      }
    };

    window.saveData = function() {
      saveFinalReport();
    };

    // Preview final report with all filled data
    window.previewFinalReport = function() {
      try {
        console.log('🔍 Opening final report template preview in PiP...');
        
        // Save current data first
        saveDepreciationData();
        
        // Get all the data from helper
        const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Set a flag to indicate we're in preview mode
        helper.preview_mode = true;
        helper.preview_timestamp = new Date().toISOString();
        
        // Make sure all the latest data is in the helper
        helper.final_report = helper.final_report || {};
        helper.final_report.generated_date = new Date().toLocaleDateString('he-IL');
        helper.final_report.preview = true;
        
        // Save the helper with preview flag
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Create preview modal if it doesn't exist
        let previewModal = document.getElementById('reportPreviewModal');
        if (!previewModal) {
          previewModal = createPreviewModal();
          document.body.appendChild(previewModal);
        }
        
        // Show the modal
        previewModal.style.display = 'block';
        
        // Load the report template in the iframe and populate tables after load
        const iframe = document.getElementById('reportPreviewFrame');
        
        // Use the exact same approach that works in template-builder
        iframe.onload = function() {
          console.log('📄 Template iframe loaded, waiting for initialization...');
          
          // Wait for the template to fully initialize
          setTimeout(() => {
            try {
              const iframeWindow = iframe.contentWindow;
              const iframeDocument = iframe.contentDocument;
              
              // Ensure sessionStorage data is available in iframe
              const helperData = sessionStorage.getItem('helper');
              const metaData = sessionStorage.getItem('meta');
              if (helperData) iframeWindow.sessionStorage.setItem('helper', helperData);
              if (metaData) iframeWindow.sessionStorage.setItem('meta', metaData);
              
              // Multiple retry attempts to ensure functions are loaded and execute
              let attempts = 0;
              const populateTables = () => {
                attempts++;
                if (iframeWindow && iframeWindow.populateNewAdjustmentsTable) {
                  console.log('✅ Populating iframe tables...');
                  iframeWindow.populateNewAdjustmentsTable();
                  iframeWindow.populateGrossDamageTable();
                  iframeWindow.formatDamagePercent();
                  console.log('✅ Preview tables populated successfully');
                } else if (attempts < 15) {
                  console.log(`⏳ Waiting for iframe functions... attempt ${attempts}`);
                  setTimeout(populateTables, 500);
                } else {
                  console.log('❌ Failed to find iframe functions after 15 attempts');
                }
              };
              
              populateTables();
            } catch (e) {
              console.error('Error populating preview tables:', e);
            }
          }, 3000); // Longer initial wait
        };
        
        iframe.src = 'final-report-template-builder.html';
        
        // Remove preview flag after a short delay
        setTimeout(() => {
          const updatedHelper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          delete updatedHelper.preview_mode;
          delete updatedHelper.preview_timestamp;
          if (updatedHelper.final_report) {
            delete updatedHelper.final_report.preview;
          }
          sessionStorage.setItem('helper', JSON.stringify(updatedHelper));
        }, 2000);
        
        console.log('✅ Final report preview opened in PiP');
        
      } catch (error) {
        console.error('❌ Error opening preview:', error);
        alert('שגיאה בפתיחת תצוגה מקדימה');
      }
    };
    
    // Create the preview modal structure
    function createPreviewModal() {
      const modal = document.createElement('div');
      modal.id = 'reportPreviewModal';
      
      // Get viewport dimensions for responsive sizing
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const isMobile = viewportWidth <= 768;
      
      // Calculate responsive dimensions and center positioning
      const width = isMobile ? Math.min(viewportWidth - 20, 350) : Math.min(800, viewportWidth - 100);
      const height = isMobile ? Math.min(viewportHeight - 100, 500) : Math.min(viewportHeight * 0.8, 600);
      const top = Math.max(10, (viewportHeight - height) / 2);
      const left = Math.max(10, (viewportWidth - width) / 2);
      
      modal.style.cssText = `
        display: none;
        position: fixed;
        top: ${top}px;
        left: ${left}px;
        width: ${width}px;
        height: ${height}px;
        background: white;
        border: 2px solid #333;
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        z-index: 10000;
        resize: ${isMobile ? 'none' : 'both'};
        overflow: auto;
        min-width: ${isMobile ? '300px' : '400px'};
        min-height: ${isMobile ? '250px' : '300px'};
        max-width: 95vw;
        max-height: 95vh;
      `;
      
      // Create header
      const header = document.createElement('div');
      header.style.cssText = `
        background: #1e40af;
        color: white;
        padding: ${isMobile ? '8px 12px' : '12px 20px'};
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: move;
        user-select: none;
        border-radius: 10px 10px 0 0;
        min-height: ${isMobile ? '40px' : '48px'};
        box-sizing: border-box;
      `;
      header.innerHTML = `
        <h3 style="margin: 0; font-size: ${isMobile ? '14px' : '18px'}; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">תצוגה מקדימה - חוות דעת</h3>
        <div style="display: flex; gap: ${isMobile ? '5px' : '10px'}; flex-shrink: 0;">
          <button onclick="minimizePreview()" style="background: none; border: none; color: white; font-size: ${isMobile ? '16px' : '20px'}; cursor: pointer; width: ${isMobile ? '32px' : '24px'}; height: ${isMobile ? '32px' : '24px'}; touch-action: manipulation;" title="מזער">_</button>
          <button onclick="maximizePreview()" style="background: none; border: none; color: white; font-size: ${isMobile ? '16px' : '20px'}; cursor: pointer; width: ${isMobile ? '32px' : '24px'}; height: ${isMobile ? '32px' : '24px'}; touch-action: manipulation;" title="הגדל">□</button>
          <button onclick="closePreview()" style="background: none; border: none; color: white; font-size: ${isMobile ? '20px' : '24px'}; cursor: pointer; width: ${isMobile ? '32px' : '24px'}; height: ${isMobile ? '32px' : '24px'}; touch-action: manipulation;" title="סגור">×</button>
        </div>
      `;
      
      // Create iframe container
      const iframeContainer = document.createElement('div');
      iframeContainer.style.cssText = `
        width: 100%;
        height: calc(100% - 50px);
        overflow: hidden;
      `;
      
      // Create iframe
      const iframe = document.createElement('iframe');
      iframe.id = 'reportPreviewFrame';
      iframe.style.cssText = `
        width: 100%;
        height: 100%;
        border: none;
      `;
      
      iframeContainer.appendChild(iframe);
      modal.appendChild(header);
      modal.appendChild(iframeContainer);
      
      // Make the modal draggable
      makeDraggable(modal, header);
      
      return modal;
    }
    
    // Make element draggable
    function makeDraggable(element, handle) {
      let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
      handle.onmousedown = dragMouseDown;
      
      function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
      }
      
      function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
        element.style.right = "auto";
      }
      
      function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
      }
    }
    
    // Preview control functions
    window.closePreview = function() {
      const modal = document.getElementById('reportPreviewModal');
      if (modal) {
        modal.style.display = 'none';
        const iframe = document.getElementById('reportPreviewFrame');
        if (iframe) iframe.src = '';
      }
    };
    
    window.minimizePreview = function() {
      const modal = document.getElementById('reportPreviewModal');
      if (modal) {
        modal.style.width = '400px';
        modal.style.height = '300px';
      }
    };
    
    window.maximizePreview = function() {
      const modal = document.getElementById('reportPreviewModal');
      if (modal) {
        modal.style.width = '90vw';
        modal.style.height = '90vh';
        modal.style.top = '5vh';
        modal.style.left = '5vw';
      }
    };


    // Functions for renamed buttons (former final report functions)
    window.fetchFinalReportPDF = function() {
      // Redirect to preview final report functionality
      previewFinalReport();
    };

    window.requestFinalReport = function() {
      // Redirect to generate final report functionality  
      generateFinalReport();
    };

    // EXPERTISE FETCH FUNCTION - Uses input field for flexibility
    window.fetchExpertisePDF = async function() {
      // FETCH functions use input field for flexibility (can load any case)
      const plateInput = document.getElementById('builderPlateInput');
      const plateNumber = plateInput ? plateInput.value.trim() : '';
      
      if (!plateNumber) {
        alert('אנא הכנס מספר רכב בשדה "טען תיק קיים"');
        return;
      }
      
      const fetchBtn = document.getElementById('fetchExpertiseBtn');
      const originalText = fetchBtn.textContent;
      
      try {
        fetchBtn.disabled = true;
        fetchBtn.textContent = 'טוען PDF...';
        
        const helper = sessionStorage.getItem('helper');
        const caseData = helper ? JSON.parse(helper) : null;
        const payload = {
          plate: plateNumber,
          case_id: caseData?.meta?.case_id,
          document_type: 'expertise'
        };
        
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('FETCH_EXPERTISE_PDF', payload);
        
        if (response?.success && response?.pdf_url) {
          showFloatingPDF(response.pdf_url, 'אקספירטיזה PDF');
        } else {
          alert('אקספירטיזה לא נמצאה במערכת או לא הופקה עדיין');
        }
        
      } catch (error) {
        console.error('Error fetching expertise PDF:', error);
        alert('שגיאה בטעינת אקספירטיזה PDF');
      } finally {
        fetchBtn.disabled = false;
        fetchBtn.textContent = originalText;
      }
    };

    // ESTIMATE FUNCTIONS - NEW ADDITION
    window.fetchEstimatePDF = async function() {
      // FETCH functions use input field for flexibility (can load any case)
      const plateInput = document.getElementById('builderPlateInput');
      const plateNumber = plateInput ? plateInput.value.trim() : '';
      
      if (!plateNumber) {
        alert('אנא הכנס מספר רכב בשדה "טען תיק קיים"');
        return;
      }
      
      const fetchBtn = document.getElementById('fetchEstimateBtn');
      const originalText = fetchBtn.textContent;
      
      try {
        fetchBtn.disabled = true;
        fetchBtn.textContent = 'טוען PDF...';
        
        const payload = {
          plate: plateNumber,
          case_id: helperData?.meta?.case_id,
          document_type: 'estimate'
        };
        
        const { sendToWebhook } = await import('./webhook.js');
        const response = await sendToWebhook('FETCH_ESTIMATE_PDF', payload);
        
        if (response?.success && response?.pdf_url) {
          showFloatingPDF(response.pdf_url, 'אומדן ראשוני PDF');
        } else {
          alert('אומדן ראשוני לא נמצא במערכת או לא הופק עדיין');
        }
        
      } catch (error) {
        console.error('Error fetching estimate PDF:', error);
        alert('שגיאה בטעינת אומדן ראשוני PDF');
      } finally {
        fetchBtn.disabled = false;
        fetchBtn.textContent = originalText;
      }
    };



    window.exitSystem = function() {
      if (confirm('האם אתה בטוח שברצונך לצאת מהמערכת? השינויים שלא נשמרו יאבדו.')) {
        // Clear session data
        sessionStorage.clear();
        window.location.href = 'index.html';
      }
    };

    // 🏛️ VAT RATE MANAGEMENT FUNCTIONS
    
    // Initialize VAT rate display
    window.initVatDisplay = async function() {
      try {
        // Try to get actual VAT rate from admin hub via MathEngine
        let adminVatRate = null;
        let vatSource = 'default';
        
        if (typeof MathEngine !== 'undefined' && MathEngine.loadAdminHubVatRate) {
          try {
            adminVatRate = await MathEngine.loadAdminHubVatRate();
            if (adminVatRate !== null) {
              vatSource = 'admin_hub';
              console.log('✅ Loaded VAT rate from admin hub:', adminVatRate + '%');
            }
          } catch (e) {
            console.warn('⚠️ Could not load VAT rate from admin hub:', e);
          }
        }
        
        // Fallback to helper or default
        if (adminVatRate === null) {
          adminVatRate = window.getHelperVatRate ? window.getHelperVatRate() : 18;
          vatSource = window.helper?.calculations?.vat_rate ? 'helper' : 'default';
        }
        
        // Update MathEngine with admin rate
        if (typeof MathEngine !== 'undefined' && MathEngine.setVatRate && vatSource === 'admin_hub') {
          MathEngine.setVatRate(adminVatRate);
        }
        
        // Update display
        const vatInput = document.getElementById('vat-rate-input');
        const sourceDisplay = document.getElementById('vat-source-display');
        const updatedDisplay = document.getElementById('vat-updated-display');
        
        if (vatInput) vatInput.value = adminVatRate;
        if (sourceDisplay) {
          sourceDisplay.textContent = vatSource === 'admin_hub' ? 'מנהל מערכת' : 
                                      vatSource === 'helper' ? 'נתוני מערכת' : 'ברירת מחדל';
        }
        if (updatedDisplay) {
          updatedDisplay.textContent = vatSource === 'admin_hub' ? 
            new Date().toLocaleString('he-IL') : 'לא עודכן מאדמין';
        }
        
        console.log(`📊 VAT display initialized: ${adminVatRate}% (${vatSource})`);
        
      } catch (e) {
        console.warn('⚠️ Could not initialize VAT display:', e);
        // Fallback initialization
        const vatInput = document.getElementById('vat-rate-input');
        if (vatInput) vatInput.value = 18;
      }
    };
    
    // Update VAT rate manually (DIRECT UPDATE TO calculations.vat_rate)
    window.updateVatRate = function() {
      const input = document.getElementById('vat-rate-input');
      const newRate = parseFloat(input.value);
      
      if (isNaN(newRate) || newRate < 0 || newRate > 100) {
        alert('אנא הזן שיעור מע"מ חוקי (0-100)');
        return;
      }
      
      // DIRECT UPDATE: Write directly to calculations.vat_rate (where all calculations read from)
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      if (!helper.calculations) helper.calculations = {};
      
      const oldRate = helper.calculations.vat_rate;
      
      // Set protection flags to ignore admin hub updates for 10 seconds
      window.lastManualVatUpdate = Date.now();
      window.ignoreAdminVatUntil = Date.now() + 10000; // 10 seconds protection
      console.log('🛡️ Manual VAT override protection activated for 10 seconds (final-report)');
      
      // CRITICAL: Create SESSION-ONLY override (NEVER touch admin hub)
      // 1. Update helper.calculations.vat_rate (session override)
      helper.calculations.vat_rate = newRate;
      helper.calculations.vat_rate_source = 'manual_session_override';
      helper.calculations.vat_rate_updated = new Date().toISOString();
      
      // 2. Update MathEngine with session override (DO NOT update admin hub core rate)
      if (typeof MathEngine !== 'undefined' && MathEngine.setSessionVatRate) {
        MathEngine.setSessionVatRate(newRate);
        console.log('SESSION OVERRIDE: MathEngine now uses:', newRate + '% (admin hub core rate preserved)');
      } else if (typeof MathEngine !== 'undefined') {
        // Fallback: direct update without admin hub communication
        sessionStorage.setItem('globalVAT', newRate);
        console.log('SESSION OVERRIDE: VAT rate stored in session, admin hub core rate preserved');
      }
      
      // Update window.helper in memory AND sessionStorage
      window.helper = helper;
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      console.log(`✅ DUAL VAT UPDATE: helper.calculations.vat_rate AND MathEngine changed to ${newRate}%`);
      console.log('Current helper.calculations.vat_rate:', helper.calculations.vat_rate);
      
      alert(`שיעור המע"מ עודכן ל-${newRate}%`);
      window.initVatDisplay(); // Refresh display
      
      // Trigger calculations refresh
      if (typeof refreshAllCalculations === 'function') {
        refreshAllCalculations();
      }
    };
    
    // Reset VAT rate to admin hub value (DIRECT IMPLEMENTATION)
    window.resetVatRateFromAdmin = function() {
      if (confirm('האם לאפס את שיעור המע"מ לערך מנהל המערכת?')) {
        
        // DIRECT ADMIN RATE RETRIEVAL (same as working estimate builder)
        console.log('DEBUGGING VAT SOURCES FOR RESET (FINAL REPORT):');
        console.log('- sessionStorage globalVAT:', sessionStorage.getItem('globalVAT'));
        console.log('- localStorage globalVAT:', localStorage.getItem('globalVAT'));
        console.log('- MathEngine available:', typeof MathEngine !== 'undefined');
        if (typeof MathEngine !== 'undefined' && MathEngine.getVatRate) {
          console.log('- MathEngine.getVatRate():', MathEngine.getVatRate());
        }
        
        // Get TRUE admin rate (NEVER from MathEngine - it has session overrides)
        let adminRate = 18; // TRUE admin hub default
        
        // Try to get the ORIGINAL admin rate from storage (if available)
        const originalAdminVat = localStorage.getItem('originalAdminVAT') || sessionStorage.getItem('originalAdminVAT');
        if (originalAdminVat && !isNaN(originalAdminVat)) {
          adminRate = parseFloat(originalAdminVat);
          console.log('Got ORIGINAL admin VAT from storage:', adminRate + '%');
        } else {
          // Fallback to known admin rate (should be 18% based on your setup)
          console.log('Using KNOWN admin hub rate (18%) - MathEngine has session overrides');
          adminRate = 18; // TRUE admin hub rate
        }
        
        console.log('ADMIN RATE FOR RESET (FINAL REPORT):', adminRate + '%');
        
        // DIRECTLY UPDATE BOTH SYSTEMS
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        if (!helper.calculations) helper.calculations = {};
        
        const oldRate = helper.calculations.vat_rate;
        const oldSource = helper.calculations.vat_rate_source;
        
        // RESTORE BOTH SYSTEMS to true admin rate
        // 1. Clear session override in helper
        helper.calculations.vat_rate = adminRate;
        helper.calculations.vat_rate_source = 'admin_hub_restored';
        helper.calculations.vat_rate_updated = new Date().toISOString();
        
        // Update window.helper and save
        window.helper = helper;
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // 2. RESTORE MathEngine to true admin rate (clear session override)
        if (typeof MathEngine !== 'undefined') {
          console.log('BEFORE RESET: MathEngine had session override:', MathEngine.getVatRate ? MathEngine.getVatRate() : 'unknown');
          
          if (MathEngine.setVatRate) {
            MathEngine.setVatRate(adminRate);
            console.log('RESTORED: MathEngine back to admin rate:', adminRate + '%');
          }
          
          // Verify the restore worked
          setTimeout(() => {
            console.log('AFTER RESET: MathEngine now uses admin rate:', MathEngine.getVatRate ? MathEngine.getVatRate() : 'unknown');
          }, 100);
        }
        
        console.log('FINAL REPORT RESET COMPLETE: ' + oldRate + '% (' + oldSource + ') -> ' + adminRate + '% (admin_hub)');
        
        // Update display
        document.getElementById('vat-rate-input').value = adminRate;
        window.initVatDisplay();
        alert(`שיעור המע"מ אופס לערך מנהל המערכת: ${adminRate}%`);
        
        // Trigger calculations refresh
        if (typeof refreshAllCalculations === 'function') {
          refreshAllCalculations();
        }
      }
    };
    
    // 🔧 DEBUG: Test admin hub connection
    window.testAdminHubConnection = function() {
      console.log('🔍 Testing admin hub connection...');
      
      if (window.parent && window.parent !== window) {
        console.log('✅ Parent frame detected - we are in an iframe');
        
        // Test VAT rate request
        const timeout = setTimeout(() => {
          console.log('❌ Timeout: Admin hub did not respond');
          alert('❌ לא התקבלה תשובה מאדמין בזמן - ייתכן שהחיבור לא פעיל');
        }, 3000);
        
        const messageHandler = (event) => {
          if (event.data && event.data.type === 'VAT_RATE_RESPONSE') {
            clearTimeout(timeout);
            window.removeEventListener('message', messageHandler);
            console.log('✅ Admin hub responded with VAT rate:', event.data.vatRate + '%');
            alert(`✅ חיבור לאדמין פעיל! שיעור מע"מ נוכחי: ${event.data.vatRate}%`);
          }
        };
        
        window.addEventListener('message', messageHandler);
        window.parent.postMessage({ type: 'GET_VAT_RATE' }, '*');
        
      } else {
        console.log('❌ No parent frame - not running in admin hub');
        alert('❌ לא רץ בתוך מנהל המערכת - פתח דרך הפורטל');
      }
    };
    
    // 🔍 VERIFY: Check if admin hub functions are loaded
    window.verifyAdminHubFunctions = function() {
      const functions = [
        'initVatDisplay',
        'updateVatRate', 
        'resetVatRateFromAdmin',
        'testAdminHubConnection',
        'getHelperVatRate',
        'refreshHelperVatRate'
      ];
      
      console.log('🔍 Checking admin hub function availability:');
      functions.forEach(funcName => {
        const available = typeof window[funcName] === 'function';
        console.log(`${available ? '✅' : '❌'} ${funcName}: ${available ? 'Available' : 'Not found'}`);
      });
      
      // Check MathEngine availability
      const mathEngineAvailable = typeof MathEngine !== 'undefined';
      console.log(`${mathEngineAvailable ? '✅' : '❌'} MathEngine: ${mathEngineAvailable ? 'Available' : 'Not found'}`);
      
      if (mathEngineAvailable) {
        console.log(`📊 Current VAT rate from MathEngine: ${MathEngine.getVatRate()}%`);
      }
      
      return {
        functions: functions.reduce((acc, func) => ({ ...acc, [func]: typeof window[func] === 'function' }), {}),
        mathEngine: mathEngineAvailable,
        currentVat: mathEngineAvailable ? MathEngine.getVatRate() : null
      };
    };
    
    // ENSURE DATA FLOW: Update dependent fields when source data changes
    function refreshAllCalculations() {
      try {
        console.log('🔄 Starting calculation refresh...');
        
        // 0. Ensure basic price is populated from helper if empty
        ensureBasicPriceFromHelper();
        
        // 1. Update total claim from damage centers
        const totalClaim = calculateTotalClaimFromDamageCenters();
        const totalClaimField = document.getElementById('totalClaim');
        if (totalClaimField) {
          totalClaimField.value = totalClaim ? `₪${totalClaim.toLocaleString()}` : '₪0';
          console.log(`💰 Updated totalClaim: ${totalClaim}`);
        }
        
        // 2. Update gross market value from basic price + adjustments
        // Only if helper data has been loaded (to avoid overriding helper data)
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        if (helper && Object.keys(helper).length > 0 && typeof updateGrossMarketValueCalculation === 'function') {
          updateGrossMarketValueCalculation();
          console.log('📊 Updated gross market value');
        }
        
        // 3. Update damage percentage: totalClaim / grossMarketValue * 100
        if (typeof updateGrossPercentageField === 'function') {
          updateGrossPercentageField();
          console.log('📈 Updated damage percentage');
        }
        
        // 4. Update full market value from basic price + all adjustments
        if (typeof calculateFullMarketValue === 'function') {
          calculateFullMarketValue();
          console.log('🏪 Updated full market value');
        }
        
        console.log('✅ All calculations refreshed');
      } catch (error) {
        console.error('❌ Error refreshing calculations:', error);
      }
    }
    
    // Ensure basic price field is populated from helper data
    function ensureBasicPriceFromHelper() {
      try {
        const basicPriceField = document.getElementById('basicPrice');
        if (!basicPriceField) return;
        
        // Only update if field is empty
        if (basicPriceField.value && basicPriceField.value.trim() !== '') return;
        
        // 🔧 PHASE 2.4: Get helper data from single source (window.helper)
        const helper = window.helper || {};
        let basePrice = 0;
        
        // Try multiple helper paths for base price
        if (helper.valuation?.base_price) {
          basePrice = parseFloat(helper.valuation.base_price.toString().replace(/[₪,]/g, ''));
        } else if (helper.levi_report?.base_price) {
          basePrice = parseFloat(helper.levi_report.base_price);
        } else if (helper.expertise?.levi_report?.base_price) {
          basePrice = parseFloat(helper.expertise.levi_report.base_price);
        } else if (helper.car_details?.base_price) {
          basePrice = parseFloat(helper.car_details.base_price.toString().replace(/[₪,]/g, ''));
        }
        
        if (basePrice > 0) {
          basicPriceField.value = `₪${basePrice.toLocaleString()}`;
          console.log(`💵 Populated basicPrice from helper: ${basePrice}`);
        }
      } catch (error) {
        console.error('❌ Error ensuring basic price from helper:', error);
      }
    }
    
    // Expose refresh function globally
    window.refreshAllCalculations = refreshAllCalculations;
    
    // NUCLEAR FIX FOR ALL MANUAL INPUT FIELDS
    function forceManualFieldsEditable() {
      const fieldsToFix = [
        {
          id: 'saleValueDamage',
          placeholder: 'הזן ערך המכירה...',
          label: 'Sale Value Damage',
          callback: function() {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[₪,]/g, '')) || 0;
            calculateDamagedSaleReport(helper, marketValue).catch(console.error);
          }
        },
        {
          id: 'salvageValueTotal',
          placeholder: 'הזן ערך שרידים...',
          label: 'Salvage Value Total',
          callback: function() {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[₪,]/g, '')) || 0;
            calculateTotalLossReport(helper, marketValue);
          }
        },
        {
          id: 'storageValueTotal',
          placeholder: 'הזן עלות גרירה ואחסנה...',
          label: 'Storage Value Total',
          callback: function() {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[₪,]/g, '')) || 0;
            calculateTotalLossReport(helper, marketValue);
          }
        },
        {
          id: 'salvageValueLegal',
          placeholder: 'הזן ערך שרידים...',
          label: 'Salvage Value Legal',
          callback: function() {
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            const marketValue = parseFloat(String(helper.calculations?.full_market_value || 0).replace(/[₪,]/g, '')) || 0;
            calculateLegalLossReport(helper, marketValue);
          }
        }
      ];

      fieldsToFix.forEach(fieldConfig => {
        const field = document.getElementById(fieldConfig.id);
        if (field) {
          console.log(`🚨 FORCING ${fieldConfig.id} to be editable...`);
          
          // Nuclear option - completely reset the field
          const parent = field.parentNode;
          const newField = document.createElement('input');
          newField.type = 'text';
          newField.id = fieldConfig.id;
          newField.placeholder = fieldConfig.placeholder;
          newField.style.cssText = 'width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; background: white; color: #333;';
          
          // LOAD SAVED VALUE FROM HELPER
          const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
          const helperKey = getHelperMappingKey(fieldConfig.id);
          if (helperKey && helper.final_report?.summary?.[helperKey]) {
            newField.value = helper.final_report.summary[helperKey];
            console.log(`📖 Restored ${fieldConfig.id} value: ${newField.value}`);
          }
          
          // Add event listener with specific callback AND persistence
          newField.addEventListener('input', function(e) {
            console.log(`💰 ${fieldConfig.label} changed:`, e.target.value);
            
            // Save to helper immediately
            const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
            if (!helper.final_report) helper.final_report = {};
            if (!helper.final_report.summary) helper.final_report.summary = {};
            
            const helperKey = getHelperMappingKey(fieldConfig.id);
            if (helperKey) {
              helper.final_report.summary[helperKey] = e.target.value;
              sessionStorage.setItem('helper', JSON.stringify(helper));
              window.helper = helper;
              console.log(`💾 Saved ${fieldConfig.id} to helper.final_report.summary.${helperKey}`);
            }
            
            // Trigger calculation
            if (fieldConfig.callback) {
              fieldConfig.callback();
            }
          });
          
          // Replace the problematic field
          parent.replaceChild(newField, field);
          console.log(`✅ ${fieldConfig.id} field replaced with editable version`);
        }
      });
    }

    // Load differential data on page load
    document.addEventListener('DOMContentLoaded', function() {
      console.log('📖 Loading saved differential data...');
      setTimeout(loadDifferentialData, 1000); // Increased delay to ensure all other loading is complete
      
      // Initialize differential fields visibility based on checkbox state
      setTimeout(() => {
        toggleDifferentialsTable(); // This will properly show/hide the "לאחר הפרשים" fields
        console.log('✅ Initialized differential fields visibility');
      }, 1200);
      
      // Fix all manual input fields
      setTimeout(forceManualFieldsEditable, 1500);
    });
    
    // Also try loading after the main data loading is complete
    window.addEventListener('load', function() {
      console.log('📖 Loading differential data after full page load...');
      setTimeout(loadDifferentialData, 500);
    });
    
    // Auto-trigger calculation refresh when key data changes
    document.addEventListener('DOMContentLoaded', function() {
      console.log('🚀 Setting up data flow observers...');
      
      // Refresh calculations when damage centers are updated
      const damageCentersElement = document.getElementById('damageCentersContent');
      if (damageCentersElement) {
        const observer = new MutationObserver(function(mutations) {
          console.log('👀 Damage centers changed, refreshing calculations...');
          setTimeout(refreshAllCalculations, 300);
        });
        observer.observe(damageCentersElement, { childList: true, subtree: true });
        console.log('👀 Damage centers observer set up');
      }
      
      // Refresh calculations when basicPrice field changes
      const basicPriceField = document.getElementById('basicPrice');
      if (basicPriceField) {
        basicPriceField.addEventListener('input', function() {
          console.log('💵 Basic price changed, refreshing calculations...');
          setTimeout(refreshAllCalculations, 100);
        });
        console.log('💵 BasicPrice observer set up');
      }
      
      // Initialize VAT display on page load
      setTimeout(function() {
        if (typeof window.initVatDisplay === 'function') {
          window.initVatDisplay();
          console.log('🏛️ VAT display initialized');
        }
      }, 1000);
      
      // Initial calculation refresh on page load (delayed to allow helper data to load first)
      // TEMPORARILY DISABLED to check if this is causing configuration issues
      // setTimeout(refreshAllCalculations, 2000);
    });
    
  </script>
  
  <script type="module">
    // Import and make MathEngine globally available
    import { MathEngine } from './math.js';
    
    // Make MathEngine available globally for other scripts
    window.MathEngine = MathEngine;
    
    // Log that MathEngine is now available
    console.log('✅ MathEngine loaded and available globally');
    
    // Dispatch event to notify other scripts MathEngine is ready
    window.dispatchEvent(new CustomEvent('mathEngineReady', { 
      detail: { MathEngine: MathEngine } 
    }));
  </script>
  
  <script>
    // 🔧 IMMEDIATE FUNCTIONS - Available right away for testing
    window.quickVatTest = function() {
      console.log('🔍 Quick VAT Test:');
      console.log('MathEngine available:', typeof MathEngine !== 'undefined');
      console.log('Helper VAT function:', typeof window.getHelperVatRate === 'function');
      console.log('Current VAT:', window.getHelperVatRate ? window.getHelperVatRate() : 'Not available');
      console.log('Parent frame detected:', window.parent !== window);
      
      // Test admin hub connection immediately
      if (window.parent && window.parent !== window) {
        console.log('📡 Sending test message to admin hub...');
        window.parent.postMessage({ type: 'GET_VAT_RATE' }, '*');
        
        // Listen for response
        const responseListener = (event) => {
          if (event.data && event.data.type === 'VAT_RATE_RESPONSE') {
            window.removeEventListener('message', responseListener);
            console.log('✅ Admin hub responded with VAT:', event.data.vatRate + '%');
          }
        };
        window.addEventListener('message', responseListener);
        
        // Timeout if no response
        setTimeout(() => {
          window.removeEventListener('message', responseListener);
          console.log('⏰ No response from admin hub after 2 seconds');
        }, 2000);
      }
    };
    
    // Make it available immediately
    console.log('🚀 Quick test available: quickVatTest()');
    
    
    // PICTURE-IN-PICTURE OVERLAY FUNCTION
    function openInPiP(url, title) {
      console.log('🖼️ Creating PiP overlay for:', url);
      
      // Remove any existing PiP windows
      const existingPiP = document.getElementById('pipOverlay');
      if (existingPiP) {
        existingPiP.remove();
      }
      
      // Create overlay container
      const overlay = document.createElement('div');
      overlay.id = 'pipOverlay';
      
      // Get viewport dimensions for responsive sizing
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const isMobile = viewportWidth <= 768;
      
      // Calculate responsive dimensions and center positioning
      const width = isMobile ? Math.min(viewportWidth - 20, 350) : Math.min(800, viewportWidth - 100);
      const height = isMobile ? Math.min(viewportHeight - 100, 500) : Math.min(600, viewportHeight - 100);
      const top = Math.max(10, (viewportHeight - height) / 2);
      const left = Math.max(10, (viewportWidth - width) / 2);
      
      overlay.style.cssText = `
        position: fixed;
        top: ${top}px;
        left: ${left}px;
        width: ${width}px;
        height: ${height}px;
        background: white;
        border: 2px solid #1e3a8a;
        border-radius: 12px;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        z-index: 10000;
        display: flex;
        flex-direction: column;
        resize: ${isMobile ? 'none' : 'both'};
        overflow: hidden;
        font-family: inherit;
        max-width: 95vw;
        max-height: 95vh;
      `;
      
      // Create header with title and controls
      const header = document.createElement('div');
      header.style.cssText = `
        background: #1e3a8a;
        color: white;
        padding: ${isMobile ? '8px 12px' : '12px 16px'};
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: move;
        border-radius: 10px 10px 0 0;
        font-size: ${isMobile ? '12px' : '14px'};
        font-weight: bold;
        min-height: ${isMobile ? '40px' : '48px'};
        box-sizing: border-box;
      `;
      header.innerHTML = `
        <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${title}</span>
        <button onclick="document.getElementById('pipOverlay').remove()" style="
          background: none;
          border: none;
          color: white;
          font-size: ${isMobile ? '20px' : '18px'};
          cursor: pointer;
          padding: 0;
          width: ${isMobile ? '32px' : '24px'};
          height: ${isMobile ? '32px' : '24px'};
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          flex-shrink: 0;
          touch-action: manipulation;
        " onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='none'" ontouchstart="this.style.background='rgba(255,255,255,0.2)'" ontouchend="this.style.background='none'">×</button>
      `;
      
      // Create iframe container
      const iframeContainer = document.createElement('div');
      iframeContainer.style.cssText = `
        flex: 1;
        overflow: hidden;
        position: relative;
      `;
      
      // Create iframe
      const iframe = document.createElement('iframe');
      iframe.src = url;
      iframe.style.cssText = `
        width: 100%;
        height: 100%;
        border: none;
        background: white;
      `;
      iframe.onload = function() {
        console.log('✅ PiP iframe loaded successfully');
      };
      iframe.onerror = function() {
        console.error('❌ PiP iframe failed to load');
        iframeContainer.innerHTML = `
          <div style="padding: 20px; text-align: center; color: #666;">
            <p>שגיאה בטעינת התוכן</p>
            <button onclick="window.open('${url}', '_blank')" style="
              background: #1e3a8a;
              color: white;
              border: none;
              padding: 10px 20px;
              border-radius: 6px;
              cursor: pointer;
              margin-top: 10px;
            ">פתח בחלון חדש</button>
          </div>
        `;
      };
      
      // Assemble the PiP window
      iframeContainer.appendChild(iframe);
      overlay.appendChild(header);
      overlay.appendChild(iframeContainer);
      document.body.appendChild(overlay);
      
      // Make draggable
      let isDragging = false;
      let startX, startY, initialX, initialY;
      
      header.addEventListener('mousedown', function(e) {
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        initialX = overlay.offsetLeft;
        initialY = overlay.offsetTop;
        overlay.style.cursor = 'grabbing';
      });
      
      document.addEventListener('mousemove', function(e) {
        if (isDragging) {
          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;
          overlay.style.left = (initialX + deltaX) + 'px';
          overlay.style.top = (initialY + deltaY) + 'px';
        }
      });
      
      document.addEventListener('mouseup', function() {
        isDragging = false;
        overlay.style.cursor = 'default';
      });
      
      console.log('✅ PiP overlay created successfully');
      
      // Add window resize listener to maintain responsiveness
      window.addEventListener('resize', function() {
        const currentOverlay = document.getElementById('pipOverlay');
        if (currentOverlay) {
          const newViewportWidth = window.innerWidth;
          const newViewportHeight = window.innerHeight;
          const newIsMobile = newViewportWidth <= 768;
          
          // Update dimensions and center on resize
          const newWidth = newIsMobile ? Math.min(newViewportWidth - 20, 350) : Math.min(800, newViewportWidth - 100);
          const newHeight = newIsMobile ? Math.min(newViewportHeight - 100, 500) : Math.min(600, newViewportHeight - 100);
          const newTop = Math.max(10, (newViewportHeight - newHeight) / 2);
          const newLeft = Math.max(10, (newViewportWidth - newWidth) / 2);
          
          currentOverlay.style.width = newWidth + 'px';
          currentOverlay.style.height = newHeight + 'px';
          currentOverlay.style.top = newTop + 'px';
          currentOverlay.style.left = newLeft + 'px';
          currentOverlay.style.right = 'auto';
          currentOverlay.style.resize = newIsMobile ? 'none' : 'both';
          currentOverlay.style.maxWidth = '95vw';
          currentOverlay.style.maxHeight = '95vh';
        }
      });
    }

    // LOCAL GENERATION FUNCTIONS - No webhooks needed, skip validation
    window.generateEstimateReport = function() {
      console.log('🔧 Generating estimate report locally...');
      console.log('✅ GenerateEstimateReport function called successfully!');
      
      // Get current helper data or plate from input
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const plateInput = document.getElementById('builderPlateInput');
      const currentPlate = helper.plate || helper.מספר_רכב || helper['מס רכב'] || (plateInput ? plateInput.value.trim() : '');
      
      console.log('📋 Current plate for estimate:', currentPlate);
      console.log('📊 Current helper data:', helper);
      
      // If no plate in helper but there's one in input, create minimal helper structure
      if (!currentPlate && plateInput && plateInput.value.trim()) {
        const plateValue = plateInput.value.trim();
        console.log('📝 Creating minimal helper structure with plate:', plateValue);
        
        // Create basic helper structure with plate
        const minimalHelper = {
          plate: plateValue,
          מספר_רכב: plateValue,
          meta: {
            case_id: `case_${plateValue}_${Date.now()}`,
            created_at: new Date().toISOString()
          }
        };
        
        // Merge with existing helper if any
        const updatedHelper = { ...helper, ...minimalHelper };
        sessionStorage.setItem('helper', JSON.stringify(updatedHelper));
        window.helper = updatedHelper;
      }
      
      // Skip saving final report data for direct report generation (avoids validation)
      console.log('⏭️ Skipping final report save for direct report generation...');
      
      // Set multiple flags to ensure estimate builder skips validation
      const reportConfig = {
        selectedReportType: 'estimate',
        skipValidation: true,
        autoSelectReportType: 'estimate',
        skipReportTypeDialog: true,
        directGeneration: true,
        fromFinalReportBuilder: 'true',
        reportTypeSelected: true,
        timestamp: new Date().toISOString()
      };
      
      // Set individual items including the bypass flag
      Object.keys(reportConfig).forEach(key => {
        sessionStorage.setItem(key, String(reportConfig[key]));
      });
      
      // Also set as complete config object
      sessionStorage.setItem('reportConfig', JSON.stringify(reportConfig));
      
      console.log('🚀 Navigating directly to estimate builder...');
      console.log('📋 Report configuration set:', reportConfig);
      
      // Navigate directly to estimate builder, bypassing fee-module and report selection
      setTimeout(() => {
        const finalPlate = helper.plate || helper.מספר_רכב || helper['מס רכב'] || (plateInput ? plateInput.value.trim() : '');
        const urlWithParams = `estimate-report-builder.html?plate=${encodeURIComponent(finalPlate)}&skipValidation=true&fromFinalReportBuilder=true`;
        console.log('🎯 Direct navigation to estimate report builder:', urlWithParams);
        
        try {
          // Create a proper PiP window using iframe approach
          openInPiP(urlWithParams, 'Estimate Report Builder');
        } catch (error) {
          console.warn('⚠️ PiP opening failed, trying fallback navigation:', error);
          window.location.href = 'estimate-report-builder.html?skipValidation=true&fromFinalReportBuilder=true';
        }
      }, 100);
    };
    
    window.generateExpertiseReport = function() {
      console.log('🔧 Generating expertise report locally...');
      console.log('✅ GenerateExpertiseReport function called successfully!');
      
      // Get current helper data or plate from input  
      const helper = window.helper || JSON.parse(sessionStorage.getItem('helper') || '{}');
      const plateInput = document.getElementById('builderPlateInput');
      const currentPlate = helper.plate || helper.מספר_רכב || helper['מס רכב'] || (plateInput ? plateInput.value.trim() : '');
      
      console.log('📋 Current plate for expertise:', currentPlate);
      console.log('📊 Current helper data:', helper);
      
      // If no plate in helper but there's one in input, create minimal helper structure
      if (!currentPlate && plateInput && plateInput.value.trim()) {
        const plateValue = plateInput.value.trim();
        console.log('📝 Creating minimal helper structure with plate:', plateValue);
        
        // Create basic helper structure with plate
        const minimalHelper = {
          plate: plateValue,
          מספר_רכב: plateValue,
          meta: {
            case_id: `case_${plateValue}_${Date.now()}`,
            created_at: new Date().toISOString()
          }
        };
        
        // Merge with existing helper if any
        const updatedHelper = { ...helper, ...minimalHelper };
        sessionStorage.setItem('helper', JSON.stringify(updatedHelper));
        window.helper = updatedHelper;
      }
      
      // Skip saving final report data for direct report generation (avoids validation)
      console.log('⏭️ Skipping final report save for direct report generation...');
      
      // Set multiple flags to ensure fee module gets the message
      const reportConfig = {
        selectedReportType: 'expertise',
        skipValidation: true,
        autoSelectReportType: 'expertise',
        skipReportTypeDialog: true,
        directGeneration: true,
        fromFinalReportBuilder: true,
        reportTypeSelected: true,
        timestamp: new Date().toISOString()
      };
      
      // Set individual items
      Object.keys(reportConfig).forEach(key => {
        sessionStorage.setItem(key, String(reportConfig[key]));
      });
      
      // Also set as complete config object
      sessionStorage.setItem('reportConfig', JSON.stringify(reportConfig));
      
      console.log('🚀 Navigating directly to expertise builder...');
      console.log('📋 Report configuration set:', reportConfig);
      
      // Navigate directly to expertise builder, bypassing fee-module and report selection
      setTimeout(() => {
        const finalPlate = helper.plate || helper.מספר_רכב || helper['מס רכב'] || (plateInput ? plateInput.value.trim() : '');
        const urlWithParams = `expertise builder.html?plate=${encodeURIComponent(finalPlate)}&skipValidation=true&fromFinalReportBuilder=true`;
        console.log('🎯 Direct navigation to expertise builder:', urlWithParams);
        
        try {
          // Create a proper PiP window using iframe approach
          openInPiP(urlWithParams, 'Expertise Builder');
        } catch (error) {
          console.warn('⚠️ PiP opening failed, trying fallback navigation:', error);
          window.location.href = 'expertise builder.html?skipValidation=true&fromFinalReportBuilder=true';
        }
      }, 100);
    };
    
    console.log('✅ Local generation functions defined:', {
      generateEstimateReport: typeof window.generateEstimateReport,
      generateExpertiseReport: typeof window.generateExpertiseReport
    });
    
    // FORCE PLATE INPUT TO BE PLAIN TEXT - Keep password type for autofill but prevent dots
    window.forcePlateInputAsText = function() {
      const plateInput = document.getElementById('builderPlateInput');
      if (plateInput) {
        // Keep type as password for autofill, but override the visual display
        plateInput.style.webkitTextSecurity = 'none';
        plateInput.style.textSecurity = 'none';
        plateInput.style.fontFamily = 'inherit';
        plateInput.style.letterSpacing = 'normal';
        plateInput.style.fontSize = '16px';
        
        // Additional CSS to prevent password styling
        plateInput.style.setProperty('-webkit-text-security', 'none', 'important');
        plateInput.style.setProperty('text-security', 'none', 'important');
        
        console.log('🔢 Plate input configured for autofill with plain text display');
      }
    };
    
    // Apply the fix immediately and on DOM ready
    setTimeout(window.forcePlateInputAsText, 100);
    document.addEventListener('DOMContentLoaded', window.forcePlateInputAsText);
    
    // Enhanced event listeners to maintain plain text display
    document.addEventListener('DOMContentLoaded', function() {
      const plateInput = document.getElementById('builderPlateInput');
      if (plateInput) {
        // Apply fixes on various events
        plateInput.addEventListener('focus', window.forcePlateInputAsText);
        plateInput.addEventListener('input', window.forcePlateInputAsText);
        plateInput.addEventListener('change', window.forcePlateInputAsText);
        plateInput.addEventListener('keyup', window.forcePlateInputAsText);
        plateInput.addEventListener('blur', window.forcePlateInputAsText);
        
        // Monitor for autofill
        setInterval(function() {
          if (plateInput.value && plateInput.style.webkitTextSecurity !== 'none') {
            window.forcePlateInputAsText();
          }
        }, 500);
        
        console.log('✅ Enhanced plate input event listeners configured');
      }
    });
    
    // Test MathEngine loading
    window.testMathEngineLoading = function() {
      console.log('🧪 Testing MathEngine loading status...');
      console.log('MathEngine available:', typeof MathEngine !== 'undefined');
      console.log('MathEngine.getVatRate available:', typeof MathEngine?.getVatRate === 'function');
      
      if (typeof MathEngine !== 'undefined' && MathEngine.getVatRate) {
        console.log('✅ MathEngine VAT rate:', MathEngine.getVatRate() + '%');
      } else {
        console.log('⚠️ MathEngine not fully loaded yet');
      }
      
      // Test helper fallback
      if (typeof window.getHelperVatRate === 'function') {
        console.log('✅ Helper VAT rate:', window.getHelperVatRate() + '%');
      }
    };
    
    // Test admin VAT change simulation
    window.simulateAdminVatChange = function(newVatRate = 19) {
      console.log(`🧪 Simulating admin VAT change to ${newVatRate}%...`);
      console.log('📊 BEFORE - helper.calculations.vat_rate:', window.helper?.calculations?.vat_rate);
      
      // Simulate the message that admin hub would send
      const simulatedMessage = {
        data: {
          type: 'VAT_RATE_UPDATED',
          vatRate: newVatRate,
          timestamp: Date.now()
        },
        origin: '*',
        source: window
      };
      
      // Trigger the message handler manually
      window.dispatchEvent(new MessageEvent('message', simulatedMessage));
      
      // Check result after a short delay
      setTimeout(() => {
        console.log('📊 AFTER - helper.calculations.vat_rate:', window.helper?.calculations?.vat_rate);
        console.log('📊 AFTER - getHelperVatRate():', window.getHelperVatRate ? window.getHelperVatRate() : 'function not available');
      }, 200);
    };
  </script>
  <script type="module" src="./helper-events.js"></script>
  <!-- TEMPORARILY DISABLED - conflicts with differential structure -->
  <!-- <script type="module" src="./depreciation_module.js"></script> -->
  
  <!-- Floating PDF Display Component -->
  <div id="floatingPdfOverlay" class="floating-pdf-overlay" style="display: none;">
    <div class="floating-pdf-container">
      <div class="floating-pdf-header">
        <h3 id="floatingPdfTitle">מציג PDF</h3>
        <div class="floating-pdf-controls">
          <button id="togglePdfBtn" class="toggle-btn">_</button>
          <button id="closePdfBtn" class="close-btn">×</button>
        </div>
      </div>
      <div id="floatingPdfContent" class="floating-pdf-content">
        <iframe id="pdfViewer" src="" width="100%" height="100%" frameborder="0"></iframe>
      </div>
    </div>
  </div>
  
  <script type="module" src="auth.js"></script>
  <script src="helper.js" type="module"></script>
  
  <script>
    // 🏛️ INITIALIZE ADMIN HUB COMMUNICATION AFTER ALL MODULES LOADED
    window.addEventListener('load', function() {
      // Wait a bit more for modules to finish loading
      setTimeout(() => {
        console.log('🔌 Now initializing admin hub communication after all modules loaded...');
        
        // Check if helper VAT function is available
        if (typeof window.setHelperVatRateFromAdmin === 'function') {
          console.log('✅ setHelperVatRateFromAdmin function is available');
        } else {
          console.log('❌ setHelperVatRateFromAdmin function NOT available');
        }
        
        // Initialize admin hub communication
        if (typeof initAdminHubCommunication === 'function') {
          initAdminHubCommunication();
        }
        
        // Initialize VAT display
        if (typeof window.initVatDisplay === 'function') {
          window.initVatDisplay();
        }
        
        console.log('🎯 Admin hub communication initialized. Testing functions available:');
        console.log('- simulateAdminVatChange(19) - Test admin VAT change');
        console.log('- testMathEngineLoading() - Test MathEngine status');
        console.log('- testCompleteVatFlow() - Test entire VAT flow');
        
        // Create comprehensive VAT flow test
        window.testCompleteVatFlow = function() {
          console.log('🧪 Testing complete VAT flow: Admin → Helper → All UI');
          console.log('═══════════════════════════════════════════════');
          
          // Step 1: Check current state
          console.log('📊 STEP 1: Current VAT State');
          console.log('helper.calculations.vat_rate:', window.helper?.calculations?.vat_rate);
          console.log('getHelperVatRate():', window.getHelperVatRate ? window.getHelperVatRate() : 'N/A');
          console.log('MathEngine.getVatRate():', typeof MathEngine !== 'undefined' ? MathEngine.getVatRate() : 'N/A');
          
          // Step 2: Test helper function availability
          console.log('📊 STEP 2: Function Availability');
          console.log('setHelperVatRateFromAdmin:', typeof window.setHelperVatRateFromAdmin === 'function');
          console.log('getHelperVatRate:', typeof window.getHelperVatRate === 'function');
          console.log('initVatDisplay:', typeof window.initVatDisplay === 'function');
          
          // Step 3: Test admin → helper flow
          console.log('📊 STEP 3: Testing Admin → Helper Flow');
          if (typeof window.setHelperVatRateFromAdmin === 'function') {
            const testRate = 19;
            console.log(`Setting helper VAT to ${testRate}% directly...`);
            const success = window.setHelperVatRateFromAdmin(testRate, 'test_admin');
            console.log('Helper update success:', success);
            
            setTimeout(() => {
              console.log('📊 STEP 4: Verification');
              console.log('helper.calculations.vat_rate after update:', window.helper?.calculations?.vat_rate);
              console.log('getHelperVatRate() after update:', window.getHelperVatRate());
              
              // Step 5: Test if UI updates
              console.log('📊 STEP 5: UI Update Test');
              const vatInput = document.getElementById('vat-rate-input');
              if (vatInput) {
                console.log('VAT input field value:', vatInput.value);
                console.log('Expected:', testRate, 'Actual:', parseFloat(vatInput.value));
                console.log('UI updated correctly:', parseFloat(vatInput.value) === testRate);
              } else {
                console.log('VAT input field not found');
              }
              
              console.log('═══════════════════════════════════════════════');
              console.log('✅ VAT flow test completed');
            }, 200);
          } else {
            console.log('❌ Cannot test - setHelperVatRateFromAdmin not available');
          }
        };
        
      }, 500);
    });
  </script>

  <!-- GENERATION BUTTONS - Static at bottom -->
  <div style="margin: 30px auto; max-width: 800px; padding: 20px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
    <div style="text-align: center; font-weight: bold; color: #1e3a8a; margin-bottom: 15px; font-size: 16px;">
      🚀 הפקת מסמכים על בסיס התיק הנוכחי
    </div>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; max-width: 500px; margin: 0 auto;">
      <button class="nav-btn" id="generateEstimateBtn" onclick="generateEstimateReport()" style="background: #ea580c; color: white; font-size: 14px; padding: 12px; border-radius: 6px;">
        צור אומדן ראשוני
      </button>
      <button class="nav-btn" id="generateExpertiseBtn" onclick="generateExpertiseReport()" style="background: #059669; color: white; font-size: 14px; padding: 12px; border-radius: 6px;">
        צור אקספירטיזה
      </button>
    </div>
    <div style="font-size: 12px; color: #6b7280; text-align: center; margin-top: 10px;">
      לא נדרש הכנסת מספר רכב נוסף - עובד על בסיס הנתונים הקיימים
    </div>
  </div>



  <script src="internal-browser.js"></script>
  <script src="levi-floating.js"></script>
  <script src="car-details-floating.js"></script>
  <script src="invoice-details-floating.js"></script>
  <script src="parts-search-results-floating.js"></script>
  <script src="password-prefill.js"></script>
  <script src="final_report.js" type="module"></script>
</body>
</html>