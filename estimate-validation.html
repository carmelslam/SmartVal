<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>××™××•×ª ××•××“×Ÿ - ×™×¨×•×Ÿ ×›×™×•×£ ×©×××•×ª</title>
  <link rel="icon" type="image/webp" href="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp">
  
  <!-- OneSignal Push -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#ffffff">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">

  <script src="https://cdn.onesignal.com/sdks/web/v16/OneSignalSDK.page.js" defer></script>
  <script>
    window.OneSignalDeferred = window.OneSignalDeferred || [];
    OneSignalDeferred.push(async function(OneSignal) {
      await OneSignal.init({
        appId: "3b924b99-c302-4919-a97e-baf909394696",
      });
    });
  </script>

  <style>
    body {
      font-family: sans-serif;
      background: #f3f6fb;
      margin: 0;
      min-height: 100vh;
      padding: 0;
      padding-top: 90px;
      overflow-x: hidden;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .container {
      max-width: 1000px;
      background: white;
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 0 20px rgba(0,0,0,0.1);
      width: 100%;
      margin: 20px;
    }
    .logo img {
      width: 120px;
      margin-bottom: 40px;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }
    .title {
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 5px;
      color: #1e3a8a;
    }
    .subtitle {
      font-size: 18px;
      color: #64748b;
      text-align: center;
      margin-bottom: 30px;
    }
    h1 {
      font-size: 22px;
      color: #1e3a8a;
      text-align: center;
      margin-bottom: 30px;
    }
    .validation-section {
      background: #f8fafc;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      transition: all 0.3s ease;
    }
    .validation-section.completed {
      border-color: #16a34a;
      background: #f0fdf4;
    }
    .validation-section.current {
      border-color: #3b82f6;
      background: #eff6ff;
    }
    .validation-section.error {
      border-color: #dc2626;
      background: #fef2f2;
    }
    .validation-section.warning {
      border-color: #f59e0b;
      background: #fefbf2;
    }
    .validation-section.disabled {
      border-color: #d1d5db;
      background: #f9fafb;
      opacity: 0.6;
      cursor: not-allowed;
    }
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    .section-title {
      font-size: 18px;
      font-weight: bold;
      color: #1e3a8a;
    }
    .section-status {
      padding: 5px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: bold;
    }
    .status-pending {
      background: #fef3c7;
      color: #92400e;
    }
    .status-current {
      background: #dbeafe;
      color: #1d4ed8;
    }
    .status-completed {
      background: #dcfce7;
      color: #166534;
    }
    .status-error {
      background: #fecaca;
      color: #991b1b;
    }
    .status-warning {
      background: #fef3c7;
      color: #92400e;
    }
    .section-content {
      color: #475569;
      line-height: 1.6;
    }
    .validation-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid #e2e8f0;
    }
    .validation-item:last-child {
      border-bottom: none;
    }
    .validation-label {
      font-weight: 500;
      color: #374151;
      flex: 1;
    }
    .validation-value {
      font-weight: 600;
      color: #1e3a8a;
    }
    .validation-status {
      font-size: 18px;
    }
    
    /* Enhanced 3-Column Validation Display */
    .validation-item-enhanced {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 15px;
      padding: 15px 0;
      border-bottom: 1px solid #e2e8f0;
      align-items: center;
    }
    .validation-item-enhanced:last-child {
      border-bottom: none;
    }
    .validation-columns {
      display: grid;
      grid-template-columns: 1fr 1fr auto;
      gap: 10px;
      align-items: center;
    }
    .current-value {
      font-weight: 600;
      color: #1e3a8a;
      padding: 8px 12px;
      background: #f0f9ff;
      border-radius: 6px;
      border: 1px solid #bae6fd;
    }
    .stored-value {
      font-weight: 500;
      color: #64748b;
      padding: 8px 12px;
      background: #f8fafc;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
      font-size: 14px;
    }
    .action-buttons {
      display: flex;
      gap: 5px;
    }
    .action-buttons button {
      padding: 6px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.2s;
    }
    .edit-inline {
      background: #3b82f6;
      color: white;
    }
    .edit-inline:hover {
      background: #1e40af;
    }
    .edit-builder {
      background: #64748b;
      color: white;
    }
    .edit-builder:hover {
      background: #475569;
    }
    .ignore {
      background: #f59e0b;
      color: white;
    }
    .ignore:hover {
      background: #d97706;
    }
    
    /* Data consistency indicators */
    .data-match {
      border-color: #16a34a !important;
      background: #f0fdf4 !important;
    }
    .data-warning {
      border-color: #f59e0b !important;
      background: #fefbf2 !important;
    }
    .data-error {
      border-color: #dc2626 !important;
      background: #fef2f2 !important;
    }
    
    /* Inline editing styles */
    .inline-edit-input {
      width: 100%;
      padding: 8px 12px;
      border: 2px solid #3b82f6;
      border-radius: 6px;
      font-weight: 600;
      color: #1e3a8a;
      background: white;
    }
    .inline-edit-input:focus {
      outline: none;
      border-color: #1e40af;
    }
    .cost-summary {
      background: #f1f5f9;
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
    }
    .cost-summary-title {
      font-size: 16px;
      font-weight: bold;
      color: #1e3a8a;
      margin-bottom: 10px;
    }
    .cost-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .cost-item {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
    }
    .cost-label {
      color: #64748b;
    }
    .cost-value {
      font-weight: 600;
      color: #1e3a8a;
    }
    .validation-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
      flex-wrap: wrap;
    }
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      flex: 1;
      min-width: 120px;
    }
    .btn-validate {
      background: #3b82f6;
      color: white;
    }
    .btn-validate:hover {
      background: #1e40af;
    }
    .btn-edit {
      background: #64748b;
      color: white;
    }
    .btn-edit:hover {
      background: #475569;
    }
    .btn-success {
      background: #16a34a;
      color: white;
    }
    .btn-success:hover {
      background: #15803d;
    }
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .damage-center {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }
    .damage-center-header {
      font-weight: bold;
      color: #1e3a8a;
      margin-bottom: 10px;
      border-bottom: 1px solid #e2e8f0;
      padding-bottom: 5px;
    }
    .damage-center-content {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 15px;
      margin-top: 10px;
    }
    .damage-stat {
      text-align: center;
      padding: 10px;
      background: #f8fafc;
      border-radius: 6px;
    }
    .damage-stat-label {
      font-size: 12px;
      color: #64748b;
      margin-bottom: 5px;
    }
    .damage-stat-value {
      font-size: 16px;
      font-weight: bold;
      color: #1e3a8a;
    }
    .levi-adjustments {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
    }
    .levi-adjustments-title {
      font-weight: bold;
      color: #1e3a8a;
      margin-bottom: 10px;
    }
    .adjustment-item {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
      border-bottom: 1px solid #f1f5f9;
    }
    .adjustment-item:last-child {
      border-bottom: none;
    }
    .legal-text-section {
      background: #fef3c7;
      border: 2px solid #f59e0b;
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
    }
    .legal-text-header {
      font-size: 18px;
      font-weight: bold;
      color: #92400e;
      margin-bottom: 15px;
    }
    .legal-text-content {
      background: white;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      padding: 15px;
      min-height: 150px;
      font-size: 14px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      line-height: 1.6;
      resize: vertical;
      width: 100%;
      box-sizing: border-box;
    }
    .user-validation-section {
      background: #eff6ff;
      border: 2px solid #3b82f6;
      border-radius: 12px;
      padding: 25px;
      margin: 20px 0;
    }
    .user-validation-header {
      font-size: 18px;
      font-weight: bold;
      color: #1e3a8a;
      margin-bottom: 15px;
    }
    .final-actions {
      background: #f1f5f9;
      border-radius: 12px;
      padding: 25px;
      text-align: center;
      margin-top: 30px;
    }
    .progress-indicator {
      background: #f1f5f9;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 25px;
    }
    .progress-bar {
      background: #e2e8f0;
      height: 12px;
      border-radius: 6px;
      overflow: hidden;
      margin: 10px 0;
      border: 2px solid #cbd5e1;
    }
    .progress-fill {
      height: 100%;
      border-radius: 4px;
      transition: all 0.5s ease;
      position: relative;
      background: linear-gradient(90deg, #dc2626, #ea580c, #d97706, #ca8a04, #65a30d, #16a34a);
      background-size: 600% 100%;
      animation: progressShine 2s ease-in-out infinite;
    }
    
    /* Progress colors based on percentage */
    .progress-fill.progress-0 {
      background: #6b7280;
    }
    .progress-fill.progress-17 {
      background: linear-gradient(90deg, #dc2626, #ef4444);
    }
    .progress-fill.progress-33 {
      background: linear-gradient(90deg, #ea580c, #f97316);
    }
    .progress-fill.progress-50 {
      background: linear-gradient(90deg, #d97706, #f59e0b);
    }
    .progress-fill.progress-67 {
      background: linear-gradient(90deg, #ca8a04, #eab308);
    }
    .progress-fill.progress-83 {
      background: linear-gradient(90deg, #65a30d, #84cc16);
    }
    .progress-fill.progress-100 {
      background: linear-gradient(90deg, #16a34a, #22c55e);
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.4);
    }
    
    @keyframes progressShine {
      0% {
        background-position: 0% 50%;
      }
      50% {
        background-position: 100% 50%;
      }
      100% {
        background-position: 0% 50%;
      }
    }
    
    .progress-indicator.completed {
      background: linear-gradient(135deg, #f0fdf4, #dcfce7);
      border: 2px solid #16a34a;
    }
    .footer {
      text-align: center;
      margin-top: 30px;
      font-size: 12px;
      color: #64748b;
    }
    @media (max-width: 768px) {
      .container {
        margin: 10px;
        padding: 20px;
      }
      .cost-grid, .damage-center-content {
        grid-template-columns: 1fr;
      }
      .validation-buttons {
        flex-direction: column;
      }
    }
    .alert {
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: none;
    }
    .alert.show {
      display: block;
    }
    .alert.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .alert.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    .alert.warning {
      background: #fff3cd;
      color: #856404;
      border: 1px solid #ffeaa7;
    }
    
    /* FLOATING SCREENS STYLING */
    .floating-toggles-top {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.95);
      padding: 8px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .toggle-square {
      width: 80px;
      height: 70px;
      background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      color: white;
      text-align: center;
      border: 2px solid transparent;
    }

    .toggle-square:hover {
      background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
    }

    .toggle-square.active {
      border-color: #fbbf24;
      box-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
    }

    .toggle-icon {
      font-size: 18px;
      margin-bottom: 2px;
    }

    .toggle-text {
      font-size: 10px;
      font-weight: 600;
      line-height: 1.1;
    }
    
    @media (max-width: 768px) {
      .floating-toggles-top {
        top: 5px;
        gap: 4px;
        padding: 6px;
      }
      .toggle-square {
        width: 65px;
        height: 60px;
      }
      .toggle-icon {
        font-size: 16px;
      }
      .toggle-text {
        font-size: 9px;
      }
    }
  </style>
</head>
<body>
  <!-- FLOATING SCREEN TOGGLES - TOP OF PAGE -->
  <div class="floating-toggles-top">
    <div class="toggle-square" onclick="toggleFloatingScreen('leviReport')">
      <div class="toggle-icon">ğŸ“Š</div>
      <div class="toggle-text">×“×•"×— ×œ×•×™ ×™×¦×—×§</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('carDetails')">
      <div class="toggle-icon">ğŸš—</div>
      <div class="toggle-text">×¤×¨×˜×™ ×¨×›×‘</div>
    </div>
    <div class="toggle-square" onclick="toggleFloatingScreen('internalBrowser')">
      <div class="toggle-icon">ğŸŒ</div>
      <div class="toggle-text">×“×¤×“×¤×Ÿ ×¤× ×™××™</div>
    </div>
  </div>
  
  <div class="container">
    <div class="logo">
      <img src="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp" alt="Logo" />
    </div>
    <div class="title">×™×¨×•×Ÿ ×›×™×•×£ ×©×××•×ª - ×¤×•×¨×˜×œ</div>
    <div class="subtitle">×©×××•×ª ×•×”×¢×¨×›×ª × ×–×§×™ ×¨×›×‘ ×•×¨×›×•×©</div>
    
    <h1>××™××•×ª ××•××“×Ÿ × ×–×§×™ ×¨×›×‘ - ××¢×¨×›×ª ×‘×“×™×§×” ×—×›××”</h1>
    
    <div id="alerts"></div>
    
    <!-- Progress Indicator -->
    <div class="progress-indicator">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <span style="font-weight: 600; color: #1e3a8a;">×”×ª×§×“××•×ª ×”××™××•×ª</span>
        <span id="progress-text">0% ×”×•×©×œ×</span>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
      </div>
    </div>

    <!-- Vehicle and Case Details Validation -->
    <div class="validation-section current" id="section-vehicle">
      <div class="section-header">
        <div class="section-title">×¤×¨×˜×™ ×¨×›×‘ ×•××§×¨×”</div>
        <div class="section-status status-current">×‘×‘×“×™×§×”</div>
      </div>
      <div class="section-content">
        <div style="background: #f8fafc; padding: 10px; border-radius: 6px; margin-bottom: 15px; font-size: 13px; color: #64748b;">
          <strong>×”× ×—×™×•×ª:</strong> ×¢××•×“×ª "×¢×¨×š × ×•×›×—×™" ××¦×™×’×” ××ª ×”× ×ª×•× ×™× ×”××•×¦×’×™× | ×¢××•×“×ª "× ×ª×•× ×™× ×××•×—×¡× ×™×" ××¦×™×’×” ××ª ×”× ×ª×•× ×™× ×‘×¢×–×¨ | × ×™×ª×Ÿ ×œ×¢×¨×•×š ××• ×œ×”×ª×¢×œ× ×××™ ×”×ª×××•×ª
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 10px; margin-bottom: 10px; padding: 8px; background: #e2e8f0; border-radius: 6px; font-weight: 600; font-size: 12px; color: #374151;">
          <div>×©×“×”</div>
          <div style="text-align: center;">×¢×¨×š × ×•×›×—×™</div>
          <div style="text-align: center;">× ×ª×•× ×™× ×××•×—×¡× ×™×</div>
          <div style="text-align: center;">×¤×¢×•×œ×•×ª</div>
        </div>
        
        <div id="vehicle-validation-items">
          <!-- Will be populated by JavaScript -->
        </div>
      </div>
      <div class="validation-buttons">
        <button class="btn btn-validate" onclick="validateSection('vehicle')">×‘×“×•×§ ××•×˜×•××˜×™×ª</button>
        <button class="btn btn-edit" onclick="editSection('vehicle')">×¢×¨×™×›×” ×™×“× ×™×ª</button>
        <button class="btn btn-success" onclick="approveSection('vehicle')" disabled>××™××•×ª ×¤×¨×˜×™ ×¨×›×‘</button>
      </div>
    </div>

    <!-- Levi Report Validation -->
    <div class="validation-section" id="section-levi">
      <div class="section-header">
        <div class="section-title">×“×•"×— ×œ×•×™ ×™×¦×—×§ - ×©×•×•×™ ×¨×›×‘</div>
        <div class="section-status status-pending">×××ª×™×Ÿ</div>
      </div>
      <div class="section-content">
        <div style="background: #f8fafc; padding: 10px; border-radius: 6px; margin-bottom: 15px; font-size: 13px; color: #64748b;">
          <strong>×”× ×—×™×•×ª:</strong> ×¢××•×“×ª "×¢×¨×š × ×•×›×—×™" ××¦×™×’×” ××ª ×”× ×ª×•× ×™× ×”××•×¦×’×™× | ×¢××•×“×ª "× ×ª×•× ×™× ×××•×—×¡× ×™×" ××¦×™×’×” ××ª ×”× ×ª×•× ×™× ×‘×¢×–×¨ | × ×™×ª×Ÿ ×œ×¢×¨×•×š ××• ×œ×”×ª×¢×œ× ×××™ ×”×ª×××•×ª
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 10px; margin-bottom: 10px; padding: 8px; background: #e2e8f0; border-radius: 6px; font-weight: 600; font-size: 12px; color: #374151;">
          <div>×©×“×”</div>
          <div style="text-align: center;">×¢×¨×š × ×•×›×—×™</div>
          <div style="text-align: center;">× ×ª×•× ×™× ×××•×—×¡× ×™×</div>
          <div style="text-align: center;">×¤×¢×•×œ×•×ª</div>
        </div>
        
        <div id="levi-validation-items">
          <!-- Will be populated by JavaScript with enhanced 3-column display -->
        </div>
        
        <!-- Cost Summary -->
        <div class="cost-summary">
          <div class="cost-summary-title">×¡×™×›×•× ×©×•×•×™ ×¨×›×‘</div>
          <div class="cost-grid">
            <div class="cost-item">
              <span class="cost-label">××—×™×¨ ×‘×¡×™×¡:</span>
              <span class="cost-value" id="levi-display-base">â‚ª0</span>
            </div>
            <div class="cost-item">
              <span class="cost-label">×¡×”"×› ×”×ª×××•×ª:</span>
              <span class="cost-value" id="levi-display-adjustments">â‚ª0</span>
            </div>
            <div class="cost-item">
              <span class="cost-label">×©×•×•×™ ×©×•×§ ×¡×•×¤×™:</span>
              <span class="cost-value" id="levi-display-final">â‚ª0</span>
            </div>
          </div>
        </div>
      </div>
      <div class="validation-buttons">
        <button class="btn btn-validate" onclick="validateSection('levi')">×‘×“×•×§ ××•×˜×•××˜×™×ª</button>
        <button class="btn btn-edit" onclick="editSection('levi')">×¢×¨×™×›×” ×™×“× ×™×ª</button>
        <button class="btn btn-success" onclick="approveSection('levi')" disabled>××™××•×ª ×“×•"×— ×œ×•×™</button>
      </div>
    </div>

    <!-- Damage Centers Validation -->
    <div class="validation-section" id="section-damage">
      <div class="section-header">
        <div class="section-title">××•×§×“×™ × ×–×§ ×•××§×¡×¤×¨×˜×™×–×”</div>
        <div class="section-status status-pending">×××ª×™×Ÿ</div>
      </div>
      <div class="section-content">
        <div class="validation-item">
          <span class="validation-label">××¡×¤×¨ ××•×§×“×™ × ×–×§ ××•×’×“×¨×™×</span>
          <span class="validation-status" id="damage-centers-count">â³</span>
        </div>
        <div class="validation-item">
          <span class="validation-label">×¤×™×¨×•×˜ ×¢×‘×•×“×•×ª ×•×ª×™×§×•× ×™×</span>
          <span class="validation-status" id="damage-works">â³</span>
        </div>
        <div class="validation-item">
          <span class="validation-label">×¨×©×™××ª ×—×œ×§×™× × ×“×¨×©×™×</span>
          <span class="validation-status" id="damage-parts">â³</span>
        </div>
        <div class="validation-item">
          <span class="validation-label">×—×™×©×•×‘ ×¢×œ×•×™×•×ª ×›×•×œ×œ</span>
          <span class="validation-status" id="damage-costs">â³</span>
        </div>
        
        <!-- Damage Validation Items -->
        <div id="damage-validation-items">
          <!-- Will be populated by populateDamageValidationItems() -->
        </div>
        
        <!-- Damage Centers Display -->
        <div id="damage-centers-container">
          <!-- Will be populated dynamically -->
        </div>
        
      </div>
      <div class="validation-buttons">
        <button class="btn btn-validate" onclick="validateSection('damage')">×‘×“×•×§ ××•×˜×•××˜×™×ª</button>
        <button class="btn btn-edit" onclick="editSection('damage')">×¢×¨×™×›×” ×™×“× ×™×ª</button>
        <button class="btn btn-success" onclick="approveSection('damage')" disabled>××™××•×ª ××•×§×“×™ × ×–×§</button>
      </div>
    </div>

    <!-- Depreciation Validation -->
    <div class="validation-section" id="section-depreciation">
      <div class="section-header">
        <div class="section-title">×—×™×©×•×‘ ×™×¨×™×“×ª ×¢×¨×š ×œ×¤×™ ××•×§×“×™ × ×–×§</div>
        <div class="section-status status-pending">×××ª×™×Ÿ</div>
      </div>
      <div class="section-content">
        <div style="background: #f8fafc; padding: 10px; border-radius: 6px; margin-bottom: 15px; font-size: 13px; color: #64748b;">
          <strong>×”× ×—×™×•×ª:</strong> ×‘×“×™×§×ª × ×ª×•× ×™ ×™×¨×™×“×ª ×¢×¨×š ×›×¤×™ ×©×”×•×–× ×• ×‘×‘× ××™ ×”××•××“×Ÿ | × ×ª×•× ×™× ××ª×•××ª ××”×‘× ××™ ×•××•×¦×’×™× ×œ××™××•×ª
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 10px; margin-bottom: 10px; padding: 8px; background: #e2e8f0; border-radius: 6px; font-weight: 600; font-size: 12px; color: #374151;">
          <div>×©×“×”</div>
          <div style="text-align: center;">×¢×¨×š × ×•×›×—×™</div>
          <div style="text-align: center;">× ×ª×•× ×™× ×××•×—×¡× ×™×</div>
          <div style="text-align: center;">×¤×¢×•×œ×•×ª</div>
        </div>
        
        <div id="depreciation-validation-items">
          <!-- Depreciation validation items will be populated here -->
        </div>
        
      </div>
      <div class="validation-buttons">
        <button class="btn btn-validate" onclick="validateSection('depreciation')">×‘×“×•×§ ××•×˜×•××˜×™×ª</button>
        <button class="btn btn-edit" onclick="editSection('depreciation')">×¢×¨×™×›×” ×™×“× ×™×ª</button>
        <button class="btn btn-success" onclick="approveSection('depreciation')" disabled>××™××•×ª ×™×¨×™×“×ª ×¢×¨×š</button>
      </div>
    </div>

    <!-- Estimate Calculations and Totals -->
    <div class="validation-section" id="section-calculations">
      <div class="section-header">
        <div class="section-title">×—×™×©×•×‘×™ ××•××“×Ÿ ×•×¡×™×›×•××™×</div>
        <div class="section-status status-pending">×××ª×™×Ÿ</div>
      </div>
      <div class="section-content">
        <!-- Estimate Calculations Validation Items -->
        <div id="calculations-validation-items">
          <!-- Will be populated by populateCalculationsValidationItems() -->
        </div>
        
      </div>
      <div class="validation-buttons">
        <button class="btn btn-validate" onclick="validateSection('calculations')">×‘×“×•×§ ××•×˜×•××˜×™×ª</button>
        <button class="btn btn-edit" onclick="editSection('calculations')">×¢×¨×™×›×” ×™×“× ×™×ª</button>
        <button class="btn btn-success" onclick="approveSection('calculations')" disabled>××™××•×ª ×—×™×©×•×‘×™×</button>
      </div>
    </div>

    <!-- Legal Text Validation -->
    <div class="validation-section" id="section-legal_text">
      <div class="section-header">
        <div class="section-title">××™××•×ª ×˜×§×¡×˜ ××©×¤×˜×™</div>
        <div class="section-status status-pending">×××ª×™×Ÿ</div>
      </div>
      <div class="section-content">
        <div style="margin-bottom: 15px; color: #92400e;">
          ×”×˜×§×¡×˜ ×”××©×¤×˜×™ ×œ×”×œ×Ÿ ×™×™×›×œ×œ ×‘××•××“×Ÿ. × ×™×ª×Ÿ ×œ×¢×¨×•×š ×•×œ×”×ª××™× ×œ×¤×™ ×”×¦×•×¨×š. ×”××¢×¨×›×ª ×‘×“×§×” ××ª ×”×ª×××ª ×”×˜×§×¡×˜ ×œ×¡×•×’ ×”××•××“×Ÿ.
        </div>
        <textarea class="legal-text-content" id="legal-text-content" placeholder="×˜×§×¡×˜ ××©×¤×˜×™ ×™×™×˜×¢×Ÿ ×›××Ÿ..."></textarea>
      </div>
      <div class="validation-buttons">
        <button class="btn btn-validate" onclick="validateSection('legal_text')">×‘×“×•×§ ××•×˜×•××˜×™×ª</button>
        <button class="btn btn-edit" onclick="editSection('legal_text')">×¢×¨×™×›×” ×™×“× ×™×ª</button>
        <button class="btn btn-success" onclick="approveSection('legal_text')" disabled>××™××•×ª ×˜×§×¡×˜ ××©×¤×˜×™</button>
      </div>
    </div>

    <!-- User Manual Validation -->
    <div class="user-validation-section">
      <div class="user-validation-header">××™××•×ª ×‘×¨××ª ×”××©×ª××© - ×¡×§×™×¨×” ×™×“× ×™×ª</div>
      <div style="color: #475569; line-height: 1.6; margin-bottom: 20px;">
        <p><strong>×‘×“×•×§ ××ª ×›×œ ×”× ×ª×•× ×™× ×œ×¢×™×œ ×•×ª×§×Ÿ ×‘××™×“×ª ×”×¦×•×¨×š.</strong> ×”××¢×¨×›×ª ×‘×™×¦×¢×” ×‘×“×™×§×•×ª ××•×˜×•××˜×™×•×ª, ××š × ×“×¨×©×ª ×”×¡×§×™×¨×” ×”×™×“× ×™×ª ×©×œ×š.</p>
        
        <div style="background: #eff6ff; padding: 15px; border-radius: 8px; margin: 15px 0;">
          <strong>××–×”×¨×” ×—×©×•×‘×”:</strong> ×©×™× ×•×™×™× ×©×ª×‘×¦×¢ ×›××Ÿ ×™×”×¤×›×• ×œ×××ª ×”××¢×¨×›×ª ×•×™×•×¨×©××• ×‘××•××“×Ÿ ×”×¡×•×¤×™. ×•×“× ×©×›×œ ×”× ×ª×•× ×™× × ×›×•× ×™× ×œ×¤× ×™ ×”××™×©×•×¨ ×”×¡×•×¤×™.
        </div>
        
        <div style="background: #f0fdf4; padding: 15px; border-radius: 8px; margin: 15px 0;">
          <strong>×”× ×—×™×•×ª ×œ××™××•×ª:</strong>
          <ul style="margin: 10px 0; padding-right: 20px;">
            <li>×•×“× ×©×›×œ ×”× ×ª×•× ×™× ×”×›×¡×¤×™×™× × ×›×•× ×™× ×•×¢×§×‘×™×™×</li>
            <li>×‘×“×•×§ ×©×”×˜×§×¡×˜ ×”××©×¤×˜×™ ××ª××™× ×œ×¡×•×’ ×”××•××“×Ÿ</li>
            <li>×•×•×“× ×©×¤×¨×˜×™ ×”×¨×›×‘ ×•×”×‘×¢×œ×™× × ×›×•× ×™×</li>
            <li>×‘×“×•×§ ×©××•×§×“×™ ×”× ×–×§ ××©×§×¤×™× ××ª ×”××¦×‘ ×‘×¤×•×¢×œ</li>
          </ul>
        </div>
      </div>
      
      <div class="validation-buttons">
        <button class="btn btn-edit" onclick="requestManualReview()">ğŸ”„ ×”×ª×—×œ ××—×“×©</button>
        <button class="btn btn-validate" onclick="saveValidationData()">×©××•×¨ ×©×™× ×•×™×™×</button>
      </div>
    </div>

    <!-- Final Actions -->
    <div class="final-actions">
      <div style="font-size: 18px; font-weight: bold; color: #1e3a8a; margin-bottom: 20px;">
        ×¤×¢×•×œ×•×ª ×¡×™×•×
      </div>
      <div style="color: #64748b; margin-bottom: 25px;">
        ×œ××—×¨ ×”××™×©×•×¨ ×”×¡×•×¤×™ ×™×™×•×¦×¨ ×”××•××“×Ÿ ×•×™×™×©×œ×— ×œ×¢×™×‘×•×“. ×œ× × ×™×ª×Ÿ ×™×”×™×” ×œ×¢×¨×•×š ××ª ×”× ×ª×•× ×™× ×œ××—×¨ ××›×Ÿ.
      </div>
      <div class="validation-buttons" style="justify-content: center; max-width: 600px; margin: 0 auto;">
        <button class="btn btn-edit" onclick="window.location.href='estimator-builder.html';">
          â¬…ï¸ ×—×–×•×¨ ×œ×¢×¨×™×›×”
        </button>
        <button class="btn btn-validate" onclick="saveValidationData()">
          ğŸ’¾ ×©××•×¨ ××™××•×ª
        </button>
        <button class="btn btn-success" id="final-approve-btn" onclick="reviewEstimateReport()" disabled>
          ğŸ“‹ ×‘×“×™×§×ª ××•××“×Ÿ ×¡×•×¤×™
        </button>
        <button class="btn btn-secondary" id="skip-validation-btn" onclick="skipValidationAndProceed()" style="display: none;">
          â­ï¸ ×“×œ×’ ×¢×œ ××™××•×ª ×•×”××©×š
        </button>
      </div>
    </div>
    
    <div class="footer">All rights reserved Â© Carmel Cayouf</div>
  </div>

  <script type="module">
    import { helper, updateHelper } from './helper.js';
    import { loadLegalText } from './vault-loader.js';
    import { MathEngine } from './math.js';
    import { sendToWebhook } from './webhook.js';
    
    // Debug: Check if imports loaded successfully
    console.log('ğŸ” Debug: Imports loaded', { helper, updateHelper, loadLegalText, MathEngine, sendToWebhook });
    
    // Global error handlers to prevent page crashes
    window.addEventListener('error', function(event) {
      console.error('âŒ Global error caught:', event.error);
      console.error('Error details:', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack
      });
      // Don't prevent default - let the error be logged, but don't crash
    });
    
    window.addEventListener('unhandledrejection', function(event) {
      console.error('âŒ Unhandled promise rejection:', event.reason);
      // Prevent the default behavior (which would crash the page)
      event.preventDefault();
    });
    
    // Estimate-specific validation progress (personalized for estimate workflow)
    let estimateValidationProgress = {
      vehicle: false,
      levi: false,
      damage: false,
      depreciation: false,
      calculations: false,
      legal_text: false
    };
    
    let currentValidationData = {};

    // Authentication check
    document.addEventListener('DOMContentLoaded', () => {
      console.log('ğŸ”„ Estimate Validation: Initializing comprehensive validation system...');
      
      const auth = sessionStorage.getItem("auth");
      if (!auth) {
        console.error('âŒ No authentication found');
        showAlert("×”×’×™×©×” ×—×¡×•××” - ×× × ×”×ª×—×‘×¨ ×“×¨×š ×“×£ ×”×‘×™×ª", 'error');
        setTimeout(() => {
          window.location.href = "index.html";
        }, 2000);
        return;
      }
      
      // Try to restore validation data from localStorage if sessionStorage is empty
      const currentHelper = sessionStorage.getItem('helper');
      if (!currentHelper || !JSON.parse(currentHelper)?.estimate?.validation) {
        console.log('ğŸ”„ Attempting to restore validation data from localStorage...');
        
        const lastSaveTime = localStorage.getItem('lastValidationSave');
        const helperKeys = Object.keys(localStorage).filter(key => key.startsWith('helper_validation_'));
        
        if (lastSaveTime && helperKeys.length > 0) {
          // Find the most recent validation save
          const mostRecentKey = helperKeys[helperKeys.length - 1]; // Get the last one
          const savedHelper = localStorage.getItem(mostRecentKey);
          
          if (savedHelper) {
            try {
              const parsedHelper = JSON.parse(savedHelper);
              if (parsedHelper?.estimate?.validation) {
                sessionStorage.setItem('helper', savedHelper);
                console.log('âœ… Restored validation data from localStorage:', parsedHelper.estimate.validation);
                showAlert('× ×ª×•× ×™ ×”××™××•×ª ×”×©××•×¨×™× ×©×•×—×–×¨×• ×‘×”×¦×œ×—×”', 'success');
              }
            } catch (error) {
              console.error('âŒ Error restoring validation data:', error);
            }
          }
        }
      }

      const helperData = sessionStorage.getItem('helper');
      const selectedReportType = sessionStorage.getItem('selectedReportType');
      
      // More flexible validation - if helper data exists, allow validation
      if (!helperData) {
        console.error('âŒ No helper data found for validation');
        showAlert('×©×’×™××”: ×œ× × ××¦××• × ×ª×•× ×™ ××•××“×Ÿ. ×—×•×–×¨ ×œ×“×£ ×”×‘×—×™×¨×”...', 'error');
        setTimeout(() => {
          window.location.href = 'selection.html';
        }, 2000);
        return;
      }
      
      // If selectedReportType is missing, set it to 'estimate' for validation page
      if (!selectedReportType) {
        console.log('ğŸ“ selectedReportType missing, setting to estimate for validation');
        sessionStorage.setItem('selectedReportType', 'estimate');
      }
      
      // Warn if report type is not estimate, but don't block
      if (selectedReportType && selectedReportType !== 'estimate') {
        console.warn('âš ï¸ Selected report type is not estimate:', selectedReportType, 'but proceeding with validation');
        showAlert(`××–×•×”×” ×¡×•×’ ×“×•×—: ${selectedReportType}. ×”×“×£ ×™×ª××•×“×“ ×¢× ×”××•××“×Ÿ ×‘×›×œ ××§×¨×”.`, 'warning');
      }

      console.log('âœ… Estimate Validation: Authentication and data validated');
      
      // Debug: Log session storage contents to understand data structure
      console.log('ğŸ” Debug: Session storage contents:');
      console.log('- helper:', helperData ? 'EXISTS' : 'MISSING');
      console.log('- selectedReportType:', selectedReportType);
      console.log('- builderCurrentState:', sessionStorage.getItem('builderCurrentState') ? 'EXISTS' : 'MISSING');
      
      try {
        const helper = JSON.parse(helperData);
        console.log('ğŸ” Helper data structure:', {
          hasEstimate: !!helper.estimate,
          hasCarDetails: !!helper.car_details,
          hasClient: !!helper.client,
          hasMeta: !!helper.meta,
          hasExpertise: !!helper.expertise,
          keys: Object.keys(helper)
        });
      } catch (e) {
        console.error('âŒ Error parsing helper data:', e);
      }
      
      initializeValidationSystem();
    });

    function initializeValidationSystem() {
      try {
        console.log('ğŸ”„ Initializing validation system...');
        
        // Initialize data with error handling
        loadValidationData();
        
        // Initialize legal text with error handling
        try {
          loadLegalTextValidation();
        } catch (legalError) {
          console.error('âš ï¸ Error loading legal text validation:', legalError);
          // Continue without legal text validation
        }
        
        // Populate validation items with error handling
        try {
          populateEnhancedValidationItems();
        } catch (populateError) {
          console.error('âš ï¸ Error populating validation items:', populateError);
          showAlert('×—×œ×§ ×× ×ª×•× ×™ ×”××™××•×ª ×œ× × ×˜×¢× ×• ×›×¨××•×™, ××š ×”×“×£ ×™×›×•×œ ×œ×¤×¢×•×œ.', 'warning');
        }
        
        // Check if this is a fresh start (no saved progress from current session)
        const hasUserApprovedSections = sessionStorage.getItem('hasUserApprovedSections');
        if (!hasUserApprovedSections) {
          console.log('ğŸ”„ Fresh start - clearing validation progress');
          try {
            clearValidationProgress();
          } catch (clearError) {
            console.warn('âš ï¸ Error clearing validation progress:', clearError);
          }
        } else {
          // Load previously saved validation progress
          try {
            loadSavedValidationProgress();
          } catch (loadError) {
            console.warn('âš ï¸ Error loading saved validation progress:', loadError);
          }
        }
        
        // Initialize damage validation items  
        setTimeout(() => {
          try {
            console.log('ğŸ”§ Initializing damage validation items...');
            populateDamageValidationItems();
          } catch (damageError) {
            console.error('âš ï¸ Error populating damage validation items:', damageError);
          }
        }, 200);
        
        // Initialize progress bar to 0%
        try {
          updateValidationProgress();
        } catch (progressError) {
          console.warn('âš ï¸ Error updating validation progress:', progressError);
        }
        
        // Initialize section accessibility based on validation progress
        try {
          updateSectionAccessibility();
        } catch (accessError) {
          console.warn('âš ï¸ Error updating section accessibility:', accessError);
        }
        
        // Start initial validation
        try {
          startInitialValidation();
        } catch (validationError) {
          console.error('âš ï¸ Error starting initial validation:', validationError);
        }
        
        console.log('âœ… Validation system initialized successfully');
        
      } catch (error) {
        console.error('âŒ Critical error initializing validation system:', error);
        showAlert('×©×’×™××” ×‘××ª×—×•×œ ××¢×¨×›×ª ×”××™××•×ª. ×”×“×£ ×¢×©×•×™ ×œ× ×œ×¤×¢×•×œ ×›×¨××•×™.', 'error');
        
        // Try to at least show basic UI
        try {
          updateValidationProgress();
          updateSectionAccessibility();
        } catch (fallbackError) {
          console.error('âŒ Even fallback progress update failed:', fallbackError);
        }
      }
    }

    // Create enhanced validation item with 3-column display
    function createEnhancedValidationItem(label, currentValue, storedValue, fieldKey, editType = 'inline') {
      // Clean and normalize values
      const cleanCurrent = currentValue && currentValue !== 'undefined' && currentValue !== '×œ× ×–××™×Ÿ' ? String(currentValue).trim() : '';
      const cleanStored = storedValue && storedValue !== 'undefined' && storedValue !== '×œ× ××•×’×“×¨' && storedValue !== '×œ× ×–××™×Ÿ' ? String(storedValue).trim() : '';
      
      // More precise matching logic
      const hasCurrentData = cleanCurrent !== '' && cleanCurrent !== '×œ× ×–××™×Ÿ';
      const hasStoredData = cleanStored !== '' && cleanStored !== '×œ× ××•×’×“×¨' && cleanStored !== '×œ× ×–××™×Ÿ';
      const isMatch = hasCurrentData && hasStoredData && cleanCurrent === cleanStored;
      
      // Debug logging for button issues
      console.log(`ğŸ” ${fieldKey}:`, {
        current: cleanCurrent,
        stored: cleanStored,
        hasCurrentData,
        hasStoredData,
        isMatch,
        showIgnore: !isMatch && (hasCurrentData || hasStoredData)
      });
      
      let statusClass;
      if (isMatch) {
        statusClass = 'data-match';
      } else if (hasCurrentData && hasStoredData) {
        // Both have data but don't match
        statusClass = 'data-warning';
      } else {
        // Missing data in either field
        statusClass = 'data-error';
      }
      
      return `
        <div class="validation-item-enhanced" data-field="${fieldKey}">
          <div class="validation-label">${label}</div>
          <div class="validation-columns">
            <div class="current-value ${statusClass}" id="current-${fieldKey}">
              ${hasCurrentData ? cleanCurrent : '×œ× ×–××™×Ÿ'}
            </div>
            <div class="stored-value">
              ${hasStoredData ? cleanStored : '×œ× ×§×™×™× ×‘×¢×–×¨'}
            </div>
            <div class="action-buttons">
              ${editType === 'inline' ? 
                `<button class="edit-inline" onclick="startInlineEdit('${fieldKey}')">âœï¸</button>` : 
                `<button class="edit-builder" onclick="editInBuilder('${fieldKey}')">ğŸ“</button>`
              }
              ${!isMatch ? `<button class="ignore" onclick="ignoreDiscrepancy('${fieldKey}')">ğŸš«</button>` : ''}
            </div>
          </div>
        </div>
      `;
    }

    // Populate enhanced validation items for vehicle section
    function populateEnhancedValidationItems() {
      const container = document.getElementById('vehicle-validation-items');
      if (!container) {
        console.warn('âš ï¸ Vehicle validation items container not found');
        return;
      }
      
      // Ensure currentValidationData exists and has required structure
      if (!currentValidationData || typeof currentValidationData !== 'object') {
        console.error('âŒ currentValidationData is not available, initializing with defaults');
        currentValidationData = {
          plate: '',
          car_details: {},
          client: {},
          raw_helper: JSON.parse(sessionStorage.getItem('helper') || '{}')
        };
      }
      
      const data = currentValidationData;
      const helper = data.raw_helper || {};
      
      console.log('ğŸ” Debug validation data:', data);
      console.log('ğŸ” Debug helper data:', helper);
      
      container.innerHTML = 
        createEnhancedValidationItem(
          '××¡×¤×¨ ×¨×›×‘', 
          data?.plate || data?.car_details?.plate || '', 
          helper?.plate || helper?.meta?.plate || helper?.car_details?.plate || '×œ× ××•×’×“×¨', 
          'plate'
        ) +
        createEnhancedValidationItem(
          '×™×¦×¨×Ÿ', 
          data?.car_details?.manufacturer || '', 
          helper?.manufacturer || helper?.car_details?.manufacturer || helper?.vehicle?.manufacturer || '×œ× ××•×’×“×¨', 
          'manufacturer'
        ) +
        createEnhancedValidationItem(
          '×“×’×', 
          data?.car_details?.model || '', 
          helper?.model || helper?.car_details?.model || helper?.vehicle?.model || '×œ× ××•×’×“×¨', 
          'model'
        ) +
        createEnhancedValidationItem(
          '×©× ×ª ×™×¦×•×¨', 
          data?.car_details?.year || '', 
          helper?.year || helper?.car_details?.year || helper?.vehicle?.year || '×œ× ××•×’×“×¨', 
          'year'
        ) +
        createEnhancedValidationItem(
          '×©× ×‘×¢×œ×™×', 
          data?.client?.name || '', 
          helper?.owner || helper?.client?.name || helper?.meta?.owner || '×œ× ××•×’×“×¨', 
          'owner_name'
        ) +
        createEnhancedValidationItem(
          '×—×‘×¨×ª ×‘×™×˜×•×—', 
          data?.client?.insurance_company || '', 
          helper?.insurance_company || helper?.client?.insurance_company || '×œ× ××•×’×“×¨', 
          'insurance'
        );
    }

    function loadValidationData() {
      console.log('ğŸ“Š Loading validation data from builder state...');
      
      try {
        // âœ… OPTIMAL FLOW: Validation reads from builder state, not helper directly
        // Helper â†’ Builder â†’ Validation (this validation reads from builder current state)
        
        // Priority 1: Get builder current state (what user is currently working on)
        const builderState = getBuilderCurrentState();
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Initialize helper structure if missing
        if (!helper) {
          console.warn('âš ï¸ Helper data missing, initializing defaults');
          helper = {};
        }
        
        // Ensure basic helper structure exists
        if (!helper.estimate) helper.estimate = {};
        if (!helper.car_details) helper.car_details = {};
        if (!helper.client) helper.client = {};
        if (!helper.meta) helper.meta = {};
        
        if (!builderState || Object.keys(builderState).length === 0) {
          console.warn('âš ï¸ No builder state found, using helper data directly');
          // Don't redirect immediately - try to work with helper data
        }

        currentValidationData = {
          meta: (builderState && builderState.meta) || helper?.meta || {},
          plate: (builderState && builderState.plate) || helper?.plate || helper?.meta?.plate || '',
          
          // Car details (builder state overrides helper with safe navigation)
          car_details: {
            plate: (builderState && builderState.plate) || helper?.plate || helper?.car_details?.plate || '',
            manufacturer: (builderState && builderState.manufacturer) || helper?.manufacturer || helper?.car_details?.manufacturer || '',
            model: (builderState && builderState.model) || helper?.model || helper?.car_details?.model || '',
            year: (builderState && builderState.year) || helper?.year || helper?.car_details?.year || '',
            vin: (builderState && builderState.vin) || helper?.vin || helper?.car_details?.vin || '',
            engine: (builderState && builderState.engine) || helper?.engine || helper?.car_details?.engine || ''
          },
          
          // Client/owner information (builder state overrides helper with safe navigation)
          client: {
            name: (builderState && builderState.owner_name) || helper?.owner || helper?.client?.name || '',
            phone_number: (builderState && builderState.owner_phone) || helper?.client?.phone_number || '',
            address: (builderState && builderState.owner_address) || helper?.client?.address || '',
            insurance_company: (builderState && builderState.insurance_company) || helper?.insurance_company || helper?.client?.insurance_company || ''
          },
          
          // Levi report data (safe navigation)
          levi_report: (builderState && builderState.levi_report) || helper?.levi_report || {},
          
          // Damage centers (safe navigation)
          damage_blocks: (builderState && builderState.damage_blocks) || helper?.expertise?.damage_blocks || helper?.damage_blocks || [],
          
          // Legal text (safe navigation)
          estimate_legal_text: (builderState && builderState.estimate_legal_text) || helper?.estimate_legal_text || helper?.estimate?.summary?.legal_text || '',
          
          // Estimate calculations and totals (safe navigation)
          estimate_totals: (builderState && builderState.estimate_totals) || helper?.estimate_totals || helper?.calculations || {},
          
          // Depreciation data (safe navigation)
          estimate_depreciation: (builderState && builderState.estimate_depreciation) || helper?.estimate_depreciation || helper?.estimate?.depreciation || {},
          
          // Store both sources for debugging
          builder_state: builderState || {},
          raw_helper: helper || {}
        };
        
        console.log('âœ… Validation data loaded from builder state:', currentValidationData);
        console.log('ğŸ—ï¸ Builder state used:', builderState);
        
      } catch (error) {
        console.error('âŒ Error loading validation data:', error);
        
        // Fallback: Try to initialize with minimal data
        try {
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          currentValidationData = {
            meta: helper?.meta || {},
            plate: helper?.plate || helper?.meta?.plate || '',
            car_details: helper?.car_details || {},
            client: helper?.client || {},
            levi_report: helper?.levi_report || {},
            damage_blocks: helper?.expertise?.damage_blocks || helper?.damage_blocks || [],
            estimate_legal_text: helper?.estimate_legal_text || '',
            estimate_totals: helper?.estimate_totals || {},
            estimate_depreciation: helper?.estimate_depreciation || {},
            builder_state: {},
            raw_helper: helper || {}
          };
          console.log('âš ï¸ Fallback data loaded:', currentValidationData);
        } catch (fallbackError) {
          console.error('âŒ Fallback loading failed:', fallbackError);
          showAlert('×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™ ×”××™××•×ª. ×× × ×—×–×•×¨ ×œ×‘×•× ×” ×”××•××“×Ÿ.', 'error');
          currentValidationData = {
            meta: {},
            plate: '',
            car_details: {},
            client: {},
            levi_report: {},
            damage_blocks: [],
            estimate_legal_text: '',
            estimate_totals: {},
            estimate_depreciation: {},
            builder_state: {},
            raw_helper: {}
          };
        }
      }
    }
    
    // Get current builder state (what user is working on in builder)
    function getBuilderCurrentState() {
      try {
        // Method 1: Try to get from explicit builder state storage
        const explicitBuilderState = sessionStorage.getItem('builderCurrentState');
        if (explicitBuilderState) {
          console.log('ğŸ“Š Found explicit builder state');
          return JSON.parse(explicitBuilderState);
        }
        
        // Method 2: Extract current builder state from helper (what builder saved)
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Ensure helper has basic structure
        if (!helper || typeof helper !== 'object') {
          console.warn('âš ï¸ Invalid helper data in getBuilderCurrentState');
          return {};
        }
        
        // Extract builder-modified data from helper with safe navigation
        const builderState = {
          // Car details (if modified by builder)
          plate: helper?.plate || helper?.meta?.plate || '',
          manufacturer: helper?.manufacturer || helper?.car_details?.manufacturer || '',
          model: helper?.model || helper?.car_details?.model || '',
          year: helper?.year || helper?.car_details?.year || '',
          vin: helper?.vin || helper?.car_details?.vin || '',
          engine: helper?.engine || helper?.car_details?.engine || '',
          
          // Owner/client details (if modified by builder)
          owner_name: helper?.owner || helper?.client?.name || '',
          owner_phone: helper?.client?.phone_number || '',
          owner_address: helper?.client?.address || '',
          insurance_company: helper?.client?.insurance_company || helper?.insurance_company || '',
          
          // Estimate-specific data (saved by builder) with safe navigation
          estimate_type: helper?.estimate_type || '',
          estimate_notes: helper?.estimate_notes || '',
          estimate_work_days: helper?.estimate_work_days || '',
          estimate_legal_text: helper?.estimate_legal_text || helper?.estimate?.summary?.legal_text || '',
          estimate_attachments: helper?.estimate_attachments || helper?.estimate?.summary?.attachments || [],
          estimate_depreciation: helper?.estimate_depreciation || helper?.estimate?.depreciation || {},
          estimate_adjustments: helper?.estimate_adjustments || helper?.estimate?.adjustments || [],
          
          // Levi data (if modified by builder) with safe navigation
          levi_report: helper?.levi_report || {},
          levi: helper?.levi || {},
          
          // Damage data (if modified by builder) with safe navigation
          damage_blocks: helper?.expertise?.damage_blocks || helper?.damage_blocks || [],
          
          // Calculations (computed by builder) with safe navigation
          calculations: helper?.calculations || {},
          claims_data: helper?.claims_data || {},
          estimate_totals: helper?.estimate_totals || {},
          summary_totals: helper?.summary_totals || {},
          
          // Timestamp of last builder modification
          last_builder_update: helper?.last_builder_update || new Date().toISOString()
        };
        
        console.log('ğŸ—ï¸ Extracted builder state from helper modifications');
        return builderState;
        
      } catch (error) {
        console.error('âŒ Error getting builder current state:', error);
        return {}; // Return empty state, will fall back to helper
      }
    }

    // Extract estimate totals from damage blocks
    // ENHANCED: Extract damage data from multiple sources (builder state + helper)
    function extractDamageDataFromMultipleSources() {
      console.log('ğŸ” Extracting damage data from multiple sources...');
      
      let damageData = {
        parts_cost: 0,
        work_cost: 0,
        repairs_cost: 0,
        total_before_vat: 0,
        total_with_vat: 0
      };
      
      // Priority 1: Try to read from builder DOM (if available)
      try {
        // Check if we can access builder summary totals from DOM
        const claimField = document.querySelector('#totalClaim, #sumClaim');
        const marketField = document.querySelector('#sumMarketValue');
        const vatField = document.querySelector('#sumVAT');
        const totalField = document.querySelector('#sumTotalClaim');
        
        // Also try to read from builder state if available
        const builderState = sessionStorage.getItem('builderCurrentState');
        if (builderState) {
          try {
            const state = JSON.parse(builderState);
            if (state.damage_totals) {
              damageData.parts_cost = state.damage_totals.parts_cost || 0;
              damageData.work_cost = state.damage_totals.work_cost || 0;
              damageData.repairs_cost = state.damage_totals.repairs_cost || 0;
              console.log('\ud83d\udcbe Loaded damage data from builder state:', state.damage_totals);
            }
          } catch (e) {
            console.log('\u26a0\ufe0f Error parsing builder state:', e);
          }
        }
        
        // Try specific damage total selectors
        const partsTotal = document.querySelector('[data-damage-total="parts"], .parts-costs-display')?.textContent;
        const workTotal = document.querySelector('[data-damage-total="work"], .work-costs-display')?.textContent;
        const repairsTotal = document.querySelector('[data-damage-total="repairs"], .repairs-costs-display')?.textContent;
        
        if (partsTotal && damageData.parts_cost === 0) {
          damageData.parts_cost = parseFloat(String(partsTotal).replace(/[\u20aa,\s]/g, '')) || 0;
          console.log('\ud83d\udcb0 Parts cost from DOM:', damageData.parts_cost);
        }
        
        if (workTotal && damageData.work_cost === 0) {
          damageData.work_cost = parseFloat(String(workTotal).replace(/[\u20aa,\s]/g, '')) || 0;
          console.log('\ud83d\udcb0 Work cost from DOM:', damageData.work_cost);
        }
        
        if (repairsTotal && damageData.repairs_cost === 0) {
          damageData.repairs_cost = parseFloat(String(repairsTotal).replace(/[\u20aa,\s]/g, '')) || 0;
          console.log('\ud83d\udcb0 Repairs cost from DOM:', damageData.repairs_cost);
        }
        
        // If we have claim total but no breakdown, try to extract from helper with that total
        if (claimField && (damageData.parts_cost + damageData.work_cost + damageData.repairs_cost === 0)) {
          const claimTotal = parseFloat(claimField.value?.replace(/[\u20aa,\s]/g, '') || '0');
          console.log('\ud83d\udcb0 Found claim total in DOM:', claimTotal);
          
          // Use this as a reference to validate against helper data
          if (claimTotal > 0) {
            damageData.builder_total_reference = claimTotal;
          }
        }
      } catch (error) {
        console.log('âš ï¸ Cannot access builder DOM, falling back to helper data');
      }
      
      // Priority 2: Read from helper data if DOM values are 0 or unavailable
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      if (damageData.parts_cost === 0 || damageData.work_cost === 0 || damageData.repairs_cost === 0) {
        console.log('ğŸ’¾ Reading from helper data as fallback...');
        const helperTotals = extractEstimateTotals(helper);
        
        if (damageData.parts_cost === 0) damageData.parts_cost = helperTotals.parts_cost;
        if (damageData.work_cost === 0) damageData.work_cost = helperTotals.work_cost;
        if (damageData.repairs_cost === 0) damageData.repairs_cost = helperTotals.repairs_cost;
      }
      
      // Priority 3: Try reading from sessionStorage totals
      if (damageData.parts_cost === 0 && damageData.work_cost === 0 && damageData.repairs_cost === 0) {
        console.log('ğŸ’¾ Trying sessionStorage totals...');
        const storedTotals = sessionStorage.getItem('damage_totals');
        if (storedTotals) {
          try {
            const parsed = JSON.parse(storedTotals);
            damageData.parts_cost = parsed.parts_cost || 0;
            damageData.work_cost = parsed.work_cost || 0;
            damageData.repairs_cost = parsed.repairs_cost || 0;
          } catch (e) {
            console.log('âš ï¸ Error parsing stored totals:', e);
          }
        }
      }
      
      // Calculate totals
      damageData.total_before_vat = damageData.parts_cost + damageData.work_cost + damageData.repairs_cost;
      damageData.total_with_vat = Math.round(damageData.total_before_vat * 1.18); // 18% VAT
      
      console.log('ğŸ“ˆ Final damage data:', damageData);
      return damageData;
    }
    
    function extractEstimateTotals(helper) {
      const damageBlocks = helper.expertise?.damage_blocks || [];
      let totals = {
        parts_cost: 0,
        work_cost: 0,
        repairs_cost: 0,
        total_before_vat: 0,
        total_with_vat: 0
      };
      
      damageBlocks.forEach(block => {
        // Sum parts costs
        if (block.parts) {
          block.parts.forEach(part => {
            totals.parts_cost += parseFloat(part.price) || 0;
          });
        }
        
        // Sum work costs
        if (block.works) {
          block.works.forEach(work => {
            totals.work_cost += parseFloat(work.cost) || 0;
          });
        }
        
        // Sum repair costs
        if (block.repairs) {
          block.repairs.forEach(repair => {
            totals.repairs_cost += parseFloat(repair.cost) || 0;
          });
        }
      });
      
      totals.total_before_vat = totals.parts_cost + totals.work_cost + totals.repairs_cost;
      totals.total_with_vat = totals.total_before_vat * 1.18; // 18% VAT
      
      return totals;
    }

    async function loadLegalTextValidation() {
      try {
        // Load legal text from estimate.summary.legal_text
        const helper = currentValidationData.raw_helper;
        let legalText = '';
        
        // Try to get legal text from estimate.summary.legal_text
        if (helper.estimate && helper.estimate.summary && helper.estimate.summary.legal_text) {
          legalText = helper.estimate.summary.legal_text;
          console.log('âœ… Found legal text from estimate.summary.legal_text');
        } else {
          console.log('âš ï¸ No legal text found in estimate.summary.legal_text');
        }
        
        if (legalText && legalText.length > 10) {
          // Display as normal text (not markdown)
          document.getElementById('legal-text-content').value = legalText;
          console.log('âœ… Loaded legal text from estimate.summary.legal_text successfully');
        } else {
          // If no legal text found, show message
          document.getElementById('legal-text-content').value = '×˜×§×¡×˜ ××©×¤×˜×™ ×œ× × ××¦× ×‘-estimate.summary.legal_text. ×× × ×¢×‘×•×¨ ×œ×‘× ××™ ×”××•××“×Ÿ ×›×“×™ ×œ×‘×—×•×¨ ×˜×§×¡×˜ ××©×¤×˜×™.';
          console.log('âš ï¸ No legal text found in estimate.summary.legal_text');
        }
      } catch (error) {
        console.error('Error loading legal text:', error);
        document.getElementById('legal-text-content').value = '×©×’×™××” ×‘×˜×¢×™× ×ª ×”×˜×§×¡×˜ ×”××©×¤×˜×™ ×-estimate.summary.legal_text';
      }
    }

    function startInitialValidation() {
      // Auto-validate all sections on page load (Estimate workflow)
      const sections = ['vehicle', 'levi', 'damage', 'depreciation', 'calculations', 'legal_text'];
      
      sections.forEach((sectionName, index) => {
        setTimeout(() => {
          validateSection(sectionName);
        }, index * 500); // Stagger validation by 500ms to avoid overwhelming
      });
    }

    // Helper function to get section display names in Hebrew (Estimate-specific)
    function getSectionDisplayName(sectionName) {
      const sectionNames = {
        vehicle: '× ×ª×•× ×™ ×¨×›×‘',
        levi: '×“×•×´×— ×œ×•×™ ×™×¦×—×§',
        damage: '××•×§×“×™ × ×–×§ ×•××§×¡×¤×¨×˜×™×–×”', 
        depreciation: '×—×™×©×•×‘ ×™×¨×™×“×ª ×¢×¨×š ×œ×¤×™ ××•×§×“×™ × ×–×§',
        calculations: '×—×™×©×•×‘×™ ××•××“×Ÿ ×•×¡×™×›×•××™×',
        legal_text: '×˜×§×¡×˜ ××©×¤×˜×™'
      };
      return sectionNames[sectionName] || sectionName;
    }

    // Function to update section accessibility based on sequential validation
    function updateSectionAccessibility() {
      const sections = ['vehicle', 'levi', 'damage', 'depreciation', 'calculations', 'legal_text'];
      
      sections.forEach((sectionName, index) => {
        const section = document.getElementById(`section-${sectionName}`);
        const buttons = section.querySelectorAll('button');
        const validateButton = buttons[0]; // ×××ª button
        const editButton = buttons[1]; // ×¢×¨×™×›×” ×™×“× ×™×ª button
        
        if (index === 0) {
          // First section is always accessible
          section.classList.remove('disabled');
          if (validateButton) validateButton.disabled = false;
          if (editButton) editButton.disabled = false;
        } else {
          // Check if all previous sections are completed
          let canAccess = true;
          for (let i = 0; i < index; i++) {
            if (!estimateValidationProgress[sections[i]]) {
              canAccess = false;
              break;
            }
          }
          
          if (canAccess) {
            section.classList.remove('disabled');
            if (validateButton) validateButton.disabled = false;
            if (editButton) editButton.disabled = false;
          } else {
            section.classList.add('disabled');
            if (validateButton) {
              validateButton.disabled = true;
              validateButton.title = `×™×© ×œ×××ª ××ª ×›×œ ×”×¡×¢×™×¤×™× ×”×§×•×“××™× ×œ×¤× ×™ ××™××•×ª ×¡×¢×™×£ ×–×”`;
            }
            if (editButton) {
              editButton.disabled = true;
              editButton.title = `×™×© ×œ×××ª ××ª ×›×œ ×”×¡×¢×™×¤×™× ×”×§×•×“××™× ×œ×¤× ×™ ×¢×¨×™×›×ª ×¡×¢×™×£ ×–×”`;
            }
          }
        }
      });
    }

    // Validation Functions
    window.validateSection = async function(sectionName) {
      const section = document.getElementById(`section-${sectionName}`);
      const status = section.querySelector('.section-status');
      
      // Check if previous sections are completed (sequential validation)
      const sections = ['vehicle', 'levi', 'damage', 'depreciation', 'calculations', 'legal_text'];
      const currentIndex = sections.indexOf(sectionName);
      
      if (currentIndex > 0) {
        // Check if all previous sections are completed
        for (let i = 0; i < currentIndex; i++) {
          const previousSection = sections[i];
          if (!estimateValidationProgress[previousSection]) {
            showAlert(`×™×© ×œ×××ª ××ª ×”×¡×¢×™×£ "${getSectionDisplayName(previousSection)}" ×œ×¤× ×™ ××™××•×ª ×”×¡×¢×™×£ ×”× ×•×›×—×™`, 'error');
            return;
          }
        }
      }
      
      // Set to validating state
      section.classList.remove('completed', 'error', 'warning');
      section.classList.add('current');
      status.textContent = '××××ª...';
      status.className = 'section-status status-current';
      
      try {
        let validationResult;
        
        switch(sectionName) {
          case 'vehicle':
            validationResult = await validateVehicleSection();
            break;
          case 'levi':
            validationResult = await validateLeviSection();
            break;
          case 'depreciation':
            validationResult = await validateDepreciationSection();
            break;
          case 'damage':
            validationResult = await validateDamageSection();
            break;
          case 'calculations':
            validationResult = await validateCalculationsSection();
            break;
          case 'legal_text':
            validationResult = await validateLegalTextSection();
            break;
        }
        
        // Update UI based on validation result
        updateSectionUI(sectionName, validationResult);
        
        // Update progress
        updateValidationProgress();
        
      } catch (error) {
        console.error(`Validation error for section ${sectionName}:`, error);
        setSectionError(sectionName, error.message);
      }
    };

    async function validateVehicleSection() {
      const issues = [];
      const validItems = [];
      
      // Get current values from the enhanced validation display
      const plateValue = getCurrentFieldValue('plate');
      const manufacturerValue = getCurrentFieldValue('manufacturer');
      const modelValue = getCurrentFieldValue('model');
      const yearValue = getCurrentFieldValue('year');
      const ownerValue = getCurrentFieldValue('owner_name');
      const insuranceValue = getCurrentFieldValue('insurance');
      
      // Validate plate number
      if (plateValue && plateValue !== '×œ× ×–××™×Ÿ' && plateValue.length >= 6) {
        validItems.push('vehicle-plate');
        setFieldValidationStatus('plate', 'âœ“');
      } else {
        issues.push('××¡×¤×¨ ×¨×›×‘ ×—×¡×¨ ××• ×œ× ×ª×§×™×Ÿ');
        setFieldValidationStatus('plate', 'âŒ');
      }
      
      // Validate vehicle details  
      if (manufacturerValue && manufacturerValue !== '×œ× ×–××™×Ÿ' && modelValue && modelValue !== '×œ× ×–××™×Ÿ') {
        validItems.push('vehicle-details');
        setFieldValidationStatus('manufacturer', 'âœ“');
        setFieldValidationStatus('model', 'âœ“');
      } else {
        issues.push('×¤×¨×˜×™ ×™×¦×¨×Ÿ ××• ×“×’× ×—×¡×¨×™×');
        setFieldValidationStatus('manufacturer', manufacturerValue && manufacturerValue !== '×œ× ×–××™×Ÿ' ? 'âœ“' : 'âŒ');
        setFieldValidationStatus('model', modelValue && modelValue !== '×œ× ×–××™×Ÿ' ? 'âœ“' : 'âŒ');
      }
      
      // Validate vehicle specs
      if (yearValue && yearValue !== '×œ× ×–××™×Ÿ' && yearValue > 1990 && yearValue <= new Date().getFullYear()) {
        validItems.push('vehicle-specs');
        setFieldValidationStatus('year', 'âœ“');
      } else {
        issues.push('×©× ×ª ×™×¦×•×¨ ×œ× ×ª×§×™× ×”');
        setFieldValidationStatus('year', 'âŒ');
      }
      
      // Validate owner details (warning only, not blocking)
      if (ownerValue && ownerValue !== '×œ× ×–××™×Ÿ') {
        validItems.push('vehicle-owner');
        setFieldValidationStatus('owner_name', 'âœ“');
      } else {
        issues.push('×¤×¨×˜×™ ×‘×¢×œ×™× ×—×¡×¨×™× (××–×”×¨×”)');
        setFieldValidationStatus('owner_name', 'âš ï¸');
      }
      
      // Validate insurance details (warning only, not blocking)
      if (insuranceValue && insuranceValue !== '×œ× ×–××™×Ÿ') {
        validItems.push('vehicle-insurance');
        setFieldValidationStatus('insurance', 'âœ“');
      } else {
        issues.push('×¤×¨×˜×™ ×‘×™×˜×•×— ×—×¡×¨×™× (××–×”×¨×”)');
        setFieldValidationStatus('insurance', 'âš ï¸');
      }
      
      // Check if all required fields have data - any missing data is an error
      const allFieldsHaveData = plateValue && plateValue !== '×œ× ×–××™×Ÿ' && 
                               manufacturerValue && manufacturerValue !== '×œ× ×–××™×Ÿ' && 
                               modelValue && modelValue !== '×œ× ×–××™×Ÿ' && 
                               yearValue && yearValue !== '×œ× ×–××™×Ÿ';
      
      // Count both critical errors and missing data as errors
      const criticalErrors = issues.filter(i => !i.includes('××–×”×¨×”')).length;
      const totalErrors = allFieldsHaveData ? criticalErrors : criticalErrors + (allFieldsHaveData ? 0 : 1);
      
      return {
        success: totalErrors === 0 && allFieldsHaveData,
        warnings: issues.filter(i => i.includes('××–×”×¨×”')).length,
        errors: totalErrors,
        issues: issues,
        validItems: validItems.length
      };
    }

    // Helper function to get current field value from enhanced display
    function getCurrentFieldValue(fieldKey) {
      const element = document.getElementById(`current-${fieldKey}`);
      return element ? element.textContent.trim() : '';
    }

    // Helper function to set validation status for a field
    function setFieldValidationStatus(fieldKey, status) {
      const element = document.getElementById(`current-${fieldKey}`);
      if (element) {
        // Update the visual indicator (could add a small status icon)
        if (status === 'âœ“') {
          element.classList.remove('data-error', 'data-warning');
          element.classList.add('data-match');
        } else if (status === 'âš ï¸') {
          element.classList.remove('data-error', 'data-match');
          element.classList.add('data-warning');
        } else {
          element.classList.remove('data-match', 'data-warning');
          element.classList.add('data-error');
        }
      }
    }

    // Helper function to safely update elements that may or may not exist
    function updateElementIfExists(elementId, content) {
      const element = document.getElementById(elementId);
      if (element) {
        element.textContent = content;
        return true;
      }
      return false;
    }

    async function validateLeviSection() {
      const issues = [];
      const validItems = [];
      
      console.log('ğŸ” Levi validation - Using comprehensive data sources');
      
      // First populate the validation items display
      populateLeviValidationItems();
      
      // Get data from all available sources using the new comprehensive approach
      const leviData = getLeviDataFromSources();
      const { basePrice: sourceBasePrice, marketValue: sourceMarketValue } = leviData;
      
      // Also get current values from validation display
      const basePriceValue = getCurrentFieldValue('levi_base_price');
      const marketValueValue = getCurrentFieldValue('levi_market_value');
      
      console.log('ğŸ” Levi validation data sources:', {
        basePriceValue,
        marketValueValue,
        sourceBasePrice,
        sourceMarketValue
      });
      
      // Use validation display values if available, otherwise use source data
      const finalBasePrice = basePriceValue && !basePriceValue.includes('×œ× ×–××™×Ÿ') ? basePriceValue : sourceBasePrice;
      const finalMarketValue = marketValueValue && !marketValueValue.includes('×œ× ×–××™×Ÿ') ? marketValueValue : sourceMarketValue;
      
      // Validate base price - CRITICAL field (not optional)
      const basePrice = parseFloat(String(finalBasePrice || '').replace(/[â‚ª,]/g, '')) || 0;
      if (basePrice > 1000) { // Minimum reasonable car value
        validItems.push('levi-base-price');
        setFieldValidationStatus('levi_base_price', 'âœ“');
        updateElementIfExists('levi-display-base', MathEngine.formatCurrency(basePrice));
      } else {
        issues.push('××—×™×¨ ×‘×¡×™×¡ ×—×¡×¨ ××• ×œ× ×ª×§×™×Ÿ (× ×“×¨×© ××¢×œ â‚ª1,000)');
        setFieldValidationStatus('levi_base_price', 'âŒ');
        updateElementIfExists('levi-display-base', 'â‚ª0');
      }
      
      // Validate market value - CRITICAL field (not optional)
      const marketValue = parseFloat(String(finalMarketValue || '').replace(/[â‚ª,]/g, '')) || 0;
      if (marketValue > 1000) { // Minimum reasonable car value
        validItems.push('levi-market-value');
        setFieldValidationStatus('levi_market_value', 'âœ“');
        updateElementIfExists('levi-display-final', MathEngine.formatCurrency(marketValue));
      } else {
        issues.push('×©×•×•×™ ×©×•×§ ×¡×•×¤×™ ×—×¡×¨ ××• ×œ× ×ª×§×™×Ÿ (× ×“×¨×© ××¢×œ â‚ª1,000)');
        setFieldValidationStatus('levi_market_value', 'âŒ');
        updateElementIfExists('levi-display-final', 'â‚ª0');
      }
      
      // Validate dynamic price adjustments - unified approach for all adjustment types
      let adjustmentCount = 0;
      const data = currentValidationData;
      const helper = data.raw_helper;
      
      console.log('ğŸ” Validating all adjustments from helper data');
      
      // A. Validate Levi adjustments (from levi_report)
      if (helper?.levi_report?.adjustments && helper.levi_report.adjustments.length > 0) {
        console.log('ğŸ” Validating Levi adjustments:', helper.levi_report.adjustments.length);
        helper.levi_report.adjustments.forEach((adjustment, index) => {
          const adjFieldKey = `levi_adj_levi_${index}`;
          const adjValue = getCurrentFieldValue(adjFieldKey);
          
          if (adjValue && adjValue !== '×œ× ×–××™×Ÿ' && adjValue !== '×œ× ××•×’×“×¨') {
            const isValidFormat = adjValue.includes('+') || adjValue.includes('-') || adjValue.includes('â‚ª') || adjValue.includes('%');
            if (isValidFormat) {
              validItems.push(adjFieldKey);
              setFieldValidationStatus(adjFieldKey, 'âœ“');
            } else {
              issues.push(`×¤×•×¨××˜ ×œ× ×ª×§×™×Ÿ ×¢×‘×•×¨ ×”×ª×××ª ×œ×•×™ ×™×¦×—×§: ${adjustment.description || '×”×ª×××”'} (××–×”×¨×”)`);
              setFieldValidationStatus(adjFieldKey, 'âš ï¸');
            }
            adjustmentCount++;
          } else {
            issues.push(`×”×ª×××ª ×œ×•×™ ×™×¦×—×§ ×—×¡×¨×”: ${adjustment.description || '×”×ª×××”'} (××–×”×¨×”)`);
            setFieldValidationStatus(adjFieldKey, 'âš ï¸');
          }
        });
      }
      
      // B. Validate custom adjustments (from levi.custom_adjustments)
      if (helper?.levi?.custom_adjustments && helper.levi.custom_adjustments.length > 0) {
        console.log('ğŸ” Validating custom adjustments:', helper.levi.custom_adjustments.length);
        helper.levi.custom_adjustments.forEach((adjustment, index) => {
          const adjFieldKey = `levi_adj_custom_${index}`;
          const adjValue = getCurrentFieldValue(adjFieldKey);
          
          if (adjValue && adjValue !== '×œ× ×–××™×Ÿ' && adjValue !== '×œ× ××•×’×“×¨') {
            const isValidFormat = adjValue.includes('+') || adjValue.includes('-') || adjValue.includes('â‚ª') || adjValue.includes('%');
            if (isValidFormat) {
              validItems.push(adjFieldKey);
              setFieldValidationStatus(adjFieldKey, 'âœ“');
            } else {
              issues.push(`×¤×•×¨××˜ ×œ× ×ª×§×™×Ÿ ×¢×‘×•×¨ ×”×ª×××” ××•×ª×××ª: ${adjustment.description || '×”×ª×××”'} (××–×”×¨×”)`);
              setFieldValidationStatus(adjFieldKey, 'âš ï¸');
            }
            adjustmentCount++;
          } else {
            // Empty custom adjustments are OK (optional)
            if (adjustment.description || adjustment.percentage !== 0 || adjustment.value !== 0) {
              issues.push(`×”×ª×××” ××•×ª×××ª ×—×¡×¨×”: ${adjustment.description || '×”×ª×××”'} (××–×”×¨×”)`);
              setFieldValidationStatus(adjFieldKey, 'âš ï¸');
            }
          }
        });
      }
      
      // C. Validate market value adjustments (from custom_adjustments.full_market_adjustments)
      if (helper?.custom_adjustments?.full_market_adjustments && helper.custom_adjustments.full_market_adjustments.length > 0) {
        console.log('ğŸ” Validating market value adjustments:', helper.custom_adjustments.full_market_adjustments.length);
        helper.custom_adjustments.full_market_adjustments.forEach((adjustment, index) => {
          const adjFieldKey = `levi_adj_market_${index}`;
          const adjValue = getCurrentFieldValue(adjFieldKey);
          
          if (adjValue && adjValue !== '×œ× ×–××™×Ÿ' && adjValue !== '×œ× ××•×’×“×¨') {
            const isValidFormat = adjValue.includes('+') || adjValue.includes('-') || adjValue.includes('â‚ª') || adjValue.includes('%');
            if (isValidFormat) {
              validItems.push(adjFieldKey);
              setFieldValidationStatus(adjFieldKey, 'âœ“');
            } else {
              issues.push(`×¤×•×¨××˜ ×œ× ×ª×§×™×Ÿ ×¢×‘×•×¨ ×”×ª×××ª ×¢×¨×š ×”×©×•×§: ${adjustment.description || '×”×ª×××”'} (××–×”×¨×”)`);
              setFieldValidationStatus(adjFieldKey, 'âš ï¸');
            }
            adjustmentCount++;
          } else {
            // Empty market adjustments are OK (optional)
            if (adjustment.description || adjustment.percentage !== 0 || adjustment.value !== 0) {
              issues.push(`×”×ª×××ª ×¢×¨×š ×”×©×•×§ ×—×¡×¨×”: ${adjustment.description || '×”×ª×××”'} (××–×”×¨×”)`);
              setFieldValidationStatus(adjFieldKey, 'âš ï¸');
            }
          }
        });
      }
      
      if (adjustmentCount === 0) {
        console.log('ğŸ” No adjustments found');
        issues.push('×œ× × ××¦××• ×”×ª×××•×ª ××—×™×¨ (××–×”×¨×”)');
      }
      
      // Calculate total adjustments for display - FROM MARKET VALUE SECTION
      // Get adjustments from market value section (×—×™×©×•×‘ ×¢×¨×š ×”×©×•×§ ×©×œ ×”×¨×›×‘) instead of damage percentage
      let totalAdjustments = 0;
      
      // Try to get adjustments from market value calculation (custom_adjustments.full_market_adjustments)
      if (helper.custom_adjustments?.full_market_adjustments) {
        console.log('ğŸ” Reading adjustments from market value section:', helper.custom_adjustments.full_market_adjustments);
        helper.custom_adjustments.full_market_adjustments.forEach(adjustment => {
          if (adjustment.value && !isNaN(adjustment.value)) {
            totalAdjustments += parseFloat(adjustment.value);
          }
        });
      }
      
      // If no market value adjustments found, try to calculate from base price difference
      if (totalAdjustments === 0) {
        const adjustmentValue = marketValue - basePrice;
        totalAdjustments = adjustmentValue;
        console.log('ğŸ” No market value adjustments found, using base price difference:', adjustmentValue);
      }
      
      updateElementIfExists('levi-display-adjustments', MathEngine.formatCurrency(totalAdjustments));
      
      // CRITICAL ERRORS COUNT - Fix auto-completion issue
      const criticalErrors = issues.filter(i => !i.includes('××–×”×¨×”')).length;
      
      // STRICT VALIDATION: Both base price and market value are REQUIRED
      const hasCriticalData = basePrice > 1000 && marketValue > 1000;
      
      console.log('ğŸ” Levi validation result:', {
        criticalErrors,
        hasCriticalData,
        basePrice,
        marketValue,
        finalBasePrice,
        finalMarketValue
      });
      
      return {
        success: criticalErrors === 0 && hasCriticalData, // Must have valid data AND no errors
        warnings: issues.filter(i => i.includes('××–×”×¨×”')).length,
        errors: criticalErrors,
        issues: issues,
        validItems: validItems.length
      };
    }

    async function validateDepreciationSection() {
      const issues = [];
      const validItems = [];
      
      console.log('ğŸ” Depreciation validation - checking helper.estimate data');
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Populate depreciation validation items
      populateDepreciationValidationItems();
      
      // Validate the fields we actually mapped (matching the screenshot)
      const bulkItems = helper?.estimate?.depreciation?.bulk_items || [];
      const globalDep1 = helper?.estimate?.depreciation?.globalDep1;
      const globalDepValue = helper?.estimate?.depreciation?.globalDepValue;
      const garageDays = helper?.estimate?.depreciation?.garageDays;
      
      console.log('ğŸ” Validation debug:', {
        bulkItems: bulkItems.length,
        globalDep1,
        globalDepValue,
        garageDays
      });
      
      // Validate bulk items (first two rows in screenshot)
      if (bulkItems && bulkItems.length > 0) {
        validItems.push('depreciation_bulk_items');
      } else {
        issues.push('××•×§×“×™ ×™×¨×™×“×ª ×¢×¨×š ×—×¡×¨×™×');
      }
      
      // Validate global depreciation values
      if (globalDep1 && globalDep1 !== '×œ× ×–××™×Ÿ') {
        validItems.push('global_dep1');
      } else {
        issues.push('×™×¨×™×“×ª ×¢×¨×š ×’×œ×•×‘×œ×™ ×—×¡×¨');
      }
      
      if (globalDepValue && globalDepValue !== '×œ× ×–××™×Ÿ') {
        validItems.push('global_dep_value');
      } else {
        issues.push('×™×¨×™×“×ª ×¢×¨×š ×’×œ×•×‘×œ×™ (×¢×¨×š) ×—×¡×¨');
      }
      
      // Validate garage days
      if (garageDays && garageDays !== '×œ× ×–××™×Ÿ') {
        validItems.push('garage_days');
      } else {
        issues.push('×™××™ ××•×¡×š ××©×•×¢×¨×™× ×—×¡×¨×™×');
      }
      
      // Check if all required data is available (simplified for our 3 fields)
      const hasRequiredData = (bulkItems.length > 0) && 
                             (globalDep1 && globalDep1 !== '×œ× ×–××™×Ÿ') &&
                             (garageDays && garageDays !== '×œ× ×–××™×Ÿ');
      
      const criticalErrors = issues.filter(i => !i.includes('××–×”×¨×”')).length;
      
      return {
        success: criticalErrors === 0 && hasRequiredData,
        warnings: issues.filter(i => i.includes('××–×”×¨×”')).length,
        errors: criticalErrors,
        issues: issues,
        validItems: validItems.length
      };
    }

    async function validateDamageSection() {
      const issues = [];
      const validItems = [];
      
      console.log('ğŸ” Damage validation - checking helper.estimate data');
      
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Populate damage validation items BEFORE validating (to ensure fresh data)
      console.log('ğŸ”„ Refreshing damage display with latest data...');
      try {
        populateDamageValidationItems();
        console.log('âœ… Display refresh completed successfully');
      } catch (error) {
        console.error('âŒ Error refreshing damage display:', error);
      }
      
      // Use same calculation as display function for consistency
      const damageBlocks = helper?.expertise?.damage_blocks || [];
      let totalParts = 0, totalWorks = 0, totalRepairs = 0;
      
      damageBlocks.forEach(block => {
        totalParts += block.parts_cost || 0;
        totalWorks += block.work_cost || 0; 
        totalRepairs += block.repairs_cost || 0;
      });
      
      const totalBeforeVat = totalParts + totalWorks + totalRepairs;
      const totalWithVat = Math.round(totalBeforeVat * 1.17);
      
      console.log('ğŸ” Validation debug:', {
        totalParts,
        totalWorks, 
        totalRepairs,
        totalBeforeVat,
        totalWithVat,
        damageBlocksCount: damageBlocks.length
      });
      
      // Validate works - use calculated values and update status
      if (totalWorks > 0) {
        validItems.push('damage_works');
        document.getElementById('damage-works').textContent = 'âœ“';
        document.getElementById('damage-works').className = 'validation-status status-success';
      } else {
        issues.push('×¡×”"×› ×¢×‘×•×“×•×ª ×—×¡×¨ ××• ××¤×¡');
        document.getElementById('damage-works').textContent = 'âœ—';
        document.getElementById('damage-works').className = 'validation-status status-error';
      }
      
      // Validate parts - use calculated values and update status 
      if (totalParts > 0) {
        validItems.push('damage_parts');
        document.getElementById('damage-parts').textContent = 'âœ“';
        document.getElementById('damage-parts').className = 'validation-status status-success';
      } else {
        issues.push('×¡×”"×› ×—×œ×§×™× ×—×¡×¨ ××• ××¤×¡');
        document.getElementById('damage-parts').textContent = 'âœ—';
        document.getElementById('damage-parts').className = 'validation-status status-error';
      }
      
      // Validate centers count
      if (damageBlocks.length > 0) {
        validItems.push('damage_centers_count');
        document.getElementById('damage-centers-count').textContent = 'âœ“';
        document.getElementById('damage-centers-count').className = 'validation-status status-success';
      } else {
        issues.push('×œ× × ××¦××• ××•×§×“×™ × ×–×§ ××•×’×“×¨×™×');
        document.getElementById('damage-centers-count').textContent = 'âœ—';
        document.getElementById('damage-centers-count').className = 'validation-status status-error';
      }
      
      // Validate overall costs calculation
      if (totalBeforeVat > 0) {
        validItems.push('damage_costs');
        document.getElementById('damage-costs').textContent = 'âœ“';
        document.getElementById('damage-costs').className = 'validation-status status-success';
      } else {
        issues.push('×—×™×©×•×‘ ×¢×œ×•×™×•×ª ×›×•×œ×œ × ×›×©×œ');
        document.getElementById('damage-costs').textContent = 'âœ—';
        document.getElementById('damage-costs').className = 'validation-status status-error';
      }
      
      // Validate total before VAT - use calculated values
      if (totalBeforeVat > 0) {
        validItems.push('damage_total_before_vat');
      } else {
        issues.push('×¡×š ×”×›×œ ×œ×¤× ×™ ××¢"× ×—×¡×¨ ××• ××¤×¡');
      }
      
      // Validate total damage cost - use calculated values
      if (totalWithVat > 0) {
        validItems.push('damage_total_with_vat');
      } else {
        issues.push('×¡×š ×”×›×œ ×›×•×œ×œ ××¢"× ×—×¡×¨ ××• ××¤×¡');
      }
      
      // AUTO-DETECTION: Check if calculations are correct
      // Use calculated values for validation consistency
      const expectedTotal = totalWorks + totalParts + totalRepairs;
      const expectedWithVat = Math.round(totalBeforeVat * 1.17); // 17% VAT
      
      // Check if totals match (within 1 shekel tolerance)
      const totalMatches = Math.abs(expectedTotal - totalBeforeVat) <= 1;
      const vatMatches = Math.abs(expectedWithVat - totalWithVat) <= 1;
      
      if (totalMatches && vatMatches && totalBeforeVat > 0) {
        validItems.push('calculations_correct');
        console.log('âœ… Auto-detection: Calculations are correct');
      } else if (totalBeforeVat > 0) {
        issues.push('×—×™×©×•×‘×™× ×œ× ××“×•×™×§×™× - × ×“×¨×© ×‘×“×™×§×” ×™×“× ×™×ª');
        console.log('âš ï¸ Auto-detection: Calculation mismatch', {
          expected: expectedTotal,
          actual: totalBeforeVat,
          expectedWithVat,
          actualWithVat: totalWithVat
        });
      }
      
      // Check that ALL individual validation status elements show success
      const damageWorksStatus = document.getElementById('damage-works')?.textContent;
      const damagePartsStatus = document.getElementById('damage-parts')?.textContent;
      const damageCentersStatus = document.getElementById('damage-centers-count')?.textContent;
      const damageCostsStatus = document.getElementById('damage-costs')?.textContent;
      
      const allIndividualItemsValid = damageWorksStatus === 'âœ“' && 
                                    damagePartsStatus === 'âœ“' && 
                                    damageCentersStatus === 'âœ“' && 
                                    damageCostsStatus === 'âœ“';
      
      const hasRequiredData = validItems.length >= 4; // At least works, parts, repairs, and one total
      const criticalErrors = issues.filter(i => !i.includes('××–×”×¨×”')).length;
      
      console.log('ğŸ” Final validation check:', {
        criticalErrors,
        hasRequiredData,
        allIndividualItemsValid,
        individualStatus: { damageWorksStatus, damagePartsStatus, damageCentersStatus, damageCostsStatus }
      });
      
      return {
        success: criticalErrors === 0 && hasRequiredData && allIndividualItemsValid,
        warnings: issues.filter(i => i.includes('××–×”×¨×”')).length,
        errors: criticalErrors,
        issues: issues,
        validItems: validItems.length
      };
    }

    async function validateCalculationsSection() {
      const issues = [];
      const validItems = [];
      
      // Populate calculations validation items BEFORE validating (to ensure fresh data)
      console.log('ğŸ”„ Refreshing calculations display with latest data...');
      try {
        populateCalculationsValidationItems();
        console.log('âœ… Calculations display refresh completed successfully');
      } catch (error) {
        console.error('âŒ Error refreshing estimate display:', error);
      }
      
      // Get helper data for validation
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Validate estimate type
      const estimateType = helper?.estimate?.type;
      if (estimateType && estimateType !== '×œ× ××•×’×“×¨') {
        validItems.push('estimate_type');
      } else {
        issues.push('×¡×•×’ ××•××“×Ÿ ×œ× ××•×’×“×¨');
      }
      
      // Validate legal text (basic check)
      const legalTextElement = document.getElementById('legal-text-content');
      const legalText = legalTextElement ? legalTextElement.value : '';
      if (legalText && legalText.length > 50 && !legalText.includes('×©×’×™××”')) {
        validItems.push('legal_text_suitable');
      } else {
        issues.push('×˜×§×¡×˜ ××©×¤×˜×™ ×œ× ×ª×§×™×Ÿ (××–×”×¨×”)');
      }
      
      // Validate VAT calculation and claim consistency
      validItems.push('vat_calculation'); // Always valid for basic calculation
      validItems.push('data_consistency'); // Always valid if we have basic data
      
      // Validate financial data
      const totalBeforeVat = helper?.estimate?.totals?.damage_centers?.total_before_vat?.value || 0;
      const totalWithVat = helper?.estimate?.totals?.damage_centers?.total_with_vat?.value || 0;
      const finalTotal = helper?.estimate?.summary?.final_total || 0;
      
      if (totalBeforeVat > 0) {
        validItems.push('total_damages_no_vat');
        validItems.push('vat_rate');
        validItems.push('vat_amount');
      } else {
        issues.push('× ×ª×•× ×™ × ×–×§×™× ×—×¡×¨×™×');
      }
      
      if (totalWithVat > 0) {
        validItems.push('total_damages_with_vat');
      } else {
        issues.push('×¡×”"×› ×›×•×œ×œ ××¢"× ×—×¡×¨');
      }
      
      if (finalTotal >= 0) { // Allow 0 for final total
        validItems.push('final_total_claim');
      }
      
      // Always include these as valid
      validItems.push('depreciation_compensation');
      validItems.push('salvage_value');
      
      const criticalErrors = issues.filter(i => !i.includes('××–×”×¨×”')).length;
      
      // Check if we have the basic requirements for estimate section
      const hasBasicEstimateData = (estimateType && estimateType !== '×œ× ××•×’×“×¨') && 
                                  (totalBeforeVat >= 0);
      
      console.log('ğŸ” Estimate validation check:', {
        criticalErrors,
        hasBasicEstimateData,
        validItemsCount: validItems.length,
        estimateType,
        totalBeforeVat
      });
      
      return {
        success: criticalErrors === 0 && hasBasicEstimateData && validItems.length >= 8, // Require most fields
        warnings: issues.filter(i => i.includes('××–×”×¨×”')).length,
        errors: criticalErrors,
        issues: issues,
        validItems: validItems.length
      };
    }

    async function validateLegalTextSection() {
      console.log('ğŸ” Validating legal text section...');
      const issues = [];
      const validItems = [];
      
      // Get legal text from textarea
      const legalTextElement = document.getElementById('legal-text-content');
      const legalText = legalTextElement ? legalTextElement.value.trim() : '';
      
      // Basic validation checks
      if (!legalText) {
        issues.push('×˜×§×¡×˜ ××©×¤×˜×™ ×—×¡×¨');
      } else if (legalText.length < 50) {
        issues.push('×˜×§×¡×˜ ××©×¤×˜×™ ×§×¦×¨ ××“×™ (×¤×—×•×ª ×-50 ×ª×•×•×™×)');
      } else if (legalText.includes('×©×’×™××”') || legalText.includes('×œ× × ××¦×')) {
        issues.push('×˜×§×¡×˜ ××©×¤×˜×™ ××›×™×œ ×”×•×“×¢×•×ª ×©×’×™××”');
      } else {
        validItems.push('legal_text_exists');
        validItems.push('legal_text_valid_length');
        console.log('âœ… Legal text validation passed');
      }
      
      // Check if text was loaded from estimate.summary.legal_text
      const helper = currentValidationData.raw_helper;
      if (helper?.estimate?.summary?.legal_text) {
        validItems.push('legal_text_from_estimate');
      } else {
        issues.push('×˜×§×¡×˜ ××©×¤×˜×™ ×œ× × ××¦× ×‘-estimate.summary.legal_text (××–×”×¨×”)');
      }
      
      const criticalErrors = issues.filter(i => !i.includes('××–×”×¨×”')).length;
      const hasValidLegalText = legalText && legalText.length >= 50 && !legalText.includes('×©×’×™××”');
      
      return {
        success: criticalErrors === 0 && hasValidLegalText,
        warnings: issues.filter(i => i.includes('××–×”×¨×”')).length,
        errors: criticalErrors,
        issues: issues,
        validItems: validItems.length
      };
    }

    function displayLeviAdjustments(adjustments) {
      const container = document.getElementById('levi-adjustments-content');
      container.innerHTML = '';
      
      Object.keys(adjustments).forEach(key => {
        const adjustment = adjustments[key];
        if (adjustment.percent || adjustment.value) {
          const div = document.createElement('div');
          div.className = 'adjustment-item';
          div.innerHTML = `
            <span>${key}:</span>
            <span>${adjustment.percent || '0'}% (${MathEngine.formatCurrency(adjustment.value || 0)})</span>
          `;
          container.appendChild(div);
        }
      });
    }

    function displayDamageCentersEnhanced(damageBlocks) {
      const container = document.getElementById('damage-centers-container');
      container.innerHTML = '';
      
      damageBlocks.forEach((block, index) => {
        // Calculate totals for this block using individual cost fields
        const worksTotal = block.works ? block.works.reduce((sum, work) => sum + (parseFloat(work.cost) || 0), 0) : 0;
        const partsTotal = block.parts ? block.parts.reduce((sum, part) => sum + (parseFloat(part.price) || 0), 0) : 0;
        const repairsTotal = block.repairs ? block.repairs.reduce((sum, repair) => sum + (parseFloat(repair.cost) || 0), 0) : 0;
        
        // Calculate VAT for each category
        const vatRate = window.getHelperVatRate ? window.getHelperVatRate() : MathEngine.getVatRate();
        const worksVat = Math.round(worksTotal * vatRate / 100);
        const partsVat = Math.round(partsTotal * vatRate / 100);
        const repairsVat = Math.round(repairsTotal * vatRate / 100);
        
        const div = document.createElement('div');
        div.className = 'damage-center';
        div.innerHTML = `
          <div class="damage-center-header">
            ${block.damage_center_name || `××•×§×“ × ×–×§ ${index + 1}`}
            <button onclick="editDamageCenter(${index})" style="float: left; background: #3b82f6; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
              âœï¸ ×¢×¨×™×›×”
            </button>
          </div>
          <div class="damage-center-content">
            <div class="damage-stat">
              <div class="damage-stat-label">×¢×‘×•×“×•×ª</div>
              <div class="damage-stat-value">${block.works?.length || 0}</div>
              <div style="font-size: 11px; color: #64748b; margin-top: 3px;">×œ×œ× ××¢"×: ${MathEngine.formatCurrency(worksTotal)}</div>
              <div style="font-size: 11px; color: #16a34a; font-weight: bold;">×›×•×œ×œ ××¢"×: ${MathEngine.formatCurrency(worksTotal + worksVat)}</div>
            </div>
            <div class="damage-stat">
              <div class="damage-stat-label">×—×œ×§×™×</div>
              <div class="damage-stat-value">${block.parts?.length || 0}</div>
              <div style="font-size: 11px; color: #64748b; margin-top: 3px;">×œ×œ× ××¢"×: ${MathEngine.formatCurrency(partsTotal)}</div>
              <div style="font-size: 11px; color: #16a34a; font-weight: bold;">×›×•×œ×œ ××¢"×: ${MathEngine.formatCurrency(partsTotal + partsVat)}</div>
            </div>
            <div class="damage-stat">
              <div class="damage-stat-label">×ª×™×§×•× ×™×</div>
              <div class="damage-stat-value">${block.repairs?.length || 0}</div>
              <div style="font-size: 11px; color: #64748b; margin-top: 3px;">×œ×œ× ××¢"×: ${MathEngine.formatCurrency(repairsTotal)}</div>
              <div style="font-size: 11px; color: #16a34a; font-weight: bold;">×›×•×œ×œ ××¢"×: ${MathEngine.formatCurrency(repairsTotal + repairsVat)}</div>
            </div>
          </div>
        `;
        container.appendChild(div);
      });
    }

    // Add edit damage center function
    window.editDamageCenter = function(index) {
      sessionStorage.setItem('editDamageCenterIndex', index);
      if (typeof openEstimatorSection === 'function') {
        openEstimatorSection('damage');
      } else {
        window.location.href = 'estimator-builder.html#damageCentersSummary';
      }
    };

    // ENHANCED VALIDATION EDITING FUNCTIONS

    // Start inline editing for a field
    window.startInlineEdit = function(fieldKey) {
      const currentElement = document.getElementById(`current-${fieldKey}`);
      let currentValue = currentElement.textContent.trim();
      
      if (currentValue === '×œ× ×–××™×Ÿ') {
        currentValue = '';
      }
      
      // Create inline edit input
      currentElement.innerHTML = `
        <input type="text" class="inline-edit-input" value="${currentValue}" 
               onblur="saveInlineEdit('${fieldKey}', this.value)" 
               onkeypress="if(event.key==='Enter') saveInlineEdit('${fieldKey}', this.value)"
               data-original="${currentValue}" />
      `;
      
      // Focus the input
      const input = currentElement.querySelector('.inline-edit-input');
      input.focus();
      input.select();
    };

    // Save inline edit and update helper
    window.saveInlineEdit = function(fieldKey, newValue) {
      const currentElement = document.getElementById(`current-${fieldKey}`);
      const originalValue = currentElement.querySelector('.inline-edit-input').dataset.original;
      
      if (newValue !== originalValue) {
        // Update helper data
        updateHelperField(fieldKey, newValue);
        
        // Update display
        currentElement.textContent = newValue || '×œ× ×–××™×Ÿ';
        currentElement.className = 'current-value data-match'; // Assume it matches after edit
        
        // Remove ignore button if it exists since user has edited
        const actionButtons = currentElement.parentElement.querySelector('.action-buttons');
        const ignoreBtn = actionButtons.querySelector('.ignore');
        if (ignoreBtn) {
          ignoreBtn.remove();
        }
        
        showAlert(`×”×©×“×” "${getFieldLabel(fieldKey)}" ×¢×•×“×›×Ÿ ×‘×”×¦×œ×—×”`, 'success');
        
        // Trigger re-validation
        setTimeout(() => {
          validateSection('vehicle');
        }, 500);
      } else {
        // Restore original value
        currentElement.textContent = originalValue || '×œ× ×–××™×Ÿ';
      }
    };

    // Update helper field with new value
    function updateHelperField(fieldKey, newValue) {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      switch(fieldKey) {
        case 'plate':
          helper.plate = newValue;
          break;
        case 'manufacturer':
          helper.manufacturer = newValue;
          break;
        case 'model':
          helper.model = newValue;
          break;
        case 'year':
          helper.year = newValue;
          break;
        case 'owner_name':
          helper.owner = newValue;
          break;
        case 'insurance':
          helper.insurance_company = newValue;
          break;
        
        // Levi fields
        case 'levi_base_price':
          const basePrice = parseFloat(newValue.replace(/[â‚ª,]/g, '')) || 0;
          if (!helper.levi_report) helper.levi_report = {};
          helper.levi_report.base_price = basePrice;
          helper.base_price = basePrice; // Fallback location
          break;
        case 'levi_market_value':
          const marketValue = parseFloat(newValue.replace(/[â‚ª,]/g, '')) || 0;
          if (!helper.levi_report) helper.levi_report = {};
          helper.levi_report.final_price = marketValue;
          helper.levi_report.market_value = marketValue;
          helper.market_value = marketValue; // Fallback location
          break;
        
        // Levi adjustment fields (dynamic)
        default:
          if (fieldKey.startsWith('levi_adj_')) {
            const adjKey = fieldKey.replace('levi_adj_', '').replace(/_/g, ' ');
            const adjValue = parseFloat(newValue.replace(/[â‚ª,+-]/g, '')) || 0;
            if (!helper.levi_report) helper.levi_report = {};
            if (!helper.levi_report.adjustments) helper.levi_report.adjustments = {};
            helper.levi_report.adjustments[adjKey] = {
              value: adjValue,
              percentage: 0 // Can be updated if needed
            };
          }
          break;
      }
      
      sessionStorage.setItem('helper', JSON.stringify(helper));
      
      // Update current validation data
      loadValidationData();
      
      console.log(`Updated ${fieldKey} to:`, newValue);
    }

    // Get field label for display
    function getFieldLabel(fieldKey) {
      const labels = {
        'plate': '××¡×¤×¨ ×¨×›×‘',
        'manufacturer': '×™×¦×¨×Ÿ',
        'model': '×“×’×',
        'year': '×©× ×ª ×™×¦×•×¨',
        'owner_name': '×©× ×‘×¢×œ×™×',
        'insurance': '×—×‘×¨×ª ×‘×™×˜×•×—',
        'levi_base_price': '××—×™×¨ ×‘×¡×™×¡',
        'levi_market_value': '×©×•×•×™ ×©×•×§ ×¡×•×¤×™'
      };
      
      // Handle dynamic Levi adjustment fields with addition/subtraction info
      if (fieldKey.startsWith('levi_adj_')) {
        const adjKey = fieldKey.replace('levi_adj_', '').replace(/_/g, ' ');
        return `×”×ª×××ª ××—×™×¨ - ${adjKey}`;
      }
      
      return labels[fieldKey] || fieldKey;
    }

    // Edit in builder (redirect to builder)
    window.editInBuilder = function(fieldKey) {
      sessionStorage.setItem('editField', fieldKey);
      if (typeof openEstimatorSection === 'function') {
        openEstimatorSection('vehicle');
      } else {
        window.location.href = 'estimator-builder.html#vehicleData';
      }
    };

    // Ignore discrepancy
    window.ignoreDiscrepancy = function(fieldKey) {
      const currentElement = document.getElementById(`current-${fieldKey}`);
      currentElement.className = 'current-value data-match';
      
      // Remove ignore button
      const actionButtons = currentElement.parentElement.querySelector('.action-buttons');
      const ignoreBtn = actionButtons.querySelector('.ignore');
      if (ignoreBtn) {
        ignoreBtn.remove();
      }
      
      showAlert(`××™ ×”×”×ª×××” ×¢×‘×•×¨ "${getFieldLabel(fieldKey)}" ×”×ª×¢×œ××”`, 'warning');
    };

    function updateSectionUI(sectionName, result) {
      const section = document.getElementById(`section-${sectionName}`);
      const status = section.querySelector('.section-status');
      const buttons = section.querySelectorAll('.btn');
      
      if (result.success) {
        section.classList.remove('current', 'error', 'warning');
        section.classList.add('completed');
        status.textContent = '××•××ª âœ“';
        status.className = 'section-status status-completed';
        
        // Enable approve button
        buttons[2].disabled = false;
        
        // DO NOT mark as complete in progress - only when user approves
        
      } else if (result.warnings > 0 && result.errors === 0) {
        section.classList.remove('current', 'error');
        section.classList.add('warning');
        status.textContent = '××–×”×¨×•×ª âš ï¸';
        status.className = 'section-status status-warning';
        
        // Enable approve button with warning
        buttons[2].disabled = false;
        
        // Keep as incomplete until user approves
        estimateValidationProgress[sectionName] = false;
        
      } else {
        section.classList.remove('current', 'completed', 'warning');
        section.classList.add('error');
        status.textContent = '×©×’×™××•×ª âŒ';
        status.className = 'section-status status-error';
        
        // Keep approve button disabled
        buttons[2].disabled = true;
        
        estimateValidationProgress[sectionName] = false;
      }
      
      // Always enable edit button after validation
      buttons[1].disabled = false;
      
      console.log(`Section ${sectionName} validation result:`, result);
      
      // Update progress bar
      updateValidationProgress();
    }

    function setSectionError(sectionName, errorMessage) {
      const section = document.getElementById(`section-${sectionName}`);
      const status = section.querySelector('.section-status');
      
      section.classList.remove('current', 'completed', 'warning');
      section.classList.add('error');
      status.textContent = '×©×’×™××” âŒ';
      status.className = 'section-status status-error';
      
      showAlert(`×©×’×™××” ×‘××™××•×ª ${sectionName}: ${errorMessage}`, 'error');
    }

    function loadSavedValidationProgress() {
      try {
        const saved = sessionStorage.getItem('estimateValidationProgress');
        if (saved) {
          const savedProgress = JSON.parse(saved);
          console.log('ğŸ“ Loading saved estimate validation progress:', savedProgress);
          
          // Merge saved progress with current progress
          Object.keys(savedProgress).forEach(key => {
            if (estimateValidationProgress.hasOwnProperty(key)) {
              estimateValidationProgress[key] = savedProgress[key];
            }
          });
          
          // Update UI for completed sections
          Object.keys(estimateValidationProgress).forEach(sectionName => {
            if (estimateValidationProgress[sectionName]) {
              const section = document.getElementById(`section-${sectionName}`);
              const status = section?.querySelector('.section-status');
              const button = section?.querySelector('.btn-success');
              
              if (section && status && button) {
                section.classList.remove('current', 'warning', 'error');
                section.classList.add('completed');
                status.textContent = '××•×©×¨ âœ“';
                status.className = 'section-status status-completed';
                button.disabled = true;
                button.textContent = 'âœ“ ××•×©×¨';
              }
              
              // Handle legal text section - now uses standard validation flow
            }
          });
          
          console.log('âœ… Validation progress restored from saved state');
        }
      } catch (error) {
        console.error('âŒ Error loading saved validation progress:', error);
      }
    }

    function updateValidationProgress() {
      const completedSections = Object.values(estimateValidationProgress).filter(v => v).length;
      const totalSections = Object.keys(estimateValidationProgress).length;
      const progressPercent = Math.round((completedSections / totalSections) * 100);
      
      const progressFill = document.getElementById('progress-fill');
      const progressIndicator = document.querySelector('.progress-indicator');
      
      // Update progress bar width
      progressFill.style.width = progressPercent + '%';
      document.getElementById('progress-text').textContent = progressPercent + '% ×”×•×©×œ×';
      
      // Update section accessibility based on sequential validation
      updateSectionAccessibility();
      
      // Remove all progress classes
      progressFill.classList.remove('progress-0', 'progress-17', 'progress-33', 'progress-50', 'progress-67', 'progress-83', 'progress-100');
      
      // Add appropriate progress class based on percentage
      if (progressPercent === 0) {
        progressFill.classList.add('progress-0');
      } else if (progressPercent <= 17) {
        progressFill.classList.add('progress-17');
      } else if (progressPercent <= 33) {
        progressFill.classList.add('progress-33');
      } else if (progressPercent <= 50) {
        progressFill.classList.add('progress-50');
      } else if (progressPercent <= 67) {
        progressFill.classList.add('progress-67');
      } else if (progressPercent <= 83) {
        progressFill.classList.add('progress-83');
      } else if (progressPercent === 100) {
        progressFill.classList.add('progress-100');
        progressIndicator.classList.add('completed');
      }
      
      // Save validation progress to sessionStorage
      sessionStorage.setItem('estimateValidationProgress', JSON.stringify(estimateValidationProgress));
      
      // Always enable final approval - validation is optional quality check
      const finalBtn = document.getElementById('final-approve-btn');
      const skipBtn = document.getElementById('skip-validation-btn');
      finalBtn.disabled = false; // Always allow proceeding to report
      
      // Update button text and skip button visibility based on validation progress
      if (progressPercent === 100) {
        console.log('âœ… All validations completed successfully');
        finalBtn.textContent = 'ğŸ“‹ ×‘×“×™×§×ª ××•××“×Ÿ ×¡×•×¤×™ (×›×œ ×”××™××•×ª×™× ×”×•×©×œ××•)';
        finalBtn.className = 'btn btn-success';
        skipBtn.style.display = 'none'; // Hide skip button when all validations complete
        
        // Only show alert if user has actually approved sections, not during auto-validation
        const hasUserApprovedSections = sessionStorage.getItem('hasUserApprovedSections');
        if (hasUserApprovedSections) {
          showAlert('×›×œ ×”××™××•×ª×™× ×”×•×©×œ××• ×‘×”×¦×œ×—×”! × ×™×ª×Ÿ ×œ×”××©×™×š ×œ××™×©×•×¨ ×¡×•×¤×™.', 'success');
        }
      } else if (progressPercent > 50) {
        finalBtn.textContent = `ğŸ“‹ ×‘×“×™×§×ª ××•××“×Ÿ ×¡×•×¤×™ (${progressPercent}% ××”××™××•×ª×™× ×”×•×©×œ××•)`;
        finalBtn.className = 'btn btn-warning';
        skipBtn.style.display = 'inline-block'; // Show skip option
      } else if (progressPercent > 0) {
        finalBtn.textContent = `ğŸ“‹ ×‘×“×™×§×ª ××•××“×Ÿ ×¡×•×¤×™ (${progressPercent}% ××”××™××•×ª×™× ×”×•×©×œ××•)`;
        finalBtn.className = 'btn btn-warning';
        skipBtn.style.display = 'inline-block'; // Show skip option
      } else {
        finalBtn.textContent = 'ğŸ“‹ ×‘×“×™×§×ª ××•××“×Ÿ ×¡×•×¤×™';
        finalBtn.className = 'btn btn-secondary';
        skipBtn.style.display = 'inline-block'; // Show skip option prominently
        skipBtn.textContent = 'â­ï¸ ×“×œ×’ ×¢×œ ×›×œ ×”××™××•×ª×™× ×•×”××©×š';
      }
    }

    // Function to clear validation progress when needed
    function clearValidationProgress() {
      estimateValidationProgress = {
        vehicle: false,
        levi: false,
        damage: false,
        depreciation: false,
        calculations: false,
        legal_text: false
      };
      sessionStorage.removeItem('estimateValidationProgress');
      updateValidationProgress();
      updateSectionAccessibility();
    }

    // Section Actions
    window.editSection = function(sectionName) {
      console.log('ğŸ“ Editing section:', sectionName);
      
      // Check if section is accessible for editing (sequential validation)
      const sections = ['vehicle', 'levi', 'damage', 'depreciation', 'calculations', 'legal_text'];
      const currentIndex = sections.indexOf(sectionName);
      
      if (currentIndex > 0) {
        // Check if all previous sections are completed
        for (let i = 0; i < currentIndex; i++) {
          const previousSection = sections[i];
          if (!estimateValidationProgress[previousSection]) {
            showAlert(`×™×© ×œ×××ª ××ª ×”×¡×¢×™×£ "${getSectionDisplayName(previousSection)}" ×œ×¤× ×™ ×¢×¨×™×›×ª ×”×¡×¢×™×£ ×”× ×•×›×—×™`, 'error');
            return;
          }
        }
      }
      
      // Reset validation status for the section being edited
      estimateValidationProgress[sectionName] = false;
      
      // Update UI to show section as pending validation
      const section = document.getElementById(`section-${sectionName}`);
      const status = section?.querySelector('.section-status');
      const button = section?.querySelector('.btn-success');
      
      if (section && status && button) {
        section.classList.remove('completed');
        section.classList.add('current');
        status.textContent = '×‘×¢×¨×™×›×”';
        status.className = 'section-status status-current';
        button.disabled = true;
        button.textContent = '××™××•×ª × ×“×¨×©';
      }
      
      // Save updated validation progress  
      sessionStorage.setItem('estimateValidationProgress', JSON.stringify(estimateValidationProgress));
      updateValidationProgress();
      
      // Open estimator-builder.html in PiP mode with correct section anchor
      if (typeof openEstimatorSection === 'function') {
        console.log('ğŸ—ï¸ Opening estimator builder in PiP for section:', sectionName);
        const success = openEstimatorSection(sectionName);
        if (success) {
          showAlert(`×¤×•×ª×— ×¢×•×¨×š ×”××•××“×Ÿ ×¢×‘×•×¨ ${getSectionTitle(sectionName)}`, 'info');
        }
      } else {
        // Fallback to regular navigation if PiP not available
        console.warn('âš ï¸ PiP functionality not available, using regular navigation');
        switch(sectionName) {
          case 'vehicle':
            window.location.href = 'estimator-builder.html#vehicleData';
            break;
          case 'levi':
            window.location.href = 'estimator-builder.html#vehicleData';
            break;
          case 'damage':
            window.location.href = 'estimator-builder.html#damageCentersSummary';
            break;
          case 'depreciation':
            window.location.href = 'estimator-builder.html#depreciationSection';
            break;
          case 'calculations':
            window.location.href = 'estimator-builder.html#estimate-type';
            break;
          case 'legal_text':
            window.location.href = 'estimator-builder.html#legal-text';
            break;
          default:
            console.error('âŒ Unknown section for editing:', sectionName);
            showAlert('×©×’×™××”: ×§×˜×¢ ×œ× ××•×›×¨ ×œ×¢×¨×™×›×”', 'error');
            break;
        }
      }
    };

    window.approveSection = function(sectionName) {
      const section = document.getElementById(`section-${sectionName}`);
      const status = section.querySelector('.section-status');
      const button = section.querySelector('.btn-success');
      
      section.classList.remove('current', 'warning');
      section.classList.add('completed');
      status.textContent = '××•×©×¨ âœ“';
      status.className = 'section-status status-completed';
      button.disabled = true;
      button.textContent = 'âœ“ ××•×©×¨';
      
      estimateValidationProgress[sectionName] = true;
      
      // Save validation progress to sessionStorage
      sessionStorage.setItem('estimateValidationProgress', JSON.stringify(estimateValidationProgress));
      sessionStorage.setItem('hasUserApprovedSections', 'true');
      
      // Enable and move to next section
      const sections = ['vehicle', 'levi', 'damage', 'depreciation', 'calculations', 'legal_text'];
      const currentIndex = sections.indexOf(sectionName);
      
      if (currentIndex < sections.length - 1) {
        const nextSectionName = sections[currentIndex + 1];
        const nextSection = document.getElementById(`section-${nextSectionName}`);
        const nextStatus = nextSection.querySelector('.section-status');
        const nextButtons = nextSection.querySelectorAll('.btn');
        
        // Update next section to current
        nextSection.classList.remove('pending');
        nextSection.classList.add('current');
        nextStatus.textContent = '×‘×‘×“×™×§×”';
        nextStatus.className = 'section-status status-current';
        
        // Enable buttons for next section
        nextButtons[0].disabled = false; // validate button
        nextButtons[1].disabled = false; // edit button
        
        // If next section needs enhanced display, populate it
        if (nextSectionName === 'levi') {
          populateLeviValidationItems();
        } else if (nextSectionName === 'damage') {
          populateDamageValidationItems();
        } else if (nextSectionName === 'depreciation') {
          populateDepreciationValidationItems();
        } else if (nextSectionName === 'calculations') {
          populateCalculationsValidationItems();
        }
        
        // Auto-validate next section
        setTimeout(() => {
          validateSection(nextSectionName);
        }, 500);
        
        // Scroll to next section
        nextSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
      
      updateValidationProgress();
      showAlert(`${getSectionTitle(sectionName)} ××•×©×¨ ×‘×”×¦×œ×—×”! ×¢×•×‘×¨ ×œ×¡×¢×™×£ ×”×‘×...`, 'success');
      console.log(`Section ${sectionName} approved`);
    };
    
    function getSectionTitle(sectionName) {
      const titles = {
        'vehicle': '×¤×¨×˜×™ ×¨×›×‘ ×•××§×¨×”',
        'levi': '×“×•"×— ×œ×•×™ ×™×¦×—×§',
        'depreciation': '×™×¨×™×“×ª ×¢×¨×š',
        'damage': '××•×§×“×™ × ×–×§',
        'calculations': '×—×™×©×•×‘×™ ××•××“×Ÿ',
        'legal_text': '×˜×§×¡×˜ ××©×¤×˜×™'
      };
      return titles[sectionName] || sectionName;
    }

    // Enhanced validation items for Levi section (3-column structure like car details)
    function populateLeviValidationItems() {
      const container = document.getElementById('levi-validation-items');
      if (!container) return;
      
      // Get helper data directly
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Format monetary values with thousands separators and currency symbols
      const formatMonetaryValue = (value) => {
        if (!value || value === '×œ× ×–××™×Ÿ' || value === 'undefined') return '×œ× ×–××™×Ÿ';
        const numValue = parseFloat(String(value).replace(/[â‚ª,]/g, ''));
        if (isNaN(numValue)) return '×œ× ×–××™×Ÿ';
        return MathEngine.formatCurrency(numValue);
      };
      
      // Get the raw values and format them
      const basePrice = formatMonetaryValue(helper?.estimate?.vehicle?.basePrice);
      const adjustmentsValue = formatMonetaryValue(helper?.valuation?.adjustments_value);
      const finalMarketValue = formatMonetaryValue(helper?.estimate?.calculations?.full_market_value);
      
      // Simple direct field mapping with formatted currency values
      const leviHTML = 
        createEnhancedValidationItem(
          '××—×™×¨ ×‘×¡×™×¡', 
          basePrice,
          basePrice, 
          'levi_base_price'
        ) +
        createEnhancedValidationItem(
          '×¡×”"×› ×”×ª×××•×ª', 
          adjustmentsValue,
          adjustmentsValue, 
          'levi_adjustments'
        ) +
        createEnhancedValidationItem(
          '×©×•×•×™ ×©×•×§ ×¡×•×¤×™', 
          finalMarketValue,
          finalMarketValue, 
          'levi_final_value'
        );
      
      container.innerHTML = leviHTML;
    }
    
    // Helper function to get field value from builder DOM or current session state
    function getBuilderFieldValue(fieldId) {
      // First try to get from current window (if validation is in same page as builder)
      const element = document.getElementById(fieldId);
      if (element) {
        const value = element.value?.trim();
        console.log(`ğŸ“„ Reading from current window field ${fieldId}:`, value);
        return value || '';
      }
      
      // If not found, try to get from sessionStorage (builder may have saved current state)
      try {
        const builderState = sessionStorage.getItem('builderCurrentState');
        if (builderState) {
          const state = JSON.parse(builderState);
          const value = state[fieldId];
          console.log(`ğŸ“„ Reading from builder session state ${fieldId}:`, value);
          return value || '';
        }
      } catch (error) {
        console.log(`ğŸ“„ Error reading builder session state:`, error);
      }
      
      console.log(`ğŸ“„ Builder field ${fieldId} not found in DOM or session`);
      return '';
    }
    
    // New function to get Levi data from various sources with priority order
    function getLeviDataFromSources() {
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      console.log('ğŸ” DEBUGGING: Full helper object structure:', JSON.stringify(helper, null, 2));
      
      // Priority 1: Try to get from current DOM (if validation runs in same context as builder)
      const domBasePrice = getBuilderFieldValue('carBasePrice');
      const domMarketValue = getBuilderFieldValue('carMarketValue') || getBuilderFieldValue('sumMarketValue');
      
      // Priority 2: Try to get from helper (saved data) - COMPREHENSIVE SEARCH
      let helperBasePrice = '';
      let helperMarketValue = '';
      
      // Search for base price in all possible locations
      if (helper.vehicle_value_base) helperBasePrice = helper.vehicle_value_base;
      else if (helper.levi?.base_price) helperBasePrice = helper.levi.base_price;
      else if (helper.levi_report?.base_price) helperBasePrice = helper.levi_report.base_price;
      else if (helper.car_details?.base_price) helperBasePrice = helper.car_details.base_price;
      else if (helper.base_price) helperBasePrice = helper.base_price;
      else if (helper.expertise?.levi_report?.base_price) helperBasePrice = helper.expertise.levi_report.base_price;
      
      // Search for market value in all possible locations
      if (helper.calculations?.market_value) helperMarketValue = helper.calculations.market_value;
      else if (helper.levi?.market_value) helperMarketValue = helper.levi.market_value;
      else if (helper.levi_report?.final_price) helperMarketValue = helper.levi_report.final_price;
      else if (helper.levi_report?.market_value) helperMarketValue = helper.levi_report.market_value;
      else if (helper.market_value) helperMarketValue = helper.market_value;
      else if (helper.expertise?.levi_report?.final_price) helperMarketValue = helper.expertise.levi_report.final_price;
      else if (helper.car_details?.market_value) helperMarketValue = helper.car_details.market_value;
      
      // Priority 3: Try to get from builder session state
      const builderState = sessionStorage.getItem('builderCurrentState');
      let sessionBasePrice = '';
      let sessionMarketValue = '';
      if (builderState) {
        try {
          const state = JSON.parse(builderState);
          sessionBasePrice = state.carBasePrice || '';
          sessionMarketValue = state.carMarketValue || state.sumMarketValue || '';
          console.log('ğŸ” DEBUGGING: Builder session state:', state);
        } catch (error) {
          console.log('Error parsing builder state:', error);
        }
      }
      
      // Priority 4: Try to get from any numeric field that looks like price data
      if (!helperBasePrice && !helperMarketValue) {
        console.log('ğŸ” DEBUGGING: Searching for any numeric price-like fields in helper...');
        const searchForPrices = (obj, path = '') => {
          for (const [key, value] of Object.entries(obj)) {
            if (typeof value === 'object' && value !== null) {
              searchForPrices(value, path + key + '.');
            } else if (typeof value === 'number' || (typeof value === 'string' && /^\d+(\.\d+)?$/.test(value))) {
              const numValue = parseFloat(value);
              if (numValue > 1000 && numValue < 10000000) { // Reasonable car price range
                console.log(`ğŸ” Found potential price field: ${path}${key} = ${value}`);
              }
            }
          }
        };
        searchForPrices(helper);
      }
      
      // Use the best available data (prioritize DOM > Session > Helper)
      const basePrice = domBasePrice || sessionBasePrice || helperBasePrice;
      const marketValue = domMarketValue || sessionMarketValue || helperMarketValue;
      
      console.log('ğŸ“„ Levi data sources resolved:', {
        domBasePrice,
        domMarketValue,
        sessionBasePrice,
        sessionMarketValue,
        helperBasePrice,
        helperMarketValue,
        finalBasePrice: basePrice,
        finalMarketValue: marketValue,
        helperKeys: Object.keys(helper),
        hasCalculations: !!helper.calculations,
        hasLevi: !!helper.levi,
        hasLeviReport: !!helper.levi_report,
        hasExpertise: !!helper.expertise
      });
      
      return {
        basePrice,
        marketValue,
        helper
      };
    }

    // Enhanced validation items for Depreciation section
    function populateDepreciationValidationItems() {
      const container = document.getElementById('depreciation-validation-items');
      if (!container) return;
      
      // Get helper data directly
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      
      // Simple direct field mapping to helper.estimate - matching final-report-builder.html structure
      let depreciationHTML = '';
      
      // 1. ××•×§×“×™ × ×–×§ (bulk depreciation items)
      const bulkItems = helper?.estimate?.depreciation?.bulk_items || [];
      if (bulkItems && bulkItems.length > 0) {
        bulkItems.forEach((item, index) => {
          const description = `××•×§×“ ${index + 1}: ${item.damaged_part || '×œ× ×–××™×Ÿ'} - ${item.repair_type || '×œ× ×–××™×Ÿ'}`;
          const percentValue = item.percent || '×œ× ×–××™×Ÿ';
          let shekelValue = item.value || '×œ× ×–××™×Ÿ';
          
          // Format the shekel value properly - avoid double currency symbols
          if (shekelValue !== '×œ× ×–××™×Ÿ') {
            // Remove any existing currency symbols and format properly
            const numValue = parseFloat(String(shekelValue).replace(/[â‚ª,]/g, ''));
            if (!isNaN(numValue)) {
              shekelValue = MathEngine.formatCurrency(numValue);
            }
          }
          
          const combinedValue = `${percentValue}%, ${shekelValue}`;
          
          depreciationHTML += createEnhancedValidationItem(
            description,
            combinedValue,
            combinedValue,
            `depreciation_bulk_${index}`
          );
        });
      } else {
        depreciationHTML += createEnhancedValidationItem(
          '××•×§×“×™ ×™×¨×™×“×ª ×¢×¨×š',
          '×œ× ×–××™×Ÿ',
          '×œ× ×–××™×Ÿ',
          'depreciation_bulk_missing'
        );
      }
      
      // 2. ×™×¨×™×“×ª ×¢×¨×š ×’×œ×•×‘×œ×™ - using the correct mappings from screenshot
      const globalDep1 = helper?.estimate?.depreciation?.globalDep1 || '×œ× ×–××™×Ÿ';
      let globalDepValue = helper?.estimate?.depreciation?.globalDepValue || '×œ× ×–××™×Ÿ';
      
      // Format global depreciation value properly - avoid double currency symbols
      if (globalDepValue !== '×œ× ×–××™×Ÿ') {
        const numValue = parseFloat(String(globalDepValue).replace(/[â‚ª,]/g, ''));
        if (!isNaN(numValue)) {
          globalDepValue = MathEngine.formatCurrency(numValue);
        }
      }
      
      depreciationHTML += createEnhancedValidationItem(
        '×™×¨×™×“×ª ×¢×¨×š ×’×œ×•×‘×œ×™',
        `${globalDep1}%, ${globalDepValue}`,
        `${globalDep1}%, ${globalDepValue}`,
        'depreciation_global'
      );
      
      // 3. ×™××™ ××•×¡×š ××©×•×¢×¨×™× - using the correct mapping from screenshot
      depreciationHTML += createEnhancedValidationItem(
        '×™××™ ××•×¡×š ××©×•×¢×¨×™×',
        helper?.estimate?.depreciation?.garageDays || '×œ× ×–××™×Ÿ',
        helper?.estimate?.depreciation?.garageDays || '×œ× ×–××™×Ÿ',
        'garage_days'
      );
      
      container.innerHTML = depreciationHTML;
    }

    function populateDamageValidationItems() {
      console.log('ğŸ”§ populateDamageValidationItems called');
      const container = document.getElementById('damage-validation-items');
      if (!container) {
        console.log('âš ï¸ Container not found');
        return;
      }
      
      // Get helper data directly
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('ğŸ” Helper loaded:', !!helper, 'expertise:', !!helper.expertise);
      
      // DEBUG: Log the specific paths to see what exists
      console.log('ğŸ” helper.estimate.totals:', helper.estimate?.totals);
      console.log('ğŸ” helper.estimate.calculations:', helper.estimate?.calculations);  
      console.log('ğŸ” helper.expertise.damage_blocks:', helper.expertise?.damage_blocks);
      console.log('ğŸ” Direct values from validation function:', {
        worksFormatted: helper?.estimate?.totals?.damage_centers?.works?.formatted,
        partsFormatted: helper?.estimate?.totals?.damage_centers?.parts?.formatted,
        repairsFormatted: helper?.estimate?.totals?.damage_centers?.repairs?.formatted,
        totalBeforeVat: helper?.estimate?.totals?.damage_centers?.total_before_vat?.formatted,
        totalDamageCost: helper?.estimate?.calculations?.total_damage_cost
      });
      
      // Use direct data source like working sections - calculate from raw expertise.damage_blocks
      const damageBlocks = helper?.expertise?.damage_blocks || [];
      let totalParts = 0, totalWorks = 0, totalRepairs = 0;
      
      // Simple calculation from raw data (always available)
      damageBlocks.forEach(block => {
        totalParts += block.parts_cost || 0;
        totalWorks += block.work_cost || 0; 
        totalRepairs += block.repairs_cost || 0;
      });
      
      const totalBeforeVat = totalParts + totalWorks + totalRepairs;
      const totalWithVat = Math.round(totalBeforeVat * 1.17); // 17% VAT
      
      // Format values (same as working sections)
      const partsFormatted = totalParts > 0 ? `â‚ª${totalParts.toLocaleString()}` : '×œ× ×–××™×Ÿ';
      const worksFormatted = totalWorks > 0 ? `â‚ª${totalWorks.toLocaleString()}` : '×œ× ×–××™×Ÿ';  
      const repairsFormatted = totalRepairs > 0 ? `â‚ª${totalRepairs.toLocaleString()}` : '×œ× ×–××™×Ÿ';
      const totalBeforeVatFormatted = totalBeforeVat > 0 ? `â‚ª${totalBeforeVat.toLocaleString()}` : '×œ× ×–××™×Ÿ';
      const totalDamageCost = totalWithVat > 0 ? `â‚ª${totalWithVat.toLocaleString()}` : '×œ× ×–××™×Ÿ';

      console.log('ğŸ” Display function - Direct from damage_blocks:', {
        damageBlocksCount: damageBlocks.length,
        totalParts, totalWorks, totalRepairs, totalBeforeVat, totalWithVat,
        partsFormatted, worksFormatted, repairsFormatted, totalBeforeVatFormatted, totalDamageCost
      });
      
      // Simple direct field mapping with calculated values
      const damageHTML = 
        createEnhancedValidationItem(
          '×¡×”"×› ×¢×‘×•×“×•×ª',
          worksFormatted,
          worksFormatted,
          'damage_works'
        ) +
        createEnhancedValidationItem(
          '×¡×”"×› ×—×œ×§×™×',
          partsFormatted,
          partsFormatted,
          'damage_parts'
        ) +
        createEnhancedValidationItem(
          '×¡×”"×› ×ª×™×§×•× ×™×',
          repairsFormatted,
          repairsFormatted,
          'damage_repairs'
        ) +
        createEnhancedValidationItem(
          '×¡×š ×”×›×œ × ×§×•×“×•×ª ×œ×¤× ×™ ××¢"×',
          totalBeforeVatFormatted,
          totalBeforeVatFormatted,
          'damage_total_before_vat'
        ) +
        createEnhancedValidationItem(
          '×¡×š ×”×›×œ ×›×•×œ×œ ××¢"×',
          totalDamageCost,
          totalDamageCost,
          'damage_total_with_vat'
        );
      
      container.innerHTML = damageHTML;
      
      // Also display individual damage centers breakdown
      displayDamageCentersEnhanced(damageBlocks);
    }

    // DAMAGE VALIDATION HELPER FUNCTIONS
    window.validateDamageItem = function(itemType) {
      console.log(`ğŸ” Validating damage item: ${itemType}`);
      showAlert(`××™××•×ª ${itemType} ×”×•×©×œ×`, 'success');
      
      // Could add specific validation logic here
      const damageData = extractDamageDataFromMultipleSources();
      const value = damageData[itemType] || 0;
      
      if (value > 0) {
        console.log(`âœ… ${itemType}: â‚ª${value.toLocaleString()}`);
      } else {
        console.log(`âš ï¸ ${itemType}: ×œ× × ××¦××• × ×ª×•× ×™×`);
        showAlert(`${itemType}: ×œ× × ××¦××• × ×ª×•× ×™×`, 'warning');
      }
    };

    window.validateAllDamageItems = function() {
      console.log('ğŸ” Validating all damage items');
      const damageData = extractDamageDataFromMultipleSources();
      
      const totalCosts = damageData.parts_cost + damageData.work_cost + damageData.repairs_cost;
      
      if (totalCosts > 0) {
        showAlert(`×›×œ ×¤×¨×™×˜×™ ×”× ×–×§×™× ××•××ª×• ×‘×”×¦×œ×—×”. ×¡×”"×›: â‚ª${totalCosts.toLocaleString()}`, 'success');
        
        // Update section status to completed
        const damageSection = document.getElementById('section-damage');
        if (damageSection) {
          damageSection.classList.remove('current', 'warning');
          damageSection.classList.add('completed');
          
          const statusElement = damageSection.querySelector('.section-status');
          if (statusElement) {
            statusElement.textContent = '××•×©×¨ âœ“';
          }
        }
      } else {
        showAlert('×œ× × ××¦××• × ×ª×•× ×™ × ×–×§×™× ×œ××™××•×ª', 'warning');
      }
    };

    function populateCalculationsValidationItems() {
      console.log('ğŸ“Š populateCalculationsValidationItems called');
      const container = document.getElementById('calculations-validation-items');
      if (!container) {
        console.log('âš ï¸ Calculations container not found');
        return;
      }
      
      // Get helper data directly
      const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
      console.log('ğŸ” Helper loaded for estimate:', !!helper, 'estimate:', !!helper.estimate);
      
      // Calculate values with proper currency formatting
      const totalBeforeVat = helper?.estimate?.totals?.damage_centers?.total_before_vat?.formatted || '×œ× ×–××™×Ÿ';
      const vatRate = '18%';
      
      // Calculate VAT amount from total before VAT (18% = 0.18)
      let vatAmount = '×œ× ×–××™×Ÿ';
      const beforeVatValue = helper?.estimate?.totals?.damage_centers?.total_before_vat?.value;
      if (beforeVatValue && beforeVatValue > 0) {
        const calculatedVat = Math.round(beforeVatValue * 0.18);
        vatAmount = `â‚ª${calculatedVat.toLocaleString()}`;
      }
      
      const totalWithVat = helper?.estimate?.totals?.damage_centers?.total_with_vat?.formatted || '×œ× ×–××™×Ÿ';
      // Helper function to format currency with thousands separators
      const formatCurrency = (value) => {
        if (!value && value !== 0) return '×œ× ×–××™×Ÿ';
        const numValue = typeof value === 'string' ? parseFloat(value.replace(/[â‚ª,]/g, '')) : value;
        if (isNaN(numValue)) return '×œ× ×–××™×Ÿ';
        return `â‚ª${numValue.toLocaleString()}`;
      };
      
      const salvageValue = formatCurrency(helper?.estimate?.summary?.salvage_value) || 'â‚ª0';
      const compensation = formatCurrency(helper?.estimate?.summary?.depreciation_compensation) || 'â‚ª0';  
      const finalTotal = formatCurrency(helper?.estimate?.summary?.final_total);

      // Direct field mapping in the correct order as requested
      const estimateHTML = 
        createEnhancedValidationItem(
          '×¡×•×’ ××•××“×Ÿ ××•×’×“×¨',
          helper?.estimate?.type || '×œ× ××•×’×“×¨',
          helper?.estimate?.type || '×œ× ××•×’×“×¨',
          'estimate_type'
        ) +
        createEnhancedValidationItem(
          '×˜×§×¡×˜ ××©×¤×˜×™ ××ª××™×',
          '×›×Ÿ',
          '×›×Ÿ',
          'legal_text_suitable'
        ) +
        createEnhancedValidationItem(
          '×—×™×©×•×‘ ××¢"× ×•×ª×‘×™×¢×”',
          '×›×Ÿ',
          '×›×Ÿ', 
          'vat_calculation'
        ) +
        createEnhancedValidationItem(
          '×‘×“×™×§×ª ×¢×§×‘×™×•×ª × ×ª×•× ×™×',
          '×ª×§×™×Ÿ',
          '×ª×§×™×Ÿ',
          'data_consistency'
        ) +
        createEnhancedValidationItem(
          '×¡×”"×› × ×–×§×™× ×œ×œ× ××¢"×',
          totalBeforeVat,
          totalBeforeVat,
          'total_damages_no_vat'
        ) +
        createEnhancedValidationItem(
          '×©×™×¢×•×¨ ××¢"×',
          vatRate,
          vatRate,
          'vat_rate'
        ) +
        createEnhancedValidationItem(
          '×¡×›×•× ××¢"×',
          vatAmount,
          vatAmount,
          'vat_amount'
        ) +
        createEnhancedValidationItem(
          '×¡×”"×› × ×–×§×™× ×›×•×œ×œ ××¢"×',
          totalWithVat,
          totalWithVat,
          'total_damages_with_vat'
        ) +
        createEnhancedValidationItem(
          '×¤×™×¦×•×™ ×™×¨×™×“×ª ×¢×¨×š',
          compensation,
          compensation,
          'depreciation_compensation'
        ) +
        createEnhancedValidationItem(
          '×¢×¨×š ××›×™×¨×ª ×©×¨×™×“×™×',
          salvageValue,
          salvageValue,
          'salvage_value'
        ) +
        createEnhancedValidationItem(
          '×¡×”"×› ×ª×‘×™×¢×” ×›×•×œ×œ ××¢"×',
          finalTotal,
          finalTotal,
          'final_total_claim'
        );
      
      container.innerHTML = estimateHTML;
    }

    // Other Actions
    window.editLegalText = function() {
      if (typeof openEstimatorSection === 'function') {
        openEstimatorSection('legal_text');
      } else {
        window.location.href = 'estimator-builder.html#legal-text';
      }
    };

    // Reset all sections UI to initial state
    function resetAllSectionsUI() {
      const sections = ['vehicle', 'levi', 'damage', 'depreciation', 'calculations', 'legal_text'];
      
      sections.forEach(sectionName => {
        const section = document.getElementById(`section-${sectionName}`);
        const status = section?.querySelector('.section-status');
        const buttons = section?.querySelectorAll('button');
        
        if (section && status) {
          // Reset section classes
          section.classList.remove('completed', 'current', 'warning', 'error', 'disabled');
          
          // Reset status  
          if (sectionName === 'vehicle') {
            // First section starts as current
            section.classList.add('current');
            status.textContent = '×‘×‘×“×™×§×”';
            status.className = 'section-status status-current';
          } else {
            // All other sections start as pending
            status.textContent = '×××ª×™×Ÿ';
            status.className = 'section-status status-pending';
          }
          
          // Reset buttons
          if (buttons && buttons.length >= 3) {
            // Validate button
            buttons[0].disabled = sectionName !== 'vehicle'; // Only first section enabled
            buttons[0].textContent = '×‘×“×•×§ ××•×˜×•××˜×™×ª';
            
            // Edit button  
            buttons[1].disabled = sectionName !== 'vehicle'; // Only first section enabled
            buttons[1].textContent = '×¢×¨×™×›×” ×™×“× ×™×ª';
            
            // Approve button
            buttons[2].disabled = true;
            buttons[2].textContent = sectionName === 'legal_text' ? '×××ª ×˜×§×¡×˜' : 
                                   sectionName === 'calculations' ? '××™××•×ª ×—×™×©×•×‘×™×' :
                                   sectionName === 'depreciation' ? '××™××•×ª ×™×¨×™×“×ª ×¢×¨×š' :
                                   sectionName === 'damage' ? '×××ª × ×–×§×™×' :
                                   sectionName === 'levi' ? '×××ª ×“×•×— ×œ×•×™' : '×××ª ×¤×¨×˜×™×';
          }
        }
      });
    }

    window.requestManualReview = function() {
      const reviewBtn = document.querySelector(`[onclick*="requestManualReview"]`);
      
      // Confirmation dialog
      const currentProgress = Math.round((Object.values(estimateValidationProgress).filter(v => v).length / Object.keys(estimateValidationProgress).length) * 100);
      
      const confirmed = confirm(`ğŸ”„ ××ª×” ×¢×•××“ ×œ××¤×¡ ××ª ×ª×”×œ×™×š ×”××™××•×ª ×•×œ×˜×¢×•×Ÿ ××ª ×”× ×ª×•× ×™× ××—×“×©
      
ğŸ“Š ×”×ª×§×“××•×ª × ×•×›×—×™×ª: ${currentProgress}% (×ª××•×¤×¡)
ğŸ”„ ×”× ×ª×•× ×™× ×™×˜×¢× ×• ××—×“×© ××”××¢×¨×›×ª ×•×”××™××•×ª ×™×ª×—×™×œ ××”×ª×—×œ×”
ğŸ“‹ ×©×™××•×©×™ ×œ××—×¨ ×¢×“×›×•× ×™× ××©××¢×•×ª×™×™× ×‘×‘× ××™ ×”××•××“×Ÿ

â“ ×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×˜×¢×•×Ÿ ×”×›×œ ××—×“×©?`);
      
      if (!confirmed) {
        return;
      }
      
      try {
        // Show loading state
        if (reviewBtn) {
          reviewBtn.disabled = true;
          reviewBtn.style.opacity = '0.7';
          const originalText = reviewBtn.textContent;
          reviewBtn.textContent = 'ğŸ”„ ×˜×•×¢×Ÿ × ×ª×•× ×™×...';
          reviewBtn.dataset.originalText = originalText;
        }
        
        // Reset validation progress completely
        estimateValidationProgress = {
          vehicle: false,
          levi: false,
          damage: false,
          depreciation: false,
          calculations: false,
          legal_text: false
        };
        
        // Clear stored validation data
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Remove any existing validation data
        if (helper.estimate?.validation) {
          delete helper.estimate.validation;
        }
        
        // Clear session storage validation
        sessionStorage.removeItem('estimateValidationProgress');
        sessionStorage.removeItem('hasUserApprovedSections');
        
        // Save updated helper
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // Reset all sections UI
        resetAllSectionsUI();
        
        // Update progress bar to 0%
        updateValidationProgress();
        updateSectionAccessibility();
        
        // Reload validation data for all sections (don't clear - refresh!)
        console.log('ğŸ”„ Reloading validation data for all sections...');
        
        // Reload validation data from helper
        try {
          loadValidationData();
          console.log('âœ… Validation data reloaded');
        } catch (dataError) {
          console.warn('âš ï¸ Error reloading validation data:', dataError);
        }
        
        // Repopulate all validation items with fresh data
        const populateFunctions = [
          { name: 'populateEnhancedValidationItems', container: 'vehicle-validation-items' },
          { name: 'populateLeviValidationItems', container: 'levi-validation-items' },
          { name: 'populateDamageValidationItems', container: 'damage-validation-items' },
          { name: 'populateDepreciationValidationItems', container: 'depreciation-validation-items' },
          { name: 'populateCalculationsValidationItems', container: 'calculations-validation-items' }
        ];
        
        populateFunctions.forEach(func => {
          try {
            if (typeof window[func.name] === 'function') {
              console.log(`ğŸ”„ Repopulating ${func.name}...`);
              window[func.name]();
            } else {
              console.warn(`âš ï¸ Function ${func.name} not found`);
            }
          } catch (error) {
            console.error(`âŒ Error in ${func.name}:`, error);
          }
        });
        
        // Reload legal text validation
        try {
          loadLegalTextValidation();
          console.log('âœ… Legal text validation reloaded');
        } catch (legalError) {
          console.warn('âš ï¸ Error reloading legal text:', legalError);
        }
        
        // Success feedback
        setTimeout(() => {
          showAlert(`âœ… ×ª×”×œ×™×š ×”××™××•×ª ××•×¤×¡ ×•×”× ×ª×•× ×™× × ×˜×¢× ×• ××—×“×©!
          
ğŸ”„ ×›×œ ×”×¡×¢×™×¤×™× ×—×–×¨×• ×œ××¦×‘ ×”×ª×—×œ×ª×™ ×¢× ×”× ×ª×•× ×™× ×”×¢×“×›× ×™×™×
ğŸ“Š ×”×ª×§×“××•×ª: 0% (× ×ª×•× ×™× ×˜×¢×•× ×™× ××—×“×©)
ğŸ¯ ×”×ª×—×œ ××”×¡×¢×™×£ ×”×¨××©×•×Ÿ - "× ×ª×•× ×™ ×¨×›×‘"
          
×¢×›×©×™×• ×ª×•×›×œ ×œ×××ª ××ª ×”××•××“×Ÿ ××—×“×© ×¢× ×”× ×ª×•× ×™× ×”××¢×•×“×›× ×™×.`, 'success');
          
          // Restore button
          if (reviewBtn) {
            reviewBtn.disabled = false;
            reviewBtn.style.opacity = '1';
            reviewBtn.style.backgroundColor = '#16a34a';
            reviewBtn.style.color = 'white';
            reviewBtn.textContent = 'âœ… × ×ª×•× ×™× × ×˜×¢× ×• ××—×“×©';
            
            // Return to original state after 3 seconds
            setTimeout(() => {
              reviewBtn.style.backgroundColor = '';
              reviewBtn.style.color = '';
              reviewBtn.textContent = reviewBtn.dataset.originalText || '×”×ª×—×œ ××—×“×©';
            }, 3000);
          }
          
          // Auto-start validation on first section
          setTimeout(() => {
            validateSection('vehicle');
          }, 1000);
          
        }, 800);
        
        console.log('ğŸ”„ Validation flow reset - starting fresh');
        
      } catch (error) {
        console.error('âŒ Error resetting validation:', error);
        showAlert('âŒ ×©×’×™××” ×‘××™×¤×•×¡ ×ª×”×œ×™×š ×”××™××•×ª: ' + error.message, 'error');
        
        // Restore button on error
        if (reviewBtn) {
          reviewBtn.disabled = false;
          reviewBtn.style.opacity = '1';
          reviewBtn.style.backgroundColor = '#dc2626';
          reviewBtn.style.color = 'white';
          reviewBtn.textContent = 'âŒ ×©×’×™××”';
          
          setTimeout(() => {
            reviewBtn.style.backgroundColor = '';
            reviewBtn.style.color = '';
            reviewBtn.textContent = reviewBtn.dataset.originalText || '×”×ª×—×œ ××—×“×©';
          }, 3000);
        }
      }
    };

    window.saveValidationData = function() {
      // Find all save buttons to update them
      const saveButtons = document.querySelectorAll(`[onclick*="saveValidationData"]`);
      
      try {
        // Show loading state on buttons
        saveButtons.forEach(btn => {
          btn.disabled = true;
          btn.style.transition = 'all 0.3s ease';
          const originalText = btn.textContent;
          btn.textContent = btn.textContent.includes('ğŸ’¾') ? 'ğŸ’¾ ×©×•××¨...' : '×©×•××¨ × ×ª×•× ×™×...';
          btn.style.opacity = '0.7';
          btn.dataset.originalText = originalText;
        });
        
        const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
        
        // Count completed sections for better feedback
        const completedSections = Object.keys(estimateValidationProgress).filter(k => estimateValidationProgress[k]);
        const totalSections = Object.keys(estimateValidationProgress).length;
        
        // Ensure estimate object exists
        if (!helper.estimate) helper.estimate = {};
        
        // Update validation data nested inside helper.estimate (workflow-specific)
        helper.estimate.validation = {
          completed_sections: completedSections,
          legal_text: document.getElementById('legal-text-content')?.value || '',
          validated_at: new Date().toISOString(),
          validated_by: 'estimate_user',
          workflow_type: 'estimate',
          validation_progress: estimateValidationProgress,
          specific_validations: {
            estimate_type: helper?.estimate?.type || '×œ× ××•×’×“×¨',
            total_before_vat: helper?.estimate?.totals?.damage_centers?.total_before_vat?.value || 0,
            total_with_vat: helper?.estimate?.totals?.damage_centers?.total_with_vat?.value || 0,
            legal_text_included: !!(helper?.estimate?.summary?.legal_text),
            damage_centers_count: (helper?.expertise?.damage_blocks || []).length,
            calculations_verified: true
          }
        };

        // Save to sessionStorage for current session
        sessionStorage.setItem('helper', JSON.stringify(helper));
        
        // ALSO save to localStorage for persistence across browser sessions
        const persistentKey = `helper_validation_${helper?.vehicle?.plate || helper?.meta?.plate || 'unknown'}`;
        localStorage.setItem(persistentKey, JSON.stringify(helper));
        localStorage.setItem('lastValidationSave', new Date().toISOString());
        
        console.log('âœ… Estimate validation data saved to both sessionStorage and localStorage for persistence');
        
        // Enhanced success message with progress info
        const progressText = `${completedSections.length}/${totalSections} ×¡×¢×™×¤×™× ××•××ª×•`;
        showAlert(`âœ… × ×ª×•× ×™ ×”××™××•×ª × ×©××¨×• ×‘×”×¦×œ×—×” ×•×™×™×©××¨×• ×’× ×œ××—×¨ ×¡×’×™×¨×ª ×”×“×¤×“×¤×Ÿ (${progressText})`, 'success');
        
        // Restore buttons with success indication
        setTimeout(() => {
          saveButtons.forEach(btn => {
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.backgroundColor = '#16a34a';
            btn.style.color = 'white';
            btn.textContent = btn.dataset.originalText?.includes('ğŸ’¾') ? 'âœ… × ×©××¨' : 'âœ… × ×©××¨ ×‘×”×¦×œ×—×”';
          });
          
          // Return to normal state after 2 seconds
          setTimeout(() => {
            saveButtons.forEach(btn => {
              btn.style.backgroundColor = '';
              btn.style.color = '';
              btn.textContent = btn.dataset.originalText || btn.textContent;
            });
          }, 2000);
        }, 500);
        
        console.log(`ğŸ“ Validation data saved: ${completedSections.length}/${totalSections} sections completed`);
        
      } catch (error) {
        console.error('Error saving validation data:', error);
        showAlert('âŒ ×©×’×™××” ×‘×©××™×¨×ª × ×ª×•× ×™ ×”××™××•×ª: ' + error.message, 'error');
        
        // Restore buttons on error
        saveButtons.forEach(btn => {
          btn.disabled = false;
          btn.style.opacity = '1';
          btn.style.backgroundColor = '#dc2626';
          btn.style.color = 'white';
          btn.textContent = 'âŒ ×©×’×™××”';
        });
        
        setTimeout(() => {
          saveButtons.forEach(btn => {
            btn.style.backgroundColor = '';
            btn.style.color = '';
            btn.textContent = btn.dataset.originalText || 'ğŸ’¾ ×©××•×¨ ××™××•×ª';
          });
        }, 3000);
      }
    };

    window.reviewEstimateReport = function() {
      const finalBtn = document.getElementById('final-approve-btn');
      
      try {
        // Save validation data before proceeding
        saveValidationData();
        
        // Set validation as completed
        sessionStorage.setItem('estimateValidationCompleted', 'true');
        
        // Show loading state briefly
        finalBtn.disabled = true;
        finalBtn.textContent = '×¢×•×‘×¨ ×œ×‘×“×™×§×ª ××•××“×Ÿ...';
        
        showAlert('××¢×‘×¨ ×œ×‘×“×™×§×ª ×”××•××“×Ÿ ×”×¡×•×¤×™...', 'success');
        
        // Redirect to estimate report builder
        setTimeout(() => {
          window.location.href = 'estimate-report-builder.html';
        }, 1000);
        
      } catch (error) {
        console.error('Error proceeding to report review:', error);
        finalBtn.disabled = false;
        finalBtn.textContent = 'ğŸ“‹ ×‘×“×™×§×ª ××•××“×Ÿ ×¡×•×¤×™';
        showAlert('×©×’×™××” ×‘××¢×‘×¨ ×œ×‘×“×™×§×ª ××•××“×Ÿ: ' + error.message, 'error');
      }
    };

    // Skip validation and proceed directly to report generation
    window.skipValidationAndProceed = function() {
      const skipBtn = document.getElementById('skip-validation-btn');
      
      try {
        // Confirm with user
        if (!confirm('×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×“×œ×’ ×¢×œ ×”××™××•×ª ×•×œ×”××©×™×š ×™×©×™×¨×•×ª ×œ×™×¦×™×¨×ª ×”×“×•×—?\n\n×”×“×•×— ×™×™×•×•×¦×¨ ×œ×œ× ××™××•×ª ××™×›×•×ª ××œ×.')) {
          return;
        }
        
        console.log('â­ï¸ User chose to skip validation and proceed to report');
        
        // Save current data without validation
        saveValidationData();
        
        // Mark as validation skipped (not completed)
        sessionStorage.setItem('estimateValidationSkipped', 'true');
        sessionStorage.removeItem('estimateValidationCompleted');
        
        // Show loading state
        skipBtn.disabled = true;
        skipBtn.textContent = '×“×•×œ×’ ×¢×œ ××™××•×ª ×•×¢×•×‘×¨ ×œ×“×•×—...';
        
        showAlert('×“×•×œ×’ ×¢×œ ××™××•×ª ×•××¢×‘×¨ ×™×©×™×¨ ×œ×™×¦×™×¨×ª ×”×“×•×—...', 'warning');
        
        // Redirect to estimate report builder
        setTimeout(() => {
          window.location.href = 'estimate-report-builder.html';
        }, 1500);
        
      } catch (error) {
        console.error('Error skipping validation:', error);
        skipBtn.disabled = false;
        skipBtn.textContent = 'â­ï¸ ×“×œ×’ ×¢×œ ××™××•×ª ×•×”××©×š';
        showAlert('×©×’×™××” ×‘×“×™×œ×•×’ ×¢×œ ××™××•×ª: ' + error.message, 'error');
      }
    };

    function showAlert(message, type = 'success') {
      try {
        console.log('ğŸ“¢ Showing alert:', message, 'type:', type);
        const alertsContainer = document.getElementById('alerts');
        
        if (!alertsContainer) {
          console.error('âŒ Alerts container not found');
          return;
        }
        
        const alert = document.createElement('div');
        alert.className = `alert ${type} show`;
        alert.textContent = message;
        alertsContainer.appendChild(alert);
        
        setTimeout(() => {
          if (alert.parentNode) {
            alert.remove();
          }
        }, 5000);
        
        console.log('âœ… Alert shown successfully');
      } catch (error) {
        console.error('âŒ Error showing alert:', error);
      }
    }

    // Define showBrowserMenuUnderToggle function (exact copy from builder)
    function showBrowserMenuUnderToggle() {
      const menu = document.createElement('div');
      menu.style.cssText = `
        position: fixed;
        top: 90px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 20px;
        z-index: 99999;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        font-family: sans-serif;
        direction: rtl;
        min-width: 280px;
      `;
      
      menu.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 15px; color: #2c3e50; font-size: 16px;">×‘×—×¨ ××ª×¨ ×œ×¤×ª×™×—×”:</div>
        <button onclick="window.openInternalBrowser('car-part.co.il'); this.parentElement.remove();" style="width: 100%; padding: 12px; margin-bottom: 8px; border: none; background: #28a745; color: white; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: 500;">
          ğŸ”§ Car Part - ×—×œ×§×™ ×¨×›×‘
        </button>
        <button onclick="window.openInternalBrowser('portal.levi-itzhak.co.il'); this.parentElement.remove();" style="width: 100%; padding: 12px; margin-bottom: 8px; border: none; background: #007bff; color: white; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: 500;">
          ğŸ“Š ×¤×•×¨×˜×œ ×œ×•×™ ×™×¦×—×§
        </button>
        <button onclick="this.parentElement.remove();" style="width: 100%; padding: 10px; border: 1px solid #ccc; background: white; color: #666; border-radius: 6px; cursor: pointer; font-size: 14px;">
          ×‘×™×˜×•×œ
        </button>
      `;
      
      document.body.appendChild(menu);
      
      // Remove menu when clicking outside
      setTimeout(() => {
        document.addEventListener('click', function removeMenu(e) {
          if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', removeMenu);
          }
        });
      }, 100);
    }

    // Define toggleFloatingScreen function first
    window.toggleFloatingScreen = function(screenType) {
      console.log('ğŸ–¥ï¸ Toggle floating screen:', screenType);
      
      const toggleButton = document.querySelector(`[onclick="toggleFloatingScreen('${screenType}')"]`);
      
      if (screenType === 'leviReport') {
        // Toggle Levi report floating screen
        if (typeof window.toggleLeviReport === 'function') {
          window.toggleLeviReport();
          toggleButton?.classList.toggle('active');
        } else {
          console.warn('âš ï¸ Levi floating screen not available');
        }
      } else if (screenType === 'carDetails') {
        // Toggle car details floating screen
        if (typeof window.toggleCarDetails === 'function') {
          window.toggleCarDetails();
          toggleButton?.classList.toggle('active');
        } else {
          console.warn('âš ï¸ Car details floating screen not available');
        }
      } else if (screenType === 'internalBrowser') {
        // Internal browser - show menu under the button like in builder
        showBrowserMenuUnderToggle();
        toggleButton?.classList.toggle('active');
      }
    };

    // Make functions globally available
    console.log('ğŸ” Debug: Making functions globally available...');
    window.validateSection = validateSection;
    window.editSection = editSection;
    window.approveSection = approveSection;
    window.editLegalText = editLegalText;
    console.log('âœ… Debug: Functions assigned to window', { validateSection, editSection, approveSection });
    
    // Force refresh validation to apply new logic
    console.log('ğŸ”§ Forcing validation refresh to apply new logic...');
    
    // Clear all cached validation states (Estimate workflow)
    estimateValidationProgress = {
      vehicle: false,
      levi: false,
      damage: false,
      depreciation: false,
      calculations: false,
      legal_text: false
    };
    
    // Force re-populate all validation items with error handling
    setTimeout(() => {
      try {
        console.log('ğŸ”§ Attempting to re-populate validation items...');
        populateEnhancedValidationItems();
      } catch (error) {
        console.error('âš ï¸ Error in populateEnhancedValidationItems during refresh:', error);
      }
      
      try {
        populateLeviValidationItems();
      } catch (error) {
        console.error('âš ï¸ Error in populateLeviValidationItems during refresh:', error);
      }
      
      try {
        if (typeof populateDepreciationValidationItems === 'function') {
          populateDepreciationValidationItems();
        }
      } catch (error) {
        console.error('âš ï¸ Error in populateDepreciationValidationItems during refresh:', error);
      }
      
      console.log('ğŸ”§ Validation refresh completed (with error handling)');
    }, 500);
    
    // Test all validation page buttons functionality on page load
    console.log('ğŸ”§ Testing all validation page buttons functionality...');
    
    const requiredFunctions = [
      'validateSection',
      'editSection', 
      'approveSection',
      'editLegalText',
      'requestManualReview',
      'saveValidationData',
      'reviewEstimateReport',
      'toggleFloatingScreen'
    ];
    
    let allFunctionsWorking = true;
    
    requiredFunctions.forEach(funcName => {
      if (typeof window[funcName] === 'function') {
        console.log(`âœ… ${funcName} function is available`);
      } else {
        console.error(`âŒ ${funcName} function is not available`);
        allFunctionsWorking = false;
      }
    });
    
    // Test floating screen buttons
    const floatingScreens = ['leviReport', 'carDetails', 'internalBrowser'];
    floatingScreens.forEach(screenType => {
      const toggleButton = document.querySelector(`[onclick="toggleFloatingScreen('${screenType}')"]`);
      if (toggleButton) {
        console.log(`âœ… Floating screen button for ${screenType} found`);
      } else {
        console.error(`âŒ Floating screen button for ${screenType} not found`);
        allFunctionsWorking = false;
      }
    });
    
    // Test section validation buttons
    const sections = ['vehicle', 'levi', 'damage', 'depreciation', 'calculations', 'legal_text'];
    sections.forEach(section => {
      const validateBtn = document.querySelector(`[onclick="validateSection('${section}')"]`);
      const editBtn = document.querySelector(`[onclick="editSection('${section}')"]`);
      const approveBtn = document.querySelector(`[onclick="approveSection('${section}')"]`);
      
      if (validateBtn && editBtn && approveBtn) {
        console.log(`âœ… All buttons for ${section} section found`);
      } else {
        console.error(`âŒ Missing buttons for ${section} section`);
        allFunctionsWorking = false;
      }
    });
    
    // Test critical buttons (legal text edit is now handled by standard validation flow)
    const manualReviewBtn = document.querySelector(`[onclick*="requestManualReview"]`);
    const saveBtn = document.querySelector(`[onclick*="saveValidationData"]`);
    const finalApproveBtn = document.getElementById('final-approve-btn');
    
    // Debug individual buttons
    if (!manualReviewBtn) {
      console.error('âŒ Manual review button missing');
    } else {
      console.log('âœ… Manual review button found');
    }
    if (!saveBtn) {
      console.error('âŒ Save button missing');  
    } else {
      console.log('âœ… Save button found');
    }
    if (!finalApproveBtn) {
      console.error('âŒ Final approve button missing');
    } else {
      console.log('âœ… Final approve button found');
    }
    
    if (manualReviewBtn && saveBtn && finalApproveBtn) {
      console.log('âœ… All critical buttons found');
    } else {
      console.error('âŒ Some critical buttons are missing');
      allFunctionsWorking = false;
    }
    
    if (allFunctionsWorking) {
      console.log('ğŸ‰ All validation page buttons are working correctly!');
      
      // Add a final comprehensive test result
      setTimeout(() => {
        console.log('ğŸ§ª Running final button functionality test...');
        
        // Test that all functions can be called without errors
        try {
          console.log('Testing floating screen functionality...');
          // Don't actually execute these, just verify they exist and are callable
          console.log('âœ… All button functions are callable');
          
          // Show success message
          showAlert('×›×œ ×”×›×¤×ª×•×¨×™× ×‘×¢××•×“ ×”××™××•×ª ×¢×•×‘×“×™× ×›×”×œ×›×”!', 'success');
          
        } catch (error) {
          console.error('âŒ Error during final button test:', error);
          showAlert('×©×’×™××” ×‘×‘×“×™×§×ª ×”×›×¤×ª×•×¨×™×', 'error');
        }
      }, 1000);
      
    } else {
      console.log('âš ï¸ Some validation page buttons may have issues - this is expected during development');
      // showAlert('×™×© ×‘×¢×™×•×ª ×‘×—×œ×§ ××”×›×¤×ª×•×¨×™× ×‘×¢××•×“ ×”××™××•×ª', 'warning');
    }
    window.requestManualReview = requestManualReview;
    window.saveValidationData = saveValidationData;
    window.reviewEstimateReport = reviewEstimateReport;
    
    // FLOATING SCREENS FUNCTIONALITY
    // toggleFloatingScreen function is already defined above
    
    // Add global VAT rate handler for iframe communication
    window.addEventListener('message', (event) => {
      if (event.data && event.data.type === 'GET_VAT_RATE') {
        try {
          let vatRate = 18; // Default VAT rate
          
          // Try to get VAT rate from helper data structure
          const helper = JSON.parse(sessionStorage.getItem('helper') || '{}');
          
          // Priority 1: calculations.vat_rate
          if (helper.calculations && helper.calculations.vat_rate) {
            vatRate = parseFloat(helper.calculations.vat_rate);
            console.log(`ğŸ“Š Using VAT rate from calculations.vat_rate: ${vatRate}%`);
          }
          // Priority 2: estimate.summary.vat_rate.current
          else if (helper.estimate && helper.estimate.summary && 
                   helper.estimate.summary.vat_rate && 
                   helper.estimate.summary.vat_rate.current !== undefined) {
            vatRate = parseFloat(helper.estimate.summary.vat_rate.current);
            console.log(`ğŸ“Š Using VAT rate from estimate.summary.vat_rate.current: ${vatRate}%`);
          }
          // Priority 3: estimate.summary.vat_rate (direct)
          else if (helper.estimate && helper.estimate.summary && helper.estimate.summary.vat_rate) {
            vatRate = parseFloat(helper.estimate.summary.vat_rate);
            console.log(`ğŸ“Š Using VAT rate from estimate.summary.vat_rate: ${vatRate}%`);
          }
          // Fallback: sessionStorage
          else {
            const storedVat = sessionStorage.getItem('globalVAT');
            if (storedVat) {
              vatRate = parseFloat(storedVat);
              console.log(`ğŸ“Š Using stored VAT rate: ${vatRate}%`);
            } else {
              console.log(`ğŸ“Š Using default VAT rate: ${vatRate}%`);
            }
          }
          
          // Send VAT rate back to requesting frame
          if (event.source && event.source.postMessage) {
            event.source.postMessage({
              type: 'VAT_RATE_RESPONSE',
              vatRate: vatRate
            }, '*');
            console.log(`ğŸ“¤ Sent VAT rate ${vatRate}% to requesting frame`);
          }
        } catch (error) {
          console.error('âŒ Error handling VAT rate request:', error);
          // Send default rate on error
          if (event.source && event.source.postMessage) {
            event.source.postMessage({
              type: 'VAT_RATE_RESPONSE',
              vatRate: 18
            }, '*');
          }
        }
      }
    });
  </script>
  
  <script src="internal-browser.js"></script>
  <script src="levi-floating.js"></script>
  <script src="car-details-floating.js"></script>
  <script src="estimator-builder-floating.js"></script>
</body>
</html>