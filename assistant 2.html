<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ניקול – עוזרת דיגיטלית</title>
  <script type="module" src="./webhook.js"></script>
  <script type="module" src="./helper.js"></script>

  <link rel="icon" type="image/webp" href="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp">
  <link rel="shortcut icon" href="https://carmelcayouf.com/wp-content/uploads/2025/04/logo-yaron.webp">
  <link rel="apple-touch-icon" href="https://carmelcayouf.com/wp-content/uploads/2025/04/logo-yaron.webp">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }
    .container {
      max-width: 480px;
      background: #fff;
      padding: 35px;
      border-radius: 18px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.12);
      text-align: center;
      position: relative;
      width: 90%;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
    }
    .logo img {
      width: 120px;
      margin-bottom: 15px;
    }
    .title { 
      font-size: 26px; 
      font-weight: 700; 
      margin-bottom: 8px; 
      color: #2d3748;
      letter-spacing: -0.5px;
    }
    .subtitle { 
      font-size: 16px; 
      color: #718096; 
      margin-bottom: 8px; 
      font-weight: 500;
    }
    h2 {
      font-size: 22px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 25px;
      font-weight: 600;
      letter-spacing: -0.3px;
    }
    input {
      width: 100%;
      padding: 14px 16px;
      font-size: 15px;
      margin-bottom: 18px;
      border-radius: 14px;
      border: 1.5px solid #e2e8f0;
      box-sizing: border-box;
      transition: all 0.3s ease;
      background: #f7fafc;
      color: #2d3748;
      font-weight: 500;
    }
    
    input:focus {
      outline: none;
      border-color: #667eea;
      background: #fff;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      transform: translateY(-1px);
    }

    /* Modern input container with integrated microphone */
    .input-container {
      position: relative;
      margin-bottom: 20px;
    }
    
    .input-with-mic {
      width: 100%;
      padding: 16px 50px 16px 18px;
      font-size: 15px;
      border-radius: 18px;
      border: 1.5px solid #e2e8f0;
      box-sizing: border-box;
      transition: all 0.3s ease;
      background: #f7fafc;
      resize: none;
      min-height: 90px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #2d3748;
      font-weight: 500;
      line-height: 1.5;
    }
    
    .input-with-mic:focus {
      outline: none;
      border-color: #667eea;
      background: #fff;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.08);
      transform: translateY(-2px);
    }
    
    .mic-button {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 34px;
      height: 34px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 15px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 12px rgba(30, 58, 138, 0.3);
    }
    
    .mic-button:hover {
      transform: translateY(-50%) scale(1.1);
      box-shadow: 0 4px 12px rgba(30, 58, 138, 0.4);
    }
    
    .mic-button:active {
      transform: translateY(-50%) scale(0.95);
    }
    
    .mic-button.recording {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3); }
      50% { box-shadow: 0 4px 16px rgba(255, 107, 107, 0.6); }
      100% { box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3); }
    }
    
    /* Modern button container */
    .button-container {
      display: flex;
      gap: 12px;
      margin-top: 28px;
      justify-content: center;
    }
    
    .btn-modern {
      padding: 12px 24px;
      font-size: 15px;
      font-weight: 600;
      border: none;
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      min-width: 130px;
      letter-spacing: -0.2px;
    }
    
    .btn-send {
      background: linear-gradient(135deg, #16a34a 0%, #22c55e 100%);
      color: white;
      box-shadow: 0 6px 20px rgba(34, 197, 94, 0.3);
    }
    
    .btn-send:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(34, 197, 94, 0.4);
    }
    
    .btn-send:active {
      transform: translateY(-1px);
    }
    
    .btn-clear {
      background: rgba(255, 255, 255, 0.9);
      color: #4a5568;
      border: 1.5px solid #e2e8f0;
      backdrop-filter: blur(10px);
    }
    
    .btn-clear:hover {
      background: rgba(255, 255, 255, 1);
      border-color: #cbd5e0;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    
    .btn-secondary {
      background: #64748b;
      color: white;
      border: 1.5px solid #64748b;
    }
    
    .btn-secondary:hover {
      background: #475569;
      border-color: #475569;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(71, 85, 105, 0.3);
    }
    .floating-response {
      position: fixed;
      bottom: 30px;
      right: 30px;
      max-width: 380px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(102, 126, 234, 0.2);
      padding: 20px;
      border-radius: 18px;
      box-shadow: 0 12px 40px rgba(102, 126, 234, 0.15);
      font-size: 15px;
      color: #2d3748;
      z-index: 1000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      animation: slideInUp 0.3s ease-out;
    }

    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @media (max-width: 480px) {
      .floating-response {
        right: 20px;
        left: 20px;
        max-width: none;
        bottom: 20px;
      }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="logo">
    <img src="https://carmelcayouf.com/wp-content/uploads/2025/06/g.webp" alt="Logo">
  </div>
  <div class="title">ירון כיוף שמאות - פורטל</div>
  <div class="subtitle">שמאי רכב והערכת נזקי רכוש</div>
  <h2>👩‍💼 ניקול – עוזרת דיגיטלית</h2>
  <form id="assistantForm">
    <input type="text" id="plateInput" name="plate" placeholder="מספר רכב (אופציונלי)">
    
    <!-- Modern input container with integrated microphone -->
    <div class="input-container">
      <textarea id="freeQuery" name="query" class="input-with-mic" placeholder="מה תרצה לדעת או לבקש? אפשר לכתוב או להקיש על המיקרופון לדבר..."></textarea>
      <button type="button" id="micBtn" class="mic-button" title="לחץ כדי להקליט קול">
        🎤
      </button>
    </div>
    
    <!-- Modern button container -->
    <div class="button-container">
      <button type="button" class="btn-modern btn-clear" onclick="clearForm()">
        🗑️ נקה
      </button>
      <button type="submit" id="sendBtn" class="btn-modern btn-send">
        <span>📤</span>
        שלח שאלה
      </button>
      <button type="button" class="btn-modern btn-secondary" onclick="window.location.href='selection.html'">
        ↩️ חזור לבחירה
      </button>
    </div>
  </form>
</div>
<div id="agentResponse" class="floating-response" style="display:none;"></div>
<script>
  // Global TTS audio control
  window.currentTTSAudio = null;
  window.isTTSPlaying = false;

  window.addEventListener('DOMContentLoaded', () => {
    // Enhanced authentication audit
    const userAuthToken = sessionStorage.getItem('auth');
    const loginTime = sessionStorage.getItem('loginTime');
    const password = sessionStorage.getItem('password');
    const plate = sessionStorage.getItem('plate');
    
    console.group("🔐 Nicole Authentication Audit");
    console.log("📊 Authentication State:", {
      auth_token: userAuthToken ? userAuthToken.substring(0, 20) + '...' : 'MISSING',
      auth_length: userAuthToken?.length || 0,
      login_time: loginTime,
      password_exists: !!password,
      password_type: password ? typeof password : 'undefined',
      plate_preloaded: plate || 'NONE',
      session_keys: Object.keys(sessionStorage).sort(),
      timestamp: new Date().toISOString()
    });
    
    // Check authentication validity
    const isValidAuth = userAuthToken && loginTime;
    console.log("🎫 Auth Validation:", {
      has_auth_token: !!userAuthToken,
      has_login_time: !!loginTime,
      is_valid: isValidAuth,
      login_age_minutes: loginTime ? Math.round((Date.now() - new Date(loginTime).getTime()) / 60000) : 'N/A'
    });
    
    // Check for auth conflicts or issues
    const authIssues = [];
    if (!userAuthToken) authIssues.push('Missing auth token');
    if (!loginTime) authIssues.push('Missing login time');
    if (!password && !userAuthToken) authIssues.push('No password fallback');
    
    if (authIssues.length > 0) {
      console.warn("⚠️ Authentication Issues:", authIssues);
    }
    
    if (!isValidAuth) {
      console.error("❌ Authentication failed, redirecting to login");
      console.log("🔄 Redirect reason:", authIssues.join(', '));
      alert("הגישה חסומה - אנא התחבר דרך דף הבית");
      window.location.href = 'index.html';
      return;
    }
    
    console.log("✅ Authentication verified successfully");
    console.groupEnd();
    
    // Pre-populate plate if available
    if (plate) {
      document.getElementById('plateInput').value = plate;
      console.log("🚗 Pre-populated plate number:", plate);
    }
    
    // Store auth audit in session for debugging
    sessionStorage.setItem('nicole_auth_audit', JSON.stringify({
      timestamp: new Date().toISOString(),
      auth_valid: true,
      auth_method: password ? 'password' : 'auth_token',
      login_age_minutes: Math.round((Date.now() - new Date(loginTime).getTime()) / 60000)
    }));
    
    // Initialize modern UI functionality
    initializeModernUI();
  });

  // Helper function to detect browser info
  function getBrowserInfo() {
    const ua = navigator.userAgent;
    if (ua.includes('Chrome')) return 'Chrome';
    if (ua.includes('Firefox')) return 'Firefox';
    if (ua.includes('Safari') && !ua.includes('Chrome')) return 'Safari';
    if (ua.includes('Edge')) return 'Edge';
    if (ua.includes('Opera')) return 'Opera';
    return 'Unknown';
  }

  function clearForm() {
    document.getElementById('plateInput').value = '';
    document.getElementById('freeQuery').value = '';
    document.getElementById('freeQuery').focus();
  }

  function initializeModernUI() {
    const micBtn = document.getElementById('micBtn');
    const textarea = document.getElementById('freeQuery');
    const sendBtn = document.getElementById('sendBtn');
    
    // Enhanced microphone button functionality
    let isRecording = false;
    let recordingTimeout;
    let inactivityTimeout;
    let wasVoiceInput = false; // Track if last input was from voice
    const MAX_RECORDING_TIME = 60000; // 60 seconds max recording
    const INACTIVITY_TIMEOUT = 15000; // 15 seconds of silence
    
    micBtn.addEventListener('click', function() {
      if (micBtn.disabled) return;
      
      if (!isRecording) {
        startRecording();
      } else {
        stopRecording();
      }
    });
    
    // Initialize speech recognition
    let recognition;
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      const SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.lang = 'he-IL';
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;
      recognition.continuous = false;

      recognition.addEventListener('result', (event) => {
        const transcript = event.results[0][0].transcript;
        textarea.value = transcript;
        
        // Mark that this input came from voice
        wasVoiceInput = true;
        
        // Reset inactivity timeout when speech is detected
        if (inactivityTimeout) {
          clearTimeout(inactivityTimeout);
          inactivityTimeout = null;
        }
        
        stopRecording();
        console.log('🎤 Speech recognized:', transcript);
      });

      recognition.addEventListener('error', (event) => {
        const errorDetails = {
          error_type: event.error,
          timestamp: new Date().toISOString(),
          user_agent: navigator.userAgent,
          browser: getBrowserInfo(),
          mic_permissions: 'unknown'
        };
        
        console.group('🚨 Microphone Error Analysis');
        console.error('🎤 Speech recognition error:', event.error);
        console.log('📊 Error Details:', errorDetails);
        
        stopRecording();
        
        let errorMessage = 'שגיאה בזיהוי קול';
        let troubleshooting = '';
        let severity = 'medium';
        
        switch(event.error) {
          case 'no-speech':
            errorMessage = 'לא זוהה דיבור. אנא נסה שוב ודבר בקול ברור.';
            troubleshooting = 'בדוק שהמיקרופון עובד ושאין רעש סביבה';
            severity = 'low';
            break;
          case 'audio-capture':
            errorMessage = 'לא ניתן לגשת למיקרופון. אנא בדוק את ההרשאות והחיבור.';
            troubleshooting = '1. בדוק שהמיקרופון מחובר\n2. אשר הרשאות למיקרופון\n3. סגור יישומים אחרים שעשויים להשתמש במיקרופון';
            severity = 'high';
            break;
          case 'not-allowed':
            errorMessage = 'גישה למיקרופון נדחתה. אנא אשר הרשאה בהגדרות הדפדפן.';
            troubleshooting = 'לחץ על סמל המיקרופון בשורת הכתובת ואשר הרשאה';
            severity = 'high';
            break;
          case 'network':
            errorMessage = 'שגיאת רשת. אנא בדוק את החיבור לאינטרנט.';
            troubleshooting = 'בדוק חיבור האינטרנט ונסה שוב';
            severity = 'medium';
            break;
          case 'aborted':
            errorMessage = 'זיהוי הקול הופסק.';
            troubleshooting = 'זוהי שגיאה זמנית, ניתן לנסות שוב';
            severity = 'low';
            break;
          case 'service-not-allowed':
            errorMessage = 'שירות זיהוי קול לא זמין.';
            troubleshooting = 'השירות עשוי להיות חסום או לא זמין באזור שלך';
            severity = 'high';
            break;
          default:
            errorMessage = `שגיאה בזיהוי קול: ${event.error}`;
            troubleshooting = 'שגיאה לא מזוהה, נסה לרענן את הדף';
            severity = 'medium';
        }
        
        // Log detailed error for debugging
        console.log('🛠️ Error Analysis:', {
          error_code: event.error,
          message: errorMessage,
          troubleshooting: troubleshooting,
          severity: severity,
          browser_support: !!window.webkitSpeechRecognition || !!window.SpeechRecognition,
          permissions_api: !!navigator.permissions
        });
        
        // Save error to session for pattern analysis
        const micErrors = JSON.parse(sessionStorage.getItem('nicole_mic_errors') || '[]');
        micErrors.push({
          ...errorDetails,
          message: errorMessage,
          severity: severity,
          troubleshooting: troubleshooting
        });
        // Keep only last 20 errors
        if (micErrors.length > 20) micErrors.shift();
        sessionStorage.setItem('nicole_mic_errors', JSON.stringify(micErrors));
        
        console.groupEnd();
        
        // Show user-friendly error with troubleshooting
        const fullMessage = `${errorMessage}\n\nפתרון מוצע:\n${troubleshooting}`;
        alert(fullMessage);
        
        // If it's a critical error, disable mic button temporarily
        if (severity === 'high') {
          micBtn.style.opacity = '0.5';
          micBtn.disabled = true;
          setTimeout(() => {
            micBtn.style.opacity = '1';
            micBtn.disabled = false;
          }, 10000); // Re-enable after 10 seconds
        }
      });

      recognition.addEventListener('end', () => {
        stopRecording();
      });
      
      // Cleanup function for page unload
      window.addEventListener('beforeunload', () => {
        if (isRecording) {
          stopRecording();
        }
        if (recordingTimeout) clearTimeout(recordingTimeout);
        if (inactivityTimeout) clearTimeout(inactivityTimeout);
      });
      
      // Cleanup function for visibility changes (tab switches)
      document.addEventListener('visibilitychange', () => {
        if (document.hidden && isRecording) {
          console.log('🎤 Tab hidden while recording, stopping...');
          stopRecording();
        }
      });
    } else {
      // Speech recognition not supported
      micBtn.style.opacity = '0.5';
      micBtn.style.cursor = 'not-allowed';
      micBtn.title = 'זיהוי קול לא נתמך בדפדפן זה';
      micBtn.disabled = true;
    }
    
    async function startRecording() {
      if (!recognition) {
        alert('זיהוי קול לא נתמך בדפדפן זה');
        return;
      }

      // Check microphone permissions
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream.getTracks().forEach(track => track.stop()); // Stop the stream immediately
      } catch (error) {
        console.error('🎤 Microphone permission error:', error);
        if (error.name === 'NotAllowedError') {
          alert('נדרשת הרשאה למיקרופון כדי להשתמש בזיהוי קול. אנא אשר את ההרשאה ונסה שוב.');
        } else if (error.name === 'NotFoundError') {
          alert('לא נמצא מיקרופון. אנא חבר מיקרופון ונסה שוב.');
        } else {
          alert('שגיאה בגישה למיקרופון: ' + error.message);
        }
        return;
      }

      isRecording = true;
      micBtn.classList.add('recording');
      micBtn.innerHTML = '⏹️';
      micBtn.title = 'לחץ כדי להפסיק הקלטה';
      
      // Add visual feedback to textarea
      textarea.style.borderColor = '#ff6b6b';
      textarea.placeholder = '🎤 מקליט... דבר עכשיו או לחץ שוב כדי להפסיק';
      
      // Set maximum recording timeout
      recordingTimeout = setTimeout(() => {
        console.log('🎤 Maximum recording time reached, stopping...');
        stopRecording();
        alert('הקלטה הופסקה לאחר דקה. אנא נסה שוב.');
      }, MAX_RECORDING_TIME);
      
      // Set inactivity timeout
      inactivityTimeout = setTimeout(() => {
        console.log('🎤 No speech detected for 15 seconds, stopping...');
        stopRecording();
        // Don't show alert for inactivity timeout - it's normal
      }, INACTIVITY_TIMEOUT);
      
      try {
        recognition.start();
        console.log('🎤 Speech recognition started with timeouts:', {
          max_time: MAX_RECORDING_TIME,
          inactivity_timeout: INACTIVITY_TIMEOUT
        });
      } catch (error) {
        console.error('🎤 Failed to start recognition:', error);
        if (error.message.includes('already started')) {
          // Recognition already running, stop and restart
          recognition.stop();
          setTimeout(() => {
            recognition.start();
          }, 100);
        } else {
          stopRecording();
          alert('שגיאה בהפעלת זיהוי קול: ' + error.message);
        }
      }
    }
    
    function stopRecording() {
      isRecording = false;
      micBtn.classList.remove('recording');
      micBtn.innerHTML = '🎤';
      micBtn.title = 'לחץ כדי להקליט קול';
      
      // Clear all timeouts
      if (recordingTimeout) {
        clearTimeout(recordingTimeout);
        recordingTimeout = null;
      }
      if (inactivityTimeout) {
        clearTimeout(inactivityTimeout);
        inactivityTimeout = null;
      }
      
      // Reset textarea styling
      textarea.style.borderColor = '#e2e8f0';
      textarea.placeholder = 'מה תרצה לדעת או לבקש? אפשר לכתוב או להקיש על המיקרופון לדבר...';
      
      if (recognition) {
        try {
          recognition.stop();
        } catch (error) {
          console.log('Recognition already stopped');
        }
      }
      
      console.log('🎤 Recording stopped with timeout cleanup...');
    }
    
    // Form submission handler
    const form = document.getElementById('assistantForm');
    form.addEventListener('submit', async function(e) {
      e.preventDefault();
      
      const query = textarea.value.trim();
      const plate = document.getElementById('plateInput').value.trim();
      
      // Check if this was voice input (will be reset after processing)
      const currentWasVoiceInput = wasVoiceInput;
      
      // Enhanced validation: require at least one field (plate OR query)
      if (!query && !plate) {
        alert('אנא מלא לפחות שדה אחד:\n• מספר רכב, או\n• שאלה/בקשה');
        
        // Focus on the first empty field
        if (!plate) {
          document.getElementById('plateInput').focus();
          document.getElementById('plateInput').style.animation = 'shake 0.5s';
          setTimeout(() => { document.getElementById('plateInput').style.animation = ''; }, 500);
        } else {
          textarea.focus();
          textarea.style.animation = 'shake 0.5s';
          setTimeout(() => { textarea.style.animation = ''; }, 500);
        }
        
        console.log('❌ Validation failed: Both fields empty', { plate, query });
        return;
      }
      
      // If only plate is provided, create a default query
      let finalQuery = query;
      if (!query && plate) {
        finalQuery = `מה המידע הזמין עבור רכב מספר ${plate}?`;
        console.log('🔄 Auto-generated query for plate-only request:', finalQuery);
      }
      
      console.log('✅ Validation passed:', { 
        plate: plate || 'NONE', 
        query: finalQuery,
        validation_type: query && plate ? 'BOTH' : query ? 'QUERY_ONLY' : 'PLATE_ONLY'
      });
      
      // Add loading state
      sendBtn.innerHTML = '<span>⏳</span> שולח...';
      sendBtn.disabled = true;
      
      try {
        // Store user query in conversation context
        storeConversationContext(finalQuery, 'user');
        
        await submitQuery(plate, finalQuery, currentWasVoiceInput);
        
        // Reset voice input flag after successful submission
        wasVoiceInput = false;
      } catch (error) {
        console.error('Submit error:', error);
        alert('שגיאה בשליחת השאלה: ' + error.message);
      } finally {
        // Reset button state
        sendBtn.innerHTML = '<span>📤</span> שלח שאלה';
        sendBtn.disabled = false;
      }
    });

    // Function to detect and complete truncated JSON responses
    function completeIncompleteJson(jsonString) {
      try {
        console.log('🔍 Checking for truncated JSON...');
        
        const trimmed = jsonString.trim();
        
        // Quick check: if it starts with { but doesn't end with }, it might be truncated
        if (trimmed.startsWith('{') && !trimmed.endsWith('}')) {
          console.log('⚠️ JSON appears to be truncated');
          
          // Look for the last complete field before truncation
          let completed = trimmed;
          
          // If the JSON ends abruptly in the middle of a string, close the string
          const lastQuoteIndex = completed.lastIndexOf('"');
          const lastOpenQuoteIndex = completed.lastIndexOf('"', lastQuoteIndex - 1);
          
          // Count quotes to see if we're in the middle of a string
          const quoteCount = (completed.match(/"/g) || []).length;
          if (quoteCount % 2 !== 0) {
            // Odd number of quotes means we're in the middle of a string
            console.log('🔧 Completing truncated string...');
            completed += '"';
          }
          
          // Add closing brace
          if (!completed.endsWith('}')) {
            completed += '}';
            console.log('🔧 Added closing brace to complete JSON');
          }
          
          // Verify the completion makes sense
          try {
            JSON.parse(completed);
            console.log('✅ Successfully completed truncated JSON');
            return completed;
          } catch (testError) {
            console.log('⚠️ Completion attempt failed, trying more aggressive completion...');
            
            // More aggressive approach: find the last valid comma and close from there
            const lastCommaIndex = trimmed.lastIndexOf(',');
            const lastColonIndex = trimmed.lastIndexOf(':');
            
            if (lastColonIndex > lastCommaIndex) {
              // We're in the middle of a value, try to close it properly
              let aggressiveComplete = trimmed;
              
              // If it looks like we're in a string value, close the string
              const afterColon = trimmed.substring(lastColonIndex + 1).trim();
              if (afterColon.startsWith('"') && !afterColon.endsWith('"')) {
                aggressiveComplete += '"';
              }
              
              aggressiveComplete += '}';
              
              try {
                JSON.parse(aggressiveComplete);
                console.log('✅ Aggressive completion succeeded');
                return aggressiveComplete;
              } catch (aggressiveError) {
                console.log('❌ Aggressive completion also failed');
              }
            }
          }
        }
        
        return jsonString;
        
      } catch (error) {
        console.error('❌ JSON completion failed:', error);
        return jsonString;
      }
    }

    // Function to sanitize JSON strings by properly escaping control characters
    function sanitizeJsonString(jsonString) {
      try {
        console.log('🧼 Sanitizing JSON string for control characters...');
        
        let sanitized = '';
        let inString = false;
        let escapeNext = false;
        let stringChar = null; // Track if we're in " or ' quotes
        let fixes = 0;
        
        for (let i = 0; i < jsonString.length; i++) {
          const char = jsonString[i];
          const charCode = char.charCodeAt(0);
          
          if (escapeNext) {
            // Previous character was escape, so this character is literal
            sanitized += char;
            escapeNext = false;
            continue;
          }
          
          if (char === '\\') {
            sanitized += char;
            escapeNext = true;
            continue;
          }
          
          if (!inString) {
            // We're outside a string
            if (char === '"' || char === "'") {
              inString = true;
              stringChar = char;
            }
            sanitized += char;
          } else {
            // We're inside a string
            if (char === stringChar) {
              // End of string
              inString = false;
              stringChar = null;
              sanitized += char;
            } else if (charCode >= 0x00 && charCode <= 0x1F && char !== '\t' && char !== '\n' && char !== '\r') {
              // Control character that needs unicode escaping
              sanitized += '\\u' + ('0000' + charCode.toString(16)).slice(-4);
              fixes++;
            } else if (char === '\n') {
              sanitized += '\\n';
              fixes++;
            } else if (char === '\r') {
              sanitized += '\\r';
              fixes++;
            } else if (char === '\t') {
              sanitized += '\\t';
              fixes++;
            } else if (char === '\b') {
              sanitized += '\\b';
              fixes++;
            } else if (char === '\f') {
              sanitized += '\\f';
              fixes++;
            } else {
              // Regular character
              sanitized += char;
            }
          }
        }
        
        if (fixes > 0) {
          console.log(`✅ JSON sanitization completed - fixed ${fixes} control characters`);
        } else {
          console.log('ℹ️ No control characters found to fix');
        }
        
        return sanitized;
        
      } catch (error) {
        console.error('❌ JSON sanitization failed:', error);
        return jsonString; // Return original if sanitization fails
      }
    }

    // Submit query to webhook and handle response
    window.submitQuery = async function submitQuery(plate, query, wasVoiceInput = false, isReply = false) {
      // Generate unique trace ID for this request
      const traceId = 'nicole_' + Date.now() + '_' + Math.random().toString(36).substring(2, 8);
      
      // Get conversation context for continuous dialogue
      const conversationContext = getConversationContext();
      const hasContext = conversationContext.length > 0;
      
      const payload = { 
        plate: plate, 
        free_query: query, 
        source: 'assistant-ui',
        password: sessionStorage.getItem('password') || sessionStorage.getItem('auth'),
        trace_id: traceId,
        timestamp: new Date().toISOString(),
        user_agent: navigator.userAgent,
        page_url: window.location.href,
        // Conversation context
        is_reply: isReply,
        conversation_context: hasContext ? conversationContext : null,
        conversation_id: hasContext ? JSON.parse(sessionStorage.getItem('nicole_conversation') || '{}').conversation_id : null,
        voice_input: wasVoiceInput
      };

      // Enhanced logging for debugging
      console.group(`🔍 Nicole Query Debug [${traceId}]`);
      console.log('📤 Outgoing Payload:', JSON.stringify(payload, null, 2));
      console.log('🔗 Webhook URL:', WEBHOOKS?.SEARCH_MODULE || 'URL_NOT_LOADED');
      console.log('🔑 Auth Data:', {
        password_exists: !!sessionStorage.getItem('password'),
        auth_exists: !!sessionStorage.getItem('auth'),
        auth_type: sessionStorage.getItem('password') ? 'password' : 'auth'
      });
      console.log('🌐 Environment Info:', {
        user_agent: navigator.userAgent,
        language: navigator.language,
        platform: navigator.platform,
        encoding: document.characterSet || document.charset,
        page_encoding: document.inputEncoding,
        url: window.location.href,
        timestamp: new Date().toISOString()
      });

      try {
        // Import webhook from webhook.js module
        const { WEBHOOKS } = await import('./webhook.js');
        const webhookUrl = WEBHOOKS.SEARCH_MODULE;
        
        console.log('🌐 Sending request to:', webhookUrl);
        const startTime = performance.now();
        
        const response = await fetch(webhookUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        // Read as text first, then try to parse as JSON
        const rawResponse = await response.text();
        const endTime = performance.now();
        const requestDuration = Math.round(endTime - startTime);
        
        // Store debug information for analysis
        const debugEntry = {
          trace_id: traceId,
          timestamp: new Date().toISOString(),
          request_duration_ms: requestDuration,
          response_status: response.status,
          response_headers: Object.fromEntries(response.headers.entries()),
          response_size: rawResponse.length,
          query: query,
          plate: plate || 'NONE'
        };
        
        // Enhanced logging for debugging JSON issues
        console.log('📥 Raw Response Details:', {
          length: rawResponse.length,
          first_200_chars: rawResponse.substring(0, 200),
          last_100_chars: rawResponse.substring(Math.max(0, rawResponse.length - 100)),
          char_codes: rawResponse.substring(0, 30).split('').map(c => c.charCodeAt(0)),
          is_empty: rawResponse.trim() === '',
          starts_with_brace: rawResponse.trim().startsWith('{'),
          ends_with_brace: rawResponse.trim().endsWith('}'),
          brace_count: (rawResponse.match(/\{/g) || []).length,
          closing_brace_count: (rawResponse.match(/\}/g) || []).length,
          has_text_field: rawResponse.includes('"text"'),
          has_audioContent_field: rawResponse.includes('"audioContent"')
        });
        
        // Log the exact raw response for manual inspection
        console.log('🔍 FULL RAW RESPONSE:', rawResponse);
        
        try {
          // Clean the response text to handle potential encoding issues
          let cleanResponse = rawResponse.trim();
          
          // Remove potential BOM (Byte Order Mark) if present
          if (cleanResponse.charCodeAt(0) === 0xFEFF) {
            cleanResponse = cleanResponse.substring(1);
            console.log('🧹 Removed BOM from response');
          }
          
          // Fix control characters in JSON strings that cause parsing errors
          cleanResponse = sanitizeJsonString(cleanResponse);
          
          // Check for truncated JSON and attempt to complete it
          cleanResponse = completeIncompleteJson(cleanResponse);
          
          // Check if JSON is complete and fix common issues
          if (!cleanResponse.endsWith('}') && cleanResponse.includes('{')) {
            console.log('⚠️ JSON appears incomplete, attempting to fix...');
            
            // Count braces to see if we need to close
            const openBraces = (cleanResponse.match(/\{/g) || []).length;
            const closeBraces = (cleanResponse.match(/\}/g) || []).length;
            
            if (openBraces > closeBraces) {
              // Add missing closing braces
              const missingBraces = openBraces - closeBraces;
              cleanResponse += '}'.repeat(missingBraces);
              console.log(`🔧 Added ${missingBraces} missing closing brace(s)`);
            }
            
            // Fix trailing commas that might cause issues
            cleanResponse = cleanResponse.replace(/,(\s*[}\]])/g, '$1');
          }
          
          // Try to parse as JSON (new format with audio)
          const responseData = JSON.parse(cleanResponse);
          
          console.log('✅ JSON Parse Success:', {
            response_type: typeof responseData,
            has_text: !!responseData.text,
            has_audio: !!responseData.audio,
            has_message: !!responseData.message,
            has_response: !!responseData.response,
            all_keys: Object.keys(responseData)
          });
          
          // Determine the text content from various possible fields
          let textContent = responseData.text || 
                           responseData.message || 
                           responseData.response || 
                           responseData.content ||
                           responseData.answer ||
                           responseData.reply ||
                           JSON.stringify(responseData, null, 2);
          
          // Handle audio content if present
          let audioContent = responseData.audio || 
                            responseData.audioContent || 
                            responseData.audio_content ||
                            null;
          
          if (!textContent || textContent.trim() === '') {
            console.warn('⚠️ No readable text content found in response');
            textContent = 'תגובה התקבלה אך ללא תוכן טקסט';
          }
          
          // Show debug info only in development
          const isDebugMode = window.location.hostname === 'localhost' || window.location.search.includes('debug=true');
          let debugInfo = '';
          
          if (isDebugMode) {
            debugInfo = `
              <div style="background: #f0f0f0; padding: 10px; margin: 10px 0; font-size: 12px; border-radius: 5px;">
                <strong>🔍 DEBUG INFO:</strong><br>
                <strong>Response Keys:</strong> ${Object.keys(responseData).join(', ')}<br>
                <strong>Text Source:</strong> ${responseData.text ? 'text' : responseData.message ? 'message' : responseData.response ? 'response' : 'fallback'}<br>
                <strong>Audio Field:</strong> ${responseData.audio ? 'Present' : 'Missing'}
              </div>
            `;
          }
          
          displayResponse(debugInfo + textContent, audioContent);
          
          // Store success in debug entry
          debugEntry.parsing_success = true;
          debugEntry.response_structure = Object.keys(responseData);
          debugEntry.text_source = responseData.text ? 'text' : responseData.message ? 'message' : responseData.response ? 'response' : responseData.answer ? 'answer' : 'fallback';
          debugEntry.has_hebrew = /[\u0590-\u05FF]/.test(textContent);
          debugEntry.final_text_length = textContent.length;
          debugEntry.has_audio = !!audioContent;
          debugEntry.audio_source = responseData.audioContent ? 'audioContent' : responseData.audio ? 'audio' : null;
          
        } catch (jsonError) {
          console.error('❌ JSON Parse Error Details:', {
            error_name: jsonError.name,
            error_message: jsonError.message,
            raw_response_preview: rawResponse.substring(0, 300),
            response_length: rawResponse.length,
            first_char_code: rawResponse.charCodeAt(0),
            last_char_code: rawResponse.charCodeAt(rawResponse.length - 1)
          });
          
          // Try to extract meaningful content even if JSON parsing fails
          let fallbackContent = rawResponse;
          let extractedSuccessfully = false;
          
          // Multiple extraction strategies
          if (rawResponse.includes('{') && rawResponse.includes('}')) {
            
            // Strategy 1: Extract the largest valid JSON block
            const firstBrace = rawResponse.indexOf('{');
            const lastBrace = rawResponse.lastIndexOf('}');
            if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
              let possibleJson = rawResponse.substring(firstBrace, lastBrace + 1);
              possibleJson = completeIncompleteJson(possibleJson); // Complete truncated JSON
              possibleJson = sanitizeJsonString(possibleJson); // Sanitize before parsing
              try {
                const extractedData = JSON.parse(possibleJson);
                const extractedText = extractedData.text || extractedData.message || extractedData.response || extractedData.answer;
                const extractedAudio = extractedData.audio || extractedData.audioContent;
                if (extractedText) {
                  console.log('✅ Successfully extracted content using Strategy 1');
                  displayResponse(extractedText, extractedAudio);
                  
                  // Update debug entry for successful extraction
                  debugEntry.parsing_success = true;
                  debugEntry.extraction_method = 'strategy_1_basic';
                  debugEntry.has_hebrew = /[\u0590-\u05FF]/.test(extractedText);
                  extractedSuccessfully = true;
                }
              } catch (secondError) {
                console.log('🔄 Strategy 1 failed, trying Strategy 2...');
              }
            }
            
            // Strategy 2: Try to fix common JSON issues and re-parse
            if (!extractedSuccessfully) {
              try {
                let fixedJson = rawResponse.substring(firstBrace, lastBrace + 1);
                
                // Complete truncated JSON first
                fixedJson = completeIncompleteJson(fixedJson);
                // Sanitize control characters
                fixedJson = sanitizeJsonString(fixedJson);
                
                // Fix common issues
                fixedJson = fixedJson.replace(/,(\s*[}\]])/g, '$1'); // Remove trailing commas
                fixedJson = fixedJson.replace(/([{,]\s*)(\w+):/g, '$1"$2":'); // Add quotes to keys
                fixedJson = fixedJson.replace(/:\s*([^",{\[\]}\s][^",}\]]*[^",}\]\s])\s*([,}])/g, ': "$1"$2'); // Quote unquoted values
                
                const extractedData = JSON.parse(fixedJson);
                const extractedText = extractedData.text || extractedData.message || extractedData.response || extractedData.answer;
                const extractedAudio = extractedData.audio || extractedData.audioContent;
                if (extractedText) {
                  console.log('✅ Successfully extracted content using Strategy 2');
                  displayResponse(extractedText, extractedAudio);
                  
                  debugEntry.parsing_success = true;
                  debugEntry.extraction_method = 'strategy_2_fixed';
                  debugEntry.has_hebrew = /[\u0590-\u05FF]/.test(extractedText);
                  extractedSuccessfully = true;
                }
              } catch (thirdError) {
                console.log('🔄 Strategy 2 also failed, trying Strategy 3...');
              }
            }
            
            // Strategy 3: Use regex to extract text field value
            if (!extractedSuccessfully) {
              const textMatch = rawResponse.match(/"text"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/);
              if (textMatch) {
                const extractedText = textMatch[1].replace(/\\"/g, '"').replace(/\\n/g, '\n');
                console.log('✅ Successfully extracted text using Strategy 3 (regex)');
                displayResponse(extractedText, null);
                
                debugEntry.parsing_success = true;
                debugEntry.extraction_method = 'strategy_3_regex';
                debugEntry.has_hebrew = /[\u0590-\u05FF]/.test(extractedText);
                extractedSuccessfully = true;
              }
            }
          }
          
          // Final fallback if no extraction strategy worked
          if (!extractedSuccessfully) {
            if (fallbackContent.length > 0) {
              displayResponse(`שגיאה בפענוח התגובה, אך התוכן התקבל:\n\n${fallbackContent}`);
            } else {
              displayResponse('שגיאה בקבלת תגובה מהשרת. אנא נסה שוב.');
            }
            
            // Store failure in debug entry
            debugEntry.parsing_success = false;
            debugEntry.error_type = 'json_parse_failed';
            debugEntry.error_message = jsonError.message;
            debugEntry.extraction_method = 'none';
            debugEntry.has_hebrew = /[\u0590-\u05FF]/.test(fallbackContent);
            debugEntry.fallback_used = fallbackContent.length > 0;
          }
        }
        
        // Store debug entry in session for analysis
        const debugHistory = JSON.parse(sessionStorage.getItem('nicole_debug_history') || '[]');
        debugHistory.push(debugEntry);
        // Keep only last 50 entries
        if (debugHistory.length > 50) debugHistory.shift();
        sessionStorage.setItem('nicole_debug_history', JSON.stringify(debugHistory));
        
        console.log(`✅ Request completed [${traceId}]:`, {
          duration: requestDuration + 'ms',
          success: debugEntry.parsing_success,
          has_hebrew: debugEntry.has_hebrew
        });
        console.groupEnd();

      } catch (err) {
        console.error('❌ Request failed:', err);
        console.groupEnd();
        displayResponse('שגיאה בשליחת הבקשה. נסה שוב.');
      }
    }

    // Display response in floating box with manual TTS controls
    function displayResponse(text, audio = null) {
      const responseBox = document.getElementById('agentResponse');
      responseBox.style.display = 'block';
      
      // Clean and format the text content for display
      let displayText = text;
      let textForTTS = text;
      
      // Handle different content types
      if (typeof text === 'object') {
        console.log('📝 Received object response, converting to readable format');
        displayText = JSON.stringify(text, null, 2);
        textForTTS = Object.values(text).join(' ');
      } else if (typeof text === 'string') {
        // Clean the text for better display
        displayText = text.trim();
        textForTTS = text.replace(/[\n\r]+/g, ' ').trim();
        
        // If text looks like JSON that wasn't parsed, try to format it
        if (displayText.startsWith('{') && displayText.endsWith('}')) {
          try {
            const parsed = JSON.parse(displayText);
            const readable = parsed.text || parsed.message || parsed.response || JSON.stringify(parsed, null, 2);
            displayText = readable;
            textForTTS = readable.replace(/[\n\r]+/g, ' ').trim();
            console.log('🔄 Reformatted JSON string for better display');
          } catch (e) {
            console.log('📝 Text looks like JSON but failed to parse, displaying as-is');
          }
        }
        
        // Convert markdown-like formatting to HTML for better display
        displayText = displayText
          .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
          .replace(/\*(.*?)\*/g, '<em>$1</em>')
          .replace(/\n/g, '<br>');
      }
      
      responseBox.innerHTML = `
        <div style="margin-bottom: 10px; font-weight: bold; color: #667eea;">
          👩‍💼 תשובת ניקול:
        </div>
        <div style="line-height: 1.5; margin-bottom: 10px; white-space: pre-wrap;">
          ${displayText}
        </div>
        
        <!-- Response Controls -->
        <div style="display: flex; gap: 8px; margin-bottom: 8px; align-items: center; flex-wrap: wrap;">
          <button onclick="showReplyBox()" style="
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
          ">
            💬 השב על התשובה
          </button>
          
          <button onclick="replayReceivedAudio()" style="
            background: #22c55e;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
          ">
            🔊 השמע תשובה
          </button>
          
          <button onclick="stopCurrentSpeaking()" style="
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
          ">
            ⏹️ עצור הקראה
          </button>
          
          <div id="ttsStatus" style="font-size: 11px; color: #666;"></div>
        </div>
        
        <!-- Reply Box (initially hidden) -->
        <div id="replyBox" style="display: none; margin-top: 12px; padding: 12px; background: rgba(102, 126, 234, 0.05); border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.2);">
          <div style="margin-bottom: 8px; font-weight: 600; color: #667eea; font-size: 13px;">
            💬 המשך השיחה:
          </div>
          <div style="position: relative; margin-bottom: 8px;">
            <textarea id="replyInput" placeholder="כתוב את השאלה או התגובה שלך..." style="
              width: 100%;
              min-height: 60px;
              padding: 8px 35px 8px 12px;
              border: 1px solid #e2e8f0;
              border-radius: 6px;
              font-size: 13px;
              font-family: inherit;
              resize: vertical;
              box-sizing: border-box;
            "></textarea>
            <button type="button" id="replyMicBtn" onclick="startReplyRecording()" style="
              position: absolute;
              left: 8px;
              top: 50%;
              transform: translateY(-50%);
              width: 24px;
              height: 24px;
              border-radius: 50%;
              border: none;
              background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
              color: white;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 12px;
              transition: all 0.3s ease;
            " title="לחץ כדי להקליט תגובה">
              🎤
            </button>
          </div>
          <div style="display: flex; gap: 6px; margin-top: 8px; justify-content: flex-end;">
            <button onclick="cancelReply()" style="
              background: #f3f4f6;
              color: #6b7280;
              border: none;
              border-radius: 4px;
              padding: 4px 8px;
              cursor: pointer;
              font-size: 11px;
            ">
              ביטול
            </button>
            <button onclick="sendReply()" style="
              background: #667eea;
              color: white;
              border: none;
              border-radius: 4px;
              padding: 4px 12px;
              cursor: pointer;
              font-size: 11px;
              font-weight: 600;
            ">
              שלח תגובה
            </button>
          </div>
        </div>
        
        <button onclick="this.parentElement.style.display='none'" style="
          position: absolute; 
          top: 8px; 
          left: 8px; 
          background: #f0f0f0; 
          border: none; 
          border-radius: 50%; 
          width: 24px; 
          height: 24px; 
          cursor: pointer;
          font-size: 12px;
        ">✕</button>
      `;


      // Handle audio playback
      if (audio) {
        let audioElement;
        
        // Handle different audio formats
        if (typeof audio === 'string') {
          if (audio.startsWith('data:audio') || audio.startsWith('http')) {
            audioElement = new Audio(audio);
          } else {
            // Assume it's base64 audio content
            audioElement = new Audio('data:audio/mp3;base64,' + audio);
          }
        } else if (audio instanceof Blob) {
          const audioUrl = URL.createObjectURL(audio);
          audioElement = new Audio(audioUrl);
        }
        
        if (audioElement) {
          // Store the audio element globally for replay
          window.currentReceivedAudio = audioElement;
          
          try {
            audioElement.play();
            console.log('🔊 Auto-playing audio response');
          } catch (e) {
            console.warn("🔇 Autoplay blocked. User must click play.");
            window.pendingTTSAudio = audioElement;
          }
        }
      }
      
      // Log response handling success
      console.log('✅ Response displayed successfully:', {
        text_length: displayText.length,
        has_audio: !!audio,
        text_type: typeof text
      });
      
      // Store this response in conversation context
      storeConversationContext(displayText, 'assistant');
    }
    
    
    


    // Enhanced Text-to-Speech functionality using Google Cloud TTS (original for auto-play)
    async function speakResponse(text) {
      if (!text) {
        console.log('🔊 No text provided for TTS');
        return;
      }
      
      // Clean text for TTS - remove markdown, special characters, etc.
      let cleanText = text
        .replace(/\*\*/g, '') // Remove ** markdown
        .replace(/\*/g, '') // Remove * markdown
        .replace(/_{2,}/g, '') // Remove __ markdown
        .replace(/`{1,3}/g, '') // Remove code blocks
        .replace(/#{1,6}\s*/g, '') // Remove headings
        .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // Replace links with text
        .replace(/\s+/g, ' ') // Normalize spaces
        .trim();
      
      // Limit text length for TTS (Google TTS has limits)
      const maxLength = 5000;
      const textForTTS = cleanText.length > maxLength ? cleanText.substring(0, maxLength) + '...' : cleanText;
      
      const apiKey = 'AIzaSyCYMIbBVJsGfOv1pbELD41-Lxe7OwsHd1o';
      const voice = 'he-IL-Wavenet-A'; // Female Hebrew voice
      
      console.log('🔊 Starting TTS for text length:', textForTTS.length);

      try {
        console.log('🔗 Calling Google TTS API...');
        const response = await fetch(`https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            input: { text: textForTTS },
            voice: { 
              languageCode: 'he-IL', 
              name: voice,
              ssmlGender: 'FEMALE'
            },
            audioConfig: { 
              audioEncoding: 'MP3',
              speakingRate: 1.0,
              pitch: 0.0,
              volumeGainDb: 0.0
            }
          })
        });

        console.log('📡 TTS API Response:', {
          status: response.status,
          statusText: response.statusText,
          headers: Object.fromEntries(response.headers.entries())
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error('❌ TTS API Error Details:', errorText);
          
          // Try to parse error for more specific info
          try {
            const errorData = JSON.parse(errorText);
            console.error('❌ Parsed API Error:', errorData);
            throw new Error(`TTS API error: ${response.status} - ${errorData.error?.message || errorText}`);
          } catch {
            throw new Error(`TTS API error: ${response.status} ${response.statusText} - ${errorText}`);
          }
        }

        const data = await response.json();
        
        if (data.audioContent) {
          const audio = new Audio('data:audio/mp3;base64,' + data.audioContent);
          
          // Store reference for potential stopping (but don't show stop button for auto-play)
          window.currentTTSAudio = audio;
          
          // Add audio event listeners for better feedback
          audio.addEventListener('loadstart', () => {
            console.log('🔊 TTS audio loading...');
          });
          
          audio.addEventListener('canplay', () => {
            console.log('🔊 TTS audio ready to play');
          });
          
          audio.addEventListener('play', () => {
            console.log('🔊 Nicole is speaking...');
            // Add visual indicator that Nicole is speaking
            updateNicoleSpeakingStatus(true);
            window.isTTSPlaying = true;
          });
          
          audio.addEventListener('ended', () => {
            console.log('🔊 Nicole finished speaking');
            updateNicoleSpeakingStatus(false);
            window.currentTTSAudio = null;
            window.isTTSPlaying = false;
            resetTTSButtons();
          });
          
          audio.addEventListener('error', (e) => {
            console.error('🔊 Audio playback error:', e);
            updateNicoleSpeakingStatus(false);
            window.currentTTSAudio = null;
            window.isTTSPlaying = false;
            resetTTSButtons();
          });
          
          // Handle browser autoplay restrictions
          try {
            // Try to play immediately
            await audio.play();
            console.log('✅ TTS played successfully (auto)');
            
          } catch (autoplayError) {
            console.warn('🔇 Browser blocked autoplay:', autoplayError.name);
            
            if (autoplayError.name === 'NotAllowedError') {
              // Browser blocked autoplay - show user notification
              console.log('💡 TTS requires user interaction due to browser autoplay policy');
              
              // Store audio for manual playback and reset UI
              window.pendingTTSAudio = audio;
              window.currentTTSAudio = null;
              resetTTSButtons();
              
              // Show visual notification that speech is ready but needs user click
              const responseBox = document.getElementById('agentResponse');
              if (responseBox) {
                const autoplayNotice = document.createElement('div');
                autoplayNotice.innerHTML = `
                  <div style="
                    background: rgba(249, 168, 37, 0.1);
                    border: 1px solid #f9a825;
                    color: #f57c00;
                    padding: 8px 12px;
                    border-radius: 8px;
                    margin-top: 8px;
                    font-size: 12px;
                    text-align: center;
                  ">
                    🔊 התשובה מוכנה להשמעה - לחץ על כפתור "השמע תשובה"
                  </div>
                `;
                responseBox.appendChild(autoplayNotice);
                
                // Store audio for manual playback
                window.pendingTTSAudio = audio;
              }
            } else {
              // Other playback error
              throw autoplayError;
            }
          }
          
        } else {
          console.warn('🔊 No audio content received from TTS API');
        }
      } catch (error) {
        console.error('🔊 Google TTS Error:', error);
        
        // Don't use automatic fallback - let user choose manually
        console.log('💡 TTS failed. User can use manual TTS buttons if needed.');
        
        // Provide detailed error feedback for debugging
        if (error.message.includes('network') || error.message.includes('fetch')) {
          console.log('🔊 TTS failed due to network issue');
        } else if (error.message.includes('quota') || error.message.includes('limit')) {
          console.log('🔊 TTS failed due to API quota limits');
        } else if (error.message.includes('403') || error.message.includes('401')) {
          console.log('🔊 TTS failed due to API authentication/authorization');
        }
        
        // Throw error so manual TTS can handle it appropriately
        throw error;
      }
    }
    
    
    // Helper function to show Nicole speaking status
    function updateNicoleSpeakingStatus(isSpeaking) {
      const responseBox = document.getElementById('agentResponse');
      if (responseBox && responseBox.style.display !== 'none') {
        const statusDiv = responseBox.querySelector('.nicole-speaking-status');
        
        if (isSpeaking) {
          if (!statusDiv) {
            const speakingIndicator = document.createElement('div');
            speakingIndicator.className = 'nicole-speaking-status';
            speakingIndicator.innerHTML = '🔊 ניקול מדברת...';
            speakingIndicator.style.cssText = `
              position: absolute;
              bottom: 8px;
              right: 8px;
              background: rgba(102, 126, 234, 0.1);
              color: #667eea;
              padding: 4px 8px;
              border-radius: 12px;
              font-size: 12px;
              font-weight: 500;
              animation: pulse 1.5s infinite;
            `;
            responseBox.appendChild(speakingIndicator);
          }
        } else {
          if (statusDiv) {
            statusDiv.remove();
          }
        }
      }
    }

    // Save conversation to helper for later reference
    function saveToHelper(question, answer) {
      try {
        const stored = sessionStorage.getItem("helper") || sessionStorage.getItem("expertise");
        if (!stored) return;

        const helper = JSON.parse(stored);
        if (!helper.assistant_history) helper.assistant_history = [];

        helper.assistant_history.push({
          question,
          answer,
          timestamp: new Date().toISOString()
        });

        sessionStorage.setItem("helper", JSON.stringify(helper));
        sessionStorage.setItem("expertise", JSON.stringify(helper));
        console.log('💾 Conversation saved to helper');
      } catch (error) {
        console.error('💾 Save to helper failed:', error);
      }
    }
    
    // Auto-resize textarea
    textarea.addEventListener('input', function() {
      this.style.height = 'auto';
      this.style.height = Math.min(this.scrollHeight, 200) + 'px';
    });
    
    // Enhanced focus states
    textarea.addEventListener('focus', function() {
      this.parentElement.style.transform = 'scale(1.02)';
    });
    
    textarea.addEventListener('blur', function() {
      this.parentElement.style.transform = 'scale(1)';
    });
    
    // Add global debug function for easy console access
    window.nicoleDebug = {
      getHistory: () => {
        const history = JSON.parse(sessionStorage.getItem('nicole_debug_history') || '[]');
        console.table(history);
        return history;
      },
      clearHistory: () => {
        sessionStorage.removeItem('nicole_debug_history');
        console.log('🧹 Nicole debug history cleared');
      },
      getLastRequest: () => {
        const history = JSON.parse(sessionStorage.getItem('nicole_debug_history') || '[]');
        return history[history.length - 1] || null;
      },
      exportHistory: () => {
        const history = JSON.parse(sessionStorage.getItem('nicole_debug_history') || '[]');
        const blob = new Blob([JSON.stringify(history, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `nicole_debug_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        console.log('💾 Debug history exported');
      },
      getMicErrors: () => {
        const errors = JSON.parse(sessionStorage.getItem('nicole_mic_errors') || '[]');
        console.table(errors);
        return errors;
      },
      clearMicErrors: () => {
        sessionStorage.removeItem('nicole_mic_errors');
        console.log('🧹 Microphone error history cleared');
      },
      getErrorPatterns: () => {
        const errors = JSON.parse(sessionStorage.getItem('nicole_mic_errors') || '[]');
        const patterns = {};
        errors.forEach(error => {
          patterns[error.error_type] = (patterns[error.error_type] || 0) + 1;
        });
        console.log('📊 Error Patterns:', patterns);
        return patterns;
      },
      testMicrophone: async () => {
        console.log('🎤 Testing microphone permissions...');
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          console.log('✅ Microphone access granted');
          stream.getTracks().forEach(track => track.stop());
          return { success: true, message: 'Microphone working' };
        } catch (error) {
          console.error('❌ Microphone test failed:', error);
          return { success: false, error: error.message };
        }
      },
      // New debugging tools for JSON and encoding issues
      analyzeText: (text) => {
        console.group('🔍 Text Analysis');
        console.log('📝 Text Info:', {
          length: text.length,
          type: typeof text,
          first_10_chars: text.substring(0, 10),
          last_10_chars: text.substring(text.length - 10),
          char_codes: text.substring(0, 20).split('').map(c => ({ char: c, code: c.charCodeAt(0) })),
          has_bom: text.charCodeAt(0) === 0xFEFF,
          has_hebrew: /[\u0590-\u05FF]/.test(text),
          has_arabic: /[\u0600-\u06FF]/.test(text),
          line_breaks: text.match(/\r?\n/g)?.length || 0,
          is_json_like: text.trim().startsWith('{') && text.trim().endsWith('}')
        });
        
        if (text.trim().startsWith('{')) {
          try {
            const parsed = JSON.parse(text);
            console.log('✅ Valid JSON:', parsed);
          } catch (e) {
            console.error('❌ JSON Parse Error:', e.message);
            console.log('🔧 JSON Syntax Check:', {
              balanced_braces: (text.match(/\{/g)?.length || 0) === (text.match(/\}/g)?.length || 0),
              balanced_brackets: (text.match(/\[/g)?.length || 0) === (text.match(/\]/g)?.length || 0),
              has_quotes: /["']/.test(text),
              has_commas: /,/.test(text)
            });
          }
        }
        console.groupEnd();
        return text;
      },
      testEncoding: () => {
        const testStrings = [
          'שלום עולם', // Hebrew
          'مرحبا بالعالم', // Arabic
          'Hello World', // English
          '{"text": "בדיקה"}' // JSON with Hebrew
        ];
        
        console.group('🌐 Character Encoding Test');
        testStrings.forEach((str, index) => {
          console.log(`Test ${index + 1}:`, {
            original: str,
            encoded: encodeURIComponent(str),
            base64: btoa(unescape(encodeURIComponent(str))),
            char_codes: str.split('').map(c => c.charCodeAt(0)),
            json_stringify: JSON.stringify(str),
            roundtrip_test: decodeURIComponent(encodeURIComponent(str)) === str
          });
        });
        console.groupEnd();
      },
      simulateResponse: (responseText) => {
        console.group('🧪 Simulate Response Processing');
        console.log('Input:', responseText);
        
        try {
          // Simulate the same processing as the real code
          let cleanResponse = responseText.trim();
          
          if (cleanResponse.charCodeAt(0) === 0xFEFF) {
            cleanResponse = cleanResponse.substring(1);
            console.log('🧹 Removed BOM');
          }
          
          const responseData = JSON.parse(cleanResponse);
          const textContent = responseData.text || responseData.message || responseData.response || responseData.content;
          
          console.log('✅ Simulation Success:', {
            parsed_data: responseData,
            extracted_text: textContent,
            would_display: textContent || 'fallback content'
          });
          
        } catch (error) {
          console.error('❌ Simulation Failed:', error.message);
          console.log('🔄 Would attempt extraction fallback...');
          
          if (responseText.includes('{') && responseText.includes('}')) {
            const firstBrace = responseText.indexOf('{');
            const lastBrace = responseText.lastIndexOf('}');
            if (firstBrace !== -1 && lastBrace !== -1) {
              const extracted = responseText.substring(firstBrace, lastBrace + 1);
              console.log('🔧 Extracted JSON:', extracted);
              try {
                const extractedData = JSON.parse(extracted);
                console.log('✅ Extraction Success:', extractedData);
              } catch (e2) {
                console.error('❌ Extraction also failed:', e2.message);
              }
            }
          }
        }
        console.groupEnd();
      },
      // Conversation context debugging
      getConversation: () => {
        const context = JSON.parse(sessionStorage.getItem('nicole_conversation') || '{}');
        console.group('💬 Conversation Context');
        console.log('Conversation ID:', context.conversation_id);
        console.log('Started:', context.started_at);
        console.log('Messages:', context.messages?.length || 0);
        console.log('Current Plate:', context.current_plate);
        if (context.messages && context.messages.length > 0) {
          console.table(context.messages.map(msg => ({
            role: msg.role,
            content: msg.content.substring(0, 50) + (msg.content.length > 50 ? '...' : ''),
            timestamp: msg.timestamp
          })));
        }
        console.groupEnd();
        return context;
      },
      clearConversation: () => {
        sessionStorage.removeItem('nicole_conversation');
        console.log('🧹 Conversation context cleared');
        initializeConversationContext();
      },
      // Test JSON sanitization with problematic strings
      testJsonSanitization: (testJson) => {
        console.group('🧪 JSON Sanitization Test');
        console.log('Original JSON:', testJson);
        
        try {
          JSON.parse(testJson);
          console.log('✅ Original JSON is valid');
        } catch (e) {
          console.log('❌ Original JSON error:', e.message);
          
          const sanitized = sanitizeJsonString(testJson);
          console.log('Sanitized JSON:', sanitized);
          
          try {
            const parsed = JSON.parse(sanitized);
            console.log('✅ Sanitized JSON is valid:', parsed);
          } catch (e2) {
            console.log('❌ Sanitized JSON still invalid:', e2.message);
          }
        }
        console.groupEnd();
      },
      // Generate test cases for Hebrew text with control characters
      generateTestCases: () => {
        const testCases = [
          '{"text": "שלום\nעולם"}',  // Newline
          '{"text": "בדיקה\tמערכת"}', // Tab  
          '{"text": "טקסט\rעברי"}',   // Carriage return
          '{"text": "הודעה עם\nמספר\nשורות"}', // Multiple newlines
          '{"message": "תגובה\nעם\tתווי\rבקרה"}',  // Mixed control chars
          // Test case based on actual failing JSON
          '{\n  "text": "שלום! אני מבינה שזו בדיקת מערכת, ואני כאן כדי להגיב ולוודא שהכל עובד כראוי. אני שמחה לעזור בכל דרך שתצטרך.\n\nאני מאשרת שאני פעילה ומוכנה לסייע בכל שאלה או בקשה. אם יש משהו ספציפי שאתה רוצה שאבדוק או אבחן במסגרת הבדיקה הזו, אנא ציין, ואני אעשה את המיטב."\n}'
        ];
        
        console.group('🧪 Generated Test Cases');
        testCases.forEach((testCase, index) => {
          console.log(`Test ${index + 1}:`, testCase);
          nicoleDebug.testJsonSanitization(testCase);
        });
        console.groupEnd();
      },
      // Test the exact failing pattern from the error
      testActualError: () => {
        const failingJson = `{
  "text": "שלום! אני מבינה שזו בדיקת מערכת, ואני כאן כדי להגיב ולוודא שהכל עובד כראוי. אני שמחה לעזור בכל דרך שתצטרך.

אני מאשרת שאני פעילה ומוכנה לסייע בכל שאלה או בקשה. אם יש משהו ספציפי שאתה רוצה שאבדוק או אבחן במסגרת הבדיקה הזו, אנא ציין, ואני אעשה את המיטב.

איך אני יכולה לעזור לך הלאה עם הבד"
}`;
        
        console.group('🚨 Testing Actual Failing JSON');
        console.log('This is the pattern that was causing the error at position 121');
        nicoleDebug.testJsonSanitization(failingJson);
        console.groupEnd();
      },
      // Test truncated JSON completion
      testTruncatedJson: () => {
        const truncatedJsons = [
          '{"text": "שלום מע', // Cut off mid-string
          '{"text": "הודעה מלאה", "audio"', // Cut off mid-key
          '{\n  "text": "שלום! אני מבינה שזו בדיקת מערכת, ואני כאן כדי להגיב ולוודא שהכל עובד כראוי. אני שמחה לעזור בכל דרך שתצטרך.\n\nאני מאשרת שאני פעילה ומוכנה לסייע בכל שאלה או בקשה. אם יש משהו ספציפי שאתה רוצה שאבדוק או אבחן במסגרת הבדיקה הזו, אנא ציין, ואני אעשה את המיטב.\n\nאיך אני יכולה לעזור לך הלאה עם הבד' // Real truncated case
        ];
        
        console.group('📝 Testing Truncated JSON Completion');
        truncatedJsons.forEach((truncated, index) => {
          console.log(`\nTruncated Test ${index + 1}:`);
          console.log('Original (truncated):', truncated);
          
          const completed = completeIncompleteJson(truncated);
          console.log('Completed:', completed);
          
          try {
            const parsed = JSON.parse(completed);
            console.log('✅ Successfully parsed completed JSON:', parsed);
          } catch (e) {
            console.log('❌ Completion failed:', e.message);
          }
        });
        console.groupEnd();
      }
    };
    
    console.log('🔧 Nicole Debug Tools Available:');
    console.log('  - nicoleDebug.getHistory() - View all request/response history');
    console.log('  - nicoleDebug.getLastRequest() - Get the most recent request');
    console.log('  - nicoleDebug.clearHistory() - Clear debug history');
    console.log('  - nicoleDebug.exportHistory() - Export history as JSON file');
    console.log('  - nicoleDebug.getMicErrors() - View microphone error history');
    console.log('  - nicoleDebug.getErrorPatterns() - Analyze error frequency');
    console.log('  - nicoleDebug.testMicrophone() - Test mic permissions');
    console.log('  - nicoleDebug.clearMicErrors() - Clear mic error history');
    console.log('  - nicoleDebug.analyzeText(text) - Analyze text and encoding');
    console.log('  - nicoleDebug.testEncoding() - Test character encoding support');
    console.log('  - nicoleDebug.simulateResponse(text) - Simulate response processing');
    console.log('  - nicoleDebug.getConversation() - View conversation context');
    console.log('  - nicoleDebug.clearConversation() - Clear conversation context');
    console.log('  - nicoleDebug.testJsonSanitization(json) - Test JSON sanitization');
    console.log('  - nicoleDebug.generateTestCases() - Generate Hebrew control character tests');
    console.log('  - nicoleDebug.testActualError() - Test the actual failing JSON pattern');
    console.log('  - nicoleDebug.testTruncatedJson() - Test truncated JSON completion');
    
    // Initialize conversation context
    initializeConversationContext();
  }
  
  // Conversation Context Management
  function initializeConversationContext() {
    if (!sessionStorage.getItem('nicole_conversation')) {
      const initialContext = {
        conversation_id: 'conv_' + Date.now() + '_' + Math.random().toString(36).substring(2, 8),
        started_at: new Date().toISOString(),
        messages: [],
        current_plate: sessionStorage.getItem('plate') || null
      };
      sessionStorage.setItem('nicole_conversation', JSON.stringify(initialContext));
      console.log('🔄 New conversation context initialized:', initialContext.conversation_id);
    }
  }
  
  function storeConversationContext(message, role = 'user') {
    try {
      const context = JSON.parse(sessionStorage.getItem('nicole_conversation') || '{}');
      if (!context.messages) context.messages = [];
      
      const messageEntry = {
        role: role, // 'user' or 'assistant'
        content: message,
        timestamp: new Date().toISOString(),
        message_id: 'msg_' + Date.now() + '_' + Math.random().toString(36).substring(2, 6)
      };
      
      context.messages.push(messageEntry);
      context.last_activity = new Date().toISOString();
      
      // Keep only last 20 messages for context (10 exchanges)
      if (context.messages.length > 20) {
        context.messages = context.messages.slice(-20);
      }
      
      sessionStorage.setItem('nicole_conversation', JSON.stringify(context));
      console.log(`💬 Stored ${role} message in conversation context`);
      
    } catch (error) {
      console.error('❌ Failed to store conversation context:', error);
    }
  }
  
  function getConversationContext() {
    try {
      const context = JSON.parse(sessionStorage.getItem('nicole_conversation') || '{}');
      return context.messages || [];
    } catch (error) {
      console.error('❌ Failed to get conversation context:', error);
      return [];
    }
  }
  
  // Replay Received Audio Function
  window.replayReceivedAudio = function() {
    // Check if we have the received audio from Make.com
    if (window.currentReceivedAudio) {
      try {
        // Reset audio to beginning and play
        window.currentReceivedAudio.currentTime = 0;
        window.currentReceivedAudio.play();
        console.log('🔊 Replaying received MP3 from Make.com');
      } catch (error) {
        console.error('🔊 Error replaying received audio:', error);
        alert('שגיאה בהשמעה חוזרת של ההודעה');
      }
    } else if (window.pendingTTSAudio) {
      // If we have pending audio from autoplay block, use that
      try {
        window.pendingTTSAudio.play();
        console.log('🔊 Playing pending audio from autoplay block');
      } catch (error) {
        console.error('🔊 Error playing pending audio:', error);
        alert('שגיאה בהשמעת ההודעה');
      }
    } else {
      console.log('🔊 No received audio available to replay');
      alert('אין הודעה קולית זמינה להשמעה חוזרת');
    }
  };

  // Stop Speaking Function
  window.stopCurrentSpeaking = function() {
    // Stop current TTS audio if playing
    if (window.currentTTSAudio) {
      window.currentTTSAudio.pause();
      window.currentTTSAudio.currentTime = 0;
      window.currentTTSAudio = null;
      console.log('🔊 Stopped current TTS audio');
    }
    
    // Stop received audio from Make.com if playing
    if (window.currentReceivedAudio) {
      window.currentReceivedAudio.pause();
      window.currentReceivedAudio.currentTime = 0;
      console.log('🔊 Stopped received MP3 audio');
    }
    
    // Clear any pending TTS audio
    if (window.pendingTTSAudio) {
      window.pendingTTSAudio.pause();
      window.pendingTTSAudio.currentTime = 0;
      console.log('🔊 Stopped pending TTS audio');
    }
    
    // Update speaking status
    updateNicoleSpeakingStatus(false);
    window.isTTSPlaying = false;
    
    console.log('⏹️ Speaking stopped by user');
  };

  // Reply Recording Function
  window.startReplyRecording = function() {
    const replyInput = document.getElementById('replyInput');
    const replyMicBtn = document.getElementById('replyMicBtn');
    
    if (!replyInput || !replyMicBtn) return;
    
    // Check if speech recognition is available
    if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
      alert('זיהוי קול לא נתמך בדפדפן זה');
      return;
    }
    
    const SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;
    const recognition = new SpeechRecognition();
    recognition.lang = 'he-IL';
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;
    recognition.continuous = false;
    
    // Update button to recording state
    replyMicBtn.innerHTML = '⏹️';
    replyMicBtn.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%)';
    replyMicBtn.title = 'לחץ כדי להפסיק הקלטה';
    replyInput.style.borderColor = '#ff6b6b';
    replyInput.placeholder = '🎤 מקליט תגובה... דבר עכשיו';
    
    recognition.addEventListener('result', (event) => {
      const transcript = event.results[0][0].transcript;
      replyInput.value = transcript;
      resetReplyMicrophone();
      console.log('🎤 Reply speech recognized:', transcript);
    });
    
    recognition.addEventListener('error', (event) => {
      console.error('🎤 Reply speech recognition error:', event.error);
      resetReplyMicrophone();
      alert('שגיאה בזיהוי קול: ' + event.error);
    });
    
    recognition.addEventListener('end', () => {
      resetReplyMicrophone();
    });
    
    // Start recognition
    try {
      recognition.start();
    } catch (error) {
      console.error('🎤 Failed to start reply recognition:', error);
      resetReplyMicrophone();
      alert('שגיאה בהפעלת זיהוי קול');
    }
    
    // Function to reset microphone button
    function resetReplyMicrophone() {
      replyMicBtn.innerHTML = '🎤';
      replyMicBtn.style.background = 'linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%)';
      replyMicBtn.title = 'לחץ כדי להקליט תגובה';
      replyInput.style.borderColor = '#e2e8f0';
      replyInput.placeholder = 'כתוב את השאלה או התגובה שלך...';
    }
  };

  // Reply Functions
  window.showReplyBox = function() {
    const replyBox = document.getElementById('replyBox');
    const replyInput = document.getElementById('replyInput');
    
    if (replyBox && replyInput) {
      replyBox.style.display = 'block';
      replyInput.focus();
      
      // Scroll the reply box into view
      setTimeout(() => {
        replyBox.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }, 100);
    }
  };
  
  window.cancelReply = function() {
    const replyBox = document.getElementById('replyBox');
    const replyInput = document.getElementById('replyInput');
    
    if (replyBox && replyInput) {
      replyBox.style.display = 'none';
      replyInput.value = '';
    }
  };
  
  window.sendReply = async function() {
    const replyInput = document.getElementById('replyInput');
    const replyText = replyInput?.value?.trim();
    
    if (!replyText) {
      alert('אנא כתוב תגובה או שאלה');
      return;
    }
    
    // Hide reply box and clear input
    cancelReply();
    
    // Get current plate from main form or session
    const currentPlate = document.getElementById('plateInput')?.value?.trim() || 
                        sessionStorage.getItem('plate') || '';
    
    // Store user message in context
    storeConversationContext(replyText, 'user');
    
    // Show loading state
    const responseBox = document.getElementById('agentResponse');
    if (responseBox) {
      const loadingDiv = document.createElement('div');
      loadingDiv.id = 'replyLoading';
      loadingDiv.innerHTML = `
        <div style="
          background: rgba(102, 126, 234, 0.1);
          border: 1px solid rgba(102, 126, 234, 0.3);
          padding: 12px;
          border-radius: 8px;
          margin-top: 12px;
          text-align: center;
          color: #667eea;
          font-size: 13px;
        ">
          <div style="display: inline-flex; align-items: center; gap: 8px;">
            <div style="width: 16px; height: 16px; border: 2px solid #667eea; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
            שולח תגובה...
          </div>
        </div>
      `;
      responseBox.appendChild(loadingDiv);
    }
    
    try {
      // Send reply with conversation context
      await submitQuery(currentPlate, replyText, false, true);
      
    } catch (error) {
      console.error('Reply error:', error);
      alert('שגיאה בשליחת התגובה: ' + error.message);
    } finally {
      // Remove loading indicator
      const loadingDiv = document.getElementById('replyLoading');
      if (loadingDiv) {
        loadingDiv.remove();
      }
    }
  };
</script>

<style>
  /* Add shake animation for validation feedback */
  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
  }
  
  /* Enhance container animations */
  .input-container {
    transition: transform 0.2s ease;
  }
  
  /* Loading button state */
  .btn-send:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    transform: none !important;
  }
  
  /* Spinner animation for loading states */
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  /* Reply box styling enhancements */
  #replyBox {
    transition: all 0.3s ease;
  }
  
  #replyInput:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
  }
</style>
</body>
</html>
