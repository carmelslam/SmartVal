Test 1 :

[
  {
    "make": "טויוטה",
    "model": "RAV4",
    "cat_num_desc": "קליפס לכנפון ראב 4 - 710-310",
    "price": "5.0"
  },
  {
    "make": "טויוטה",
    "model": null,
    "cat_num_desc": "קליפס למגן קד' טויוטה+לקסוס",
    "price": "10.35"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "כיסוי מגן קד קורולה -80",
    "price": "10.35"
  }
]

Test 2 :

[
  {
    "make": "טויוטה",
    "model": "RAV4",
    "cat_num_desc": "קליפס לכנפון ראב 4 - 710-310",
    "price": "5.0"
  },
  {
    "make": "טויוטה",
    "model": null,
    "cat_num_desc": "קליפס למגן קד' טויוטה+לקסוס",
    "price": "10.35"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "כיסוי מגן קד קורולה -80",
    "price": "10.35"
  }
]

Test 3 :

[
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "כיסוי מגן קד קורולה -80",
    "price": "10.35"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "קליפס למגן פרדו+קורולה 80",
    "price": "10.35"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "גומי שמשה אח'תח'קורולה 80",
    "price": "15.53"
  }
]

Test 4 :
[
  {
    "make": "הונדה",
    "model": null,
    "cat_num_desc": "כנף אחורית ימין סיווק היבריידי-610",
    "part_family": "דלתות וכנפיים",
    "price": "8322.37"
  }
]

Test 5 :
[
  {
    "make": "טויוטה",
    "model": null,
    "cat_num_desc": "תומך פח חזית ימ' אונסיס 11-90",
    "year_from": 2011,
    "price": "207.06"
  },
  {
    "make": "טויוטה",
    "model": null,
    "cat_num_desc": "תומך פח חזית שמ' אונסיס 11-90",
    "year_from": 2011,
    "price": "258.83"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "תפס מגן אח' ימ' ארוך - קורולה 11-80",
    "year_from": 2011,
    "price": "305.86"
  }
]

Test 6 :

[
  {
    "make": "טויוטה",
    "model": "RAV4",
    "cat_num_desc": "קליפס לכנפון ראב 4 - 710-310",
    "price": "5.0"
  },
  {
    "make": "טויוטה",
    "model": null,
    "cat_num_desc": "קליפס למגן קד' טויוטה+לקסוס",
    "price": "10.35"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "כיסוי מגן קד קורולה -80",
    "price": "10.35"
  }
]

Test 7:

[
  {
    "test_name": "Test 7: OEM search"
  }
]

Test 8:

[
  {
    "make": "האמר",
    "model": null,
    "cat_num_desc": "בית פנס צד כנף אחורי 40-29 ~ 1H",
    "price": "1.04"
  },
  {
    "make": "שברולט אמ",
    "model": null,
    "cat_num_desc": "תפס לפנס ראשי שמ' - מאליבו -410",
    "price": "12.3"
  },
  {
    "make": "פולקסווגן",
    "model": "פולו",
    "cat_num_desc": "תושבת פנס - פולו -010",
    "price": "12.42"
  }
]

Test 9;

[
  {
    "make": "טויוטה",
    "model": "RAV4",
    "cat_num_desc": "קליפס לכנפון ראב 4 - 710-310",
    "price": "5.0"
  },
  {
    "make": "טויוטה",
    "model": null,
    "cat_num_desc": "קליפס למגן קד' טויוטה+לקסוס",
    "price": "10.35"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "כיסוי מגן קד קורולה -80",
    "price": "10.35"
  }
]

Test 10 ;

[
  {
    "make": "טטרה",
    "model": null,
    "cat_num_desc": "מתג איתות ריאו עם בלם מנוע - ריאו",
    "part_family": "פנסים ותאורה",
    "price": "1.04"
  },
  {
    "make": "האמר",
    "model": null,
    "cat_num_desc": "בית פנס צד כנף אחורי 40-29 ~ 1H",
    "part_family": "פנסים ותאורה",
    "price": "1.04"
  },
  {
    "make": "שברולט אמ",
    "model": null,
    "cat_num_desc": "תפס לפנס ראשי שמ' - מאליבו -410",
    "part_family": "פנסים ותאורה",
    "price": "12.3"
  }
]

Test 11:

[
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "פנס אח' ימ' פנ' - קורולה 010-80",
    "year_from": 2010,
    "part_family": "פנסים ותאורה",
    "price": "354.41"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "פנס אח' שמ' חיצ' - קורולה -010",
    "year_from": 2010,
    "part_family": "פנסים ותאורה",
    "price": "425.29"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "פנס אח' ימ' - קורולה -010",
    "year_from": 2010,
    "part_family": "פנסים ותאורה",
    "price": "446.6"
  }
]

Test 12 :

[
  {
    "toyota_count": 2981,
    "corolla_count": 463,
    "knaf_count": 4433,
    "knaf_achorit_count": 1,
    "year_2011_count": 285,
    "has_oem_count": 0,
    "lights_family_count": 7118,
    "chalifi_count": 47176,
    "mekori_count": 0
  }
]

Test for the new search enhancement:
Test 1 :
[
  {
    "make": "טויוטה",
    "model": "RAV4",
    "cat_num_desc": "קליפס לכנפון ראב 4 - 710-310",
    "price": "5.0"
  },
  {
    "make": "טויוטה",
    "model": null,
    "cat_num_desc": "קליפס למגן קד' טויוטה+לקסוס",
    "price": "10.35"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "כיסוי מגן קד קורולה -80",
    "price": "10.35"
  }
]

Test 2 

[
  {
    "make": "טויוטה",
    "model": "RAV4",
    "cat_num_desc": "קליפס לכנפון ראב 4 - 710-310",
    "price": "5.0"
  },
  {
    "make": "טויוטה",
    "model": null,
    "cat_num_desc": "קליפס למגן קד' טויוטה+לקסוס",
    "price": "10.35"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "כיסוי מגן קד קורולה -80",
    "price": "10.35"
  }
]

Test 3 :

[
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "כיסוי מגן קד קורולה -80",
    "price": "10.35"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "קליפס למגן פרדו+קורולה 80",
    "price": "10.35"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "גומי שמשה אח'תח'קורולה 80",
    "price": "15.53"
  }
]

Test 4 :

[
  {
    "make": "הונדה",
    "model": null,
    "cat_num_desc": "כנף אחורית ימין סיווק היבריידי-610",
    "part_family": "דלתות וכנפיים",
    "price": "8322.37"
  }
]

Test 5 ;

[
  {
    "make": "טויוטה",
    "model": null,
    "cat_num_desc": "תומך פח חזית ימ' אונסיס 11-90",
    "year_from": 2011,
    "price": "207.06"
  },
  {
    "make": "טויוטה",
    "model": null,
    "cat_num_desc": "תומך פח חזית שמ' אונסיס 11-90",
    "year_from": 2011,
    "price": "258.83"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "תפס מגן אח' ימ' ארוך - קורולה 11-80",
    "year_from": 2011,
    "price": "305.86"
  }
]

Test 6:

[
  {
    "make": "טויוטה",
    "model": "RAV4",
    "cat_num_desc": "קליפס לכנפון ראב 4 - 710-310",
    "price": "5.0"
  },
  {
    "make": "טויוטה",
    "model": null,
    "cat_num_desc": "קליפס למגן קד' טויוטה+לקסוס",
    "price": "10.35"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "כיסוי מגן קד קורולה -80",
    "price": "10.35"
  }
]

Test 7:

[
  {
    "test_name": "Test 7: OEM search"
  }
]

Test 8:

[
  {
    "make": "האמר",
    "model": null,
    "cat_num_desc": "בית פנס צד כנף אחורי 40-29 ~ 1H",
    "price": "1.04"
  },
  {
    "make": "טטרה",
    "model": null,
    "cat_num_desc": "מתג איתות ריאו עם בלם מנוע - ריאו",
    "price": "1.04"
  },
  {
    "make": "שברולט אמ",
    "model": null,
    "cat_num_desc": "תפס לפנס ראשי שמ' - מאליבו -410",
    "price": "12.3"
  }
]

Test 9:

[
  {
    "make": "טויוטה",
    "model": "RAV4",
    "cat_num_desc": "קליפס לכנפון ראב 4 - 710-310",
    "price": "5.0"
  },
  {
    "make": "טויוטה",
    "model": null,
    "cat_num_desc": "קליפס למגן קד' טויוטה+לקסוס",
    "price": "10.35"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "כיסוי מגן קד קורולה -80",
    "price": "10.35"
  }
]

Test 10

[
  {
    "make": "טטרה",
    "model": null,
    "cat_num_desc": "מתג איתות ריאו עם בלם מנוע - ריאו",
    "part_family": "פנסים ותאורה",
    "price": "1.04"
  },
  {
    "make": "האמר",
    "model": null,
    "cat_num_desc": "בית פנס צד כנף אחורי 40-29 ~ 1H",
    "part_family": "פנסים ותאורה",
    "price": "1.04"
  },
  {
    "make": "שברולט אמ",
    "model": null,
    "cat_num_desc": "תפס לפנס ראשי שמ' - מאליבו -410",
    "part_family": "פנסים ותאורה",
    "price": "12.3"
  }
]

Test 11: 
[
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "פנס אח' ימ' פנ' - קורולה 010-80",
    "year_from": 2010,
    "part_family": "פנסים ותאורה",
    "price": "354.41"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "פנס אח' שמ' חיצ' - קורולה -010",
    "year_from": 2010,
    "part_family": "פנסים ותאורה",
    "price": "425.29"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "פנס אח' ימ' - קורולה -010",
    "year_from": 2010,
    "part_family": "פנסים ותאורה",
    "price": "446.6"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "פנס ראשי ימ' - קורולה 010-80 D4",
    "year_from": 2010,
    "part_family": "פנסים ותאורה",
    "price": "959.18"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "פנס ראשי שמ' - קורולה 010-80 D4",
    "year_from": 2010,
    "part_family": "פנסים ותאורה",
    "price": "974.4"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "פנס ראשי ימ' + מנוע - קורולה 210-110",
    "year_from": 2010,
    "part_family": "פנסים ותאורה",
    "price": "1065.75"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "פנס ראשי שמ' + מנוע - קורולה 210-110",
    "year_from": 2010,
    "part_family": "פנסים ותאורה",
    "price": "1121.58"
  },
  {
    "make": "טויוטה",
    "model": "קורולה",
    "cat_num_desc": "פנס ראשי שמ' - קורולה 610-310",
    "year_from": 2010,
    "part_family": "פנסים ותאורה",
    "price": "2191.37"
  }
]
Test 12 :
[
  {
    "make": "האמר",
    "model": null,
    "cat_num_desc": "שעון לחץ שמן קילופסק המר-40-29 ~ 2A 1H",
    "source": "חליפי",
    "price": "1.04"
  },
  {
    "make": "האמר",
    "model": null,
    "cat_num_desc": "שעון טמפ' מנוע - 40-29 1H",
    "source": "חליפי",
    "price": "1.04"
  },
  {
    "make": "האמר",
    "model": null,
    "cat_num_desc": "מסנן סולר (מושלם) - 40-29 1H",
    "source": "חליפי",
    "price": "1.04"
  }
]

Test 13: 
[
  {
    "toyota_count": 2981,
    "corolla_count": 463,
    "knaf_count": 4433,
    "knaf_achorit_count": 1,
    "year_2011_count": 285,
    "has_oem_count": 0,
    "lights_family_count": 7118,
    "chalifi_count": 47176,
    "mekori_count": 0
  }
]

Conflicting sql :

New search sql :
-- ENFORCE PART PARAMETER REQUIREMENT
-- Make part_param MANDATORY for all searches
-- Part must match - no fallback to make/model if part doesn't exist

-- This modifies COMPLETE_SEARCH_ALL_PARAMS.sql to enforce:
-- 1. Part parameter is REQUIRED (search fails if empty)
-- 2. Part must exist in catalog (deal-breaker like make)
-- 3. No results if part doesn't match

DROP FUNCTION IF EXISTS smart_parts_search(
    TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, INT, TEXT, TEXT, TEXT, TEXT, TEXT, INT, TEXT, TEXT, TEXT, TEXT
) CASCADE;

CREATE OR REPLACE FUNCTION smart_parts_search(
    make_param TEXT DEFAULT NULL,
    model_param TEXT DEFAULT NULL,
    free_query_param TEXT DEFAULT NULL,
    part_param TEXT DEFAULT NULL,
    oem_param TEXT DEFAULT NULL,
    family_param TEXT DEFAULT NULL,
    limit_results INT DEFAULT 50,
    car_plate TEXT DEFAULT NULL,
    engine_code_param TEXT DEFAULT NULL,
    engine_type_param TEXT DEFAULT NULL,
    engine_volume_param TEXT DEFAULT NULL,
    model_code_param TEXT DEFAULT NULL,
    quantity_param INT DEFAULT NULL,
    source_param TEXT DEFAULT NULL,
    trim_param TEXT DEFAULT NULL,
    vin_number_param TEXT DEFAULT NULL,
    year_param TEXT DEFAULT NULL
)
RETURNS TABLE (
    id UUID,
    cat_num_desc TEXT,
    supplier_name TEXT,
    pcode TEXT,
    price NUMERIC,
    oem TEXT,
    make TEXT,
    model TEXT,
    part_family TEXT,
    side_position TEXT,
    version_date TEXT,
    availability TEXT,
    extracted_year TEXT,
    model_display TEXT,
    match_score INT,
    year_from INT,
    year_to INT
)
LANGUAGE plpgsql
AS $$
DECLARE
    result_count INT := 0;
    where_parts TEXT[] := ARRAY[]::TEXT[];
    final_where TEXT;
    final_query TEXT;
    
    make_terms TEXT[];
    model_terms TEXT[];
    part_terms TEXT[];
    free_terms TEXT[];
    year_formats TEXT[];
    
    current_search TEXT;
    i INT;
BEGIN
    -- ============================================================================
    -- CRITICAL: PART PARAMETER IS MANDATORY
    -- ============================================================================
    
    -- If part_param is NULL or empty, return no results
    -- Part must be provided for search to work
    IF part_param IS NULL OR part_param = '' THEN
        RETURN; -- Return empty result set
    END IF;
    
    -- ============================================================================
    -- STEP 1: CASCADE PART FIRST (MANDATORY - DEAL BREAKER)
    -- ============================================================================
    
    part_terms := string_to_array(part_param, ' ');
    
    FOR i IN REVERSE array_length(part_terms, 1)..1 LOOP
        current_search := array_to_string(part_terms[1:i], ' ');
        
        where_parts := array_append(where_parts,
            format('(ci.cat_num_desc ILIKE %L OR ci.part_family ILIKE %L)',
                '%' || current_search || '%', '%' || current_search || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count > 0 THEN EXIT; END IF;
        where_parts := where_parts[1:array_length(where_parts,1)-1];
    END LOOP;
    
    -- If no part found at all, return empty (DEAL BREAKER)
    IF result_count = 0 THEN 
        RETURN; 
    END IF;
    
    -- ============================================================================
    -- STEP 2: CASCADE MAKE (if provided)
    -- ============================================================================
    
    IF make_param IS NOT NULL AND make_param != '' THEN
        make_terms := string_to_array(make_param, ' ');
        
        FOR i IN REVERSE array_length(make_terms, 1)..1 LOOP
            current_search := array_to_string(make_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('ci.make ILIKE %L', '%' || current_search || '%'));
            
            final_where := array_to_string(where_parts, ' AND ');
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || final_where INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        -- If no make found after adding make filter, return empty
        IF result_count = 0 THEN RETURN; END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 3-7: OTHER PARAMETERS (model, year, family, etc.)
    -- [Same cascade logic as COMPLETE_SEARCH_ALL_PARAMS.sql]
    -- ============================================================================
    
    -- Model cascade
    IF model_param IS NOT NULL AND model_param != '' THEN
        model_terms := string_to_array(model_param, ' ');
        
        FOR i IN REVERSE array_length(model_terms, 1)..1 LOOP
            current_search := array_to_string(model_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('ci.model ILIKE %L', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
    END IF;
    
    -- Year cascade
    IF year_param IS NOT NULL AND year_param != '' THEN
        IF length(year_param) = 4 THEN
            IF year_param::INT >= 2010 THEN
                year_formats := ARRAY[year_param, '0' || substring(year_param from 3), substring(year_param from 3)];
            ELSE
                year_formats := ARRAY[year_param, substring(year_param from 3)];
            END IF;
        ELSE
            year_formats := ARRAY[year_param];
        END IF;
        
        FOR i IN 1..array_length(year_formats, 1) LOOP
            where_parts := array_append(where_parts,
                format('(ci.year_from::TEXT ILIKE %L OR ci.extracted_year ILIKE %L)',
                    '%' || year_formats[i] || '%', '%' || year_formats[i] || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
    END IF;
    
    -- Family filter
    IF family_param IS NOT NULL AND family_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.part_family ILIKE %L', '%' || family_param || '%'));
    END IF;
    
    -- Source filter
    IF source_param IS NOT NULL AND source_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.source ILIKE %L', '%' || source_param || '%'));
    END IF;
    
    -- OEM filter
    IF oem_param IS NOT NULL AND oem_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.oem ILIKE %L', '%' || oem_param || '%'));
    END IF;
    
    -- Free query cascade
    IF free_query_param IS NOT NULL AND free_query_param != '' THEN
        free_terms := string_to_array(free_query_param, ' ');
        
        FOR i IN REVERSE array_length(free_terms, 1)..1 LOOP
            current_search := array_to_string(free_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('(ci.cat_num_desc ILIKE %L OR ci.part_family ILIKE %L)',
                    '%' || current_search || '%', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
    END IF;
    
    -- ============================================================================
    -- EXECUTE FINAL QUERY
    -- ============================================================================
    
    final_where := array_to_string(where_parts, ' AND ');
    IF final_where = '' THEN final_where := 'TRUE'; END IF;
    
    final_query := format('
        SELECT 
            ci.id,
            ci.cat_num_desc,
            ci.supplier_name,
            ci.pcode,
            ci.price::NUMERIC,
            ci.oem,
            ci.make,
            ci.model,
            COALESCE(ci.part_family, ''לא מוגדר'') as part_family,
            ci.side_position,
            ci.version_date::TEXT,
            COALESCE(ci.source, ''חליפי'') as availability,
            ci.extracted_year,
            ci.model_display,
            10 as match_score,
            ci.year_from,
            ci.year_to
        FROM catalog_items ci
        WHERE %s
        ORDER BY ci.price ASC NULLS LAST
        LIMIT %s
    ', final_where, limit_results);
    
    RETURN QUERY EXECUTE final_query;
END;
$$;

-- Test: Search without part parameter should return nothing
SELECT 'Test 1: Search without part (should be empty)' as test;
SELECT COUNT(*) as result_count
FROM smart_parts_search(make_param := 'טויוטה', model_param := 'קורולה');

-- Test: Search with non-matching part should return nothing
SELECT 'Test 2: Search with wrong part (should be empty)' as test;
SELECT COUNT(*) as result_count
FROM smart_parts_search(
    make_param := 'טויוטה',
    model_param := 'COROLLA CROSS', 
    part_param := 'פנס'
)
WHERE pcode = 'TEST-12345';

-- Test: Search with matching part should return test row
SELECT 'Test 3: Search with correct part (should find test row)' as test;
SELECT make, model, cat_num_desc, price
FROM smart_parts_search(
    make_param := 'טויוטה',
    model_param := 'COROLLA CROSS',
    part_param := 'כנף אחורית'
)
WHERE pcode = 'TEST-12345'
LIMIT 1;
 
Old WORKING sql - but no mandatory part config:
-- COMPLETE CASCADING SEARCH - ALL 16 PARAMETERS
-- Implements exact cascade logic from task file
--
-- Parameters (in cascade order):
-- 1. car_plate - Always accept (never filters)
-- 2. make - "טויוטה יפן" → "טויוטה"
-- 3. model - "COROLLA CROSS" → "COROLLA" → fallback to make only
-- 4. model_code - "ZVG12L-KHXGBW" → "ZVG12L" → fallback to model → make
-- 5. trim - Fallback to model_code → model → make
-- 6. year - Normalize (2022→022, 1989→89), fallback to make
-- 7. engine_volume - If doesn't exist, IGNORE (don't break search)
-- 8. engine_code - If doesn't exist, IGNORE
-- 9. engine_type - If doesn't exist, IGNORE
-- 10. vin_number - If doesn't exist, IGNORE
-- 11. oem - Search if exists
-- 12. free_query - Multi-word cascade
-- 13. family - Part family filter
-- 14. part - Multi-word cascade "כנף אחורית שמאלית" → "כנף אחורית" → "כנף"
-- 15. source - חליפי/מקורי filter
-- 16. quantity - Informational only

DROP FUNCTION IF EXISTS smart_parts_search(
    TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, INT, TEXT, TEXT, TEXT, TEXT, TEXT, INT, TEXT, TEXT, TEXT, TEXT
) CASCADE;

CREATE OR REPLACE FUNCTION smart_parts_search(
    make_param TEXT DEFAULT NULL,
    model_param TEXT DEFAULT NULL,
    free_query_param TEXT DEFAULT NULL,
    part_param TEXT DEFAULT NULL,
    oem_param TEXT DEFAULT NULL,
    family_param TEXT DEFAULT NULL,
    limit_results INT DEFAULT 50,
    car_plate TEXT DEFAULT NULL,
    engine_code_param TEXT DEFAULT NULL,
    engine_type_param TEXT DEFAULT NULL,
    engine_volume_param TEXT DEFAULT NULL,
    model_code_param TEXT DEFAULT NULL,
    quantity_param INT DEFAULT NULL,
    source_param TEXT DEFAULT NULL,
    trim_param TEXT DEFAULT NULL,
    vin_number_param TEXT DEFAULT NULL,
    year_param TEXT DEFAULT NULL
)
RETURNS TABLE (
    id UUID,
    cat_num_desc TEXT,
    supplier_name TEXT,
    pcode TEXT,
    price NUMERIC,
    oem TEXT,
    make TEXT,
    model TEXT,
    part_family TEXT,
    side_position TEXT,
    version_date TEXT,
    availability TEXT,
    extracted_year TEXT,
    model_display TEXT,
    match_score INT,
    year_from INT,
    year_to INT
)
LANGUAGE plpgsql
AS $$
DECLARE
    result_count INT := 0;
    where_parts TEXT[] := ARRAY[]::TEXT[];
    final_where TEXT;
    final_query TEXT;
    
    -- Cascade variables
    make_terms TEXT[];
    model_terms TEXT[];
    part_terms TEXT[];
    free_terms TEXT[];
    year_formats TEXT[];
    
    current_search TEXT;
    i INT;
BEGIN
    -- ============================================================================
    -- PLATE: Always accepted, never filters (informational only)
    -- ============================================================================
    -- car_plate is stored for context but doesn't filter results
    
    -- ============================================================================
    -- STEP 1: CASCADE MAKE (טויוטה יפן → טויוטה)
    -- ============================================================================
    
    IF make_param IS NOT NULL AND make_param != '' THEN
        make_terms := string_to_array(make_param, ' ');
        
        -- Try progressively fewer words
        FOR i IN REVERSE array_length(make_terms, 1)..1 LOOP
            current_search := array_to_string(make_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('ci.make ILIKE %L', '%' || current_search || '%'));
            
            final_where := array_to_string(where_parts, ' AND ');
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || final_where INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        -- If no make found, return empty
        IF result_count = 0 THEN RETURN; END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 2: CASCADE MODEL_CODE (ZVG12L-KHXGBW → ZVG12L → model → make)
    -- ============================================================================
    
    IF model_code_param IS NOT NULL AND model_code_param != '' THEN
        -- Try full model_code
        where_parts := array_append(where_parts,
            format('ci.model_code ILIKE %L', '%' || model_code_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            -- Try code before '-'
            IF position('-' IN model_code_param) > 0 THEN
                where_parts := where_parts[1:array_length(where_parts,1)-1];
                current_search := split_part(model_code_param, '-', 1);
                
                where_parts := array_append(where_parts,
                    format('ci.model_code ILIKE %L', '%' || current_search || '%'));
                
                EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            END IF;
            
            -- If still no results, fallback to model/make (don't add model_code filter)
            IF result_count = 0 THEN
                where_parts := where_parts[1:array_length(where_parts,1)-1];
            END IF;
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 3: CASCADE TRIM (ADVENTURE → model_code → model → make)
    -- ============================================================================
    
    IF trim_param IS NOT NULL AND trim_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.trim ILIKE %L', '%' || trim_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        -- If no trim match, remove filter (fallback to previous filters)
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 4: CASCADE MODEL (COROLLA CROSS → COROLLA → make)
    -- ============================================================================
    
    IF model_param IS NOT NULL AND model_param != '' THEN
        model_terms := string_to_array(model_param, ' ');
        
        FOR i IN REVERSE array_length(model_terms, 1)..1 LOOP
            current_search := array_to_string(model_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('ci.model ILIKE %L', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        -- If no model match, continue without model (fallback to make)
    END IF;
    
    -- ============================================================================
    -- STEP 5: CASCADE YEAR (2022 → 022, 1989 → 89)
    -- ============================================================================
    
    IF year_param IS NOT NULL AND year_param != '' THEN
        -- Normalize year format
        IF length(year_param) = 4 THEN
            IF year_param::INT >= 2010 THEN
                -- 2022 → 022 (leading 0 + last 2 digits)
                year_formats := ARRAY[
                    year_param,
                    '0' || substring(year_param from 3),
                    substring(year_param from 3)
                ];
            ELSE
                -- 1989 → 89 (just last 2 digits)
                year_formats := ARRAY[
                    year_param,
                    substring(year_param from 3)
                ];
            END IF;
        ELSE
            year_formats := ARRAY[year_param];
        END IF;
        
        -- Try each year format
        FOR i IN 1..array_length(year_formats, 1) LOOP
            where_parts := array_append(where_parts,
                format('(ci.year_from::TEXT ILIKE %L OR ci.extracted_year ILIKE %L)',
                    '%' || year_formats[i] || '%', '%' || year_formats[i] || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        -- If no year match, continue without year (fallback to make)
    END IF;
    
    -- ============================================================================
    -- STEP 6: ENGINE PARAMETERS - IGNORE if don't exist (don't break search)
    -- ============================================================================
    
    -- engine_code: Try to filter, but ignore if no results
    IF engine_code_param IS NOT NULL AND engine_code_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.engine_code ILIKE %L', '%' || engine_code_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1]; -- Ignore
        END IF;
    END IF;
    
    -- engine_type: Try to filter, but ignore if no results
    IF engine_type_param IS NOT NULL AND engine_type_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.engine_type ILIKE %L', '%' || engine_type_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1]; -- Ignore
        END IF;
    END IF;
    
    -- engine_volume: Try to filter, but ignore if no results
    IF engine_volume_param IS NOT NULL AND engine_volume_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.engine_volume ILIKE %L', '%' || engine_volume_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1]; -- Ignore
        END IF;
    END IF;
    
    -- vin_number: Try to filter, but ignore if no results
    IF vin_number_param IS NOT NULL AND vin_number_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.vin ILIKE %L', '%' || vin_number_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1]; -- Ignore
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 7: PART PARAMETERS (parts search)
    -- ============================================================================
    
    -- CASCADE PART (כנף אחורית שמאלית → כנף אחורית → כנף)
    IF part_param IS NOT NULL AND part_param != '' THEN
        part_terms := string_to_array(part_param, ' ');
        
        FOR i IN REVERSE array_length(part_terms, 1)..1 LOOP
            current_search := array_to_string(part_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('(ci.cat_num_desc ILIKE %L OR ci.part_family ILIKE %L)',
                    '%' || current_search || '%', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        -- If no part found at all, return empty
        IF result_count = 0 THEN RETURN; END IF;
    END IF;
    
    -- OEM filter
    IF oem_param IS NOT NULL AND oem_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.oem ILIKE %L', '%' || oem_param || '%'));
    END IF;
    
    -- Part family filter
    IF family_param IS NOT NULL AND family_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.part_family ILIKE %L', '%' || family_param || '%'));
    END IF;
    
    -- Source filter (חליפי/מקורי)
    IF source_param IS NOT NULL AND source_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.source ILIKE %L', '%' || source_param || '%'));
    END IF;
    
    -- CASCADE FREE QUERY (multi-word)
    IF free_query_param IS NOT NULL AND free_query_param != '' THEN
        free_terms := string_to_array(free_query_param, ' ');
        
        FOR i IN REVERSE array_length(free_terms, 1)..1 LOOP
            current_search := array_to_string(free_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('(ci.cat_num_desc ILIKE %L OR ci.part_family ILIKE %L)',
                    '%' || current_search || '%', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
    END IF;
    
    -- ============================================================================
    -- STEP 8: EXECUTE FINAL QUERY
    -- ============================================================================
    
    final_where := array_to_string(where_parts, ' AND ');
    IF final_where = '' THEN final_where := 'TRUE'; END IF;
    
    final_query := format('
        SELECT 
            ci.id,
            ci.cat_num_desc,
            ci.supplier_name,
            ci.pcode,
            ci.price::NUMERIC,
            ci.oem,
            ci.make,
            ci.model,
            COALESCE(ci.part_family, ''לא מוגדר'') as part_family,
            ci.side_position,
            ci.version_date::TEXT,
            COALESCE(ci.source, ''חליפי'') as availability,
            ci.extracted_year,
            ci.model_display,
            10 as match_score,
            ci.year_from,
            ci.year_to
        FROM catalog_items ci
        WHERE %s
        ORDER BY ci.price ASC NULLS LAST
        LIMIT %s
    ', final_where, limit_results);
    
    RETURN QUERY EXECUTE final_query;
END;
$$;


Check functions test :

[
  {
    "test": "Search function output:",
    "cat_num_desc": "קישוט דלת אח' שמ' - קורולה קרוס (220- (A",
    "part_family": "חלקי מרכב",
    "extracted_year": null
  }
]

2. 

[
  {
    "info": "Current search function:",
    "function_name": "smart_parts_search",
    "has_definition": "CREATE OR REPLACE FUNCTION public.smart_parts_search(make_param text DEFAULT NULL::text, model_param text DEFAULT NULL::text, free_query_param text DEFAULT NULL::text, part_param text DEFAULT NULL::text, oem_param text DEFAULT NULL::text, family_param text DEFAULT NULL::text, limit_results integer DEFAULT 50, car_plate text DEFAULT NULL::text, engine_code_param text DEFAULT NULL::text, engine_type_param text DEFAULT NULL::text, engine_volume_param text DEFAULT NULL::text, model_code_param text DEFAULT NULL::text, quantity_param integer DEFAULT NULL::integer, source_param text DEFAULT NULL::text, trim_param text DEFAULT NULL::text, vin_number_param text DEFAULT NULL::text, year_param text DEFAULT NULL::text)\n RETURNS TABLE(id uuid, cat_num_desc text, supplier_name text, pcode text, price numeric, oem text, make text, model text, part_family text, side_position text, version_date text, availability text, extracted_year text, model_display text, match_score integer, year_from integer, year_to integer)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    result_count INT := 0;\n    where_parts TEXT[] := ARRAY[]::TEXT[];\n    final_where TEXT;\n    final_query TEXT;\n    \n    make_terms TEXT[];\n    model_terms TEXT[];\n    part_terms TEXT[];\n    free_terms TEXT[];\n    year_formats TEXT[];\n    \n    current_search TEXT;\n    i INT;\nBEGIN\n    -- PLATE is tracked for results assignment (not used for filtering)\n    -- car_plate stored in context but doesn't filter results\n    \n    -- ============================================================================\n    -- STEP 1: FAMILY FIRST (Primary filter if provided)\n    -- ============================================================================\n    \n    IF family_param IS NOT NULL AND family_param != '' THEN\n        where_parts := array_append(where_parts,\n            format('ci.part_family ILIKE %L', '%' || family_param || '%'));\n        \n        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;\n        \n        -- If family doesn't exist, return empty\n        IF result_count = 0 THEN RETURN; END IF;\n    END IF;\n    \n    -- ============================================================================\n    -- STEP 2: PART SECOND (Required - must match within family results)\n    -- Use part_param if provided, otherwise use free_query_param\n    -- ============================================================================\n    \n    IF part_param IS NOT NULL AND part_param != '' THEN\n        part_terms := string_to_array(part_param, ' ');\n        \n        FOR i IN REVERSE array_length(part_terms, 1)..1 LOOP\n            current_search := array_to_string(part_terms[1:i], ' ');\n            \n            where_parts := array_append(where_parts,\n                format('(ci.cat_num_desc ILIKE %L OR ci.part_family ILIKE %L)',\n                    '%' || current_search || '%', '%' || current_search || '%'));\n            \n            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;\n            \n            IF result_count > 0 THEN EXIT; END IF;\n            where_parts := where_parts[1:array_length(where_parts,1)-1];\n        END LOOP;\n        \n        -- If no part found, return empty (REQUIRED)\n        IF result_count = 0 THEN RETURN; END IF;\n        \n    ELSIF free_query_param IS NOT NULL AND free_query_param != '' THEN\n        free_terms := string_to_array(free_query_param, ' ');\n        \n        FOR i IN REVERSE array_length(free_terms, 1)..1 LOOP\n            current_search := array_to_string(free_terms[1:i], ' ');\n            \n            where_parts := array_append(where_parts,\n                format('(ci.cat_num_desc ILIKE %L OR ci.part_family ILIKE %L)',\n                    '%' || current_search || '%', '%' || current_search || '%'));\n            \n            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;\n            \n            IF result_count > 0 THEN EXIT; END IF;\n            where_parts := where_parts[1:array_length(where_parts,1)-1];\n        END LOOP;\n        \n        -- If no match found, return empty (REQUIRED)\n        IF result_count = 0 THEN RETURN; END IF;\n    ELSE\n        -- No part or free_query provided - return empty\n        RETURN;\n    END IF;\n    \n    -- ============================================================================\n    -- STEP 3: MAKE (Filter part results with cascading)\n    -- ============================================================================\n    \n    IF make_param IS NOT NULL AND make_param != '' THEN\n        make_terms := string_to_array(make_param, ' ');\n        \n        FOR i IN REVERSE array_length(make_terms, 1)..1 LOOP\n            current_search := array_to_string(make_terms[1:i], ' ');\n            \n            where_parts := array_append(where_parts,\n                format('ci.make ILIKE %L', '%' || current_search || '%'));\n            \n            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;\n            \n            IF result_count > 0 THEN EXIT; END IF;\n            where_parts := where_parts[1:array_length(where_parts,1)-1];\n        END LOOP;\n        \n        -- If make doesn't match, return empty\n        IF result_count = 0 THEN RETURN; END IF;\n    END IF;\n    \n    -- ============================================================================\n    -- STEP 4: MODEL_CODE (Optional - try to match, remove if no results)\n    -- ============================================================================\n    \n    IF model_code_param IS NOT NULL AND model_code_param != '' THEN\n        where_parts := array_append(where_parts,\n            format('ci.model_code ILIKE %L', '%' || model_code_param || '%'));\n        \n        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;\n        \n        IF result_count = 0 THEN\n            IF position('-' IN model_code_param) > 0 THEN\n                where_parts := where_parts[1:array_length(where_parts,1)-1];\n                current_search := split_part(model_code_param, '-', 1);\n                \n                where_parts := array_append(where_parts,\n                    format('ci.model_code ILIKE %L', '%' || current_search || '%'));\n                \n                EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;\n            END IF;\n            \n            IF result_count = 0 THEN\n                where_parts := where_parts[1:array_length(where_parts,1)-1];\n            END IF;\n        END IF;\n    END IF;\n    \n    -- ============================================================================\n    -- STEP 5: TRIM (Optional - remove if no results)\n    -- ============================================================================\n    \n    IF trim_param IS NOT NULL AND trim_param != '' THEN\n        where_parts := array_append(where_parts,\n            format('ci.trim ILIKE %L', '%' || trim_param || '%'));\n        \n        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;\n        \n        IF result_count = 0 THEN\n            where_parts := where_parts[1:array_length(where_parts,1)-1];\n        END IF;\n    END IF;\n    \n    -- ============================================================================\n    -- STEP 6: MODEL (Filter with cascading)\n    -- ============================================================================\n    \n    IF model_param IS NOT NULL AND model_param != '' THEN\n        model_terms := string_to_array(model_param, ' ');\n        \n        FOR i IN REVERSE array_length(model_terms, 1)..1 LOOP\n            current_search := array_to_string(model_terms[1:i], ' ');\n            \n            where_parts := array_append(where_parts,\n                format('ci.model ILIKE %L', '%' || current_search || '%'));\n            \n            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;\n            \n            IF result_count > 0 THEN EXIT; END IF;\n            where_parts := where_parts[1:array_length(where_parts,1)-1];\n        END LOOP;\n    END IF;\n    \n    -- ============================================================================\n    -- STEP 7: YEAR (Optional with cascading)\n    -- ============================================================================\n    \n    IF year_param IS NOT NULL AND year_param != '' THEN\n        IF length(year_param) = 4 THEN\n            IF year_param::INT >= 2010 THEN\n                year_formats := ARRAY[year_param, '0' || substring(year_param from 3), substring(year_param from 3)];\n            ELSE\n                year_formats := ARRAY[year_param, substring(year_param from 3)];\n            END IF;\n        ELSE\n            year_formats := ARRAY[year_param];\n        END IF;\n        \n        FOR i IN 1..array_length(year_formats, 1) LOOP\n            where_parts := array_append(where_parts,\n                format('(ci.year_from::TEXT ILIKE %L OR ci.extracted_year ILIKE %L)',\n                    '%' || year_formats[i] || '%', '%' || year_formats[i] || '%'));\n            \n            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;\n            \n            IF result_count > 0 THEN EXIT; END IF;\n            where_parts := where_parts[1:array_length(where_parts,1)-1];\n        END LOOP;\n    END IF;\n    \n    -- ============================================================================\n    -- STEP 8: ENGINE PARAMETERS (Optional - remove if no match)\n    -- ============================================================================\n    \n    IF engine_code_param IS NOT NULL AND engine_code_param != '' THEN\n        where_parts := array_append(where_parts,\n            format('ci.engine_code ILIKE %L', '%' || engine_code_param || '%'));\n        \n        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;\n        \n        IF result_count = 0 THEN\n            where_parts := where_parts[1:array_length(where_parts,1)-1];\n        END IF;\n    END IF;\n    \n    IF engine_type_param IS NOT NULL AND engine_type_param != '' THEN\n        where_parts := array_append(where_parts,\n            format('ci.engine_type ILIKE %L', '%' || engine_type_param || '%'));\n        \n        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;\n        \n        IF result_count = 0 THEN\n            where_parts := where_parts[1:array_length(where_parts,1)-1];\n        END IF;\n    END IF;\n    \n    IF engine_volume_param IS NOT NULL AND engine_volume_param != '' THEN\n        where_parts := array_append(where_parts,\n            format('ci.engine_volume ILIKE %L', '%' || engine_volume_param || '%'));\n        \n        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;\n        \n        IF result_count = 0 THEN\n            where_parts := where_parts[1:array_length(where_parts,1)-1];\n        END IF;\n    END IF;\n    \n    IF vin_number_param IS NOT NULL AND vin_number_param != '' THEN\n        where_parts := array_append(where_parts,\n            format('ci.vin ILIKE %L', '%' || vin_number_param || '%'));\n        \n        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;\n        \n        IF result_count = 0 THEN\n            where_parts := where_parts[1:array_length(where_parts,1)-1];\n        END IF;\n    END IF;\n    \n    -- ============================================================================\n    -- STEP 9: OEM and SOURCE (Optional filters)\n    -- ============================================================================\n    \n    IF oem_param IS NOT NULL AND oem_param != '' THEN\n        where_parts := array_append(where_parts,\n            format('ci.oem ILIKE %L', '%' || oem_param || '%'));\n    END IF;\n    \n    IF source_param IS NOT NULL AND source_param != '' THEN\n        where_parts := array_append(where_parts,\n            format('ci.source ILIKE %L', '%' || source_param || '%'));\n    END IF;\n    \n    -- ============================================================================\n    -- EXECUTE FINAL QUERY\n    -- ============================================================================\n    \n    final_where := array_to_string(where_parts, ' AND ');\n    IF final_where = '' THEN final_where := 'TRUE'; END IF;\n    \n    final_query := format('\n        SELECT \n            ci.id,\n            ci.cat_num_desc,\n            ci.supplier_name,\n            ci.pcode,\n            ci.price::NUMERIC,\n            ci.oem,\n            ci.make,\n            ci.model,\n            COALESCE(ci.part_family, ''לא מוגדר'') as part_family,\n            ci.side_position,\n            ci.version_date::TEXT,\n            COALESCE(ci.source, ''חליפי'') as availability,\n            ci.extracted_year,\n            ci.model_display,\n            10 as match_score,\n            ci.year_from,\n            ci.year_to\n        FROM catalog_items ci\n        WHERE %s\n        ORDER BY ci.price ASC NULLS LAST\n        LIMIT %s\n    ', final_where, limit_results);\n    \n    RETURN QUERY EXECUTE final_query;\nEND;\n$function$\n"
  }
]

3.

[
  {
    "test": "Current door data:",
    "pcode": "VBP42072661",
    "cat_num_desc": "-220 סורק הלורוק - ןעטמ תלדל 'מי םלוב",
    "part_family": "םישוגפו םינגמ",
    "year_range": null,
    "extracted_year": null
  }
]

4. 

[
  {
    "test": "Search function output:",
    "cat_num_desc": "קישוט דלת אח' שמ' - קורולה קרוס (220- (A",
    "part_family": "חלקי מרכב",
    "extracted_year": null
  }
]

**5.10 - new search fix needed - this section is after the search function worked properly and was broken by functions patches done by claude**

Current main search functions running :

1. Comprehensive smart search sql :

-- COMPLETE CASCADING SEARCH - ALL 16 PARAMETERS
-- Implements exact cascade logic from task file
--
-- Parameters (in cascade order):
-- 1. car_plate - Always accept (never filters)
-- 2. make - "טויוטה יפן" → "טויוטה"
-- 3. model - "COROLLA CROSS" → "COROLLA" → fallback to make only
-- 4. model_code - "ZVG12L-KHXGBW" → "ZVG12L" → fallback to model → make
-- 5. trim - Fallback to model_code → model → make
-- 6. year - Normalize (2022→022, 1989→89), fallback to make
-- 7. engine_volume - If doesn't exist, IGNORE (don't break search)
-- 8. engine_code - If doesn't exist, IGNORE
-- 9. engine_type - If doesn't exist, IGNORE
-- 10. vin_number - If doesn't exist, IGNORE
-- 11. oem - Search if exists
-- 12. free_query - Multi-word cascade
-- 13. family - Part family filter
-- 14. part - Multi-word cascade "כנף אחורית שמאלית" → "כנף אחורית" → "כנף"
-- 15. source - חליפי/מקורי filter
-- 16. quantity - Informational only

DROP FUNCTION IF EXISTS smart_parts_search(
    TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, INT, TEXT, TEXT, TEXT, TEXT, TEXT, INT, TEXT, TEXT, TEXT, TEXT
) CASCADE;

CREATE OR REPLACE FUNCTION smart_parts_search(
    make_param TEXT DEFAULT NULL,
    model_param TEXT DEFAULT NULL,
    free_query_param TEXT DEFAULT NULL,
    part_param TEXT DEFAULT NULL,
    oem_param TEXT DEFAULT NULL,
    family_param TEXT DEFAULT NULL,
    limit_results INT DEFAULT 50,
    car_plate TEXT DEFAULT NULL,
    engine_code_param TEXT DEFAULT NULL,
    engine_type_param TEXT DEFAULT NULL,
    engine_volume_param TEXT DEFAULT NULL,
    model_code_param TEXT DEFAULT NULL,
    quantity_param INT DEFAULT NULL,
    source_param TEXT DEFAULT NULL,
    trim_param TEXT DEFAULT NULL,
    vin_number_param TEXT DEFAULT NULL,
    year_param TEXT DEFAULT NULL
)
RETURNS TABLE (
    id UUID,
    cat_num_desc TEXT,
    supplier_name TEXT,
    pcode TEXT,
    price NUMERIC,
    oem TEXT,
    make TEXT,
    model TEXT,
    part_family TEXT,
    side_position TEXT,
    version_date TEXT,
    availability TEXT,
    extracted_year TEXT,
    model_display TEXT,
    match_score INT,
    year_from INT,
    year_to INT
)
LANGUAGE plpgsql
AS $$
DECLARE
    result_count INT := 0;
    where_parts TEXT[] := ARRAY[]::TEXT[];
    final_where TEXT;
    final_query TEXT;
    
    -- Cascade variables
    make_terms TEXT[];
    model_terms TEXT[];
    part_terms TEXT[];
    free_terms TEXT[];
    year_formats TEXT[];
    
    current_search TEXT;
    i INT;
BEGIN
    -- ============================================================================
    -- PLATE: Always accepted, never filters (informational only)
    -- ============================================================================
    -- car_plate is stored for context but doesn't filter results
    
    -- ============================================================================
    -- STEP 1: CASCADE MAKE (טויוטה יפן → טויוטה)
    -- ============================================================================
    
    IF make_param IS NOT NULL AND make_param != '' THEN
        make_terms := string_to_array(make_param, ' ');
        
        -- Try progressively fewer words
        FOR i IN REVERSE array_length(make_terms, 1)..1 LOOP
            current_search := array_to_string(make_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('ci.make ILIKE %L', '%' || current_search || '%'));
            
            final_where := array_to_string(where_parts, ' AND ');
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || final_where INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        -- If no make found, return empty
        IF result_count = 0 THEN RETURN; END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 2: CASCADE MODEL_CODE (ZVG12L-KHXGBW → ZVG12L → model → make)
    -- ============================================================================
    
    IF model_code_param IS NOT NULL AND model_code_param != '' THEN
        -- Try full model_code
        where_parts := array_append(where_parts,
            format('ci.model_code ILIKE %L', '%' || model_code_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            -- Try code before '-'
            IF position('-' IN model_code_param) > 0 THEN
                where_parts := where_parts[1:array_length(where_parts,1)-1];
                current_search := split_part(model_code_param, '-', 1);
                
                where_parts := array_append(where_parts,
                    format('ci.model_code ILIKE %L', '%' || current_search || '%'));
                
                EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            END IF;
            
            -- If still no results, fallback to model/make (don't add model_code filter)
            IF result_count = 0 THEN
                where_parts := where_parts[1:array_length(where_parts,1)-1];
            END IF;
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 3: CASCADE TRIM (ADVENTURE → model_code → model → make)
    -- ============================================================================
    
    IF trim_param IS NOT NULL AND trim_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.trim ILIKE %L', '%' || trim_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        -- If no trim match, remove filter (fallback to previous filters)
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 4: CASCADE MODEL (COROLLA CROSS → COROLLA → make)
    -- ============================================================================
    
    IF model_param IS NOT NULL AND model_param != '' THEN
        model_terms := string_to_array(model_param, ' ');
        
        FOR i IN REVERSE array_length(model_terms, 1)..1 LOOP
            current_search := array_to_string(model_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('ci.model ILIKE %L', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        -- If no model match, continue without model (fallback to make)
    END IF;
    
    -- ============================================================================
    -- STEP 5: CASCADE YEAR (2022 → 022, 1989 → 89)
    -- ============================================================================
    
    IF year_param IS NOT NULL AND year_param != '' THEN
        -- Normalize year format
        IF length(year_param) = 4 THEN
            IF year_param::INT >= 2010 THEN
                -- 2022 → 022 (leading 0 + last 2 digits)
                year_formats := ARRAY[
                    year_param,
                    '0' || substring(year_param from 3),
                    substring(year_param from 3)
                ];
            ELSE
                -- 1989 → 89 (just last 2 digits)
                year_formats := ARRAY[
                    year_param,
                    substring(year_param from 3)
                ];
            END IF;
        ELSE
            year_formats := ARRAY[year_param];
        END IF;
        
        -- Try each year format
        FOR i IN 1..array_length(year_formats, 1) LOOP
            where_parts := array_append(where_parts,
                format('(ci.year_from::TEXT ILIKE %L OR ci.extracted_year ILIKE %L)',
                    '%' || year_formats[i] || '%', '%' || year_formats[i] || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        -- If no year match, continue without year (fallback to make)
    END IF;
    
    -- ============================================================================
    -- STEP 6: ENGINE PARAMETERS - IGNORE if don't exist (don't break search)
    -- ============================================================================
    
    -- engine_code: Try to filter, but ignore if no results
    IF engine_code_param IS NOT NULL AND engine_code_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.engine_code ILIKE %L', '%' || engine_code_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1]; -- Ignore
        END IF;
    END IF;
    
    -- engine_type: Try to filter, but ignore if no results
    IF engine_type_param IS NOT NULL AND engine_type_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.engine_type ILIKE %L', '%' || engine_type_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1]; -- Ignore
        END IF;
    END IF;
    
    -- engine_volume: Try to filter, but ignore if no results
    IF engine_volume_param IS NOT NULL AND engine_volume_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.engine_volume ILIKE %L', '%' || engine_volume_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1]; -- Ignore
        END IF;
    END IF;
    
    -- vin_number: Try to filter, but ignore if no results
    IF vin_number_param IS NOT NULL AND vin_number_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.vin ILIKE %L', '%' || vin_number_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1]; -- Ignore
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 7: PART PARAMETERS (parts search)
    -- ============================================================================
    
    -- CASCADE PART (כנף אחורית שמאלית → כנף אחורית → כנף)
    IF part_param IS NOT NULL AND part_param != '' THEN
        part_terms := string_to_array(part_param, ' ');
        
        FOR i IN REVERSE array_length(part_terms, 1)..1 LOOP
            current_search := array_to_string(part_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('(ci.cat_num_desc ILIKE %L OR ci.part_family ILIKE %L)',
                    '%' || current_search || '%', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        -- If no part found at all, return empty
        IF result_count = 0 THEN RETURN; END IF;
    END IF;
    
    -- OEM filter
    IF oem_param IS NOT NULL AND oem_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.oem ILIKE %L', '%' || oem_param || '%'));
    END IF;
    
    -- Part family filter
    IF family_param IS NOT NULL AND family_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.part_family ILIKE %L', '%' || family_param || '%'));
    END IF;
    
    -- Source filter (חליפי/מקורי)
    IF source_param IS NOT NULL AND source_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.source ILIKE %L', '%' || source_param || '%'));
    END IF;
    
    -- CASCADE FREE QUERY (multi-word)
    IF free_query_param IS NOT NULL AND free_query_param != '' THEN
        free_terms := string_to_array(free_query_param, ' ');
        
        FOR i IN REVERSE array_length(free_terms, 1)..1 LOOP
            current_search := array_to_string(free_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('(ci.cat_num_desc ILIKE %L OR ci.part_family ILIKE %L)',
                    '%' || current_search || '%', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
    END IF;
    
    -- ============================================================================
    -- STEP 8: EXECUTE FINAL QUERY
    -- ============================================================================
    
    final_where := array_to_string(where_parts, ' AND ');
    IF final_where = '' THEN final_where := 'TRUE'; END IF;
    
    final_query := format('
        SELECT 
            ci.id,
            ci.cat_num_desc,
            ci.supplier_name,
            ci.pcode,
            ci.price::NUMERIC,
            ci.oem,
            ci.make,
            ci.model,
            COALESCE(ci.part_family, ''לא מוגדר'') as part_family,
            ci.side_position,
            ci.version_date::TEXT,
            COALESCE(ci.source, ''חליפי'') as availability,
            ci.extracted_year,
            ci.model_display,
            10 as match_score,
            ci.year_from,
            ci.year_to
        FROM catalog_items ci
        WHERE %s
        ORDER BY ci.price ASC NULLS LAST
        LIMIT %s
    ', final_where, limit_results);
    
    RETURN QUERY EXECUTE final_query;
END;
$$;



2. Fixed smart search : 

-- Take the OLD WORKING SQL and add part/free_query requirement
-- WITHOUT using COUNT queries for the requirement check
-- Just check if parameters are provided, then use normal cascading

DROP FUNCTION IF EXISTS smart_parts_search(
    TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, INT, TEXT, TEXT, TEXT, TEXT, TEXT, INT, TEXT, TEXT, TEXT, TEXT
) CASCADE;

CREATE OR REPLACE FUNCTION smart_parts_search(
    make_param TEXT DEFAULT NULL,
    model_param TEXT DEFAULT NULL,
    free_query_param TEXT DEFAULT NULL,
    part_param TEXT DEFAULT NULL,
    oem_param TEXT DEFAULT NULL,
    family_param TEXT DEFAULT NULL,
    limit_results INT DEFAULT 50,
    car_plate TEXT DEFAULT NULL,
    engine_code_param TEXT DEFAULT NULL,
    engine_type_param TEXT DEFAULT NULL,
    engine_volume_param TEXT DEFAULT NULL,
    model_code_param TEXT DEFAULT NULL,
    quantity_param INT DEFAULT NULL,
    source_param TEXT DEFAULT NULL,
    trim_param TEXT DEFAULT NULL,
    vin_number_param TEXT DEFAULT NULL,
    year_param TEXT DEFAULT NULL
)
RETURNS TABLE (
    id UUID,
    cat_num_desc TEXT,
    supplier_name TEXT,
    pcode TEXT,
    price NUMERIC,
    oem TEXT,
    make TEXT,
    model TEXT,
    part_family TEXT,
    side_position TEXT,
    version_date TEXT,
    availability TEXT,
    extracted_year TEXT,
    model_display TEXT,
    match_score INT,
    year_from INT,
    year_to INT
)
LANGUAGE plpgsql
AS $$
DECLARE
    result_count INT := 0;
    where_parts TEXT[] := ARRAY[]::TEXT[];
    final_where TEXT;
    final_query TEXT;
    
    make_terms TEXT[];
    model_terms TEXT[];
    part_terms TEXT[];
    free_terms TEXT[];
    year_formats TEXT[];
    
    current_search TEXT;
    i INT;
BEGIN
    -- ============================================================================
    -- CRITICAL REQUIREMENT: Either part_param OR free_query_param must be provided
    -- This is a simple NULL check - no COUNT queries needed
    -- ============================================================================
    
    IF (part_param IS NULL OR part_param = '') AND (free_query_param IS NULL OR free_query_param = '') THEN
        RETURN; -- Return empty - no part search criteria provided
    END IF;
    
    -- ============================================================================
    -- STEP 1: CASCADE MAKE (טויוטה יפן → טויוטה)
    -- ============================================================================
    
    IF make_param IS NOT NULL AND make_param != '' THEN
        make_terms := string_to_array(make_param, ' ');
        
        FOR i IN REVERSE array_length(make_terms, 1)..1 LOOP
            current_search := array_to_string(make_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('ci.make ILIKE %L', '%' || current_search || '%'));
            
            final_where := array_to_string(where_parts, ' AND ');
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || final_where INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        IF result_count = 0 THEN RETURN; END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 2: CASCADE MODEL_CODE
    -- ============================================================================
    
    IF model_code_param IS NOT NULL AND model_code_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.model_code ILIKE %L', '%' || model_code_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            IF position('-' IN model_code_param) > 0 THEN
                where_parts := where_parts[1:array_length(where_parts,1)-1];
                current_search := split_part(model_code_param, '-', 1);
                
                where_parts := array_append(where_parts,
                    format('ci.model_code ILIKE %L', '%' || current_search || '%'));
                
                EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            END IF;
            
            IF result_count = 0 THEN
                where_parts := where_parts[1:array_length(where_parts,1)-1];
            END IF;
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 3: CASCADE TRIM
    -- ============================================================================
    
    IF trim_param IS NOT NULL AND trim_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.trim ILIKE %L', '%' || trim_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 4: CASCADE MODEL
    -- ============================================================================
    
    IF model_param IS NOT NULL AND model_param != '' THEN
        model_terms := string_to_array(model_param, ' ');
        
        FOR i IN REVERSE array_length(model_terms, 1)..1 LOOP
            current_search := array_to_string(model_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('ci.model ILIKE %L', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
    END IF;
    
    -- ============================================================================
    -- STEP 5: CASCADE YEAR
    -- ============================================================================
    
    IF year_param IS NOT NULL AND year_param != '' THEN
        IF length(year_param) = 4 THEN
            IF year_param::INT >= 2010 THEN
                year_formats := ARRAY[year_param, '0' || substring(year_param from 3), substring(year_param from 3)];
            ELSE
                year_formats := ARRAY[year_param, substring(year_param from 3)];
            END IF;
        ELSE
            year_formats := ARRAY[year_param];
        END IF;
        
        FOR i IN 1..array_length(year_formats, 1) LOOP
            where_parts := array_append(where_parts,
                format('(ci.year_from::TEXT ILIKE %L OR ci.extracted_year ILIKE %L)',
                    '%' || year_formats[i] || '%', '%' || year_formats[i] || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
    END IF;
    
    -- ============================================================================
    -- STEP 6: ENGINE PARAMETERS - IGNORE if don't exist
    -- ============================================================================
    
    IF engine_code_param IS NOT NULL AND engine_code_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.engine_code ILIKE %L', '%' || engine_code_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    IF engine_type_param IS NOT NULL AND engine_type_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.engine_type ILIKE %L', '%' || engine_type_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    IF engine_volume_param IS NOT NULL AND engine_volume_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.engine_volume ILIKE %L', '%' || engine_volume_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    IF vin_number_param IS NOT NULL AND vin_number_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.vin ILIKE %L', '%' || vin_number_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 7: PART PARAMETERS - Use part_param if provided, else free_query
    -- ============================================================================
    
    IF part_param IS NOT NULL AND part_param != '' THEN
        part_terms := string_to_array(part_param, ' ');
        
        FOR i IN REVERSE array_length(part_terms, 1)..1 LOOP
            current_search := array_to_string(part_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('(ci.cat_num_desc ILIKE %L OR ci.part_family ILIKE %L)',
                    '%' || current_search || '%', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        IF result_count = 0 THEN RETURN; END IF;
    END IF;
    
    IF oem_param IS NOT NULL AND oem_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.oem ILIKE %L', '%' || oem_param || '%'));
    END IF;
    
    IF family_param IS NOT NULL AND family_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.part_family ILIKE %L', '%' || family_param || '%'));
    END IF;
    
    IF source_param IS NOT NULL AND source_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.source ILIKE %L', '%' || source_param || '%'));
    END IF;
    
    IF free_query_param IS NOT NULL AND free_query_param != '' THEN
        free_terms := string_to_array(free_query_param, ' ');
        
        FOR i IN REVERSE array_length(free_terms, 1)..1 LOOP
            current_search := array_to_string(free_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('(ci.cat_num_desc ILIKE %L OR ci.part_family ILIKE %L)',
                    '%' || current_search || '%', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
    END IF;
    
    -- ============================================================================
    -- EXECUTE FINAL QUERY
    -- ============================================================================
    
    final_where := array_to_string(where_parts, ' AND ');
    IF final_where = '' THEN final_where := 'TRUE'; END IF;
    
    final_query := format('
        SELECT 
            ci.id,
            ci.cat_num_desc,
            ci.supplier_name,
            ci.pcode,
            ci.price::NUMERIC,
            ci.oem,
            ci.make,
            ci.model,
            COALESCE(ci.part_family, ''לא מוגדר'') as part_family,
            ci.side_position,
            ci.version_date::TEXT,
            COALESCE(ci.source, ''חליפי'') as availability,
            ci.extracted_year,
            ci.model_display,
            10 as match_score,
            ci.year_from,
            ci.year_to
        FROM catalog_items ci
        WHERE %s
        ORDER BY ci.price ASC NULLS LAST
        LIMIT %s
    ', final_where, limit_results);
    
    RETURN QUERY EXECUTE final_query;
END;
$$;


3. Smart search filter re-order : this is an important function to prevent displaying results for the parts than the one in query :
-- FIX: Correct search order - FAMILY → PART → MAKE → MODEL → YEAR
-- Family is primary filter (if provided)
-- Part must match (required)
-- Plate is tracked but doesn't filter

DROP FUNCTION IF EXISTS smart_parts_search(
    TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, INT, TEXT, TEXT, TEXT, TEXT, TEXT, INT, TEXT, TEXT, TEXT, TEXT
) CASCADE;

CREATE OR REPLACE FUNCTION smart_parts_search(
    make_param TEXT DEFAULT NULL,
    model_param TEXT DEFAULT NULL,
    free_query_param TEXT DEFAULT NULL,
    part_param TEXT DEFAULT NULL,
    oem_param TEXT DEFAULT NULL,
    family_param TEXT DEFAULT NULL,
    limit_results INT DEFAULT 50,
    car_plate TEXT DEFAULT NULL,
    engine_code_param TEXT DEFAULT NULL,
    engine_type_param TEXT DEFAULT NULL,
    engine_volume_param TEXT DEFAULT NULL,
    model_code_param TEXT DEFAULT NULL,
    quantity_param INT DEFAULT NULL,
    source_param TEXT DEFAULT NULL,
    trim_param TEXT DEFAULT NULL,
    vin_number_param TEXT DEFAULT NULL,
    year_param TEXT DEFAULT NULL
)
RETURNS TABLE (
    id UUID,
    cat_num_desc TEXT,
    supplier_name TEXT,
    pcode TEXT,
    price NUMERIC,
    oem TEXT,
    make TEXT,
    model TEXT,
    part_family TEXT,
    side_position TEXT,
    version_date TEXT,
    availability TEXT,
    extracted_year TEXT,
    model_display TEXT,
    match_score INT,
    year_from INT,
    year_to INT
)
LANGUAGE plpgsql
AS $$
DECLARE
    result_count INT := 0;
    where_parts TEXT[] := ARRAY[]::TEXT[];
    final_where TEXT;
    final_query TEXT;
    
    make_terms TEXT[];
    model_terms TEXT[];
    part_terms TEXT[];
    free_terms TEXT[];
    year_formats TEXT[];
    
    current_search TEXT;
    i INT;
BEGIN
    -- PLATE is tracked for results assignment (not used for filtering)
    -- car_plate stored in context but doesn't filter results
    
    -- ============================================================================
    -- STEP 1: FAMILY FIRST (Primary filter if provided)
    -- ============================================================================
    
    IF family_param IS NOT NULL AND family_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.part_family ILIKE %L', '%' || family_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        -- If family doesn't exist, return empty
        IF result_count = 0 THEN RETURN; END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 2: PART SECOND (Required - must match within family results)
    -- Use part_param if provided, otherwise use free_query_param
    -- ============================================================================
    
    IF part_param IS NOT NULL AND part_param != '' THEN
        part_terms := string_to_array(part_param, ' ');
        
        FOR i IN REVERSE array_length(part_terms, 1)..1 LOOP
            current_search := array_to_string(part_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('(ci.cat_num_desc ILIKE %L OR ci.part_family ILIKE %L)',
                    '%' || current_search || '%', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        -- If no part found, return empty (REQUIRED)
        IF result_count = 0 THEN RETURN; END IF;
        
    ELSIF free_query_param IS NOT NULL AND free_query_param != '' THEN
        free_terms := string_to_array(free_query_param, ' ');
        
        FOR i IN REVERSE array_length(free_terms, 1)..1 LOOP
            current_search := array_to_string(free_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('(ci.cat_num_desc ILIKE %L OR ci.part_family ILIKE %L)',
                    '%' || current_search || '%', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        -- If no match found, return empty (REQUIRED)
        IF result_count = 0 THEN RETURN; END IF;
    ELSE
        -- No part or free_query provided - return empty
        RETURN;
    END IF;
    
    -- ============================================================================
    -- STEP 3: MAKE (Filter part results with cascading)
    -- ============================================================================
    
    IF make_param IS NOT NULL AND make_param != '' THEN
        make_terms := string_to_array(make_param, ' ');
        
        FOR i IN REVERSE array_length(make_terms, 1)..1 LOOP
            current_search := array_to_string(make_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('ci.make ILIKE %L', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        -- If make doesn't match, return empty
        IF result_count = 0 THEN RETURN; END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 4: MODEL_CODE (Optional - try to match, remove if no results)
    -- ============================================================================
    
    IF model_code_param IS NOT NULL AND model_code_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.model_code ILIKE %L', '%' || model_code_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            IF position('-' IN model_code_param) > 0 THEN
                where_parts := where_parts[1:array_length(where_parts,1)-1];
                current_search := split_part(model_code_param, '-', 1);
                
                where_parts := array_append(where_parts,
                    format('ci.model_code ILIKE %L', '%' || current_search || '%'));
                
                EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            END IF;
            
            IF result_count = 0 THEN
                where_parts := where_parts[1:array_length(where_parts,1)-1];
            END IF;
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 5: TRIM (Optional - remove if no results)
    -- ============================================================================
    
    IF trim_param IS NOT NULL AND trim_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.trim ILIKE %L', '%' || trim_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 6: MODEL (Filter with cascading)
    -- ============================================================================
    
    IF model_param IS NOT NULL AND model_param != '' THEN
        model_terms := string_to_array(model_param, ' ');
        
        FOR i IN REVERSE array_length(model_terms, 1)..1 LOOP
            current_search := array_to_string(model_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('ci.model ILIKE %L', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
    END IF;
    
    -- ============================================================================
    -- STEP 7: YEAR (Optional with cascading)
    -- ============================================================================
    
    IF year_param IS NOT NULL AND year_param != '' THEN
        IF length(year_param) = 4 THEN
            IF year_param::INT >= 2010 THEN
                year_formats := ARRAY[year_param, '0' || substring(year_param from 3), substring(year_param from 3)];
            ELSE
                year_formats := ARRAY[year_param, substring(year_param from 3)];
            END IF;
        ELSE
            year_formats := ARRAY[year_param];
        END IF;
        
        FOR i IN 1..array_length(year_formats, 1) LOOP
            where_parts := array_append(where_parts,
                format('(ci.year_from::TEXT ILIKE %L OR ci.extracted_year ILIKE %L)',
                    '%' || year_formats[i] || '%', '%' || year_formats[i] || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
    END IF;
    
    -- ============================================================================
    -- STEP 8: ENGINE PARAMETERS (Optional - remove if no match)
    -- ============================================================================
    
    IF engine_code_param IS NOT NULL AND engine_code_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.engine_code ILIKE %L', '%' || engine_code_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    IF engine_type_param IS NOT NULL AND engine_type_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.engine_type ILIKE %L', '%' || engine_type_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    IF engine_volume_param IS NOT NULL AND engine_volume_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.engine_volume ILIKE %L', '%' || engine_volume_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    IF vin_number_param IS NOT NULL AND vin_number_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.vin ILIKE %L', '%' || vin_number_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 9: OEM and SOURCE (Optional filters)
    -- ============================================================================
    
    IF oem_param IS NOT NULL AND oem_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.oem ILIKE %L', '%' || oem_param || '%'));
    END IF;
    
    IF source_param IS NOT NULL AND source_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.source ILIKE %L', '%' || source_param || '%'));
    END IF;
    
    -- ============================================================================
    -- EXECUTE FINAL QUERY
    -- ============================================================================
    
    final_where := array_to_string(where_parts, ' AND ');
    IF final_where = '' THEN final_where := 'TRUE'; END IF;
    
    final_query := format('
        SELECT 
            ci.id,
            ci.cat_num_desc,
            ci.supplier_name,
            ci.pcode,
            ci.price::NUMERIC,
            ci.oem,
            ci.make,
            ci.model,
            COALESCE(ci.part_family, ''לא מוגדר'') as part_family,
            ci.side_position,
            ci.version_date::TEXT,
            COALESCE(ci.source, ''חליפי'') as availability,
            ci.extracted_year,
            ci.model_display,
            10 as match_score,
            ci.year_from,
            ci.year_to
        FROM catalog_items ci
        WHERE %s
        ORDER BY ci.price ASC NULLS LAST
        LIMIT %s
    ', final_where, limit_results);
    
    RETURN QUERY EXECUTE final_query;
END;
$$;


4. Fix cascade search order : - this sql was deployed after the point where the system was working and it was supposed to fix the search problem but its doesn’t  work or corrupted more :

-- FIX MODEL CASCADE ORDER
-- 
-- PROBLEM: Model cascading not working - search for "קורולה קרוס" doesn't cascade to "קורולה"
-- ROOT CAUSE: Current function has MODEL_CODE and TRIM before MODEL, interfering with cascade
--
-- CORRECT ORDER:
-- 1. FAMILY (if provided)
-- 2. PART (required - either part_param or free_query_param)
-- 3. MAKE (cascades: "טויוטה יפן" → "טויוטה")
-- 4. MODEL (cascades: "קורולה קרוס" → "קורולה") ← THIS WAS IN WRONG POSITION
-- 5. YEAR (optional, cascades: "2022" → "022" → "22")
-- 6. TRIM (optional, removed if no match)
-- 7. MODEL_CODE (optional, removed if no match)
-- 8. ENGINE params (all optional, removed if no match)
-- 9. OEM, SOURCE (optional filters)
--
-- NOTE: The current function has YEAR at step 7, AFTER model_code and trim
-- This is WRONG - YEAR should be at step 5, right after MODEL
--
-- FIX: Move MODEL to STEP 4, BEFORE trim and model_code

DROP FUNCTION IF EXISTS smart_parts_search(
    TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, INT, TEXT, TEXT, TEXT, TEXT, TEXT, INT, TEXT, TEXT, TEXT, TEXT
) CASCADE;

CREATE OR REPLACE FUNCTION smart_parts_search(
    make_param TEXT DEFAULT NULL,
    model_param TEXT DEFAULT NULL,
    free_query_param TEXT DEFAULT NULL,
    part_param TEXT DEFAULT NULL,
    oem_param TEXT DEFAULT NULL,
    family_param TEXT DEFAULT NULL,
    limit_results INT DEFAULT 50,
    car_plate TEXT DEFAULT NULL,
    engine_code_param TEXT DEFAULT NULL,
    engine_type_param TEXT DEFAULT NULL,
    engine_volume_param TEXT DEFAULT NULL,
    model_code_param TEXT DEFAULT NULL,
    quantity_param INT DEFAULT NULL,
    source_param TEXT DEFAULT NULL,
    trim_param TEXT DEFAULT NULL,
    vin_number_param TEXT DEFAULT NULL,
    year_param TEXT DEFAULT NULL
)
RETURNS TABLE (
    id UUID,
    cat_num_desc TEXT,
    supplier_name TEXT,
    pcode TEXT,
    price NUMERIC,
    oem TEXT,
    make TEXT,
    model TEXT,
    part_family TEXT,
    side_position TEXT,
    version_date TEXT,
    availability TEXT,
    extracted_year TEXT,
    model_display TEXT,
    match_score INT,
    year_from INT,
    year_to INT
)
LANGUAGE plpgsql
AS $$
DECLARE
    result_count INT := 0;
    where_parts TEXT[] := ARRAY[]::TEXT[];
    final_where TEXT;
    final_query TEXT;
    
    make_terms TEXT[];
    model_terms TEXT[];
    part_terms TEXT[];
    free_terms TEXT[];
    year_formats TEXT[];
    
    current_search TEXT;
    i INT;
BEGIN
    -- ============================================================================
    -- STEP 1: FAMILY FIRST (Primary filter if provided)
    -- ============================================================================
    
    IF family_param IS NOT NULL AND family_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.part_family ILIKE %L', '%' || family_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN RETURN; END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 2: PART SECOND (Required - must match)
    -- ============================================================================
    
    IF part_param IS NOT NULL AND part_param != '' THEN
        part_terms := string_to_array(part_param, ' ');
        
        FOR i IN REVERSE array_length(part_terms, 1)..1 LOOP
            current_search := array_to_string(part_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('(ci.cat_num_desc ILIKE %L OR ci.part_family ILIKE %L)',
                    '%' || current_search || '%', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        IF result_count = 0 THEN RETURN; END IF;
        
    ELSIF free_query_param IS NOT NULL AND free_query_param != '' THEN
        free_terms := string_to_array(free_query_param, ' ');
        
        FOR i IN REVERSE array_length(free_terms, 1)..1 LOOP
            current_search := array_to_string(free_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('(ci.cat_num_desc ILIKE %L OR ci.part_family ILIKE %L)',
                    '%' || current_search || '%', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        IF result_count = 0 THEN RETURN; END IF;
    ELSE
        RETURN;
    END IF;
    
    -- ============================================================================
    -- STEP 3: MAKE (Cascades: "טויוטה יפן" → "טויוטה")
    -- ============================================================================
    
    IF make_param IS NOT NULL AND make_param != '' THEN
        make_terms := string_to_array(make_param, ' ');
        
        FOR i IN REVERSE array_length(make_terms, 1)..1 LOOP
            current_search := array_to_string(make_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('ci.make ILIKE %L', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        IF result_count = 0 THEN RETURN; END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 4: MODEL (Cascades: "קורולה קרוס" → "קורולה") 
    -- CRITICAL: This must come BEFORE year, trim, and model_code
    -- ============================================================================
    
    IF model_param IS NOT NULL AND model_param != '' THEN
        model_terms := string_to_array(model_param, ' ');
        
        FOR i IN REVERSE array_length(model_terms, 1)..1 LOOP
            current_search := array_to_string(model_terms[1:i], ' ');
            
            where_parts := array_append(where_parts,
                format('ci.model ILIKE %L', '%' || current_search || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
    END IF;
    
    -- ============================================================================
    -- STEP 5: YEAR (Optional - cascades)
    -- CRITICAL: This must come AFTER model, BEFORE trim and model_code
    -- ============================================================================
    
    IF year_param IS NOT NULL AND year_param != '' THEN
        IF length(year_param) = 4 THEN
            IF year_param::INT >= 2010 THEN
                year_formats := ARRAY[year_param, '0' || substring(year_param from 3), substring(year_param from 3)];
            ELSE
                year_formats := ARRAY[year_param, substring(year_param from 3)];
            END IF;
        ELSE
            year_formats := ARRAY[year_param];
        END IF;
        
        FOR i IN 1..array_length(year_formats, 1) LOOP
            where_parts := array_append(where_parts,
                format('(ci.year_from::TEXT ILIKE %L OR ci.extracted_year ILIKE %L)',
                    '%' || year_formats[i] || '%', '%' || year_formats[i] || '%'));
            
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
    END IF;
    
    -- ============================================================================
    -- STEP 6: TRIM (Optional - removed if no match)
    -- ============================================================================
    
    IF trim_param IS NOT NULL AND trim_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.trim ILIKE %L', '%' || trim_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 7: MODEL_CODE (Optional - removed if no match)
    -- ============================================================================
    
    IF model_code_param IS NOT NULL AND model_code_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.model_code ILIKE %L', '%' || model_code_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            IF position('-' IN model_code_param) > 0 THEN
                where_parts := where_parts[1:array_length(where_parts,1)-1];
                current_search := split_part(model_code_param, '-', 1);
                
                where_parts := array_append(where_parts,
                    format('ci.model_code ILIKE %L', '%' || current_search || '%'));
                
                EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
            END IF;
            
            IF result_count = 0 THEN
                where_parts := where_parts[1:array_length(where_parts,1)-1];
            END IF;
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 8: ENGINE PARAMETERS (All optional - removed if no match)
    -- ============================================================================
    
    IF engine_code_param IS NOT NULL AND engine_code_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.engine_code ILIKE %L', '%' || engine_code_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    IF engine_type_param IS NOT NULL AND engine_type_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.engine_type ILIKE %L', '%' || engine_type_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    IF engine_volume_param IS NOT NULL AND engine_volume_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.engine_volume ILIKE %L', '%' || engine_volume_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    IF vin_number_param IS NOT NULL AND vin_number_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.vin ILIKE %L', '%' || vin_number_param || '%'));
        
        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;
        
        IF result_count = 0 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 9: OEM and SOURCE (Optional filters)
    -- ============================================================================
    
    IF oem_param IS NOT NULL AND oem_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.oem ILIKE %L', '%' || oem_param || '%'));
    END IF;
    
    IF source_param IS NOT NULL AND source_param != '' THEN
        where_parts := array_append(where_parts,
            format('ci.source ILIKE %L', '%' || source_param || '%'));
    END IF;
    
    -- ============================================================================
    -- EXECUTE FINAL QUERY
    -- ============================================================================
    
    final_where := array_to_string(where_parts, ' AND ');
    IF final_where = '' THEN final_where := 'TRUE'; END IF;
    
    final_query := format('
        SELECT 
            ci.id,
            ci.cat_num_desc,
            ci.supplier_name,
            ci.pcode,
            ci.price::NUMERIC,
            ci.oem,
            ci.make,
            ci.model,
            COALESCE(ci.part_family, ''לא מוגדר'') as part_family,
            ci.side_position,
            ci.version_date::TEXT,
            COALESCE(ci.source, ''חליפי'') as availability,
            ci.extracted_year,
            ci.model_display,
            10 as match_score,
            ci.year_from,
            ci.year_to
        FROM catalog_items ci
        WHERE %s
        ORDER BY ci.price ASC NULLS LAST
        LIMIT %s
    ', final_where, limit_results);
    
    RETURN QUERY EXECUTE final_query;
END;
$$;

-- ============================================================================
-- VERIFICATION TESTS
-- ============================================================================

-- Test 1: Should return Corolla results (not Yaris)
SELECT 'Test 1: Corolla Cross should cascade to Corolla' as test;
SELECT count(*) 
FROM smart_parts_search(
    make_param := 'טויוטה יפן',
    model_param := 'קורולה קרוס',
    free_query_param := 'חלקי מרכב'
);
-- Expected: 50 results (multiple Corolla parts)

-- Test 2: Just Corolla should still work
SELECT 'Test 2: Direct Corolla search' as test;
SELECT count(*) 
FROM smart_parts_search(
    make_param := 'טויוטה',
    model_param := 'קורולה',
    free_query_param := 'חלקי מרכב'
);
-- Expected: 50 results

-- Test 3: Without model should return all Toyota parts
SELECT 'Test 3: Toyota without model' as test;
SELECT count(*) 
FROM smart_parts_search(
    make_param := 'טויוטה',
    free_query_param := 'חלקי מרכב'
);
-- Expected: 50 results (all Toyota body parts)


6. Connect UI query to cascading search :

-- Drop the 17-parameter version that UI is calling
DROP FUNCTION IF EXISTS smart_parts_search(
    TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, INT, TEXT, TEXT, TEXT, TEXT, TEXT, INT, TEXT, TEXT, TEXT, TEXT
) CASCADE;

-- Drop the 11-parameter version we just created
DROP FUNCTION IF EXISTS smart_parts_search(
    TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, INT
) CASCADE;

-- Create NEW cascading search with 17-parameter signature (what UI expects)
CREATE OR REPLACE FUNCTION smart_parts_search(
    make_param TEXT DEFAULT NULL,
    model_param TEXT DEFAULT NULL,
    free_query_param TEXT DEFAULT NULL,
    part_param TEXT DEFAULT NULL,
    oem_param TEXT DEFAULT NULL,
    family_param TEXT DEFAULT NULL,
    limit_results INT DEFAULT 50,
    car_plate TEXT DEFAULT NULL,
    engine_code_param TEXT DEFAULT NULL,
    engine_type_param TEXT DEFAULT NULL,
    engine_volume_param TEXT DEFAULT NULL,
    model_code_param TEXT DEFAULT NULL,
    quantity_param INT DEFAULT NULL,
    source_param TEXT DEFAULT NULL,
    trim_param TEXT DEFAULT NULL,
    vin_number_param TEXT DEFAULT NULL,
    year_param TEXT DEFAULT NULL
)
RETURNS TABLE (
    id UUID,
    cat_num_desc TEXT,
    supplier_name TEXT,
    pcode TEXT,
    price NUMERIC,
    oem TEXT,
    make TEXT,
    model TEXT,
    part_family TEXT,
    side_position TEXT,
    version_date TEXT,
    availability TEXT,
    extracted_year TEXT,
    model_display TEXT,
    match_score INT,
    year_from INT,
    year_to INT
)
LANGUAGE plpgsql
AS $$
DECLARE
    result_count INT := 0;
    where_parts TEXT[] := ARRAY[]::TEXT[];
    final_where TEXT;
    final_query TEXT;
    
    make_terms TEXT[];
    model_terms TEXT[];
    part_terms TEXT[];
    year_formats TEXT[];
    current_part_search TEXT;
BEGIN
    -- ============================================================================
    -- CASCADE MAKE (טויוטה יפן → טויוטה)
    -- ============================================================================
    
    IF make_param IS NOT NULL AND make_param != '' THEN
        make_terms := string_to_array(make_param, ' ');
        
        FOR i IN REVERSE array_length(make_terms, 1)..1 LOOP
            DECLARE
                current_make TEXT := array_to_string(make_terms[1:i], ' ');
            BEGIN
                IF current_make != '' THEN
                    where_parts := array_append(where_parts,
                        format('ci.make ILIKE %L', '%' || current_make || '%'));
                    
                    final_where := array_to_string(where_parts, ' AND ');
                    EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || final_where INTO result_count;
                    
                    IF result_count > 0 THEN EXIT; END IF;
                    where_parts := where_parts[1:array_length(where_parts,1)-1];
                END IF;
            END;
        END LOOP;
        
        IF result_count = 0 THEN RETURN; END IF;
    END IF;
    
    -- ============================================================================
    -- CASCADE MODEL (COROLLA CROSS → COROLLA)
    -- ============================================================================
    
    IF model_param IS NOT NULL AND model_param != '' THEN
        model_terms := string_to_array(model_param, ' ');
        
        FOR i IN REVERSE array_length(model_terms, 1)..1 LOOP
            DECLARE
                current_model TEXT := array_to_string(model_terms[1:i], ' ');
            BEGIN
                IF current_model != '' THEN
                    where_parts := array_append(where_parts,
                        format('ci.model ILIKE %L', '%' || current_model || '%'));
                    
                    final_where := array_to_string(where_parts, ' AND ');
                    EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || final_where INTO result_count;
                    
                    IF result_count > 0 THEN EXIT; END IF;
                    where_parts := where_parts[1:array_length(where_parts,1)-1];
                END IF;
            END;
        END LOOP;
    END IF;
    
    -- ============================================================================
    -- CASCADE YEAR (2011 → 011 → 11)
    -- ============================================================================
    
    IF year_param IS NOT NULL AND year_param != '' THEN
        IF length(year_param) = 4 THEN
            year_formats := ARRAY[year_param, substring(year_param from 2), substring(year_param from 3)];
        ELSIF length(year_param) = 3 THEN
            year_formats := ARRAY[year_param, '2' || year_param, substring(year_param from 2)];
        ELSE
            year_formats := ARRAY[year_param];
        END IF;
        
        FOR i IN 1..array_length(year_formats, 1) LOOP
            where_parts := array_append(where_parts,
                format('(ci.year_from::TEXT ILIKE %L OR ci.extracted_year ILIKE %L)',
                    '%' || year_formats[i] || '%', '%' || year_formats[i] || '%'));
            
            final_where := array_to_string(where_parts, ' AND ');
            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || final_where INTO result_count;
            
            IF result_count > 0 THEN EXIT; END IF;
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
    END IF;
    
    -- ============================================================================
    -- CASCADE PART (כנף אחורית שמאלית → כנף אחורית → כנף)
    -- ============================================================================
    
    IF part_param IS NOT NULL AND part_param != '' THEN
        part_terms := string_to_array(part_param, ' ');
        
        FOR i IN REVERSE array_length(part_terms, 1)..1 LOOP
            current_part_search := array_to_string(part_terms[1:i], ' ');
            
            IF current_part_search != '' THEN
                where_parts := array_append(where_parts,
                    format('(ci.cat_num_desc ILIKE %L OR ci.part_name ILIKE %L OR ci.part_family ILIKE %L)',
                        '%' || current_part_search || '%', '%' || current_part_search || '%', '%' || current_part_search || '%'));
                
                final_where := array_to_string(where_parts, ' AND ');
                EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || final_where INTO result_count;
                
                IF result_count > 0 THEN EXIT; END IF;
                where_parts := where_parts[1:array_length(where_parts,1)-1];
            END IF;
        END LOOP;
        
        IF result_count = 0 AND part_param IS NOT NULL THEN RETURN; END IF;
    END IF;
    
    -- ============================================================================
    -- OTHER FILTERS
    -- ============================================================================
    
    IF oem_param IS NOT NULL AND oem_param != '' THEN
        where_parts := array_append(where_parts, format('ci.oem ILIKE %L', '%' || oem_param || '%'));
    END IF;
    
    IF family_param IS NOT NULL AND family_param != '' THEN
        where_parts := array_append(where_parts, format('ci.part_family ILIKE %L', '%' || family_param || '%'));
    END IF;
    
    IF free_query_param IS NOT NULL AND free_query_param != '' THEN
        where_parts := array_append(where_parts,
            format('(ci.cat_num_desc ILIKE %L OR ci.part_name ILIKE %L)',
                '%' || free_query_param || '%', '%' || free_query_param || '%'));
    END IF;
    
    -- ============================================================================
    -- EXECUTE QUERY
    -- ============================================================================
    
    final_where := array_to_string(where_parts, ' AND ');
    IF final_where = '' THEN final_where := 'TRUE'; END IF;
    
    final_query := format('
        SELECT 
            ci.id,
            ci.cat_num_desc,
            ci.supplier_name,
            ci.pcode,
            ci.price::NUMERIC,
            ci.oem,
            ci.make,
            ci.model,
            COALESCE(ci.part_family, ''לא מוגדר'') as part_family,
            ci.side_position,
            ci.version_date::TEXT,
            COALESCE(ci.source, ''חליפי'') as availability,
            ci.extracted_year,
            ci.model_display,
            10 as match_score,
            ci.year_from,
            ci.year_to
        FROM catalog_items ci
        WHERE %s
        ORDER BY ci.price ASC NULLS LAST
        LIMIT %s
    ', final_where, limit_results);
    
    RETURN QUERY EXECUTE final_query;
END;
$$;

5. Field level cascading filter :

-- FIELD-LEVEL CASCADING SEARCH - EXACT USER REQUIREMENTS
-- Cascades WITHIN each field (word-by-word) and BETWEEN parameters
--
-- Field Cascading Examples:
-- - Part: "כנף אחורית שמאלית" → "כנף אחורית" → "כנף" → 0
-- - Make: "טויוטה יפן" → "טויוטה"
-- - Model: "COROLLA CROSS" → "COROLLA"
-- - Year: 2011 → 011 → 11
--
-- Returns Hebrew messages: "לא נמצא כנף אחורית שמאלית, מציג כנף אחורית"

CREATE OR REPLACE FUNCTION smart_parts_search_field_cascade(
    plate_param TEXT DEFAULT NULL,
    make_param TEXT DEFAULT NULL,
    model_param TEXT DEFAULT NULL,
    year_param TEXT DEFAULT NULL,
    part_param TEXT DEFAULT NULL,
    trim_param TEXT DEFAULT NULL,
    model_code_param TEXT DEFAULT NULL,
    limit_results INT DEFAULT 50
)
RETURNS TABLE (
    id UUID,
    cat_num_desc TEXT,
    supplier_name TEXT,
    pcode TEXT,
    price NUMERIC,
    oem TEXT,
    make TEXT,
    model TEXT,
    part_family TEXT,
    side_position TEXT,
    front_rear TEXT,
    year_from INT,
    source TEXT,
    model_display TEXT,
    match_score INT,
    search_message TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    result_count INT := 0;
    where_parts TEXT[] := ARRAY[]::TEXT[];
    final_where TEXT;
    final_query TEXT;
    
    -- Field cascading variables
    make_terms TEXT[];
    model_terms TEXT[];
    part_terms TEXT[];
    year_formats TEXT[];
    
    current_message TEXT := '';
    ignored_terms TEXT[] := ARRAY[]::TEXT[];
BEGIN
    -- ============================================================================
    -- STEP 1: PLATE (always accept, never filter)
    -- ============================================================================
    
    -- Plate is informational only, doesn't filter results
    
    -- ============================================================================
    -- STEP 2: CASCADE MAKE FIELD
    -- ============================================================================
    
    IF make_param IS NOT NULL AND make_param != '' THEN
        make_terms := string_to_array(make_param, ' ');
        
        -- Try full make first
        where_parts := array_append(where_parts, 
            format('ci.make ILIKE %L', '%' || make_param || '%'));
        
        final_where := array_to_string(where_parts, ' AND ');
        final_query := 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || final_where;
        EXECUTE final_query INTO result_count;
        
        -- If no results, try each word separately
        IF result_count = 0 AND array_length(make_terms, 1) > 1 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1]; -- Remove last condition
            
            FOR i IN 1..array_length(make_terms, 1) LOOP
                where_parts := array_append(where_parts,
                    format('ci.make ILIKE %L', '%' || make_terms[i] || '%'));
                
                final_where := array_to_string(where_parts, ' AND ');
                final_query := 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || final_where;
                EXECUTE final_query INTO result_count;
                
                IF result_count > 0 THEN
                    ignored_terms := array_append(ignored_terms, array_to_string(make_terms[i+1:array_length(make_terms,1)], ' '));
                    current_message := 'נמצא יצרן: ' || make_terms[i];
                    EXIT;
                END IF;
                
                where_parts := where_parts[1:array_length(where_parts,1)-1];
            END LOOP;
        ELSE
            current_message := 'נמצא: ' || make_param;
        END IF;
        
        -- If still no results, make doesn't exist - return 0
        IF result_count = 0 THEN
            current_message := 'לא נמצא יצרן: ' || make_param;
            RETURN;
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 3: CASCADE MODEL FIELD
    -- ============================================================================
    
    IF model_param IS NOT NULL AND model_param != '' THEN
        model_terms := string_to_array(model_param, ' ');
        
        -- Try full model
        where_parts := array_append(where_parts,
            format('ci.model ILIKE %L', '%' || model_param || '%'));
        
        final_where := array_to_string(where_parts, ' AND ');
        final_query := 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || final_where;
        EXECUTE final_query INTO result_count;
        
        -- If no results, cascade word-by-word
        IF result_count = 0 AND array_length(model_terms, 1) > 1 THEN
            where_parts := where_parts[1:array_length(where_parts,1)-1];
            
            FOR i IN 1..array_length(model_terms, 1) LOOP
                where_parts := array_append(where_parts,
                    format('ci.model ILIKE %L', '%' || model_terms[i] || '%'));
                
                final_where := array_to_string(where_parts, ' AND ');
                final_query := 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || final_where;
                EXECUTE final_query INTO result_count;
                
                IF result_count > 0 THEN
                    ignored_terms := array_append(ignored_terms, array_to_string(model_terms[i+1:array_length(model_terms,1)], ' '));
                    current_message := current_message || ', לא נמצא ' || model_param || ', מציג ' || model_terms[i];
                    EXIT;
                END IF;
                
                where_parts := where_parts[1:array_length(where_parts,1)-1];
            END LOOP;
        END IF;
        
        -- If still no results with model, continue without it
        IF result_count = 0 THEN
            current_message := current_message || ', לא נמצא דגם: ' || model_param;
            -- Don't return, continue with make only
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 4: CASCADE YEAR FIELD (try all formats)
    -- ============================================================================
    
    IF year_param IS NOT NULL AND year_param != '' THEN
        -- Generate all year format variations
        IF length(year_param) = 4 THEN
            -- Input: 2011 → try 011, 11
            year_formats := ARRAY[
                year_param,
                substring(year_param from 2),  -- 011
                substring(year_param from 3)   -- 11
            ];
        ELSIF length(year_param) = 3 THEN
            -- Input: 011 → try 2011, 11
            year_formats := ARRAY[
                year_param,
                '2' || year_param,
                substring(year_param from 2)
            ];
        ELSE
            year_formats := ARRAY[year_param];
        END IF;
        
        -- Try each year format
        FOR i IN 1..array_length(year_formats, 1) LOOP
            where_parts := array_append(where_parts,
                format('(ci.year_from::TEXT ILIKE %L OR ci.extracted_year ILIKE %L OR ci.year_range ILIKE %L)',
                    '%' || year_formats[i] || '%', '%' || year_formats[i] || '%', '%' || year_formats[i] || '%'));
            
            final_where := array_to_string(where_parts, ' AND ');
            final_query := 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || final_where;
            EXECUTE final_query INTO result_count;
            
            IF result_count > 0 THEN
                IF i > 1 THEN
                    current_message := current_message || ', שנה: ' || year_formats[i] || ' (פורמט ' || year_param || ')';
                END IF;
                EXIT;
            END IF;
            
            where_parts := where_parts[1:array_length(where_parts,1)-1];
        END LOOP;
        
        -- If no year match, continue without year
        IF result_count = 0 THEN
            current_message := current_message || ', לא נמצאה שנה: ' || year_param;
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 5: CASCADE PART FIELD (word-by-word removal from end)
    -- ============================================================================
    
    IF part_param IS NOT NULL AND part_param != '' THEN
        part_terms := string_to_array(part_param, ' ');
        
        -- Try progressively shorter versions (remove last word each time)
        FOR i IN REVERSE array_length(part_terms, 1)..1 LOOP
            DECLARE
                current_part TEXT := array_to_string(part_terms[1:i], ' ');
            BEGIN
                where_parts := array_append(where_parts,
                    format('(ci.cat_num_desc ILIKE %L OR ci.part_name ILIKE %L OR ci.part_family ILIKE %L)',
                        '%' || current_part || '%', '%' || current_part || '%', '%' || current_part || '%'));
                
                final_where := array_to_string(where_parts, ' AND ');
                final_query := 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || final_where;
                EXECUTE final_query INTO result_count;
                
                IF result_count > 0 THEN
                    IF i < array_length(part_terms, 1) THEN
                        ignored_terms := array_append(ignored_terms, array_to_string(part_terms[i+1:array_length(part_terms,1)], ' '));
                        current_message := current_message || ', לא נמצא ' || part_param || ', מציג ' || current_part;
                    ELSE
                        current_message := current_message || ', חלק: ' || current_part;
                    END IF;
                    EXIT;
                END IF;
                
                where_parts := where_parts[1:array_length(where_parts,1)-1];
            END;
        END LOOP;
        
        -- If even first word not found, return 0
        IF result_count = 0 THEN
            current_message := 'לא נמצא: ' || part_terms[1];
            RETURN;
        END IF;
    END IF;
    
    -- ============================================================================
    -- STEP 6: EXECUTE FINAL QUERY AND RETURN RESULTS
    -- ============================================================================
    
    final_where := array_to_string(where_parts, ' AND ');
    
    IF final_where = '' THEN
        current_message := 'לא הוזנו פרמטרים לחיפוש';
        RETURN;
    END IF;
    
    final_query := format('
        SELECT 
            ci.id,
            ci.cat_num_desc,
            ci.supplier_name,
            ci.pcode,
            ci.price::NUMERIC,
            ci.oem,
            ci.make,
            ci.model,
            ci.part_family,
            ci.side_position,
            ci.front_rear,
            ci.year_from,
            ci.source,
            ci.model_display,
            10 as match_score,
            %L as search_message
        FROM catalog_items ci
        WHERE %s
        ORDER BY ci.price ASC
        LIMIT %s
    ', current_message, final_where, limit_results);
    
    RETURN QUERY EXECUTE final_query;
END;
$$;

-- Test field-level cascading
SELECT 
    search_message,
    make,
    model,
    cat_num_desc,
    price
FROM smart_parts_search_field_cascade(
    make_param := 'טויוטה יפן',
    model_param := 'COROLLA CROSS',
    year_param := '2011',
    part_param := 'כנף אחורית שמאלית'
)
LIMIT 5;

7. Extraction :

-- Fix year extraction patterns to handle edge cases

DROP FUNCTION IF EXISTS extract_model_and_year() CASCADE;

CREATE OR REPLACE FUNCTION extract_model_and_year()
RETURNS TRIGGER LANGUAGE plpgsql AS $func$
DECLARE
    txt text;
    year_match text[];
    yr_from_str text;
    yr_to_str text;
    yr_from_int int;
    yr_to_int int;
BEGIN
    txt := COALESCE(NEW.cat_num_desc, '');
    
    -- MODEL EXTRACTION (keep existing)
    IF NEW.make = 'טויוטה' THEN
        IF txt LIKE '%קורולה%' THEN NEW.model := 'קורולה';
        ELSIF txt LIKE '%קאמרי%' THEN NEW.model := 'קאמרי';
        ELSIF txt LIKE '%פריוס%' THEN NEW.model := 'פריוס';
        END IF;
    ELSIF NEW.make = 'VAG' OR NEW.make = 'אודי' THEN
        IF txt LIKE '%A3%' THEN NEW.model := 'A3';
        ELSIF txt LIKE '%A4%' THEN NEW.model := 'A4';
        ELSIF txt LIKE '%A5%' THEN NEW.model := 'A5';
        ELSIF txt LIKE '%Q3%' THEN NEW.model := 'Q3';
        ELSIF txt LIKE '%Q5%' THEN NEW.model := 'Q5';
        END IF;
    ELSIF NEW.make = 'פולקסווגן' THEN
        IF txt LIKE '%גולף%' THEN NEW.model := 'גולף';
        ELSIF txt LIKE '%פולו%' THEN NEW.model := 'פולו';
        ELSIF txt LIKE '%טיגואן%' THEN NEW.model := 'טיגואן';
        END IF;
    END IF;
    
    -- YEAR EXTRACTION - improved patterns
    -- Pattern 1: 2-digit dash 2-digit (e.g., 15-19, 89-01)
    SELECT regexp_match(txt, '(\d{2})-(\d{2})(?:\D|$)') INTO year_match;
    
    -- Pattern 2: 3-digit dash 3-digit (e.g., 015-019)
    IF year_match IS NULL THEN
        SELECT regexp_match(txt, '(\d{3})-(\d{3})(?:\D|$)') INTO year_match;
    END IF;
    
    -- Pattern 3: 3-digit followed by dash and space/end (e.g., 013- )
    IF year_match IS NULL THEN
        SELECT regexp_match(txt, '[^\d](\d{3})-(?:\s|$)') INTO year_match;
    END IF;
    
    -- Pattern 4: space/dash followed by 3-digit year (e.g., -019 or " 019")
    IF year_match IS NULL THEN
        SELECT regexp_match(txt, '[\s-](\d{3})(?:\s|$|-)') INTO year_match;
    END IF;
    
    IF year_match IS NOT NULL THEN
        yr_from_str := year_match[1];
        yr_to_str := year_match[2];
        
        IF yr_from_str IS NOT NULL AND yr_from_str ~ '^\d+$' THEN
            IF length(yr_from_str) = 2 THEN
                IF yr_from_str::int >= 80 THEN
                    yr_from_int := 1900 + yr_from_str::int;
                ELSE
                    yr_from_int := 2000 + yr_from_str::int;
                END IF;
            ELSIF length(yr_from_str) = 3 THEN
                yr_from_int := 2000 + yr_from_str::int;
            END IF;
            
            IF yr_from_int >= 1980 AND yr_from_int <= 2030 THEN
                NEW.year_from := yr_from_int;
                NEW.year_to := yr_from_int;
            END IF;
        END IF;
        
        IF yr_to_str IS NOT NULL AND yr_to_str ~ '^\d+$' THEN
            IF length(yr_to_str) = 2 THEN
                IF yr_to_str::int >= 80 THEN
                    yr_to_int := 1900 + yr_to_str::int;
                ELSE
                    yr_to_int := 2000 + yr_to_str::int;
                END IF;
            ELSIF length(yr_to_str) = 3 THEN
                yr_to_int := 2000 + yr_to_str::int;
            END IF;
            
            IF yr_to_int >= 1980 AND yr_to_int <= 2030 THEN
                NEW.year_to := yr_to_int;
            END IF;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$func$;

CREATE TRIGGER trigger_extract_model_and_year
    BEFORE INSERT OR UPDATE OF cat_num_desc, make
    ON catalog_items FOR EACH ROW
    EXECUTE FUNCTION extract_model_and_year();
 

THERE ARE MORE EXTRACTION LOGICS DEPLOYED - I CANNOT TRACK THEM ALL 


**5.10 DIGNOSIS**

Section 1 :
[
  {
    "info": "Function source (first 2000 chars):",
    "source_preview": "\nDECLARE\n    result_count INT := 0;\n    where_parts TEXT[] := ARRAY[]::TEXT[];\n    final_where TEXT;\n    final_query TEXT;\n    \n    make_terms TEXT[];\n    model_terms TEXT[];\n    part_terms TEXT[];\n    free_terms TEXT[];\n    year_formats TEXT[];\n    \n    current_search TEXT;\n    i INT;\nBEGIN\n    -- ============================================================================\n    -- STEP 1: FAMILY FIRST (Primary filter if provided)\n    -- ============================================================================\n    \n    IF family_param IS NOT NULL AND family_param != '' THEN\n        where_parts := array_append(where_parts,\n            format('ci.part_family ILIKE %L', '%' || family_param || '%'));\n        \n        EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;\n        \n        IF result_count = 0 THEN RETURN; END IF;\n    END IF;\n    \n    -- ============================================================================\n    -- STEP 2: PART SECOND (Required - must match)\n    -- ============================================================================\n    \n    IF part_param IS NOT NULL AND part_param != '' THEN\n        part_terms := string_to_array(part_param, ' ');\n        \n        FOR i IN REVERSE array_length(part_terms, 1)..1 LOOP\n            current_search := array_to_string(part_terms[1:i], ' ');\n            \n            where_parts := array_append(where_parts,\n                format('(ci.cat_num_desc ILIKE %L OR ci.part_family ILIKE %L)',\n                    '%' || current_search || '%', '%' || current_search || '%'));\n            \n            EXECUTE 'SELECT COUNT(*) FROM catalog_items ci WHERE ' || array_to_string(where_parts, ' AND ') INTO result_count;\n            \n            IF result_count > 0 THEN EXIT; END IF;\n            where_parts := where_parts[1:array_length(where_parts,1)-1];\n        END LOOP;\n        \n        IF result_count = 0 THEN RETURN; END IF;\n        \n    ELSIF free_query..."
  }
] 

Section 2 :

[
  {
    "trigger_name": "RI_ConstraintTrigger_c_53849",
    "status": "✅ ENABLED",
    "execution_order": "UNKNOWN ORDER",
    "trigger_definition": "CREATE CONSTRAINT TRIGGER \"RI_ConstraintTrigger_c_53849\" AFTER INSERT ON public.catalog_items FROM suppliers NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION \"RI_FKey_check_ins\"()"
  },
  {
    "trigger_name": "RI_ConstraintTrigger_c_53850",
    "status": "✅ ENABLED",
    "execution_order": "UNKNOWN ORDER",
    "trigger_definition": "CREATE CONSTRAINT TRIGGER \"RI_ConstraintTrigger_c_53850\" AFTER UPDATE ON public.catalog_items FROM suppliers NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION \"RI_FKey_check_upd\"()"
  },
  {
    "trigger_name": "RI_ConstraintTrigger_c_59807",
    "status": "✅ ENABLED",
    "execution_order": "UNKNOWN ORDER",
    "trigger_definition": "CREATE CONSTRAINT TRIGGER \"RI_ConstraintTrigger_c_59807\" AFTER INSERT ON public.catalog_items FROM catalogs NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION \"RI_FKey_check_ins\"()"
  },
  {
    "trigger_name": "RI_ConstraintTrigger_c_59808",
    "status": "✅ ENABLED",
    "execution_order": "UNKNOWN ORDER",
    "trigger_definition": "CREATE CONSTRAINT TRIGGER \"RI_ConstraintTrigger_c_59808\" AFTER UPDATE ON public.catalog_items FROM catalogs NOT DEFERRABLE INITIALLY IMMEDIATE FOR EACH ROW EXECUTE FUNCTION \"RI_FKey_check_upd\"()"
  },
  {
    "trigger_name": "hebrew_reversal_trigger",
    "status": "✅ ENABLED",
    "execution_order": "UNKNOWN ORDER",
    "trigger_definition": "CREATE TRIGGER hebrew_reversal_trigger BEFORE INSERT OR UPDATE ON public.catalog_items FOR EACH ROW EXECUTE FUNCTION process_hebrew_before_insert()"
  },
  {
    "trigger_name": "trigger_00_auto_fix_and_extract",
    "status": "✅ ENABLED",
    "execution_order": "0 - FIRST",
    "trigger_definition": "CREATE TRIGGER trigger_00_auto_fix_and_extract BEFORE INSERT OR UPDATE ON public.catalog_items FOR EACH ROW EXECUTE FUNCTION auto_fix_and_extract()"
  },
  {
    "trigger_name": "trigger_00_auto_fix_hebrew_reversal",
    "status": "✅ ENABLED",
    "execution_order": "0 - FIRST",
    "trigger_definition": "CREATE TRIGGER trigger_00_auto_fix_hebrew_reversal BEFORE INSERT OR UPDATE ON public.catalog_items FOR EACH ROW EXECUTE FUNCTION auto_fix_hebrew_reversal()"
  },
  {
    "trigger_name": "trigger_01_set_supplier_name",
    "status": "✅ ENABLED",
    "execution_order": "1 - SECOND",
    "trigger_definition": "CREATE TRIGGER trigger_01_set_supplier_name BEFORE INSERT OR UPDATE ON public.catalog_items FOR EACH ROW EXECUTE FUNCTION _set_supplier_name()"
  },
  {
    "trigger_name": "trigger_extract_model_and_year",
    "status": "✅ ENABLED",
    "execution_order": "UNKNOWN ORDER",
    "trigger_definition": "CREATE TRIGGER trigger_extract_model_and_year BEFORE INSERT OR UPDATE OF cat_num_desc, make ON public.catalog_items FOR EACH ROW EXECUTE FUNCTION extract_model_and_year()"
  }
]

Section 3 :

[
  {
    "function_name": "auto_fix_hebrew_reversal",
    "status": "✅ EXISTS"
  },
  {
    "function_name": "reverse_hebrew",
    "status": "✅ EXISTS"
  },
  {
    "function_name": "fix_hebrew_text",
    "status": "✅ EXISTS"
  },
  {
    "function_name": "process_catalog_item_complete",
    "status": "✅ EXISTS"
  },
  {
    "function_name": "auto_fix_and_extract",
    "status": "✅ EXISTS"
  }
]

Section 4 :

[
  {
    "total_records": 48276,
    "has_part_name": 27041,
    "has_model": 11822,
    "has_year_from": 12581,
    "has_extracted_year": 40531,
    "has_part_family": 48276,
    "categorized_family": 48276,
    "part_name_pct": "56.0",
    "model_pct": "24.5",
    "year_pct": "26.1",
    "family_pct": "100.0"
  }
]

Section 5 :

[
  {
    "check_type": "Hebrew Text Status:",
    "reversed_count": 11590,
    "correct_count": 11295,
    "total_checked": 48276
  }
]

Section 6 :
Test 1: 

[
  {
    "test_name": "Test 1: Simple Toyota search",
    "result_count": 50
  }
]

Test 2 :

[
  {
    "test_name": "Test 2: Multi-word Toyota Japan search",
    "result_count": 50
  }
]

Test 3:
[
  {
    "test_name": "Test 3: Corolla model search",
    "result_count": 20
  }
]

Test 4 :
[
  {
    "test_name": "Test 4: Corolla Cross cascade test (CRITICAL)",
    "result_count": 50,
    "cascade_status": "✅ CASCADE WORKING"
  }
]

Test 5 :
[
  {
    "info": "Sample results from Corolla Cross cascade test:",
    "cat_num_desc": "20-89 הלורוק 'מי 'דק ךמות",
    "model": "קורולה",
    "make": "טויוטה"
  },
  {
    "info": "Sample results from Corolla Cross cascade test:",
    "cat_num_desc": "70-30 הלורוק -'מי עונמ הסכמ ריצ",
    "model": "קורולה",
    "make": "טויוטה"
  },
  {
    "info": "Sample results from Corolla Cross cascade test:",
    "cat_num_desc": "00-89 הלורוק - 'מי עונמ הסכמ ריצ",
    "model": "קורולה",
    "make": "טויוטה"
  },
  {
    "info": "Sample results from Corolla Cross cascade test:",
    "cat_num_desc": "20-89 הלורוק - 'מי 'ציח 'דק תידי",
    "model": "קורולה",
    "make": "טויוטה"
  },
  {
    "info": "Sample results from Corolla Cross cascade test:",
    "cat_num_desc": "10-89 הלורוק ןגמב 'מי לירג",
    "model": "קורולה",
    "make": "טויוטה"
  }
]

Section 7 :

[
  {
    "cat_num_desc": "פח חזית מושלם - קורולה -910",
    "year_from": null,
    "year_to": null,
    "extracted_year": "910",
    "year_range": null
  },
  {
    "cat_num_desc": "מגן קד' - אוואלון -810",
    "year_from": null,
    "year_to": null,
    "extracted_year": "810",
    "year_range": null
  },
  {
    "cat_num_desc": "כיסוי שמ' לגריל תח' במגן קד' - קורולה -910",
    "year_from": null,
    "year_to": null,
    "extracted_year": "910",
    "year_range": null
  },
  {
    "cat_num_desc": "כיסוי וו גרירה במגן קד' - קורולה -910",
    "year_from": null,
    "year_to": null,
    "extracted_year": "910",
    "year_range": null
  },
  {
    "cat_num_desc": "מגן מצננים תח' סטלביו -810",
    "year_from": null,
    "year_to": null,
    "extracted_year": "810",
    "year_range": null
  },
  {
    "cat_num_desc": "גריל שמ' למגן קד' - סטלביו -810",
    "year_from": null,
    "year_to": null,
    "extracted_year": "810",
    "year_range": null
  },
  {
    "cat_num_desc": "תומך מגן קד' ימ' - קורולה -910",
    "year_from": null,
    "year_to": null,
    "extracted_year": "910",
    "year_range": null
  },
  {
    "cat_num_desc": "ניקל גריל ימ' במגן פאסאט -510",
    "year_from": null,
    "year_to": null,
    "extracted_year": "510",
    "year_range": null
  },
  {
    "cat_num_desc": "מגן קד' חיצ' - קורולה -120",
    "year_from": null,
    "year_to": null,
    "extracted_year": "120",
    "year_range": null
  },
  {
    "cat_num_desc": "קלקר תח' למגן קד' - קורולה -910",
    "year_from": null,
    "year_to": null,
    "extracted_year": "910",
    "year_range": null
  }
].  YEAR EXTRACTION IS REVERSED :810 ISTEAD OF 018

Section 8 :

[
  {
    "info": "Checking parameter order in function body...",
    "parameter_order_status": "✅ CORRECT ORDER: MODEL before MODEL_CODE"
  }
] THE ORDER IS : FAMILY, MAKE ,MODEL, PART 

DIAGNOSTIC SUMMARY:

[
  {
    "section": "=== DIAGNOSTIC COMPLETE ==="
  }
]

**VARIFICATION**

TEST 1 :
[
  {
    "reversed_count": 2700,
    "has_hebrew_total": 48276,
    "total_records": 48276,
    "reversed_percentage": "5.59",
    "status": "❌ STILL HAS ISSUES"
  }
]

TETS 2 :

[
  {
    "pcode": "VB42111000",
    "cat_num_desc": "-910 קורולה - םלשומ תיזח חפ",
    "make": "טויוטה",
    "model": "קורולה",
    "part_family": "חלקי מרכב",
    "hebrew_status": "UNKNOWN"
  },
  {
    "pcode": "VB4216281",
    "cat_num_desc": "מגן קד' - אוואלון -810",
    "make": "טויוטה",
    "model": null,
    "part_family": "מגנים ופגושים",
    "hebrew_status": "✅ CORRECT"
  },
  {
    "pcode": "VB421110524",
    "cat_num_desc": "כיסוי שמ' לגריל תח' במגן קד' - קורולה -910",
    "make": "טויוטה",
    "model": "קורולה",
    "part_family": "מגנים ופגושים",
    "hebrew_status": "✅ CORRECT"
  },
  {
    "pcode": "VB42111068",
    "cat_num_desc": "כיסוי וו גרירה במגן קד' - קורולה -910",
    "make": "טויוטה",
    "model": "קורולה",
    "part_family": "אביזרים נלווים",
    "hebrew_status": "✅ CORRECT"
  },
  {
    "pcode": "VB5118173G",
    "cat_num_desc": "מגן מצננים תח' סטלביו -810",
    "make": "אלפא רומיא",
    "model": null,
    "part_family": "מגנים ופגושים",
    "hebrew_status": "✅ CORRECT"
  },
  {
    "pcode": "VB51181782G",
    "cat_num_desc": "גריל שמ' למגן קד' - סטלביו -810",
    "make": "אלפא רומיא",
    "model": null,
    "part_family": "חלקי מרכב",
    "hebrew_status": "✅ CORRECT"
  },
  {
    "pcode": "VB421110791",
    "cat_num_desc": "תומך מגן קד' ימ' - קורולה -910",
    "make": "טויוטה",
    "model": "קורולה",
    "part_family": "חלקי מרכב",
    "hebrew_status": "✅ CORRECT"
  },
  {
    "pcode": "VB52349777",
    "cat_num_desc": "ניקל גריל ימ' במגן פאסאט -510",
    "make": "פולקסווגן",
    "model": "פאסאת",
    "part_family": "חלקי מרכב",
    "hebrew_status": "✅ CORRECT"
  },
  {
    "pcode": "VB4211107741",
    "cat_num_desc": "קישוט לכיסוי ערפל קד' ימ' (שחור) - קורולה -",
    "make": "הטויוט",
    "model": "קורולה",
    "part_family": "חלקי מרכב",
    "hebrew_status": "UNKNOWN"
  },
  {
    "pcode": "VB42111081T",
    "cat_num_desc": "מגן קד' חיצ' - קורולה -120",
    "make": "טויוטה",
    "model": "קורולה",
    "part_family": "מגנים ופגושים",
    "hebrew_status": "✅ CORRECT"
  }
]

TEST 3 :

[
  {
    "cat_num_desc": "98-01 קורולה במגן 'ימ גריל",
    "make": "טויוטה",
    "model": "קורולה",
    "part_family": "חלקי מרכב",
    "price": "84.21"
  },
  {
    "cat_num_desc": "93-97 קורולה שמ במגן-איתות פנס",
    "make": "טויוטה",
    "model": "קורולה",
    "part_family": "פנסים",
    "price": "91.35"
  },
  {
    "cat_num_desc": "חיזוק מגן אח' - קורולה 79-39",
    "make": "טויוטה",
    "model": "קורולה",
    "part_family": "םישוגפו םינגמ",
    "price": "104.69"
  },
  {
    "cat_num_desc": "4D -019 קורולה - 'קד למגן גרירה וו כיסוי",
    "make": "טויוטה",
    "model": "קורולה",
    "part_family": "םיוולנ םירזיבא",
    "price": "118.56"
  },
  {
    "cat_num_desc": "07-010 קורולה דל5 חור+'שמ במגן גריל",
    "make": "טויוטה",
    "model": "קורולה",
    "part_family": "חלקי מרכב",
    "price": "124.24"
  }
]

TEST 4 :

[
  {
    "info": "Common Hebrew words check:",
    "has_magen_correct": 13987,
    "has_magen_reversed": 0,
    "has_panas_correct": 7131,
    "has_panas_reversed": 0,
    "has_delet_correct": 2051,
    "has_delet_reversed": 0
  }
]

TEST 5 :

[
  {
    "before_state": "Previous state had 11,590 reversed records (24%)",
    "after_state": "Current state:",
    "current_reversed": 2700
  }
]

TEST 6 :

[
  {
    "section": "=== VERIFICATION COMPLETE ==="
  }
]

**Analyze Remaining Pattern**

1.:
[
  {
    "pcode": "VB1099210",
    "cat_num_desc": "הסכמ עונמ יטויד -110",
    "make": "פורד",
    "model": null,
    "part_family": "חלקי מרכב"
  },
  {
    "pcode": "VB65609961",
    "cat_num_desc": "ריצ מי' הסכמל עונמ - גאטרופס' -220",
    "make": "קיה",
    "model": null,
    "part_family": "חלקי מרכב"
  },
  {
    "pcode": "VB65609962",
    "cat_num_desc": "ריצ מש' הסכמל עונמ - גאטרופס' -220",
    "make": "קיה",
    "model": null,
    "part_family": "חלקי מרכב"
  },
  {
    "pcode": "VB5251795",
    "cat_num_desc": "6T -61 שפריצר מיכל צינור",
    "make": "פולקסווגן",
    "model": null,
    "part_family": "חלקי מרכב"
  },
  {
    "pcode": "VB5251795",
    "cat_num_desc": "6T -61 שפריצר מיכל צינור",
    "make": "VAG",
    "model": null,
    "part_family": "חלקי מרכב"
  },
  {
    "pcode": "VB1651810",
    "cat_num_desc": "הסכמ עונמ הסרוק -51",
    "make": "אופל (לובינס",
    "model": null,
    "part_family": "חלקי מרכב"
  },
  {
    "pcode": "VB2345210",
    "cat_num_desc": "הסכמ עונמ -60 06S",
    "make": "וולוו",
    "model": null,
    "part_family": "חלקי מרכב"
  },
  {
    "pcode": "VB5233449",
    "cat_num_desc": "הסכמ ןעטמ - ג'הט -210",
    "make": "פולקסווגן",
    "model": null,
    "part_family": "חלקי מרכב"
  },
  {
    "pcode": "VBP23252803",
    "cat_num_desc": "ספת ןוחטב הסכמ עונמ-06X",
    "make": "וולוו",
    "model": null,
    "part_family": "חלקי מרכב"
  },
  {
    "pcode": "VB4512710T",
    "cat_num_desc": "הסכמ עונמ D5/D4 -310 3M",
    "make": "מזדה",
    "model": null,
    "part_family": "חלקי מרכב"
  },
  {
    "pcode": "VB51901961G",
    "cat_num_desc": "ריצ הסכמ עונמ מי' -ג'הילו -710",
    "make": "אימור אפלא",
    "model": null,
    "part_family": "חלקי מרכב"
  },
  {
    "pcode": "VB51901962G",
    "cat_num_desc": "ריצ הסכמ עונמ מש' -ג'הילו -710",
    "make": "אימור אפלא",
    "model": null,
    "part_family": "חלקי מרכב"
  },
  {
    "pcode": "VB5295272",
    "cat_num_desc": "70 ארג'טו-שפריצר כיסוי",
    "make": "VAG",
    "model": null,
    "part_family": "חלקי מרכב"
  },
  {
    "pcode": "VB52952918",
    "cat_num_desc": "0102 טוארג במגן 'ימ שפריצר כיסוי",
    "make": "ןגווסקלופ",
    "model": null,
    "part_family": "מגנים ופגושים"
  },
  {
    "pcode": "VB53155814",
    "cat_num_desc": "4-A -08-חיישן.ח עם שפריצר.ח עם 'קד מגן",
    "make": "אודי",
    "model": null,
    "part_family": "מגנים ופגושים"
  },
  {
    "pcode": "VB53155814",
    "cat_num_desc": "4-A -08-חיישן.ח עם שפריצר.ח עם 'קד מגן",
    "make": "VAG",
    "model": null,
    "part_family": "מגנים ופגושים"
  },
  {
    "pcode": "VB53155813",
    "cat_num_desc": "4A -80 - חיישן.ח בלי שפריצר.ח עם 'קד מגן",
    "make": "VAG",
    "model": null,
    "part_family": "מגנים ופגושים"
  },
  {
    "pcode": "VB4281810",
    "cat_num_desc": "הסכמ עונמ - וגיו -120",
    "make": "הטויוט",
    "model": null,
    "part_family": "חלקי מרכב"
  },
  {
    "pcode": "VB43023961",
    "cat_num_desc": "ריצ הסכמ עונמ מי' -410 052 SI",
    "make": "סוסקל",
    "model": "SI",
    "part_family": "חלקי מרכב"
  },
  {
    "pcode": "VB5319171",
    "cat_num_desc": "7-A 41 'קד למגן ימין שפריצר כיסוי",
    "make": "ידוא",
    "model": null,
    "part_family": "מגנים ופגושים"
  }
]

2.:

[
  {
    "pattern_sample": "ריצ הסכמ עונמ מש' - ",
    "occurrence_count": 42
  },
  {
    "pattern_sample": "ריצ הסכמ עונמ מי' - ",
    "occurrence_count": 34
  },
  {
    "pattern_sample": "ריצ מש' הסכמל עונמ -",
    "occurrence_count": 28
  },
  {
    "pattern_sample": "ריצ מי' הסכמל עונמ -",
    "occurrence_count": 25
  },
  {
    "pattern_sample": ")ושפריצר חיישנים ללא",
    "occurrence_count": 8
  },
  {
    "pattern_sample": "הסכמ עונמ - אוקטביה ",
    "occurrence_count": 8
  },
  {
    "pattern_sample": "טושיק מי' לירגל דק' ",
    "occurrence_count": 7
  },
  {
    "pattern_sample": "תידי דק' ציח' מי' - ",
    "occurrence_count": 6
  },
  {
    "pattern_sample": "טושיק לע' לירגל דק' ",
    "occurrence_count": 6
  },
  {
    "pattern_sample": "A1 -011 חיישן+שפריצר",
    "occurrence_count": 6
  },
  {
    "pattern_sample": "ךמות מי' חפל תיזח - ",
    "occurrence_count": 6
  },
  {
    "pattern_sample": "הסכמ עונמ םוינימולא ",
    "occurrence_count": 6
  },
  {
    "pattern_sample": "טושיק מש' לירגל דק' ",
    "occurrence_count": 6
  },
  {
    "pattern_sample": "לירג דק' מי' - 510- ",
    "occurrence_count": 5
  },
  {
    "pattern_sample": "לקינ חת' לירגל דק' -",
    "occurrence_count": 5
  }
]

3,:

[
  {
    "section": "=== ANALYSIS COMPLETE ==="
  }
]

**DIAGNOSTICS 2 - 5.10:**

Check 1 :

[
  {
    "info": "Sample of full-string reversed records:",
    "reversed_display": "גריל קד' מושלם!!! פביה 05-08",
    "would_be_corrected": "80-50 היבפ !!!םלשומ 'דק לירג",
    "pcode": "VB62252511"
  },
  {
    "info": "Sample of full-string reversed records:",
    "reversed_display": "ראי שמ'+3 כבל לצבע כיסוי גדול- פולו 01-02",
    "would_be_corrected": "20-10 ולופ -לודג יוסיכ עבצל לבכ 3+'מש יאר",
    "pcode": "VM192AL"
  },
  {
    "info": "Sample of full-string reversed records:",
    "reversed_display": "ראי ימ' חש' חמ'+פנס לצבע פאסאט 03-05",
    "would_be_corrected": "50-30 טאסאפ עבצל סנפ+'מח 'שח 'מי יאר",
    "pcode": "VM199EHPR"
  },
  {
    "info": "Sample of full-string reversed records:",
    "reversed_display": "ראי ימ' חש' חמ' לצבע קורסה 01-06",
    "would_be_corrected": "60-10 הסרוק עבצל 'מח 'שח 'מי יאר",
    "pcode": "VM200EHPR"
  },
  {
    "info": "Sample of full-string reversed records:",
    "reversed_display": "ראי ימ'+3 כבל שחור - קורסה 01-06",
    "would_be_corrected": "60-10 הסרוק - רוחש לבכ 3+'מי יאר",
    "pcode": "VM200R"
  },
  {
    "info": "Sample of full-string reversed records:",
    "reversed_display": "ראי ימ'+3 כבל כיסוי קטן - איביזה 00-02",
    "would_be_corrected": "20-00 הזיביא - ןטק יוסיכ לבכ 3+'מי יאר",
    "pcode": "VM359R"
  },
  {
    "info": "Sample of full-string reversed records:",
    "reversed_display": "ראי ימ'+3 כבל כיסוי קטן - איביזה 00-02",
    "would_be_corrected": "20-00 הזיביא - ןטק יוסיכ לבכ 3+'מי יאר",
    "pcode": "VM359R"
  },
  {
    "info": "Sample of full-string reversed records:",
    "reversed_display": "ראי שמ'+3 כבל - אקסנט 94-99",
    "would_be_corrected": "99-49 טנסקא - לבכ 3+'מש יאר",
    "pcode": "VM441L"
  },
  {
    "info": "Sample of full-string reversed records:",
    "reversed_display": "ראי ימ' חשמלי אלנטרה 01-07",
    "would_be_corrected": "70-10 הרטנלא ילמשח 'מי יאר",
    "pcode": "VM458ER"
  },
  {
    "info": "Sample of full-string reversed records:",
    "reversed_display": "סורג קד' - ריאו 05-09",
    "would_be_corrected": "90-50 ואיר - 'דק גרוס",
    "pcode": "VB6575353"
  }
]

Check 2 :

[
  {
    "info": "Sample of reversed years:",
    "cat_num_desc": "מגן מנוע ימ' -310 02I",
    "current_wrong": "310",
    "would_be_correct": "013",
    "year_from": null,
    "year_to": null
  },
  {
    "info": "Sample of reversed years:",
    "cat_num_desc": "גריל תח' במגן קד' - (02G) סדרה 3 -810",
    "current_wrong": "810",
    "would_be_correct": "018",
    "year_from": null,
    "year_to": null
  },
  {
    "info": "Sample of reversed years:",
    "cat_num_desc": "סט פחיות למגן אח' C-אליזה -310",
    "current_wrong": "310",
    "would_be_correct": "013",
    "year_from": null,
    "year_to": null
  },
  {
    "info": "Sample of reversed years:",
    "cat_num_desc": "גריל במגן קד' מרכזי -310 3C",
    "current_wrong": "310",
    "would_be_correct": "013",
    "year_from": null,
    "year_to": null
  },
  {
    "info": "Sample of reversed years:",
    "cat_num_desc": "כיסוי תח' ימ' למגן אח' - ספורטאג' -910",
    "current_wrong": "910",
    "would_be_correct": "019",
    "year_from": null,
    "year_to": null
  },
  {
    "info": "Sample of reversed years:",
    "cat_num_desc": "רשת לגריל קד'-שירוקי -110",
    "current_wrong": "110",
    "would_be_correct": "011",
    "year_from": null,
    "year_to": null
  },
  {
    "info": "Sample of reversed years:",
    "cat_num_desc": "משולש תח' קד' שמ' - מודל 3 -610",
    "current_wrong": "610",
    "would_be_correct": "016",
    "year_from": null,
    "year_to": null
  },
  {
    "info": "Sample of reversed years:",
    "cat_num_desc": "זרוע מייצב אח' שמ' פאסאט -510",
    "current_wrong": "510",
    "would_be_correct": "015",
    "year_from": null,
    "year_to": null
  },
  {
    "info": "Sample of reversed years:",
    "cat_num_desc": "זרוע מייצב אח' שמ' פאסאט -510",
    "current_wrong": "510",
    "would_be_correct": "015",
    "year_from": null,
    "year_to": null
  },
  {
    "info": "Sample of reversed years:",
    "cat_num_desc": "זרוע מייצב אח' ימ' פאסאט -510",
    "current_wrong": "510",
    "would_be_correct": "015",
    "year_from": null,
    "year_to": null
  }
]

Check 3 :

[
  {
    "info": "Sample variations in database:",
    "cat_num_desc": "כנף קד' שמאל 310- VX ללא חור",
    "format_used": "Other format"
  },
  {
    "info": "Sample variations in database:",
    "cat_num_desc": "קשת כנף קד ימין 810- GM",
    "format_used": "Other format"
  },
  {
    "info": "Sample variations in database:",
    "cat_num_desc": "כנף קד' שמאל פאסאט 510- 8B",
    "format_used": "Other format"
  },
  {
    "info": "Sample variations in database:",
    "cat_num_desc": "כנף קד' ימין 410- 04-V",
    "format_used": "Other format"
  },
  {
    "info": "Sample variations in database:",
    "cat_num_desc": "קשת כנף שמאל - 810- 09CX",
    "format_used": "Other format"
  },
  {
    "info": "Sample variations in database:",
    "cat_num_desc": "קשת כנף קד' שמאל 710- XSA",
    "format_used": "Other format"
  },
  {
    "info": "Sample variations in database:",
    "cat_num_desc": "ביטנה כנף אחורי ימ' -710- XSA",
    "format_used": "Other format"
  },
  {
    "info": "Sample variations in database:",
    "cat_num_desc": "ביטנה כנף אחורי שמ' -710- XSA",
    "format_used": "Uses: שמ'"
  },
  {
    "info": "Sample variations in database:",
    "cat_num_desc": "קשת כנף קדמי ימין (שחור) - טראוורס 120-8",
    "format_used": "Other format"
  },
  {
    "info": "Sample variations in database:",
    "cat_num_desc": "קשת כנף אח' שמאל 610- RH-C",
    "format_used": "Other format"
  },
  {
    "info": "Sample variations in database:",
    "cat_num_desc": "כנף קד' שמאל פאסאט 510- 8B",
    "format_used": "Other format"
  },
  {
    "info": "Sample variations in database:",
    "cat_num_desc": "כנף קדמי שמ' -710- 5Q",
    "format_used": "Uses: שמ'"
  },
  {
    "info": "Sample variations in database:",
    "cat_num_desc": "כנף קדמי שמ' -710- 5Q",
    "format_used": "Uses: שמ'"
  },
  {
    "info": "Sample variations in database:",
    "cat_num_desc": "קישוט כנף קדמי ימ' - 110- 52F 3X",
    "format_used": "Other format"
  },
  {
    "info": "Sample variations in database:",
    "cat_num_desc": "כנף קדמי ימ' עם חור לגלגל 710- 3C",
    "format_used": "Other format"
  }
]

Check 4 :

[
  {
    "category": "Position variations:",
    "קדמי_count": 856,
    "קידמי_count": 24,
    "קדמית_count": 18,
    "קדא_abbrev_count": 9810,
    "אחורי_count": 650,
    "אחורית_count": 24,
    "אחא_abbrev_count": 4614
  }
]

Check 5 :

[
  {
    "test": "Test: smart_parts_search with just כנף",
    "result_count": 50
  }
] the כנף was just an example

Check  6:

[
  {
    "test": "Advanced test: Make + Model + Part",
    "result_count": 33
  }
]

Check 7 :

[
  {
    "metric": "Data quality metrics:",
    "total_records": 48276,
    "has_part_name": 30889,
    "has_part_family": 48276,
    "has_year": 40531,
    "has_model": 12959,
    "part_name_pct": "63.98",
    "year_pct": "83.96"
  }
]

Check 8 :

[
  {
    "section": "=== DIAGNOSTIC COMPLETE ==="
  }
]
